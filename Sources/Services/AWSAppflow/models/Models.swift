// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// AppFlow/Requester has invalid or missing permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes.AggregationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationType
        case targetFileSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationType = self.aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
        if let targetFileSize = self.targetFileSize {
            try encodeContainer.encode(targetFileSize, forKey: .targetFileSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let targetFileSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetFileSize)
        targetFileSize = targetFileSizeDecoded
    }
}

extension AppflowClientTypes {
    /// The aggregation settings that you can use to customize the output format of your flow data.
    public struct AggregationConfig: Swift.Equatable {
        /// Specifies whether Amazon AppFlow aggregates the flow records into a single file, or leave them unaggregated.
        public var aggregationType: AppflowClientTypes.AggregationType?
        /// The desired file size, in MB, for each output file that Amazon AppFlow writes to the flow destination. For each file, Amazon AppFlow attempts to achieve the size that you specify. The actual file sizes might differ from this target based on the number and size of the records that each file contains.
        public var targetFileSize: Swift.Int?

        public init(
            aggregationType: AppflowClientTypes.AggregationType? = nil,
            targetFileSize: Swift.Int? = nil
        )
        {
            self.aggregationType = aggregationType
            self.targetFileSize = targetFileSize
        }
    }

}

extension AppflowClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case singleFile
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .none,
                .singleFile,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "None"
            case .singleFile: return "SingleFile"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum AmplitudeConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case sdkUnknown(Swift.String)

        public static var allCases: [AmplitudeConnectorOperator] {
            return [
                .between,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AmplitudeConnectorOperator(rawValue: rawValue) ?? AmplitudeConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case secretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let secretKey = self.secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
    }
}

extension AppflowClientTypes.AmplitudeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmplitudeConnectorProfileCredentials(apiKey: \"CONTENT_REDACTED\", secretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific credentials required when using Amplitude.
    public struct AmplitudeConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var secretKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            secretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.secretKey = secretKey
        }
    }

}

extension AppflowClientTypes.AmplitudeConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Amplitude.
    public struct AmplitudeConnectorProfileProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.AmplitudeMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amplitude.
    public struct AmplitudeMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.AmplitudeSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amplitude is being used as a source.
    public struct AmplitudeSourceProperties: Swift.Equatable {
        /// The object specified in the Amplitude flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.ApiKeyCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case apiSecretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let apiSecretKey = self.apiSecretKey {
            try encodeContainer.encode(apiSecretKey, forKey: .apiSecretKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let apiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSecretKey)
        apiSecretKey = apiSecretKeyDecoded
    }
}

extension AppflowClientTypes.ApiKeyCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApiKeyCredentials(apiKey: \"CONTENT_REDACTED\", apiSecretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The API key credentials required for API key authentication.
    public struct ApiKeyCredentials: Swift.Equatable {
        /// The API key required for API key authentication.
        /// This member is required.
        public var apiKey: Swift.String?
        /// The API secret key required for API key authentication.
        public var apiSecretKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.apiSecretKey = apiSecretKey
        }
    }

}

extension AppflowClientTypes.AuthParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorSuppliedValues
        case description
        case isRequired
        case isSensitiveField
        case key
        case label
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorSuppliedValues = connectorSuppliedValues {
            var connectorSuppliedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorSuppliedValues)
            for connectorsuppliedvalue0 in connectorSuppliedValues {
                try connectorSuppliedValuesContainer.encode(connectorsuppliedvalue0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isRequired != false {
            try encodeContainer.encode(isRequired, forKey: .isRequired)
        }
        if isSensitiveField != false {
            try encodeContainer.encode(isSensitiveField, forKey: .isSensitiveField)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let isRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequired) ?? false
        isRequired = isRequiredDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isSensitiveFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSensitiveField) ?? false
        isSensitiveField = isSensitiveFieldDecoded
        let connectorSuppliedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorSuppliedValues)
        var connectorSuppliedValuesDecoded0:[Swift.String]? = nil
        if let connectorSuppliedValuesContainer = connectorSuppliedValuesContainer {
            connectorSuppliedValuesDecoded0 = [Swift.String]()
            for string0 in connectorSuppliedValuesContainer {
                if let string0 = string0 {
                    connectorSuppliedValuesDecoded0?.append(string0)
                }
            }
        }
        connectorSuppliedValues = connectorSuppliedValuesDecoded0
    }
}

extension AppflowClientTypes {
    /// Information about required authentication parameters.
    public struct AuthParameter: Swift.Equatable {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public var connectorSuppliedValues: [Swift.String]?
        /// A description about the authentication parameter.
        public var description: Swift.String?
        /// Indicates whether this authentication parameter is required.
        public var isRequired: Swift.Bool
        /// Indicates whether this authentication parameter is a sensitive field.
        public var isSensitiveField: Swift.Bool
        /// The authentication key required to authenticate with the connector.
        public var key: Swift.String?
        /// Label used for authentication parameter.
        public var label: Swift.String?

        public init(
            connectorSuppliedValues: [Swift.String]? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            isSensitiveField: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil
        )
        {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
        }
    }

}

extension AppflowClientTypes.AuthenticationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customAuthConfigs
        case isApiKeyAuthSupported
        case isBasicAuthSupported
        case isCustomAuthSupported
        case isOAuth2Supported
        case oAuth2Defaults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customAuthConfigs = customAuthConfigs {
            var customAuthConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customAuthConfigs)
            for customauthconfig0 in customAuthConfigs {
                try customAuthConfigsContainer.encode(customauthconfig0)
            }
        }
        if isApiKeyAuthSupported != false {
            try encodeContainer.encode(isApiKeyAuthSupported, forKey: .isApiKeyAuthSupported)
        }
        if isBasicAuthSupported != false {
            try encodeContainer.encode(isBasicAuthSupported, forKey: .isBasicAuthSupported)
        }
        if isCustomAuthSupported != false {
            try encodeContainer.encode(isCustomAuthSupported, forKey: .isCustomAuthSupported)
        }
        if isOAuth2Supported != false {
            try encodeContainer.encode(isOAuth2Supported, forKey: .isOAuth2Supported)
        }
        if let oAuth2Defaults = self.oAuth2Defaults {
            try encodeContainer.encode(oAuth2Defaults, forKey: .oAuth2Defaults)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isBasicAuthSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBasicAuthSupported) ?? false
        isBasicAuthSupported = isBasicAuthSupportedDecoded
        let isApiKeyAuthSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isApiKeyAuthSupported) ?? false
        isApiKeyAuthSupported = isApiKeyAuthSupportedDecoded
        let isOAuth2SupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isOAuth2Supported) ?? false
        isOAuth2Supported = isOAuth2SupportedDecoded
        let isCustomAuthSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCustomAuthSupported) ?? false
        isCustomAuthSupported = isCustomAuthSupportedDecoded
        let oAuth2DefaultsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2Defaults.self, forKey: .oAuth2Defaults)
        oAuth2Defaults = oAuth2DefaultsDecoded
        let customAuthConfigsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.CustomAuthConfig?].self, forKey: .customAuthConfigs)
        var customAuthConfigsDecoded0:[AppflowClientTypes.CustomAuthConfig]? = nil
        if let customAuthConfigsContainer = customAuthConfigsContainer {
            customAuthConfigsDecoded0 = [AppflowClientTypes.CustomAuthConfig]()
            for structure0 in customAuthConfigsContainer {
                if let structure0 = structure0 {
                    customAuthConfigsDecoded0?.append(structure0)
                }
            }
        }
        customAuthConfigs = customAuthConfigsDecoded0
    }
}

extension AppflowClientTypes {
    /// Contains information about the authentication config that the connector supports.
    public struct AuthenticationConfig: Swift.Equatable {
        /// Contains information required for custom authentication.
        public var customAuthConfigs: [AppflowClientTypes.CustomAuthConfig]?
        /// Indicates whether API key authentication is supported by the connector
        public var isApiKeyAuthSupported: Swift.Bool
        /// Indicates whether basic authentication is supported by the connector.
        public var isBasicAuthSupported: Swift.Bool
        /// Indicates whether custom authentication is supported by the connector
        public var isCustomAuthSupported: Swift.Bool
        /// Indicates whether OAuth 2.0 authentication is supported by the connector.
        public var isOAuth2Supported: Swift.Bool
        /// Contains the default values required for OAuth 2.0 authentication.
        public var oAuth2Defaults: AppflowClientTypes.OAuth2Defaults?

        public init(
            customAuthConfigs: [AppflowClientTypes.CustomAuthConfig]? = nil,
            isApiKeyAuthSupported: Swift.Bool = false,
            isBasicAuthSupported: Swift.Bool = false,
            isCustomAuthSupported: Swift.Bool = false,
            isOAuth2Supported: Swift.Bool = false,
            oAuth2Defaults: AppflowClientTypes.OAuth2Defaults? = nil
        )
        {
            self.customAuthConfigs = customAuthConfigs
            self.isApiKeyAuthSupported = isApiKeyAuthSupported
            self.isBasicAuthSupported = isBasicAuthSupported
            self.isCustomAuthSupported = isCustomAuthSupported
            self.isOAuth2Supported = isOAuth2Supported
            self.oAuth2Defaults = oAuth2Defaults
        }
    }

}

extension AppflowClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apikey
        case basic
        case custom
        case oauth2
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .apikey,
                .basic,
                .custom,
                .oauth2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apikey: return "APIKEY"
            case .basic: return "BASIC"
            case .custom: return "CUSTOM"
            case .oauth2: return "OAUTH2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.BasicAuthCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.BasicAuthCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BasicAuthCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The basic auth credentials required for basic authentication.
    public struct BasicAuthCredentials: Swift.Equatable {
        /// The password to use to connect to a resource.
        /// This member is required.
        public var password: Swift.String?
        /// The username to use to connect to a resource.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension CancelFlowExecutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionIds
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionIds = executionIds {
            var executionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .executionIds)
            for executionid0 in executionIds {
                try executionIdsContainer.encode(executionid0)
            }
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension CancelFlowExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/cancel-flow-executions"
    }
}

public struct CancelFlowExecutionsInput: Swift.Equatable {
    /// The ID of each active run to cancel. These runs must belong to the flow you specify in your request. If you omit this parameter, your request ends all active runs that belong to the flow.
    public var executionIds: [Swift.String]?
    /// The name of a flow with active runs that you want to cancel.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        executionIds: [Swift.String]? = nil,
        flowName: Swift.String? = nil
    )
    {
        self.executionIds = executionIds
        self.flowName = flowName
    }
}

struct CancelFlowExecutionsInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let executionIds: [Swift.String]?
}

extension CancelFlowExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionIds
        case flowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let executionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .executionIds)
        var executionIdsDecoded0:[Swift.String]? = nil
        if let executionIdsContainer = executionIdsContainer {
            executionIdsDecoded0 = [Swift.String]()
            for string0 in executionIdsContainer {
                if let string0 = string0 {
                    executionIdsDecoded0?.append(string0)
                }
            }
        }
        executionIds = executionIdsDecoded0
    }
}

extension CancelFlowExecutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelFlowExecutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.invalidExecutions = output.invalidExecutions
        } else {
            self.invalidExecutions = nil
        }
    }
}

public struct CancelFlowExecutionsOutput: Swift.Equatable {
    /// The IDs of runs that Amazon AppFlow couldn't cancel. These runs might be ineligible for canceling because they haven't started yet or have already completed.
    public var invalidExecutions: [Swift.String]?

    public init(
        invalidExecutions: [Swift.String]? = nil
    )
    {
        self.invalidExecutions = invalidExecutions
    }
}

struct CancelFlowExecutionsOutputBody: Swift.Equatable {
    let invalidExecutions: [Swift.String]?
}

extension CancelFlowExecutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidExecutions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidExecutionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .invalidExecutions)
        var invalidExecutionsDecoded0:[Swift.String]? = nil
        if let invalidExecutionsContainer = invalidExecutionsContainer {
            invalidExecutionsDecoded0 = [Swift.String]()
            for string0 in invalidExecutionsContainer {
                if let string0 = string0 {
                    invalidExecutionsDecoded0?.append(string0)
                }
            }
        }
        invalidExecutions = invalidExecutionsDecoded0
    }
}

enum CancelFlowExecutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes {
    public enum CatalogType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case glue
        case sdkUnknown(Swift.String)

        public static var allCases: [CatalogType] {
            return [
                .glue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .glue: return "GLUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CatalogType(rawValue: rawValue) ?? CatalogType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was a conflict when processing the request (for example, a flow with the given name already exists within the account. Check for conflicting resource names and try again.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionMode] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "Private"
            case .public: return "Public"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionMode(rawValue: rawValue) ?? ConnectionMode.sdkUnknown(rawValue)
        }
    }
}

extension ConnectorAuthenticationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectorAuthenticationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error occurred when authenticating with the connector endpoint.
public struct ConnectorAuthenticationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorAuthenticationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConnectorAuthenticationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorAuthenticationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes.ConnectorConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfig
        case canUseAsDestination
        case canUseAsSource
        case connectorArn
        case connectorDescription
        case connectorLabel
        case connectorMetadata
        case connectorModes
        case connectorName
        case connectorOwner
        case connectorProvisioningConfig
        case connectorProvisioningType
        case connectorRuntimeSettings
        case connectorType
        case connectorVersion
        case isPrivateLinkEnabled
        case isPrivateLinkEndpointUrlRequired
        case logoURL
        case registeredAt
        case registeredBy
        case supportedApiVersions
        case supportedDataTransferApis
        case supportedDataTransferTypes
        case supportedDestinationConnectors
        case supportedOperators
        case supportedSchedulingFrequencies
        case supportedTriggerTypes
        case supportedWriteOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfig = self.authenticationConfig {
            try encodeContainer.encode(authenticationConfig, forKey: .authenticationConfig)
        }
        if canUseAsDestination != false {
            try encodeContainer.encode(canUseAsDestination, forKey: .canUseAsDestination)
        }
        if canUseAsSource != false {
            try encodeContainer.encode(canUseAsSource, forKey: .canUseAsSource)
        }
        if let connectorArn = self.connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let connectorDescription = self.connectorDescription {
            try encodeContainer.encode(connectorDescription, forKey: .connectorDescription)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorMetadata = self.connectorMetadata {
            try encodeContainer.encode(connectorMetadata, forKey: .connectorMetadata)
        }
        if let connectorModes = connectorModes {
            var connectorModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorModes)
            for connectormode0 in connectorModes {
                try connectorModesContainer.encode(connectormode0)
            }
        }
        if let connectorName = self.connectorName {
            try encodeContainer.encode(connectorName, forKey: .connectorName)
        }
        if let connectorOwner = self.connectorOwner {
            try encodeContainer.encode(connectorOwner, forKey: .connectorOwner)
        }
        if let connectorProvisioningConfig = self.connectorProvisioningConfig {
            try encodeContainer.encode(connectorProvisioningConfig, forKey: .connectorProvisioningConfig)
        }
        if let connectorProvisioningType = self.connectorProvisioningType {
            try encodeContainer.encode(connectorProvisioningType.rawValue, forKey: .connectorProvisioningType)
        }
        if let connectorRuntimeSettings = connectorRuntimeSettings {
            var connectorRuntimeSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorRuntimeSettings)
            for connectorruntimesetting0 in connectorRuntimeSettings {
                try connectorRuntimeSettingsContainer.encode(connectorruntimesetting0)
            }
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let connectorVersion = self.connectorVersion {
            try encodeContainer.encode(connectorVersion, forKey: .connectorVersion)
        }
        if isPrivateLinkEnabled != false {
            try encodeContainer.encode(isPrivateLinkEnabled, forKey: .isPrivateLinkEnabled)
        }
        if isPrivateLinkEndpointUrlRequired != false {
            try encodeContainer.encode(isPrivateLinkEndpointUrlRequired, forKey: .isPrivateLinkEndpointUrlRequired)
        }
        if let logoURL = self.logoURL {
            try encodeContainer.encode(logoURL, forKey: .logoURL)
        }
        if let registeredAt = self.registeredAt {
            try encodeContainer.encodeTimestamp(registeredAt, format: .epochSeconds, forKey: .registeredAt)
        }
        if let registeredBy = self.registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let supportedApiVersions = supportedApiVersions {
            var supportedApiVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedApiVersions)
            for supportedapiversion0 in supportedApiVersions {
                try supportedApiVersionsContainer.encode(supportedapiversion0)
            }
        }
        if let supportedDataTransferApis = supportedDataTransferApis {
            var supportedDataTransferApisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDataTransferApis)
            for datatransferapi0 in supportedDataTransferApis {
                try supportedDataTransferApisContainer.encode(datatransferapi0)
            }
        }
        if let supportedDataTransferTypes = supportedDataTransferTypes {
            var supportedDataTransferTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDataTransferTypes)
            for supporteddatatransfertype0 in supportedDataTransferTypes {
                try supportedDataTransferTypesContainer.encode(supporteddatatransfertype0.rawValue)
            }
        }
        if let supportedDestinationConnectors = supportedDestinationConnectors {
            var supportedDestinationConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDestinationConnectors)
            for connectortype0 in supportedDestinationConnectors {
                try supportedDestinationConnectorsContainer.encode(connectortype0.rawValue)
            }
        }
        if let supportedOperators = supportedOperators {
            var supportedOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOperators)
            for operators0 in supportedOperators {
                try supportedOperatorsContainer.encode(operators0.rawValue)
            }
        }
        if let supportedSchedulingFrequencies = supportedSchedulingFrequencies {
            var supportedSchedulingFrequenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedSchedulingFrequencies)
            for schedulefrequencytype0 in supportedSchedulingFrequencies {
                try supportedSchedulingFrequenciesContainer.encode(schedulefrequencytype0.rawValue)
            }
        }
        if let supportedTriggerTypes = supportedTriggerTypes {
            var supportedTriggerTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedTriggerTypes)
            for triggertype0 in supportedTriggerTypes {
                try supportedTriggerTypesContainer.encode(triggertype0.rawValue)
            }
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for writeoperationtype0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(writeoperationtype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let canUseAsSourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUseAsSource) ?? false
        canUseAsSource = canUseAsSourceDecoded
        let canUseAsDestinationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .canUseAsDestination) ?? false
        canUseAsDestination = canUseAsDestinationDecoded
        let supportedDestinationConnectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .supportedDestinationConnectors)
        var supportedDestinationConnectorsDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let supportedDestinationConnectorsContainer = supportedDestinationConnectorsContainer {
            supportedDestinationConnectorsDecoded0 = [AppflowClientTypes.ConnectorType]()
            for enum0 in supportedDestinationConnectorsContainer {
                if let enum0 = enum0 {
                    supportedDestinationConnectorsDecoded0?.append(enum0)
                }
            }
        }
        supportedDestinationConnectors = supportedDestinationConnectorsDecoded0
        let supportedSchedulingFrequenciesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ScheduleFrequencyType?].self, forKey: .supportedSchedulingFrequencies)
        var supportedSchedulingFrequenciesDecoded0:[AppflowClientTypes.ScheduleFrequencyType]? = nil
        if let supportedSchedulingFrequenciesContainer = supportedSchedulingFrequenciesContainer {
            supportedSchedulingFrequenciesDecoded0 = [AppflowClientTypes.ScheduleFrequencyType]()
            for enum0 in supportedSchedulingFrequenciesContainer {
                if let enum0 = enum0 {
                    supportedSchedulingFrequenciesDecoded0?.append(enum0)
                }
            }
        }
        supportedSchedulingFrequencies = supportedSchedulingFrequenciesDecoded0
        let isPrivateLinkEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrivateLinkEnabled) ?? false
        isPrivateLinkEnabled = isPrivateLinkEnabledDecoded
        let isPrivateLinkEndpointUrlRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrivateLinkEndpointUrlRequired) ?? false
        isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequiredDecoded
        let supportedTriggerTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.TriggerType?].self, forKey: .supportedTriggerTypes)
        var supportedTriggerTypesDecoded0:[AppflowClientTypes.TriggerType]? = nil
        if let supportedTriggerTypesContainer = supportedTriggerTypesContainer {
            supportedTriggerTypesDecoded0 = [AppflowClientTypes.TriggerType]()
            for enum0 in supportedTriggerTypesContainer {
                if let enum0 = enum0 {
                    supportedTriggerTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedTriggerTypes = supportedTriggerTypesDecoded0
        let connectorMetadataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorMetadata.self, forKey: .connectorMetadata)
        connectorMetadata = connectorMetadataDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorOwner)
        connectorOwner = connectorOwnerDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorVersion)
        connectorVersion = connectorVersionDecoded
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let connectorModesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorModes)
        var connectorModesDecoded0:[Swift.String]? = nil
        if let connectorModesContainer = connectorModesContainer {
            connectorModesDecoded0 = [Swift.String]()
            for string0 in connectorModesContainer {
                if let string0 = string0 {
                    connectorModesDecoded0?.append(string0)
                }
            }
        }
        connectorModes = connectorModesDecoded0
        let authenticationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AuthenticationConfig.self, forKey: .authenticationConfig)
        authenticationConfig = authenticationConfigDecoded
        let connectorRuntimeSettingsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorRuntimeSetting?].self, forKey: .connectorRuntimeSettings)
        var connectorRuntimeSettingsDecoded0:[AppflowClientTypes.ConnectorRuntimeSetting]? = nil
        if let connectorRuntimeSettingsContainer = connectorRuntimeSettingsContainer {
            connectorRuntimeSettingsDecoded0 = [AppflowClientTypes.ConnectorRuntimeSetting]()
            for structure0 in connectorRuntimeSettingsContainer {
                if let structure0 = structure0 {
                    connectorRuntimeSettingsDecoded0?.append(structure0)
                }
            }
        }
        connectorRuntimeSettings = connectorRuntimeSettingsDecoded0
        let supportedApiVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedApiVersions)
        var supportedApiVersionsDecoded0:[Swift.String]? = nil
        if let supportedApiVersionsContainer = supportedApiVersionsContainer {
            supportedApiVersionsDecoded0 = [Swift.String]()
            for string0 in supportedApiVersionsContainer {
                if let string0 = string0 {
                    supportedApiVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedApiVersions = supportedApiVersionsDecoded0
        let supportedOperatorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Operators?].self, forKey: .supportedOperators)
        var supportedOperatorsDecoded0:[AppflowClientTypes.Operators]? = nil
        if let supportedOperatorsContainer = supportedOperatorsContainer {
            supportedOperatorsDecoded0 = [AppflowClientTypes.Operators]()
            for enum0 in supportedOperatorsContainer {
                if let enum0 = enum0 {
                    supportedOperatorsDecoded0?.append(enum0)
                }
            }
        }
        supportedOperators = supportedOperatorsDecoded0
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[AppflowClientTypes.WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [AppflowClientTypes.WriteOperationType]()
            for enum0 in supportedWriteOperationsContainer {
                if let enum0 = enum0 {
                    supportedWriteOperationsDecoded0?.append(enum0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
        let connectorProvisioningTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningType.self, forKey: .connectorProvisioningType)
        connectorProvisioningType = connectorProvisioningTypeDecoded
        let connectorProvisioningConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningConfig.self, forKey: .connectorProvisioningConfig)
        connectorProvisioningConfig = connectorProvisioningConfigDecoded
        let logoURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logoURL)
        logoURL = logoURLDecoded
        let registeredAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let supportedDataTransferTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.SupportedDataTransferType?].self, forKey: .supportedDataTransferTypes)
        var supportedDataTransferTypesDecoded0:[AppflowClientTypes.SupportedDataTransferType]? = nil
        if let supportedDataTransferTypesContainer = supportedDataTransferTypesContainer {
            supportedDataTransferTypesDecoded0 = [AppflowClientTypes.SupportedDataTransferType]()
            for enum0 in supportedDataTransferTypesContainer {
                if let enum0 = enum0 {
                    supportedDataTransferTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedDataTransferTypes = supportedDataTransferTypesDecoded0
        let supportedDataTransferApisContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DataTransferApi?].self, forKey: .supportedDataTransferApis)
        var supportedDataTransferApisDecoded0:[AppflowClientTypes.DataTransferApi]? = nil
        if let supportedDataTransferApisContainer = supportedDataTransferApisContainer {
            supportedDataTransferApisDecoded0 = [AppflowClientTypes.DataTransferApi]()
            for structure0 in supportedDataTransferApisContainer {
                if let structure0 = structure0 {
                    supportedDataTransferApisDecoded0?.append(structure0)
                }
            }
        }
        supportedDataTransferApis = supportedDataTransferApisDecoded0
    }
}

extension AppflowClientTypes {
    /// The configuration settings related to a given connector.
    public struct ConnectorConfiguration: Swift.Equatable {
        /// The authentication config required for the connector.
        public var authenticationConfig: AppflowClientTypes.AuthenticationConfig?
        /// Specifies whether the connector can be used as a destination.
        public var canUseAsDestination: Swift.Bool
        /// Specifies whether the connector can be used as a source.
        public var canUseAsSource: Swift.Bool
        /// The Amazon Resource Name (ARN) for the registered connector.
        public var connectorArn: Swift.String?
        /// A description about the connector.
        public var connectorDescription: Swift.String?
        /// The label used for registering the connector.
        public var connectorLabel: Swift.String?
        /// Specifies connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
        public var connectorMetadata: AppflowClientTypes.ConnectorMetadata?
        /// The connection modes that the connector supports.
        public var connectorModes: [Swift.String]?
        /// The connector name.
        public var connectorName: Swift.String?
        /// The owner who developed the connector.
        public var connectorOwner: Swift.String?
        /// The configuration required for registering the connector.
        public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
        /// The provisioning type used to register the connector.
        public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
        /// The required connector runtime settings.
        public var connectorRuntimeSettings: [AppflowClientTypes.ConnectorRuntimeSetting]?
        /// The connector type.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// The connector version.
        public var connectorVersion: Swift.String?
        /// Specifies if PrivateLink is enabled for that connector.
        public var isPrivateLinkEnabled: Swift.Bool
        /// Specifies if a PrivateLink endpoint URL is required.
        public var isPrivateLinkEndpointUrlRequired: Swift.Bool
        /// Logo URL of the connector.
        public var logoURL: Swift.String?
        /// The date on which the connector was registered.
        public var registeredAt: ClientRuntime.Date?
        /// Information about who registered the connector.
        public var registeredBy: Swift.String?
        /// A list of API versions that are supported by the connector.
        public var supportedApiVersions: [Swift.String]?
        /// The APIs of the connector application that Amazon AppFlow can use to transfer your data.
        public var supportedDataTransferApis: [AppflowClientTypes.DataTransferApi]?
        /// The data transfer types that the connector supports. RECORD Structured records. FILE Files or binary data.
        public var supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]?
        /// Lists the connectors that are available for use as destinations.
        public var supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]?
        /// A list of operators supported by the connector.
        public var supportedOperators: [AppflowClientTypes.Operators]?
        /// Specifies the supported flow frequency for that connector.
        public var supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]?
        /// Specifies the supported trigger types for the flow.
        public var supportedTriggerTypes: [AppflowClientTypes.TriggerType]?
        /// A list of write operations supported by the connector.
        public var supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init(
            authenticationConfig: AppflowClientTypes.AuthenticationConfig? = nil,
            canUseAsDestination: Swift.Bool = false,
            canUseAsSource: Swift.Bool = false,
            connectorArn: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorLabel: Swift.String? = nil,
            connectorMetadata: AppflowClientTypes.ConnectorMetadata? = nil,
            connectorModes: [Swift.String]? = nil,
            connectorName: Swift.String? = nil,
            connectorOwner: Swift.String? = nil,
            connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
            connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
            connectorRuntimeSettings: [AppflowClientTypes.ConnectorRuntimeSetting]? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            connectorVersion: Swift.String? = nil,
            isPrivateLinkEnabled: Swift.Bool = false,
            isPrivateLinkEndpointUrlRequired: Swift.Bool = false,
            logoURL: Swift.String? = nil,
            registeredAt: ClientRuntime.Date? = nil,
            registeredBy: Swift.String? = nil,
            supportedApiVersions: [Swift.String]? = nil,
            supportedDataTransferApis: [AppflowClientTypes.DataTransferApi]? = nil,
            supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]? = nil,
            supportedDestinationConnectors: [AppflowClientTypes.ConnectorType]? = nil,
            supportedOperators: [AppflowClientTypes.Operators]? = nil,
            supportedSchedulingFrequencies: [AppflowClientTypes.ScheduleFrequencyType]? = nil,
            supportedTriggerTypes: [AppflowClientTypes.TriggerType]? = nil,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.authenticationConfig = authenticationConfig
            self.canUseAsDestination = canUseAsDestination
            self.canUseAsSource = canUseAsSource
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorMetadata = connectorMetadata
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningConfig = connectorProvisioningConfig
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorRuntimeSettings = connectorRuntimeSettings
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.isPrivateLinkEnabled = isPrivateLinkEnabled
            self.isPrivateLinkEndpointUrlRequired = isPrivateLinkEndpointUrlRequired
            self.logoURL = logoURL
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedApiVersions = supportedApiVersions
            self.supportedDataTransferApis = supportedDataTransferApis
            self.supportedDataTransferTypes = supportedDataTransferTypes
            self.supportedDestinationConnectors = supportedDestinationConnectors
            self.supportedOperators = supportedOperators
            self.supportedSchedulingFrequencies = supportedSchedulingFrequencies
            self.supportedTriggerTypes = supportedTriggerTypes
            self.supportedWriteOperations = supportedWriteOperations
        }
    }

}

extension AppflowClientTypes.ConnectorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationType
        case connectorDescription
        case connectorLabel
        case connectorModes
        case connectorName
        case connectorOwner
        case connectorProvisioningType
        case connectorType
        case connectorVersion
        case registeredAt
        case registeredBy
        case supportedDataTransferTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationType = self.applicationType {
            try encodeContainer.encode(applicationType, forKey: .applicationType)
        }
        if let connectorDescription = self.connectorDescription {
            try encodeContainer.encode(connectorDescription, forKey: .connectorDescription)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorModes = connectorModes {
            var connectorModesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorModes)
            for connectormode0 in connectorModes {
                try connectorModesContainer.encode(connectormode0)
            }
        }
        if let connectorName = self.connectorName {
            try encodeContainer.encode(connectorName, forKey: .connectorName)
        }
        if let connectorOwner = self.connectorOwner {
            try encodeContainer.encode(connectorOwner, forKey: .connectorOwner)
        }
        if let connectorProvisioningType = self.connectorProvisioningType {
            try encodeContainer.encode(connectorProvisioningType.rawValue, forKey: .connectorProvisioningType)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let connectorVersion = self.connectorVersion {
            try encodeContainer.encode(connectorVersion, forKey: .connectorVersion)
        }
        if let registeredAt = self.registeredAt {
            try encodeContainer.encodeTimestamp(registeredAt, format: .epochSeconds, forKey: .registeredAt)
        }
        if let registeredBy = self.registeredBy {
            try encodeContainer.encode(registeredBy, forKey: .registeredBy)
        }
        if let supportedDataTransferTypes = supportedDataTransferTypes {
            var supportedDataTransferTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedDataTransferTypes)
            for supporteddatatransfertype0 in supportedDataTransferTypes {
                try supportedDataTransferTypesContainer.encode(supporteddatatransfertype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDescription)
        connectorDescription = connectorDescriptionDecoded
        let connectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorName)
        connectorName = connectorNameDecoded
        let connectorOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorOwner)
        connectorOwner = connectorOwnerDecoded
        let connectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorVersion)
        connectorVersion = connectorVersionDecoded
        let applicationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationType)
        applicationType = applicationTypeDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let registeredAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
        let registeredByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredBy)
        registeredBy = registeredByDecoded
        let connectorProvisioningTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningType.self, forKey: .connectorProvisioningType)
        connectorProvisioningType = connectorProvisioningTypeDecoded
        let connectorModesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorModes)
        var connectorModesDecoded0:[Swift.String]? = nil
        if let connectorModesContainer = connectorModesContainer {
            connectorModesDecoded0 = [Swift.String]()
            for string0 in connectorModesContainer {
                if let string0 = string0 {
                    connectorModesDecoded0?.append(string0)
                }
            }
        }
        connectorModes = connectorModesDecoded0
        let supportedDataTransferTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.SupportedDataTransferType?].self, forKey: .supportedDataTransferTypes)
        var supportedDataTransferTypesDecoded0:[AppflowClientTypes.SupportedDataTransferType]? = nil
        if let supportedDataTransferTypesContainer = supportedDataTransferTypesContainer {
            supportedDataTransferTypesDecoded0 = [AppflowClientTypes.SupportedDataTransferType]()
            for enum0 in supportedDataTransferTypesContainer {
                if let enum0 = enum0 {
                    supportedDataTransferTypesDecoded0?.append(enum0)
                }
            }
        }
        supportedDataTransferTypes = supportedDataTransferTypesDecoded0
    }
}

extension AppflowClientTypes {
    /// Information about the registered connector.
    public struct ConnectorDetail: Swift.Equatable {
        /// The application type of the connector.
        public var applicationType: Swift.String?
        /// A description about the registered connector.
        public var connectorDescription: Swift.String?
        /// A label used for the connector.
        public var connectorLabel: Swift.String?
        /// The connection mode that the connector supports.
        public var connectorModes: [Swift.String]?
        /// The name of the connector.
        public var connectorName: Swift.String?
        /// The owner of the connector.
        public var connectorOwner: Swift.String?
        /// The provisioning type that the connector uses.
        public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
        /// The connector type.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// The connector version.
        public var connectorVersion: Swift.String?
        /// The time at which the connector was registered.
        public var registeredAt: ClientRuntime.Date?
        /// The user who registered the connector.
        public var registeredBy: Swift.String?
        /// The data transfer types that the connector supports. RECORD Structured records. FILE Files or binary data.
        public var supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]?

        public init(
            applicationType: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorLabel: Swift.String? = nil,
            connectorModes: [Swift.String]? = nil,
            connectorName: Swift.String? = nil,
            connectorOwner: Swift.String? = nil,
            connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            connectorVersion: Swift.String? = nil,
            registeredAt: ClientRuntime.Date? = nil,
            registeredBy: Swift.String? = nil,
            supportedDataTransferTypes: [AppflowClientTypes.SupportedDataTransferType]? = nil
        )
        {
            self.applicationType = applicationType
            self.connectorDescription = connectorDescription
            self.connectorLabel = connectorLabel
            self.connectorModes = connectorModes
            self.connectorName = connectorName
            self.connectorOwner = connectorOwner
            self.connectorProvisioningType = connectorProvisioningType
            self.connectorType = connectorType
            self.connectorVersion = connectorVersion
            self.registeredAt = registeredAt
            self.registeredBy = registeredBy
            self.supportedDataTransferTypes = supportedDataTransferTypes
        }
    }

}

extension AppflowClientTypes.ConnectorEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hasNestedEntities
        case label
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hasNestedEntities != false {
            try encodeContainer.encode(hasNestedEntities, forKey: .hasNestedEntities)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let hasNestedEntitiesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasNestedEntities) ?? false
        hasNestedEntities = hasNestedEntitiesDecoded
    }
}

extension AppflowClientTypes {
    /// The high-level entity that can be queried in Amazon AppFlow. For example, a Salesforce entity might be an Account or Opportunity, whereas a ServiceNow entity might be an Incident.
    public struct ConnectorEntity: Swift.Equatable {
        /// Specifies whether the connector entity is a parent or a category and has more entities nested underneath it. If another call is made with entitiesPath = "the_current_entity_name_with_hasNestedEntities_true", then it returns the nested entities underneath it. This provides a way to retrieve all supported entities in a recursive fashion.
        public var hasNestedEntities: Swift.Bool
        /// The label applied to the connector entity.
        public var label: Swift.String?
        /// The name of the connector entity.
        /// This member is required.
        public var name: Swift.String?

        public init(
            hasNestedEntities: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.hasNestedEntities = hasNestedEntities
            self.label = label
            self.name = name
        }
    }

}

extension AppflowClientTypes.ConnectorEntityField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customProperties
        case defaultValue
        case description
        case destinationProperties
        case identifier
        case isDeprecated
        case isPrimaryKey
        case label
        case parentIdentifier
        case sourceProperties
        case supportedFieldTypeDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customProperties = customProperties {
            var customPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customProperties)
            for (dictKey0, customProperties0) in customProperties {
                try customPropertiesContainer.encode(customProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationProperties = self.destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if isDeprecated != false {
            try encodeContainer.encode(isDeprecated, forKey: .isDeprecated)
        }
        if isPrimaryKey != false {
            try encodeContainer.encode(isPrimaryKey, forKey: .isPrimaryKey)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let parentIdentifier = self.parentIdentifier {
            try encodeContainer.encode(parentIdentifier, forKey: .parentIdentifier)
        }
        if let sourceProperties = self.sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let supportedFieldTypeDetails = self.supportedFieldTypeDetails {
            try encodeContainer.encode(supportedFieldTypeDetails, forKey: .supportedFieldTypeDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let parentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentIdentifier)
        parentIdentifier = parentIdentifierDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let isPrimaryKeyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimaryKey) ?? false
        isPrimaryKey = isPrimaryKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let isDeprecatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDeprecated) ?? false
        isDeprecated = isDeprecatedDecoded
        let supportedFieldTypeDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SupportedFieldTypeDetails.self, forKey: .supportedFieldTypeDetails)
        supportedFieldTypeDetails = supportedFieldTypeDetailsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFieldProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationFieldProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
        let customPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customProperties)
        var customPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let customPropertiesContainer = customPropertiesContainer {
            customPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, custompropertyvalue0) in customPropertiesContainer {
                if let custompropertyvalue0 = custompropertyvalue0 {
                    customPropertiesDecoded0?[key0] = custompropertyvalue0
                }
            }
        }
        customProperties = customPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// Describes the data model of a connector field. For example, for an account entity, the fields would be account name, account ID, and so on.
    public struct ConnectorEntityField: Swift.Equatable {
        /// A map that has specific properties related to the ConnectorEntityField.
        public var customProperties: [Swift.String:Swift.String]?
        /// Default value that can be assigned to this field.
        public var defaultValue: Swift.String?
        /// A description of the connector entity field.
        public var description: Swift.String?
        /// The properties applied to a field when the connector is being used as a destination.
        public var destinationProperties: AppflowClientTypes.DestinationFieldProperties?
        /// The unique identifier of the connector field.
        /// This member is required.
        public var identifier: Swift.String?
        /// Booelan value that indicates whether this field is deprecated or not.
        public var isDeprecated: Swift.Bool
        /// Booelan value that indicates whether this field can be used as a primary key.
        public var isPrimaryKey: Swift.Bool
        /// The label applied to a connector entity field.
        public var label: Swift.String?
        /// The parent identifier of the connector field.
        public var parentIdentifier: Swift.String?
        /// The properties that can be applied to a field when the connector is being used as a source.
        public var sourceProperties: AppflowClientTypes.SourceFieldProperties?
        /// Contains details regarding the supported FieldType, including the corresponding filterOperators and supportedValues.
        public var supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails?

        public init(
            customProperties: [Swift.String:Swift.String]? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationProperties: AppflowClientTypes.DestinationFieldProperties? = nil,
            identifier: Swift.String? = nil,
            isDeprecated: Swift.Bool = false,
            isPrimaryKey: Swift.Bool = false,
            label: Swift.String? = nil,
            parentIdentifier: Swift.String? = nil,
            sourceProperties: AppflowClientTypes.SourceFieldProperties? = nil,
            supportedFieldTypeDetails: AppflowClientTypes.SupportedFieldTypeDetails? = nil
        )
        {
            self.customProperties = customProperties
            self.defaultValue = defaultValue
            self.description = description
            self.destinationProperties = destinationProperties
            self.identifier = identifier
            self.isDeprecated = isDeprecated
            self.isPrimaryKey = isPrimaryKey
            self.label = label
            self.parentIdentifier = parentIdentifier
            self.sourceProperties = sourceProperties
            self.supportedFieldTypeDetails = supportedFieldTypeDetails
        }
    }

}

extension AppflowClientTypes.ConnectorMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customerProfiles = "CustomerProfiles"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case eventBridge = "EventBridge"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case redshift = "Redshift"
        case s3 = "S3"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case upsolver = "Upsolver"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = self.amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customerProfiles = self.customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let datadog = self.datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = self.dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let eventBridge = self.eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let googleAnalytics = self.googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = self.honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = self.inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let pardot = self.pardot {
            try encodeContainer.encode(pardot, forKey: .pardot)
        }
        if let redshift = self.redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = self.singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = self.slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = self.snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = self.trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let upsolver = self.upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let veeva = self.veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeMetadata.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogMetadata.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceMetadata.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsMetadata.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusMetadata.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoMetadata.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftMetadata.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3Metadata.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceMetadata.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowMetadata.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularMetadata.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackMetadata.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeMetadata.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroMetadata.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaMetadata.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskMetadata.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeMetadata.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverMetadata.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesMetadata.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeMetadata.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataMetadata.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
        let pardotDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PardotMetadata.self, forKey: .pardot)
        pardot = pardotDecoded
    }
}

extension AppflowClientTypes {
    /// A structure to specify connector-specific metadata such as oAuthScopes, supportedRegions, privateLinkServiceUrl, and so on.
    public struct ConnectorMetadata: Swift.Equatable {
        /// The connector metadata specific to Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeMetadata?
        /// The connector metadata specific to Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesMetadata?
        /// The connector metadata specific to Datadog.
        public var datadog: AppflowClientTypes.DatadogMetadata?
        /// The connector metadata specific to Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceMetadata?
        /// The connector metadata specific to Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeMetadata?
        /// The connector metadata specific to Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata?
        /// The connector metadata specific to Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeMetadata?
        /// The connector metadata specific to Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusMetadata?
        /// The connector metadata specific to Marketo.
        public var marketo: AppflowClientTypes.MarketoMetadata?
        /// The connector metadata specific to Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotMetadata?
        /// The connector metadata specific to Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftMetadata?
        /// The connector metadata specific to Amazon S3.
        public var s3: AppflowClientTypes.S3Metadata?
        /// The connector metadata specific to Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceMetadata?
        /// The connector metadata specific to SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataMetadata?
        /// The connector metadata specific to ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowMetadata?
        /// The connector metadata specific to Singular.
        public var singular: AppflowClientTypes.SingularMetadata?
        /// The connector metadata specific to Slack.
        public var slack: AppflowClientTypes.SlackMetadata?
        /// The connector metadata specific to Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeMetadata?
        /// The connector metadata specific to Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroMetadata?
        /// The connector metadata specific to Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverMetadata?
        /// The connector metadata specific to Veeva.
        public var veeva: AppflowClientTypes.VeevaMetadata?
        /// The connector metadata specific to Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskMetadata?

        public init(
            amplitude: AppflowClientTypes.AmplitudeMetadata? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesMetadata? = nil,
            datadog: AppflowClientTypes.DatadogMetadata? = nil,
            dynatrace: AppflowClientTypes.DynatraceMetadata? = nil,
            eventBridge: AppflowClientTypes.EventBridgeMetadata? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsMetadata? = nil,
            honeycode: AppflowClientTypes.HoneycodeMetadata? = nil,
            inforNexus: AppflowClientTypes.InforNexusMetadata? = nil,
            marketo: AppflowClientTypes.MarketoMetadata? = nil,
            pardot: AppflowClientTypes.PardotMetadata? = nil,
            redshift: AppflowClientTypes.RedshiftMetadata? = nil,
            s3: AppflowClientTypes.S3Metadata? = nil,
            salesforce: AppflowClientTypes.SalesforceMetadata? = nil,
            sapoData: AppflowClientTypes.SAPODataMetadata? = nil,
            serviceNow: AppflowClientTypes.ServiceNowMetadata? = nil,
            singular: AppflowClientTypes.SingularMetadata? = nil,
            slack: AppflowClientTypes.SlackMetadata? = nil,
            snowflake: AppflowClientTypes.SnowflakeMetadata? = nil,
            trendmicro: AppflowClientTypes.TrendmicroMetadata? = nil,
            upsolver: AppflowClientTypes.UpsolverMetadata? = nil,
            veeva: AppflowClientTypes.VeevaMetadata? = nil,
            zendesk: AppflowClientTypes.ZendeskMetadata? = nil
        )
        {
            self.amplitude = amplitude
            self.customerProfiles = customerProfiles
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.eventBridge = eventBridge
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.upsolver = upsolver
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorOAuthRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCode
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCode = self.authCode {
            try encodeContainer.encode(authCode, forKey: .authCode)
        }
        if let redirectUri = self.redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCode)
        authCode = authCodeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension AppflowClientTypes {
    /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
    public struct ConnectorOAuthRequest: Swift.Equatable {
        /// The code provided by the connector when it has been authenticated via the connected app.
        public var authCode: Swift.String?
        /// The URL to which the authentication server redirects the browser after authorization has been granted.
        public var redirectUri: Swift.String?

        public init(
            authCode: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.authCode = authCode
            self.redirectUri = redirectUri
        }
    }

}

extension AppflowClientTypes.ConnectorOperator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customConnector = "CustomConnector"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case s3 = "S3"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = self.amplitude {
            try encodeContainer.encode(amplitude.rawValue, forKey: .amplitude)
        }
        if let customConnector = self.customConnector {
            try encodeContainer.encode(customConnector.rawValue, forKey: .customConnector)
        }
        if let datadog = self.datadog {
            try encodeContainer.encode(datadog.rawValue, forKey: .datadog)
        }
        if let dynatrace = self.dynatrace {
            try encodeContainer.encode(dynatrace.rawValue, forKey: .dynatrace)
        }
        if let googleAnalytics = self.googleAnalytics {
            try encodeContainer.encode(googleAnalytics.rawValue, forKey: .googleAnalytics)
        }
        if let inforNexus = self.inforNexus {
            try encodeContainer.encode(inforNexus.rawValue, forKey: .inforNexus)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo.rawValue, forKey: .marketo)
        }
        if let pardot = self.pardot {
            try encodeContainer.encode(pardot.rawValue, forKey: .pardot)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3.rawValue, forKey: .s3)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData.rawValue, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce.rawValue, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow.rawValue, forKey: .serviceNow)
        }
        if let singular = self.singular {
            try encodeContainer.encode(singular.rawValue, forKey: .singular)
        }
        if let slack = self.slack {
            try encodeContainer.encode(slack.rawValue, forKey: .slack)
        }
        if let trendmicro = self.trendmicro {
            try encodeContainer.encode(trendmicro.rawValue, forKey: .trendmicro)
        }
        if let veeva = self.veeva {
            try encodeContainer.encode(veeva.rawValue, forKey: .veeva)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk.rawValue, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorOperator.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorOperator.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorOperator.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorOperator.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorOperator.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorOperator.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3ConnectorOperator.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorOperator.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorOperator.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorOperator.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorOperator.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorOperator.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorOperator.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorOperator.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorOperator.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
        let customConnectorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.Operator.self, forKey: .customConnector)
        customConnector = customConnectorDecoded
        let pardotDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PardotConnectorOperator.self, forKey: .pardot)
        pardot = pardotDecoded
    }
}

extension AppflowClientTypes {
    /// The operation to be performed on the provided source fields.
    public struct ConnectorOperator: Swift.Equatable {
        /// The operation to be performed on the provided Amplitude source fields.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorOperator?
        /// Operators supported by the custom connector.
        public var customConnector: AppflowClientTypes.Operator?
        /// The operation to be performed on the provided Datadog source fields.
        public var datadog: AppflowClientTypes.DatadogConnectorOperator?
        /// The operation to be performed on the provided Dynatrace source fields.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorOperator?
        /// The operation to be performed on the provided Google Analytics source fields.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator?
        /// The operation to be performed on the provided Infor Nexus source fields.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorOperator?
        /// The operation to be performed on the provided Marketo source fields.
        public var marketo: AppflowClientTypes.MarketoConnectorOperator?
        /// The operation to be performed on the provided Salesforce Pardot source fields.
        public var pardot: AppflowClientTypes.PardotConnectorOperator?
        /// The operation to be performed on the provided Amazon S3 source fields.
        public var s3: AppflowClientTypes.S3ConnectorOperator?
        /// The operation to be performed on the provided Salesforce source fields.
        public var salesforce: AppflowClientTypes.SalesforceConnectorOperator?
        /// The operation to be performed on the provided SAPOData source fields.
        public var sapoData: AppflowClientTypes.SAPODataConnectorOperator?
        /// The operation to be performed on the provided ServiceNow source fields.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorOperator?
        /// The operation to be performed on the provided Singular source fields.
        public var singular: AppflowClientTypes.SingularConnectorOperator?
        /// The operation to be performed on the provided Slack source fields.
        public var slack: AppflowClientTypes.SlackConnectorOperator?
        /// The operation to be performed on the provided Trend Micro source fields.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorOperator?
        /// The operation to be performed on the provided Veeva source fields.
        public var veeva: AppflowClientTypes.VeevaConnectorOperator?
        /// The operation to be performed on the provided Zendesk source fields.
        public var zendesk: AppflowClientTypes.ZendeskConnectorOperator?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorOperator? = nil,
            customConnector: AppflowClientTypes.Operator? = nil,
            datadog: AppflowClientTypes.DatadogConnectorOperator? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorOperator? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorOperator? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorOperator? = nil,
            marketo: AppflowClientTypes.MarketoConnectorOperator? = nil,
            pardot: AppflowClientTypes.PardotConnectorOperator? = nil,
            s3: AppflowClientTypes.S3ConnectorOperator? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorOperator? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorOperator? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorOperator? = nil,
            singular: AppflowClientTypes.SingularConnectorOperator? = nil,
            slack: AppflowClientTypes.SlackConnectorOperator? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorOperator? = nil,
            veeva: AppflowClientTypes.VeevaConnectorOperator? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorOperator? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionMode
        case connectorLabel
        case connectorProfileArn
        case connectorProfileName
        case connectorProfileProperties
        case connectorType
        case createdAt
        case credentialsArn
        case lastUpdatedAt
        case privateConnectionProvisioningState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionMode = self.connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorProfileArn = self.connectorProfileArn {
            try encodeContainer.encode(connectorProfileArn, forKey: .connectorProfileArn)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorProfileProperties = self.connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let credentialsArn = self.credentialsArn {
            try encodeContainer.encode(credentialsArn, forKey: .credentialsArn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let privateConnectionProvisioningState = self.privateConnectionProvisioningState {
            try encodeContainer.encode(privateConnectionProvisioningState, forKey: .privateConnectionProvisioningState)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let credentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .credentialsArn)
        credentialsArn = credentialsArnDecoded
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let privateConnectionProvisioningStateDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningState.self, forKey: .privateConnectionProvisioningState)
        privateConnectionProvisioningState = privateConnectionProvisioningStateDecoded
    }
}

extension AppflowClientTypes {
    /// Describes an instance of a connector. This includes the provided name, credentials ARN, connection-mode, and so on. To keep the API intuitive and extensible, the fields that are common to all types of connector profiles are explicitly specified at the top level. The rest of the connector-specific properties are available via the connectorProfileProperties field.
    public struct ConnectorProfile: Swift.Equatable {
        /// Indicates the connection mode and if it is public or private.
        public var connectionMode: AppflowClientTypes.ConnectionMode?
        /// The label for the connector profile being created.
        public var connectorLabel: Swift.String?
        /// The Amazon Resource Name (ARN) of the connector profile.
        public var connectorProfileArn: Swift.String?
        /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The connector-specific properties of the profile configuration.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Specifies when the connector profile was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the connector profile credentials.
        public var credentialsArn: Swift.String?
        /// Specifies when the connector profile was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Specifies the private connection provisioning state.
        public var privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState?

        public init(
            connectionMode: AppflowClientTypes.ConnectionMode? = nil,
            connectorLabel: Swift.String? = nil,
            connectorProfileArn: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            credentialsArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            privateConnectionProvisioningState: AppflowClientTypes.PrivateConnectionProvisioningState? = nil
        )
        {
            self.connectionMode = connectionMode
            self.connectorLabel = connectorLabel
            self.connectorProfileArn = connectorProfileArn
            self.connectorProfileName = connectorProfileName
            self.connectorProfileProperties = connectorProfileProperties
            self.connectorType = connectorType
            self.createdAt = createdAt
            self.credentialsArn = credentialsArn
            self.lastUpdatedAt = lastUpdatedAt
            self.privateConnectionProvisioningState = privateConnectionProvisioningState
        }
    }

}

extension AppflowClientTypes.ConnectorProfileConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileCredentials
        case connectorProfileProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileCredentials = self.connectorProfileCredentials {
            try encodeContainer.encode(connectorProfileCredentials, forKey: .connectorProfileCredentials)
        }
        if let connectorProfileProperties = self.connectorProfileProperties {
            try encodeContainer.encode(connectorProfileProperties, forKey: .connectorProfileProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfilePropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileProperties.self, forKey: .connectorProfileProperties)
        connectorProfileProperties = connectorProfilePropertiesDecoded
        let connectorProfileCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileCredentials.self, forKey: .connectorProfileCredentials)
        connectorProfileCredentials = connectorProfileCredentialsDecoded
    }
}

extension AppflowClientTypes {
    /// Defines the connector-specific configuration and credentials for the connector profile.
    public struct ConnectorProfileConfig: Swift.Equatable {
        /// The connector-specific credentials required by each connector.
        public var connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials?
        /// The connector-specific properties of the profile configuration.
        /// This member is required.
        public var connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties?

        public init(
            connectorProfileCredentials: AppflowClientTypes.ConnectorProfileCredentials? = nil,
            connectorProfileProperties: AppflowClientTypes.ConnectorProfileProperties? = nil
        )
        {
            self.connectorProfileCredentials = connectorProfileCredentials
            self.connectorProfileProperties = connectorProfileProperties
        }
    }

}

extension AppflowClientTypes.ConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customConnector = "CustomConnector"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case redshift = "Redshift"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = self.amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customConnector = self.customConnector {
            try encodeContainer.encode(customConnector, forKey: .customConnector)
        }
        if let datadog = self.datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = self.dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = self.googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = self.honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = self.inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let pardot = self.pardot {
            try encodeContainer.encode(pardot, forKey: .pardot)
        }
        if let redshift = self.redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = self.singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = self.slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = self.snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = self.trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = self.veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileCredentials.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileCredentials.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileCredentials.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileCredentials.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileCredentials.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileCredentials.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileCredentials.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileCredentials.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileCredentials.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileCredentials.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileCredentials.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileCredentials.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileCredentials.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileCredentials.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileCredentials.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorProfileCredentials.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
        let customConnectorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomConnectorProfileCredentials.self, forKey: .customConnector)
        customConnector = customConnectorDecoded
        let pardotDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PardotConnectorProfileCredentials.self, forKey: .pardot)
        pardot = pardotDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific credentials required by a connector.
    public struct ConnectorProfileCredentials: Swift.Equatable {
        /// The connector-specific credentials required when using Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials?
        /// The connector-specific profile credentials that are required when using the custom connector.
        public var customConnector: AppflowClientTypes.CustomConnectorProfileCredentials?
        /// The connector-specific credentials required when using Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileCredentials?
        /// The connector-specific credentials required when using Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials?
        /// The connector-specific credentials required when using Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials?
        /// The connector-specific credentials required when using Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotConnectorProfileCredentials?
        /// The connector-specific credentials required when using Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials?
        /// The connector-specific credentials required when using Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials?
        /// The connector-specific profile credentials required when using SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataConnectorProfileCredentials?
        /// The connector-specific credentials required when using ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials?
        /// The connector-specific credentials required when using Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileCredentials?
        /// The connector-specific credentials required when using Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileCredentials?
        /// The connector-specific credentials required when using Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials?
        /// The connector-specific credentials required when using Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials?
        /// The connector-specific credentials required when using Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileCredentials?
        /// The connector-specific credentials required when using Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileCredentials? = nil,
            customConnector: AppflowClientTypes.CustomConnectorProfileCredentials? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileCredentials? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileCredentials? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileCredentials? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileCredentials? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileCredentials? = nil,
            pardot: AppflowClientTypes.PardotConnectorProfileCredentials? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileCredentials? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileCredentials? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorProfileCredentials? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileCredentials? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileCredentials? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileCredentials? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileCredentials? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileCredentials? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileCredentials? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileCredentials? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customConnector = "CustomConnector"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case honeycode = "Honeycode"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case redshift = "Redshift"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case snowflake = "Snowflake"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = self.amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customConnector = self.customConnector {
            try encodeContainer.encode(customConnector, forKey: .customConnector)
        }
        if let datadog = self.datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = self.dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = self.googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let honeycode = self.honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let inforNexus = self.inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let pardot = self.pardot {
            try encodeContainer.encode(pardot, forKey: .pardot)
        }
        if let redshift = self.redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = self.singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = self.slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let snowflake = self.snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let trendmicro = self.trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = self.veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeConnectorProfileProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogConnectorProfileProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceConnectorProfileProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeConnectorProfileProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusConnectorProfileProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoConnectorProfileProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftConnectorProfileProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceConnectorProfileProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowConnectorProfileProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularConnectorProfileProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackConnectorProfileProperties.self, forKey: .slack)
        slack = slackDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeConnectorProfileProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroConnectorProfileProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaConnectorProfileProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskConnectorProfileProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataConnectorProfileProperties.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
        let customConnectorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomConnectorProfileProperties.self, forKey: .customConnector)
        customConnector = customConnectorDecoded
        let pardotDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PardotConnectorProfileProperties.self, forKey: .pardot)
        pardot = pardotDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by each connector.
    public struct ConnectorProfileProperties: Swift.Equatable {
        /// The connector-specific properties required by Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties?
        /// The properties required by the custom connector.
        public var customConnector: AppflowClientTypes.CustomConnectorProfileProperties?
        /// The connector-specific properties required by Datadog.
        public var datadog: AppflowClientTypes.DatadogConnectorProfileProperties?
        /// The connector-specific properties required by Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties?
        /// The connector-specific properties required Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties?
        /// The connector-specific properties required by Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties?
        /// The connector-specific properties required by Marketo.
        public var marketo: AppflowClientTypes.MarketoConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotConnectorProfileProperties?
        /// The connector-specific properties required by Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftConnectorProfileProperties?
        /// The connector-specific properties required by Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties?
        /// The connector-specific profile properties required when using SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataConnectorProfileProperties?
        /// The connector-specific properties required by serviceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties?
        /// The connector-specific properties required by Singular.
        public var singular: AppflowClientTypes.SingularConnectorProfileProperties?
        /// The connector-specific properties required by Slack.
        public var slack: AppflowClientTypes.SlackConnectorProfileProperties?
        /// The connector-specific properties required by Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties?
        /// The connector-specific properties required by Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties?
        /// The connector-specific properties required by Veeva.
        public var veeva: AppflowClientTypes.VeevaConnectorProfileProperties?
        /// The connector-specific properties required by Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties?

        public init(
            amplitude: AppflowClientTypes.AmplitudeConnectorProfileProperties? = nil,
            customConnector: AppflowClientTypes.CustomConnectorProfileProperties? = nil,
            datadog: AppflowClientTypes.DatadogConnectorProfileProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceConnectorProfileProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeConnectorProfileProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusConnectorProfileProperties? = nil,
            marketo: AppflowClientTypes.MarketoConnectorProfileProperties? = nil,
            pardot: AppflowClientTypes.PardotConnectorProfileProperties? = nil,
            redshift: AppflowClientTypes.RedshiftConnectorProfileProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceConnectorProfileProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataConnectorProfileProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowConnectorProfileProperties? = nil,
            singular: AppflowClientTypes.SingularConnectorProfileProperties? = nil,
            slack: AppflowClientTypes.SlackConnectorProfileProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeConnectorProfileProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroConnectorProfileProperties? = nil,
            veeva: AppflowClientTypes.VeevaConnectorProfileProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskConnectorProfileProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.honeycode = honeycode
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.redshift = redshift
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.snowflake = snowflake
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.ConnectorProvisioningConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambda
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambda = self.lambda {
            try encodeContainer.encode(lambda, forKey: .lambda)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.LambdaConnectorProvisioningConfig.self, forKey: .lambda)
        lambda = lambdaDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of the connector being registered.
    public struct ConnectorProvisioningConfig: Swift.Equatable {
        /// Contains information about the configuration of the lambda which is being registered as the connector.
        public var lambda: AppflowClientTypes.LambdaConnectorProvisioningConfig?

        public init(
            lambda: AppflowClientTypes.LambdaConnectorProvisioningConfig? = nil
        )
        {
            self.lambda = lambda
        }
    }

}

extension AppflowClientTypes {
    /// The type of provisioning that the connector supports, such as Lambda.
    public enum ConnectorProvisioningType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorProvisioningType] {
            return [
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorProvisioningType(rawValue: rawValue) ?? ConnectorProvisioningType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ConnectorRuntimeSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorSuppliedValueOptions
        case dataType
        case description
        case isRequired
        case key
        case label
        case scope
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorSuppliedValueOptions = connectorSuppliedValueOptions {
            var connectorSuppliedValueOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorSuppliedValueOptions)
            for connectorsuppliedvalue0 in connectorSuppliedValueOptions {
                try connectorSuppliedValueOptionsContainer.encode(connectorsuppliedvalue0)
            }
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isRequired != false {
            try encodeContainer.encode(isRequired, forKey: .isRequired)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let isRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequired) ?? false
        isRequired = isRequiredDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let connectorSuppliedValueOptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorSuppliedValueOptions)
        var connectorSuppliedValueOptionsDecoded0:[Swift.String]? = nil
        if let connectorSuppliedValueOptionsContainer = connectorSuppliedValueOptionsContainer {
            connectorSuppliedValueOptionsDecoded0 = [Swift.String]()
            for string0 in connectorSuppliedValueOptionsContainer {
                if let string0 = string0 {
                    connectorSuppliedValueOptionsDecoded0?.append(string0)
                }
            }
        }
        connectorSuppliedValueOptions = connectorSuppliedValueOptionsDecoded0
    }
}

extension AppflowClientTypes {
    /// Contains information about the connector runtime settings that are required for flow execution.
    public struct ConnectorRuntimeSetting: Swift.Equatable {
        /// Contains default values for the connector runtime setting that are supplied by the connector.
        public var connectorSuppliedValueOptions: [Swift.String]?
        /// Data type of the connector runtime setting.
        public var dataType: Swift.String?
        /// A description about the connector runtime setting.
        public var description: Swift.String?
        /// Indicates whether this connector runtime setting is required.
        public var isRequired: Swift.Bool
        /// Contains value information about the connector runtime setting.
        public var key: Swift.String?
        /// A label used for connector runtime setting.
        public var label: Swift.String?
        /// Indicates the scope of the connector runtime setting.
        public var scope: Swift.String?

        public init(
            connectorSuppliedValueOptions: [Swift.String]? = nil,
            dataType: Swift.String? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil,
            scope: Swift.String? = nil
        )
        {
            self.connectorSuppliedValueOptions = connectorSuppliedValueOptions
            self.dataType = dataType
            self.description = description
            self.isRequired = isRequired
            self.key = key
            self.label = label
            self.scope = scope
        }
    }

}

extension ConnectorServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConnectorServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error occurred when retrieving data from the connector endpoint.
public struct ConnectorServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorServerException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConnectorServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConnectorServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum ConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amplitude
        case customconnector
        case customerprofiles
        case datadog
        case dynatrace
        case eventbridge
        case googleanalytics
        case honeycode
        case infornexus
        case lookoutmetrics
        case marketo
        case pardot
        case redshift
        case s3
        case salesforce
        case sapodata
        case servicenow
        case singular
        case slack
        case snowflake
        case trendmicro
        case upsolver
        case veeva
        case zendesk
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorType] {
            return [
                .amplitude,
                .customconnector,
                .customerprofiles,
                .datadog,
                .dynatrace,
                .eventbridge,
                .googleanalytics,
                .honeycode,
                .infornexus,
                .lookoutmetrics,
                .marketo,
                .pardot,
                .redshift,
                .s3,
                .salesforce,
                .sapodata,
                .servicenow,
                .singular,
                .slack,
                .snowflake,
                .trendmicro,
                .upsolver,
                .veeva,
                .zendesk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amplitude: return "Amplitude"
            case .customconnector: return "CustomConnector"
            case .customerprofiles: return "CustomerProfiles"
            case .datadog: return "Datadog"
            case .dynatrace: return "Dynatrace"
            case .eventbridge: return "EventBridge"
            case .googleanalytics: return "Googleanalytics"
            case .honeycode: return "Honeycode"
            case .infornexus: return "Infornexus"
            case .lookoutmetrics: return "LookoutMetrics"
            case .marketo: return "Marketo"
            case .pardot: return "Pardot"
            case .redshift: return "Redshift"
            case .s3: return "S3"
            case .salesforce: return "Salesforce"
            case .sapodata: return "SAPOData"
            case .servicenow: return "Servicenow"
            case .singular: return "Singular"
            case .slack: return "Slack"
            case .snowflake: return "Snowflake"
            case .trendmicro: return "Trendmicro"
            case .upsolver: return "Upsolver"
            case .veeva: return "Veeva"
            case .zendesk: return "Zendesk"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorType(rawValue: rawValue) ?? ConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension CreateConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectionMode
        case connectorLabel
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectionMode = self.connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorProfileConfig = self.connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
    }
}

extension CreateConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-connector-profile"
    }
}

public struct CreateConnectorProfileInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your CreateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateConnectorProfile. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// Indicates the connection mode and specifies whether it is public or private. Private flows use Amazon Web Services PrivateLink to route data over Amazon Web Services infrastructure without exposing it to the public internet.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// Defines the connector-specific configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    /// This member is required.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        kmsArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionMode = connectionMode
        self.connectorLabel = connectorLabel
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.kmsArn = kmsArn
    }
}

struct CreateConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let kmsArn: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorLabel: Swift.String?
    let connectionMode: AppflowClientTypes.ConnectionMode?
    let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    let clientToken: Swift.String?
}

extension CreateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectionMode
        case connectorLabel
        case connectorProfileConfig
        case connectorProfileName
        case connectorType
        case kmsArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateConnectorProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectorProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct CreateConnectorProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init(
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct CreateConnectorProfileOutputBody: Swift.Equatable {
    let connectorProfileArn: Swift.String?
}

extension CreateConnectorProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

enum CreateConnectorProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case metadataCatalogConfig
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfig0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfig0)
            }
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let kmsArn = self.kmsArn {
            try encodeContainer.encode(kmsArn, forKey: .kmsArn)
        }
        if let metadataCatalogConfig = self.metadataCatalogConfig {
            try encodeContainer.encode(metadataCatalogConfig, forKey: .metadataCatalogConfig)
        }
        if let sourceFlowConfig = self.sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for task0 in tasks {
                try tasksContainer.encode(task0)
            }
        }
        if let triggerConfig = self.triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

extension CreateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/create-flow"
    }
}

public struct CreateFlowInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your CreateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to CreateFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description of the flow you want to create.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow places data in the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.kmsArn = kmsArn
        self.metadataCatalogConfig = metadataCatalogConfig
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct CreateFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let description: Swift.String?
    let kmsArn: Swift.String?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let tasks: [AppflowClientTypes.Task]?
    let tags: [Swift.String:Swift.String]?
    let metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    let clientToken: Swift.String?
}

extension CreateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case destinationFlowConfigList
        case flowName
        case kmsArn
        case metadataCatalogConfig
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let metadataCatalogConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MetadataCatalogConfig.self, forKey: .metadataCatalogConfig)
        metadataCatalogConfig = metadataCatalogConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct CreateFlowOutput: Swift.Equatable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct CreateFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension CreateFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

enum CreateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.CustomAuthConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authParameters
        case customAuthenticationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = authParameters {
            var authParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authParameters)
            for authparameter0 in authParameters {
                try authParametersContainer.encode(authparameter0)
            }
        }
        if let customAuthenticationType = self.customAuthenticationType {
            try encodeContainer.encode(customAuthenticationType, forKey: .customAuthenticationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAuthenticationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAuthenticationType)
        customAuthenticationType = customAuthenticationTypeDecoded
        let authParametersContainer = try containerValues.decodeIfPresent([AppflowClientTypes.AuthParameter?].self, forKey: .authParameters)
        var authParametersDecoded0:[AppflowClientTypes.AuthParameter]? = nil
        if let authParametersContainer = authParametersContainer {
            authParametersDecoded0 = [AppflowClientTypes.AuthParameter]()
            for structure0 in authParametersContainer {
                if let structure0 = structure0 {
                    authParametersDecoded0?.append(structure0)
                }
            }
        }
        authParameters = authParametersDecoded0
    }
}

extension AppflowClientTypes {
    /// Configuration information required for custom authentication.
    public struct CustomAuthConfig: Swift.Equatable {
        /// Information about authentication parameters required for authentication.
        public var authParameters: [AppflowClientTypes.AuthParameter]?
        /// The authentication type that the custom connector uses.
        public var customAuthenticationType: Swift.String?

        public init(
            authParameters: [AppflowClientTypes.AuthParameter]? = nil,
            customAuthenticationType: Swift.String? = nil
        )
        {
            self.authParameters = authParameters
            self.customAuthenticationType = customAuthenticationType
        }
    }

}

extension AppflowClientTypes.CustomAuthCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentialsMap
        case customAuthenticationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let credentialsMap = credentialsMap {
            var credentialsMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .credentialsMap)
            for (dictKey0, credentialsMap0) in credentialsMap {
                try credentialsMapContainer.encode(credentialsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let customAuthenticationType = self.customAuthenticationType {
            try encodeContainer.encode(customAuthenticationType, forKey: .customAuthenticationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customAuthenticationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customAuthenticationType)
        customAuthenticationType = customAuthenticationTypeDecoded
        let credentialsMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .credentialsMap)
        var credentialsMapDecoded0: [Swift.String:Swift.String]? = nil
        if let credentialsMapContainer = credentialsMapContainer {
            credentialsMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, credentialsmapvalue0) in credentialsMapContainer {
                if let credentialsmapvalue0 = credentialsmapvalue0 {
                    credentialsMapDecoded0?[key0] = credentialsmapvalue0
                }
            }
        }
        credentialsMap = credentialsMapDecoded0
    }
}

extension AppflowClientTypes {
    /// The custom credentials required for custom authentication.
    public struct CustomAuthCredentials: Swift.Equatable {
        /// A map that holds custom authentication credentials.
        public var credentialsMap: [Swift.String:Swift.String]?
        /// The custom authentication type that the connector uses.
        /// This member is required.
        public var customAuthenticationType: Swift.String?

        public init(
            credentialsMap: [Swift.String:Swift.String]? = nil,
            customAuthenticationType: Swift.String? = nil
        )
        {
            self.credentialsMap = credentialsMap
            self.customAuthenticationType = customAuthenticationType
        }
    }

}

extension AppflowClientTypes.CustomConnectorDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customProperties
        case entityName
        case errorHandlingConfig
        case idFieldNames
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customProperties = customProperties {
            var customPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customProperties)
            for (dictKey0, customProperties0) in customProperties {
                try customPropertiesContainer.encode(customProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for name0 in idFieldNames {
                try idFieldNamesContainer.encode(name0)
            }
        }
        if let writeOperationType = self.writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let customPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customProperties)
        var customPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let customPropertiesContainer = customPropertiesContainer {
            customPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, custompropertyvalue0) in customPropertiesContainer {
                if let custompropertyvalue0 = custompropertyvalue0 {
                    customPropertiesDecoded0?[key0] = custompropertyvalue0
                }
            }
        }
        customProperties = customPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when the custom connector is being used as a destination.
    public struct CustomConnectorDestinationProperties: Swift.Equatable {
        /// The custom properties that are specific to the connector when it's used as a destination in the flow.
        public var customProperties: [Swift.String:Swift.String]?
        /// The entity specified in the custom connector as a destination in the flow.
        /// This member is required.
        public var entityName: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the custom connector as destination.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update, delete, or upsert.
        public var idFieldNames: [Swift.String]?
        /// Specifies the type of write operation to be performed in the custom connector when it's used as destination.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            customProperties: [Swift.String:Swift.String]? = nil,
            entityName: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.customProperties = customProperties
            self.entityName = entityName
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.CustomConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case authenticationType
        case basic
        case custom
        case oauth2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let authenticationType = self.authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let basic = self.basic {
            try encodeContainer.encode(basic, forKey: .basic)
        }
        if let custom = self.custom {
            try encodeContainer.encode(custom, forKey: .custom)
        }
        if let oauth2 = self.oauth2 {
            try encodeContainer.encode(oauth2, forKey: .oauth2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let basicDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.BasicAuthCredentials.self, forKey: .basic)
        basic = basicDecoded
        let oauth2Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2Credentials.self, forKey: .oauth2)
        oauth2 = oauth2Decoded
        let apiKeyDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ApiKeyCredentials.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let customDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomAuthCredentials.self, forKey: .custom)
        custom = customDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials that are required when using the custom connector.
    public struct CustomConnectorProfileCredentials: Swift.Equatable {
        /// The API keys required for the authentication of the user.
        public var apiKey: AppflowClientTypes.ApiKeyCredentials?
        /// The authentication type that the custom connector uses for authenticating while creating a connector profile.
        /// This member is required.
        public var authenticationType: AppflowClientTypes.AuthenticationType?
        /// The basic credentials that are required for the authentication of the user.
        public var basic: AppflowClientTypes.BasicAuthCredentials?
        /// If the connector uses the custom authentication mechanism, this holds the required credentials.
        public var custom: AppflowClientTypes.CustomAuthCredentials?
        /// The OAuth 2.0 credentials required for the authentication of the user.
        public var oauth2: AppflowClientTypes.OAuth2Credentials?

        public init(
            apiKey: AppflowClientTypes.ApiKeyCredentials? = nil,
            authenticationType: AppflowClientTypes.AuthenticationType? = nil,
            basic: AppflowClientTypes.BasicAuthCredentials? = nil,
            custom: AppflowClientTypes.CustomAuthCredentials? = nil,
            oauth2: AppflowClientTypes.OAuth2Credentials? = nil
        )
        {
            self.apiKey = apiKey
            self.authenticationType = authenticationType
            self.basic = basic
            self.custom = custom
            self.oauth2 = oauth2
        }
    }

}

extension AppflowClientTypes.CustomConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuth2Properties
        case profileProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuth2Properties = self.oAuth2Properties {
            try encodeContainer.encode(oAuth2Properties, forKey: .oAuth2Properties)
        }
        if let profileProperties = profileProperties {
            var profilePropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .profileProperties)
            for (dictKey0, profilePropertiesMap0) in profileProperties {
                try profilePropertiesContainer.encode(profilePropertiesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilePropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .profileProperties)
        var profilePropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let profilePropertiesContainer = profilePropertiesContainer {
            profilePropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, profilepropertyvalue0) in profilePropertiesContainer {
                if let profilepropertyvalue0 = profilepropertyvalue0 {
                    profilePropertiesDecoded0?[key0] = profilepropertyvalue0
                }
            }
        }
        profileProperties = profilePropertiesDecoded0
        let oAuth2PropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2Properties.self, forKey: .oAuth2Properties)
        oAuth2Properties = oAuth2PropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// The profile properties required by the custom connector.
    public struct CustomConnectorProfileProperties: Swift.Equatable {
        /// The OAuth 2.0 properties required for OAuth 2.0 authentication.
        public var oAuth2Properties: AppflowClientTypes.OAuth2Properties?
        /// A map of properties that are required to create a profile for the custom connector.
        public var profileProperties: [Swift.String:Swift.String]?

        public init(
            oAuth2Properties: AppflowClientTypes.OAuth2Properties? = nil,
            profileProperties: [Swift.String:Swift.String]? = nil
        )
        {
            self.oAuth2Properties = oAuth2Properties
            self.profileProperties = profileProperties
        }
    }

}

extension AppflowClientTypes.CustomConnectorSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customProperties
        case dataTransferApi
        case entityName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customProperties = customProperties {
            var customPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .customProperties)
            for (dictKey0, customProperties0) in customProperties {
                try customPropertiesContainer.encode(customProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let dataTransferApi = self.dataTransferApi {
            try encodeContainer.encode(dataTransferApi, forKey: .dataTransferApi)
        }
        if let entityName = self.entityName {
            try encodeContainer.encode(entityName, forKey: .entityName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityName)
        entityName = entityNameDecoded
        let customPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .customProperties)
        var customPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let customPropertiesContainer = customPropertiesContainer {
            customPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, custompropertyvalue0) in customPropertiesContainer {
                if let custompropertyvalue0 = custompropertyvalue0 {
                    customPropertiesDecoded0?[key0] = custompropertyvalue0
                }
            }
        }
        customProperties = customPropertiesDecoded0
        let dataTransferApiDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DataTransferApi.self, forKey: .dataTransferApi)
        dataTransferApi = dataTransferApiDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when the custom connector is being used as a source.
    public struct CustomConnectorSourceProperties: Swift.Equatable {
        /// Custom properties that are required to use the custom connector as a source.
        public var customProperties: [Swift.String:Swift.String]?
        /// The API of the connector application that Amazon AppFlow uses to transfer your data.
        public var dataTransferApi: AppflowClientTypes.DataTransferApi?
        /// The entity specified in the custom connector as a source in the flow.
        /// This member is required.
        public var entityName: Swift.String?

        public init(
            customProperties: [Swift.String:Swift.String]? = nil,
            dataTransferApi: AppflowClientTypes.DataTransferApi? = nil,
            entityName: Swift.String? = nil
        )
        {
            self.customProperties = customProperties
            self.dataTransferApi = dataTransferApi
            self.entityName = entityName
        }
    }

}

extension AppflowClientTypes.CustomerProfilesDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName
        case objectTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let objectTypeName = self.objectTypeName {
            try encodeContainer.encode(objectTypeName, forKey: .objectTypeName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let objectTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectTypeName)
        objectTypeName = objectTypeNameDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Connect Customer Profiles is used as a destination.
    public struct CustomerProfilesDestinationProperties: Swift.Equatable {
        /// The unique name of the Amazon Connect Customer Profiles domain.
        /// This member is required.
        public var domainName: Swift.String?
        /// The object specified in the Amazon Connect Customer Profiles flow destination.
        public var objectTypeName: Swift.String?

        public init(
            domainName: Swift.String? = nil,
            objectTypeName: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }
    }

}

extension AppflowClientTypes.CustomerProfilesMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Connect Customer Profiles.
    public struct CustomerProfilesMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes {
    public enum DataPullMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case incremental
        case sdkUnknown(Swift.String)

        public static var allCases: [DataPullMode] {
            return [
                .complete,
                .incremental,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "Complete"
            case .incremental: return "Incremental"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataPullMode(rawValue: rawValue) ?? DataPullMode.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DataTransferApi: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DataTransferApiType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppflowClientTypes {
    /// The API of the connector application that Amazon AppFlow uses to transfer your data.
    public struct DataTransferApi: Swift.Equatable {
        /// The name of the connector application API.
        public var name: Swift.String?
        /// You can specify one of the following types: AUTOMATIC The default. Optimizes a flow for datasets that fluctuate in size from small to large. For each flow run, Amazon AppFlow chooses to use the SYNC or ASYNC API type based on the amount of data that the run transfers. SYNC A synchronous API. This type of API optimizes a flow for small to medium-sized datasets. ASYNC An asynchronous API. This type of API optimizes a flow for large datasets.
        public var type: AppflowClientTypes.DataTransferApiType?

        public init(
            name: Swift.String? = nil,
            type: AppflowClientTypes.DataTransferApiType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension AppflowClientTypes {
    public enum DataTransferApiType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case async
        case automatic
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [DataTransferApiType] {
            return [
                .async,
                .automatic,
                .sync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case .automatic: return "AUTOMATIC"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataTransferApiType(rawValue: rawValue) ?? DataTransferApiType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum DatadogConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DatadogConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatadogConnectorOperator(rawValue: rawValue) ?? DatadogConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
        case applicationKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if let applicationKey = self.applicationKey {
            try encodeContainer.encode(applicationKey, forKey: .applicationKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let applicationKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationKey)
        applicationKey = applicationKeyDecoded
    }
}

extension AppflowClientTypes.DatadogConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatadogConnectorProfileCredentials(applicationKey: \(Swift.String(describing: applicationKey)), apiKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific credentials required by Datadog.
    public struct DatadogConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?
        /// Application keys, in conjunction with your API key, give you full access to Datadogs programmatic API. Application keys are associated with the user account that created them. The application key is used to log all requests made to the API.
        /// This member is required.
        public var applicationKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil,
            applicationKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
            self.applicationKey = applicationKey
        }
    }

}

extension AppflowClientTypes.DatadogConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Datadog.
    public struct DatadogConnectorProfileProperties: Swift.Equatable {
        /// The location of the Datadog resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DatadogMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Datadog.
    public struct DatadogMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.DatadogSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Datadog is being used as a source.
    public struct DatadogSourceProperties: Swift.Equatable {
        /// The object specified in the Datadog flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension DeleteConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let forceDelete = self.forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-connector-profile"
    }
}

public struct DeleteConnectorProfileInput: Swift.Equatable {
    /// The name of the connector profile. The name is unique for each ConnectorProfile in your account.
    /// This member is required.
    public var connectorProfileName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the profile, even if it is currently in use in one or more flows.
    public var forceDelete: Swift.Bool?

    public init(
        connectorProfileName: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.connectorProfileName = connectorProfileName
        self.forceDelete = forceDelete
    }
}

struct DeleteConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let forceDelete: Swift.Bool?
}

extension DeleteConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileName
        case forceDelete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteConnectorProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectorProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectorProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let forceDelete = self.forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension DeleteFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/delete-flow"
    }
}

public struct DeleteFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Indicates whether Amazon AppFlow should delete the flow, even if it is currently in use.
    public var forceDelete: Swift.Bool?

    public init(
        flowName: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.flowName = flowName
        self.forceDelete = forceDelete
    }
}

struct DeleteFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let forceDelete: Swift.Bool?
}

extension DeleteFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case forceDelete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension DeleteFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFlowOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectorEntityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiVersion = self.apiVersion {
            try encodeContainer.encode(apiVersion, forKey: .apiVersion)
        }
        if let connectorEntityName = self.connectorEntityName {
            try encodeContainer.encode(connectorEntityName, forKey: .connectorEntityName)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
    }
}

extension DescribeConnectorEntityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connector-entity"
    }
}

public struct DescribeConnectorEntityInput: Swift.Equatable {
    /// The version of the API that's used by the connector.
    public var apiVersion: Swift.String?
    /// The entity name for that connector.
    /// This member is required.
    public var connectorEntityName: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileName: Swift.String?
    /// The type of connector application, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?

    public init(
        apiVersion: Swift.String? = nil,
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
    }
}

struct DescribeConnectorEntityInputBody: Swift.Equatable {
    let connectorEntityName: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorProfileName: Swift.String?
    let apiVersion: Swift.String?
}

extension DescribeConnectorEntityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorEntityName
        case connectorProfileName
        case connectorType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorEntityName)
        connectorEntityName = connectorEntityNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let apiVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiVersion)
        apiVersion = apiVersionDecoded
    }
}

extension DescribeConnectorEntityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectorEntityOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityFields = output.connectorEntityFields
        } else {
            self.connectorEntityFields = nil
        }
    }
}

public struct DescribeConnectorEntityOutput: Swift.Equatable {
    /// Describes the fields for that connector entity. For example, for an account entity, the fields would be account name, account ID, and so on.
    /// This member is required.
    public var connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?

    public init(
        connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]? = nil
    )
    {
        self.connectorEntityFields = connectorEntityFields
    }
}

struct DescribeConnectorEntityOutputBody: Swift.Equatable {
    let connectorEntityFields: [AppflowClientTypes.ConnectorEntityField]?
}

extension DescribeConnectorEntityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityFields
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityFieldsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorEntityField?].self, forKey: .connectorEntityFields)
        var connectorEntityFieldsDecoded0:[AppflowClientTypes.ConnectorEntityField]? = nil
        if let connectorEntityFieldsContainer = connectorEntityFieldsContainer {
            connectorEntityFieldsDecoded0 = [AppflowClientTypes.ConnectorEntityField]()
            for structure0 in connectorEntityFieldsContainer {
                if let structure0 = structure0 {
                    connectorEntityFieldsDecoded0?.append(structure0)
                }
            }
        }
        connectorEntityFields = connectorEntityFieldsDecoded0
    }
}

enum DescribeConnectorEntityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case connectorType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
    }
}

extension DescribeConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connector"
    }
}

public struct DescribeConnectorInput: Swift.Equatable {
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// The connector type, such as CUSTOMCONNECTOR, Saleforce, Marketo. Please choose CUSTOMCONNECTOR for Lambda based custom connectors.
    /// This member is required.
    public var connectorType: AppflowClientTypes.ConnectorType?

    public init(
        connectorLabel: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil
    )
    {
        self.connectorLabel = connectorLabel
        self.connectorType = connectorType
    }
}

struct DescribeConnectorInputBody: Swift.Equatable {
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorLabel: Swift.String?
}

extension DescribeConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case connectorType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
    }
}

extension DescribeConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorConfiguration = output.connectorConfiguration
        } else {
            self.connectorConfiguration = nil
        }
    }
}

public struct DescribeConnectorOutput: Swift.Equatable {
    /// Configuration info of all the connectors that the user requested.
    public var connectorConfiguration: AppflowClientTypes.ConnectorConfiguration?

    public init(
        connectorConfiguration: AppflowClientTypes.ConnectorConfiguration? = nil
    )
    {
        self.connectorConfiguration = connectorConfiguration
    }
}

struct DescribeConnectorOutputBody: Swift.Equatable {
    let connectorConfiguration: AppflowClientTypes.ConnectorConfiguration?
}

extension DescribeConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorConfigurationDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorConfiguration.self, forKey: .connectorConfiguration)
        connectorConfiguration = connectorConfigurationDecoded
    }
}

enum DescribeConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectorProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorProfileNames = connectorProfileNames {
            var connectorProfileNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorProfileNames)
            for connectorprofilename0 in connectorProfileNames {
                try connectorProfileNamesContainer.encode(connectorprofilename0)
            }
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectorProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connector-profiles"
    }
}

public struct DescribeConnectorProfilesInput: Swift.Equatable {
    /// The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account. Only needed if calling for CUSTOMCONNECTOR connector type/.
    public var connectorLabel: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account.
    public var connectorProfileNames: [Swift.String]?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorLabel: Swift.String? = nil,
        connectorProfileNames: [Swift.String]? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorLabel = connectorLabel
        self.connectorProfileNames = connectorProfileNames
        self.connectorType = connectorType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesInputBody: Swift.Equatable {
    let connectorProfileNames: [Swift.String]?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorLabel: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectorProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case connectorProfileNames
        case connectorType
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorProfileNames)
        var connectorProfileNamesDecoded0:[Swift.String]? = nil
        if let connectorProfileNamesContainer = connectorProfileNamesContainer {
            connectorProfileNamesDecoded0 = [Swift.String]()
            for string0 in connectorProfileNamesContainer {
                if let string0 = string0 {
                    connectorProfileNamesDecoded0?.append(string0)
                }
            }
        }
        connectorProfileNames = connectorProfileNamesDecoded0
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectorProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileDetails = output.connectorProfileDetails
            self.nextToken = output.nextToken
        } else {
            self.connectorProfileDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorProfilesOutput: Swift.Equatable {
    /// Returns information about the connector profiles associated with the flow.
    public var connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
    public var nextToken: Swift.String?

    public init(
        connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorProfileDetails = connectorProfileDetails
        self.nextToken = nextToken
    }
}

struct DescribeConnectorProfilesOutputBody: Swift.Equatable {
    let connectorProfileDetails: [AppflowClientTypes.ConnectorProfile]?
    let nextToken: Swift.String?
}

extension DescribeConnectorProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileDetails
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileDetailsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorProfile?].self, forKey: .connectorProfileDetails)
        var connectorProfileDetailsDecoded0:[AppflowClientTypes.ConnectorProfile]? = nil
        if let connectorProfileDetailsContainer = connectorProfileDetailsContainer {
            connectorProfileDetailsDecoded0 = [AppflowClientTypes.ConnectorProfile]()
            for structure0 in connectorProfileDetailsContainer {
                if let structure0 = structure0 {
                    connectorProfileDetailsDecoded0?.append(structure0)
                }
            }
        }
        connectorProfileDetails = connectorProfileDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConnectorProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorTypes = connectorTypes {
            var connectorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorTypes)
            for connectortype0 in connectorTypes {
                try connectorTypesContainer.encode(connectortype0.rawValue)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-connectors"
    }
}

public struct DescribeConnectorsInput: Swift.Equatable {
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorTypes: [AppflowClientTypes.ConnectorType]?
    /// The maximum number of items that should be returned in the result set. The default is 20.
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorTypes: [AppflowClientTypes.ConnectorType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorTypes = connectorTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsInputBody: Swift.Equatable {
    let connectorTypes: [AppflowClientTypes.ConnectorType]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorTypes
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorType?].self, forKey: .connectorTypes)
        var connectorTypesDecoded0:[AppflowClientTypes.ConnectorType]? = nil
        if let connectorTypesContainer = connectorTypesContainer {
            connectorTypesDecoded0 = [AppflowClientTypes.ConnectorType]()
            for enum0 in connectorTypesContainer {
                if let enum0 = enum0 {
                    connectorTypesDecoded0?.append(enum0)
                }
            }
        }
        connectorTypes = connectorTypesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorConfigurations = output.connectorConfigurations
            self.connectors = output.connectors
            self.nextToken = output.nextToken
        } else {
            self.connectorConfigurations = nil
            self.connectors = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeConnectorsOutput: Swift.Equatable {
    /// The configuration that is applied to the connectors used in the flow.
    public var connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    /// Information about the connectors supported in Amazon AppFlow.
    public var connectors: [AppflowClientTypes.ConnectorDetail]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil,
        connectors: [AppflowClientTypes.ConnectorDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorConfigurations = connectorConfigurations
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

struct DescribeConnectorsOutputBody: Swift.Equatable {
    let connectorConfigurations: [Swift.String:AppflowClientTypes.ConnectorConfiguration]?
    let connectors: [AppflowClientTypes.ConnectorDetail]?
    let nextToken: Swift.String?
}

extension DescribeConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorConfigurations
        case connectors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorConfigurationsContainer = try containerValues.decodeIfPresent([Swift.String: AppflowClientTypes.ConnectorConfiguration?].self, forKey: .connectorConfigurations)
        var connectorConfigurationsDecoded0: [Swift.String:AppflowClientTypes.ConnectorConfiguration]? = nil
        if let connectorConfigurationsContainer = connectorConfigurationsContainer {
            connectorConfigurationsDecoded0 = [Swift.String:AppflowClientTypes.ConnectorConfiguration]()
            for (key0, connectorconfiguration0) in connectorConfigurationsContainer {
                if let connectorconfiguration0 = connectorconfiguration0 {
                    connectorConfigurationsDecoded0?[key0] = connectorconfiguration0
                }
            }
        }
        connectorConfigurations = connectorConfigurationsDecoded0
        let connectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorDetail?].self, forKey: .connectors)
        var connectorsDecoded0:[AppflowClientTypes.ConnectorDetail]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [AppflowClientTypes.ConnectorDetail]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFlowExecutionRecordsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFlowExecutionRecordsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-flow-execution-records"
    }
}

public struct DescribeFlowExecutionRecordsInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        flowName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowName = flowName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFlowExecutionRecordsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFlowExecutionRecordsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowExecutions = output.flowExecutions
            self.nextToken = output.nextToken
        } else {
            self.flowExecutions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFlowExecutionRecordsOutput: Swift.Equatable {
    /// Returns a list of all instances when this flow was run.
    public var flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        flowExecutions: [AppflowClientTypes.ExecutionRecord]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

struct DescribeFlowExecutionRecordsOutputBody: Swift.Equatable {
    let flowExecutions: [AppflowClientTypes.ExecutionRecord]?
    let nextToken: Swift.String?
}

extension DescribeFlowExecutionRecordsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowExecutions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowExecutionsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ExecutionRecord?].self, forKey: .flowExecutions)
        var flowExecutionsDecoded0:[AppflowClientTypes.ExecutionRecord]? = nil
        if let flowExecutionsContainer = flowExecutionsContainer {
            flowExecutionsDecoded0 = [AppflowClientTypes.ExecutionRecord]()
            for structure0 in flowExecutionsContainer {
                if let structure0 = structure0 {
                    flowExecutionsDecoded0?.append(structure0)
                }
            }
        }
        flowExecutions = flowExecutionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeFlowExecutionRecordsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension DescribeFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describe-flow"
    }
}

public struct DescribeFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct DescribeFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
}

extension DescribeFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension DescribeFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.createdBy = output.createdBy
            self.description = output.description
            self.destinationFlowConfigList = output.destinationFlowConfigList
            self.flowArn = output.flowArn
            self.flowName = output.flowName
            self.flowStatus = output.flowStatus
            self.flowStatusMessage = output.flowStatusMessage
            self.kmsArn = output.kmsArn
            self.lastRunExecutionDetails = output.lastRunExecutionDetails
            self.lastRunMetadataCatalogDetails = output.lastRunMetadataCatalogDetails
            self.lastUpdatedAt = output.lastUpdatedAt
            self.lastUpdatedBy = output.lastUpdatedBy
            self.metadataCatalogConfig = output.metadataCatalogConfig
            self.schemaVersion = output.schemaVersion
            self.sourceFlowConfig = output.sourceFlowConfig
            self.tags = output.tags
            self.tasks = output.tasks
            self.triggerConfig = output.triggerConfig
        } else {
            self.createdAt = nil
            self.createdBy = nil
            self.description = nil
            self.destinationFlowConfigList = nil
            self.flowArn = nil
            self.flowName = nil
            self.flowStatus = nil
            self.flowStatusMessage = nil
            self.kmsArn = nil
            self.lastRunExecutionDetails = nil
            self.lastRunMetadataCatalogDetails = nil
            self.lastUpdatedAt = nil
            self.lastUpdatedBy = nil
            self.metadataCatalogConfig = nil
            self.schemaVersion = nil
            self.sourceFlowConfig = nil
            self.tags = nil
            self.tasks = nil
            self.triggerConfig = nil
        }
    }
}

public struct DescribeFlowOutput: Swift.Equatable {
    /// Specifies when the flow was created.
    public var createdAt: ClientRuntime.Date?
    /// The ARN of the user who created the flow.
    public var createdBy: Swift.String?
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    public var flowName: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?
    /// Contains an error message if the flow status is in a suspended or error state. This applies only to scheduled or event-triggered flows.
    public var flowStatusMessage: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon AppFlow-managed KMS key. If you don't provide anything here, Amazon AppFlow uses the Amazon AppFlow-managed KMS key.
    public var kmsArn: Swift.String?
    /// Describes the details of the most recent flow run.
    public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
    public var lastRunMetadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]?
    /// Specifies when the flow was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Specifies the user name of the account that performed the most recent update.
    public var lastUpdatedBy: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:
    ///
    /// * Source-to-destination field mappings
    ///
    /// * Field data types
    ///
    /// * Partition keys
    public var schemaVersion: Swift.Int?
    /// The configuration that controls how Amazon AppFlow retrieves data from the source connector.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowArn: Swift.String? = nil,
        flowName: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil,
        flowStatusMessage: Swift.String? = nil,
        kmsArn: Swift.String? = nil,
        lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
        lastRunMetadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        lastUpdatedBy: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        schemaVersion: Swift.Int? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowArn = flowArn
        self.flowName = flowName
        self.flowStatus = flowStatus
        self.flowStatusMessage = flowStatusMessage
        self.kmsArn = kmsArn
        self.lastRunExecutionDetails = lastRunExecutionDetails
        self.lastRunMetadataCatalogDetails = lastRunMetadataCatalogDetails
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.metadataCatalogConfig = metadataCatalogConfig
        self.schemaVersion = schemaVersion
        self.sourceFlowConfig = sourceFlowConfig
        self.tags = tags
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct DescribeFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let description: Swift.String?
    let flowName: Swift.String?
    let kmsArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
    let flowStatusMessage: Swift.String?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let tasks: [AppflowClientTypes.Task]?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let createdBy: Swift.String?
    let lastUpdatedBy: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    let lastRunMetadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]?
    let schemaVersion: Swift.Int?
}

extension DescribeFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationFlowConfigList
        case flowArn
        case flowName
        case flowStatus
        case flowStatusMessage
        case kmsArn
        case lastRunExecutionDetails
        case lastRunMetadataCatalogDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case metadataCatalogConfig
        case schemaVersion
        case sourceFlowConfig
        case tags
        case tasks
        case triggerConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let kmsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsArn)
        kmsArn = kmsArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let flowStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowStatusMessage)
        flowStatusMessage = flowStatusMessageDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let metadataCatalogConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MetadataCatalogConfig.self, forKey: .metadataCatalogConfig)
        metadataCatalogConfig = metadataCatalogConfigDecoded
        let lastRunMetadataCatalogDetailsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.MetadataCatalogDetail?].self, forKey: .lastRunMetadataCatalogDetails)
        var lastRunMetadataCatalogDetailsDecoded0:[AppflowClientTypes.MetadataCatalogDetail]? = nil
        if let lastRunMetadataCatalogDetailsContainer = lastRunMetadataCatalogDetailsContainer {
            lastRunMetadataCatalogDetailsDecoded0 = [AppflowClientTypes.MetadataCatalogDetail]()
            for structure0 in lastRunMetadataCatalogDetailsContainer {
                if let structure0 = structure0 {
                    lastRunMetadataCatalogDetailsDecoded0?.append(structure0)
                }
            }
        }
        lastRunMetadataCatalogDetails = lastRunMetadataCatalogDetailsDecoded0
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
    }
}

enum DescribeFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.DestinationConnectorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customConnector = "CustomConnector"
        case customerProfiles = "CustomerProfiles"
        case eventBridge = "EventBridge"
        case honeycode = "Honeycode"
        case lookoutMetrics = "LookoutMetrics"
        case marketo = "Marketo"
        case redshift = "Redshift"
        case s3 = "S3"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case snowflake = "Snowflake"
        case upsolver = "Upsolver"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customConnector = self.customConnector {
            try encodeContainer.encode(customConnector, forKey: .customConnector)
        }
        if let customerProfiles = self.customerProfiles {
            try encodeContainer.encode(customerProfiles, forKey: .customerProfiles)
        }
        if let eventBridge = self.eventBridge {
            try encodeContainer.encode(eventBridge, forKey: .eventBridge)
        }
        if let honeycode = self.honeycode {
            try encodeContainer.encode(honeycode, forKey: .honeycode)
        }
        if let lookoutMetrics = self.lookoutMetrics {
            try encodeContainer.encode(lookoutMetrics, forKey: .lookoutMetrics)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let redshift = self.redshift {
            try encodeContainer.encode(redshift, forKey: .redshift)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let snowflake = self.snowflake {
            try encodeContainer.encode(snowflake, forKey: .snowflake)
        }
        if let upsolver = self.upsolver {
            try encodeContainer.encode(upsolver, forKey: .upsolver)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redshiftDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RedshiftDestinationProperties.self, forKey: .redshift)
        redshift = redshiftDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3DestinationProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceDestinationProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let snowflakeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SnowflakeDestinationProperties.self, forKey: .snowflake)
        snowflake = snowflakeDecoded
        let eventBridgeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.EventBridgeDestinationProperties.self, forKey: .eventBridge)
        eventBridge = eventBridgeDecoded
        let lookoutMetricsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.LookoutMetricsDestinationProperties.self, forKey: .lookoutMetrics)
        lookoutMetrics = lookoutMetricsDecoded
        let upsolverDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverDestinationProperties.self, forKey: .upsolver)
        upsolver = upsolverDecoded
        let honeycodeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.HoneycodeDestinationProperties.self, forKey: .honeycode)
        honeycode = honeycodeDecoded
        let customerProfilesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomerProfilesDestinationProperties.self, forKey: .customerProfiles)
        customerProfiles = customerProfilesDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskDestinationProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoDestinationProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let customConnectorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomConnectorDestinationProperties.self, forKey: .customConnector)
        customConnector = customConnectorDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataDestinationProperties.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
    }
}

extension AppflowClientTypes {
    /// This stores the information that is required to query a particular connector.
    public struct DestinationConnectorProperties: Swift.Equatable {
        /// The properties that are required to query the custom Connector.
        public var customConnector: AppflowClientTypes.CustomConnectorDestinationProperties?
        /// The properties required to query Amazon Connect Customer Profiles.
        public var customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties?
        /// The properties required to query Amazon EventBridge.
        public var eventBridge: AppflowClientTypes.EventBridgeDestinationProperties?
        /// The properties required to query Amazon Honeycode.
        public var honeycode: AppflowClientTypes.HoneycodeDestinationProperties?
        /// The properties required to query Amazon Lookout for Metrics.
        public var lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties?
        /// The properties required to query Marketo.
        public var marketo: AppflowClientTypes.MarketoDestinationProperties?
        /// The properties required to query Amazon Redshift.
        public var redshift: AppflowClientTypes.RedshiftDestinationProperties?
        /// The properties required to query Amazon S3.
        public var s3: AppflowClientTypes.S3DestinationProperties?
        /// The properties required to query Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceDestinationProperties?
        /// The properties required to query SAPOData.
        public var sapoData: AppflowClientTypes.SAPODataDestinationProperties?
        /// The properties required to query Snowflake.
        public var snowflake: AppflowClientTypes.SnowflakeDestinationProperties?
        /// The properties required to query Upsolver.
        public var upsolver: AppflowClientTypes.UpsolverDestinationProperties?
        /// The properties required to query Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskDestinationProperties?

        public init(
            customConnector: AppflowClientTypes.CustomConnectorDestinationProperties? = nil,
            customerProfiles: AppflowClientTypes.CustomerProfilesDestinationProperties? = nil,
            eventBridge: AppflowClientTypes.EventBridgeDestinationProperties? = nil,
            honeycode: AppflowClientTypes.HoneycodeDestinationProperties? = nil,
            lookoutMetrics: AppflowClientTypes.LookoutMetricsDestinationProperties? = nil,
            marketo: AppflowClientTypes.MarketoDestinationProperties? = nil,
            redshift: AppflowClientTypes.RedshiftDestinationProperties? = nil,
            s3: AppflowClientTypes.S3DestinationProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceDestinationProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataDestinationProperties? = nil,
            snowflake: AppflowClientTypes.SnowflakeDestinationProperties? = nil,
            upsolver: AppflowClientTypes.UpsolverDestinationProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskDestinationProperties? = nil
        )
        {
            self.customConnector = customConnector
            self.customerProfiles = customerProfiles
            self.eventBridge = eventBridge
            self.honeycode = honeycode
            self.lookoutMetrics = lookoutMetrics
            self.marketo = marketo
            self.redshift = redshift
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.snowflake = snowflake
            self.upsolver = upsolver
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.DestinationFieldProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isCreatable
        case isDefaultedOnCreate
        case isNullable
        case isUpdatable
        case isUpsertable
        case supportedWriteOperations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isCreatable != false {
            try encodeContainer.encode(isCreatable, forKey: .isCreatable)
        }
        if isDefaultedOnCreate != false {
            try encodeContainer.encode(isDefaultedOnCreate, forKey: .isDefaultedOnCreate)
        }
        if isNullable != false {
            try encodeContainer.encode(isNullable, forKey: .isNullable)
        }
        if isUpdatable != false {
            try encodeContainer.encode(isUpdatable, forKey: .isUpdatable)
        }
        if isUpsertable != false {
            try encodeContainer.encode(isUpsertable, forKey: .isUpsertable)
        }
        if let supportedWriteOperations = supportedWriteOperations {
            var supportedWriteOperationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedWriteOperations)
            for writeoperationtype0 in supportedWriteOperations {
                try supportedWriteOperationsContainer.encode(writeoperationtype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCreatableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isCreatable) ?? false
        isCreatable = isCreatableDecoded
        let isNullableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isNullable) ?? false
        isNullable = isNullableDecoded
        let isUpsertableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUpsertable) ?? false
        isUpsertable = isUpsertableDecoded
        let isUpdatableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isUpdatable) ?? false
        isUpdatable = isUpdatableDecoded
        let isDefaultedOnCreateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefaultedOnCreate) ?? false
        isDefaultedOnCreate = isDefaultedOnCreateDecoded
        let supportedWriteOperationsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.WriteOperationType?].self, forKey: .supportedWriteOperations)
        var supportedWriteOperationsDecoded0:[AppflowClientTypes.WriteOperationType]? = nil
        if let supportedWriteOperationsContainer = supportedWriteOperationsContainer {
            supportedWriteOperationsDecoded0 = [AppflowClientTypes.WriteOperationType]()
            for enum0 in supportedWriteOperationsContainer {
                if let enum0 = enum0 {
                    supportedWriteOperationsDecoded0?.append(enum0)
                }
            }
        }
        supportedWriteOperations = supportedWriteOperationsDecoded0
    }
}

extension AppflowClientTypes {
    /// The properties that can be applied to a field when connector is being used as a destination.
    public struct DestinationFieldProperties: Swift.Equatable {
        /// Specifies if the destination field can be created by the current user.
        public var isCreatable: Swift.Bool
        /// Specifies whether the field can use the default value during a Create operation.
        public var isDefaultedOnCreate: Swift.Bool
        /// Specifies if the destination field can have a null value.
        public var isNullable: Swift.Bool
        /// Specifies whether the field can be updated during an UPDATE or UPSERT write operation.
        public var isUpdatable: Swift.Bool
        /// Specifies if the flow run can either insert new rows in the destination field if they do not already exist, or update them if they do.
        public var isUpsertable: Swift.Bool
        /// A list of supported write operations. For each write operation listed, this field can be used in idFieldNames when that write operation is present as a destination option.
        public var supportedWriteOperations: [AppflowClientTypes.WriteOperationType]?

        public init(
            isCreatable: Swift.Bool = false,
            isDefaultedOnCreate: Swift.Bool = false,
            isNullable: Swift.Bool = false,
            isUpdatable: Swift.Bool = false,
            isUpsertable: Swift.Bool = false,
            supportedWriteOperations: [AppflowClientTypes.WriteOperationType]? = nil
        )
        {
            self.isCreatable = isCreatable
            self.isDefaultedOnCreate = isDefaultedOnCreate
            self.isNullable = isNullable
            self.isUpdatable = isUpdatable
            self.isUpsertable = isUpsertable
            self.supportedWriteOperations = supportedWriteOperations
        }
    }

}

extension AppflowClientTypes.DestinationFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorProfileName
        case connectorType
        case destinationConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiVersion = self.apiVersion {
            try encodeContainer.encode(apiVersion, forKey: .apiVersion)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let destinationConnectorProperties = self.destinationConnectorProperties {
            try encodeContainer.encode(destinationConnectorProperties, forKey: .destinationConnectorProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let apiVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiVersion)
        apiVersion = apiVersionDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let destinationConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DestinationConnectorProperties.self, forKey: .destinationConnectorProperties)
        destinationConnectorProperties = destinationConnectorPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of destination connectors present in the flow.
    public struct DestinationFlowConfig: Swift.Equatable {
        /// The API version that the destination connector uses.
        public var apiVersion: Swift.String?
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// This stores the information that is required to query a particular connector.
        /// This member is required.
        public var destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties?

        public init(
            apiVersion: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            destinationConnectorProperties: AppflowClientTypes.DestinationConnectorProperties? = nil
        )
        {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.destinationConnectorProperties = destinationConnectorProperties
        }
    }

}

extension AppflowClientTypes {
    public enum DynatraceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [DynatraceConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DynatraceConnectorOperator(rawValue: rawValue) ?? DynatraceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.DynatraceConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiToken = self.apiToken {
            try encodeContainer.encode(apiToken, forKey: .apiToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiToken)
        apiToken = apiTokenDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Dynatrace.
    public struct DynatraceConnectorProfileCredentials: Swift.Equatable {
        /// The API tokens used by Dynatrace API to authenticate various API calls.
        /// This member is required.
        public var apiToken: Swift.String?

        public init(
            apiToken: Swift.String? = nil
        )
        {
            self.apiToken = apiToken
        }
    }

}

extension AppflowClientTypes.DynatraceConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Dynatrace.
    public struct DynatraceConnectorProfileProperties: Swift.Equatable {
        /// The location of the Dynatrace resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.DynatraceMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Dynatrace.
    public struct DynatraceMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.DynatraceSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Dynatrace is being used as a source.
    public struct DynatraceSourceProperties: Swift.Equatable {
        /// The object specified in the Dynatrace flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.ErrorHandlingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case failOnFirstDestinationError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if failOnFirstDestinationError != false {
            try encodeContainer.encode(failOnFirstDestinationError, forKey: .failOnFirstDestinationError)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failOnFirstDestinationErrorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failOnFirstDestinationError) ?? false
        failOnFirstDestinationError = failOnFirstDestinationErrorDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AppflowClientTypes {
    /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
    public struct ErrorHandlingConfig: Swift.Equatable {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?
        /// Specifies if the flow should fail after the first instance of a failure when attempting to place data in the destination.
        public var failOnFirstDestinationError: Swift.Bool

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            failOnFirstDestinationError: Swift.Bool = false
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.failOnFirstDestinationError = failOnFirstDestinationError
        }
    }

}

extension AppflowClientTypes.ErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionMessage
        case putFailuresCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionMessage = self.executionMessage {
            try encodeContainer.encode(executionMessage, forKey: .executionMessage)
        }
        if let putFailuresCount = self.putFailuresCount {
            try encodeContainer.encode(putFailuresCount, forKey: .putFailuresCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putFailuresCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .putFailuresCount)
        putFailuresCount = putFailuresCountDecoded
        let executionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionMessage)
        executionMessage = executionMessageDecoded
    }
}

extension AppflowClientTypes {
    /// Provides details in the event of a failed flow, including the failure count and the related error messages.
    public struct ErrorInfo: Swift.Equatable {
        /// Specifies the error message that appears if a flow fails.
        public var executionMessage: Swift.String?
        /// Specifies the failure count for the attempted flow.
        public var putFailuresCount: Swift.Int?

        public init(
            executionMessage: Swift.String? = nil,
            putFailuresCount: Swift.Int? = nil
        )
        {
            self.executionMessage = executionMessage
            self.putFailuresCount = putFailuresCount
        }
    }

}

extension AppflowClientTypes.EventBridgeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon EventBridge is being used as a destination.
    public struct EventBridgeDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon EventBridge flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.EventBridgeMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon EventBridge.
    public struct EventBridgeMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.ExecutionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mostRecentExecutionMessage
        case mostRecentExecutionStatus
        case mostRecentExecutionTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mostRecentExecutionMessage = self.mostRecentExecutionMessage {
            try encodeContainer.encode(mostRecentExecutionMessage, forKey: .mostRecentExecutionMessage)
        }
        if let mostRecentExecutionStatus = self.mostRecentExecutionStatus {
            try encodeContainer.encode(mostRecentExecutionStatus.rawValue, forKey: .mostRecentExecutionStatus)
        }
        if let mostRecentExecutionTime = self.mostRecentExecutionTime {
            try encodeContainer.encodeTimestamp(mostRecentExecutionTime, format: .epochSeconds, forKey: .mostRecentExecutionTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mostRecentExecutionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mostRecentExecutionMessage)
        mostRecentExecutionMessage = mostRecentExecutionMessageDecoded
        let mostRecentExecutionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .mostRecentExecutionTime)
        mostRecentExecutionTime = mostRecentExecutionTimeDecoded
        let mostRecentExecutionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .mostRecentExecutionStatus)
        mostRecentExecutionStatus = mostRecentExecutionStatusDecoded
    }
}

extension AppflowClientTypes {
    /// Describes the details of the flow run, including the timestamp, status, and message.
    public struct ExecutionDetails: Swift.Equatable {
        /// Describes the details of the most recent flow run.
        public var mostRecentExecutionMessage: Swift.String?
        /// Specifies the status of the most recent flow run.
        public var mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent flow run.
        public var mostRecentExecutionTime: ClientRuntime.Date?

        public init(
            mostRecentExecutionMessage: Swift.String? = nil,
            mostRecentExecutionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            mostRecentExecutionTime: ClientRuntime.Date? = nil
        )
        {
            self.mostRecentExecutionMessage = mostRecentExecutionMessage
            self.mostRecentExecutionStatus = mostRecentExecutionStatus
            self.mostRecentExecutionTime = mostRecentExecutionTime
        }
    }

}

extension AppflowClientTypes.ExecutionRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullEndTime
        case dataPullStartTime
        case executionId
        case executionResult
        case executionStatus
        case lastUpdatedAt
        case metadataCatalogDetails
        case startedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullEndTime = self.dataPullEndTime {
            try encodeContainer.encodeTimestamp(dataPullEndTime, format: .epochSeconds, forKey: .dataPullEndTime)
        }
        if let dataPullStartTime = self.dataPullStartTime {
            try encodeContainer.encodeTimestamp(dataPullStartTime, format: .epochSeconds, forKey: .dataPullStartTime)
        }
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let executionResult = self.executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let executionStatus = self.executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let metadataCatalogDetails = metadataCatalogDetails {
            var metadataCatalogDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadataCatalogDetails)
            for metadatacatalogdetail0 in metadataCatalogDetails {
                try metadataCatalogDetailsContainer.encode(metadatacatalogdetail0)
            }
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let executionResultDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let dataPullStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dataPullStartTime)
        dataPullStartTime = dataPullStartTimeDecoded
        let dataPullEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dataPullEndTime)
        dataPullEndTime = dataPullEndTimeDecoded
        let metadataCatalogDetailsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.MetadataCatalogDetail?].self, forKey: .metadataCatalogDetails)
        var metadataCatalogDetailsDecoded0:[AppflowClientTypes.MetadataCatalogDetail]? = nil
        if let metadataCatalogDetailsContainer = metadataCatalogDetailsContainer {
            metadataCatalogDetailsDecoded0 = [AppflowClientTypes.MetadataCatalogDetail]()
            for structure0 in metadataCatalogDetailsContainer {
                if let structure0 = structure0 {
                    metadataCatalogDetailsDecoded0?.append(structure0)
                }
            }
        }
        metadataCatalogDetails = metadataCatalogDetailsDecoded0
    }
}

extension AppflowClientTypes {
    /// Specifies information about the past flow run instances for a given flow.
    public struct ExecutionRecord: Swift.Equatable {
        /// The timestamp that indicates the last new or updated record to be transferred in the flow run.
        public var dataPullEndTime: ClientRuntime.Date?
        /// The timestamp that determines the first new or updated record to be transferred in the flow run.
        public var dataPullStartTime: ClientRuntime.Date?
        /// Specifies the identifier of the given flow run.
        public var executionId: Swift.String?
        /// Describes the result of the given flow run.
        public var executionResult: AppflowClientTypes.ExecutionResult?
        /// Specifies the flow run status and whether it is in progress, has completed successfully, or has failed.
        public var executionStatus: AppflowClientTypes.ExecutionStatus?
        /// Specifies the time of the most recent update.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
        public var metadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]?
        /// Specifies the start time of the flow run.
        public var startedAt: ClientRuntime.Date?

        public init(
            dataPullEndTime: ClientRuntime.Date? = nil,
            dataPullStartTime: ClientRuntime.Date? = nil,
            executionId: Swift.String? = nil,
            executionResult: AppflowClientTypes.ExecutionResult? = nil,
            executionStatus: AppflowClientTypes.ExecutionStatus? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            metadataCatalogDetails: [AppflowClientTypes.MetadataCatalogDetail]? = nil,
            startedAt: ClientRuntime.Date? = nil
        )
        {
            self.dataPullEndTime = dataPullEndTime
            self.dataPullStartTime = dataPullStartTime
            self.executionId = executionId
            self.executionResult = executionResult
            self.executionStatus = executionStatus
            self.lastUpdatedAt = lastUpdatedAt
            self.metadataCatalogDetails = metadataCatalogDetails
            self.startedAt = startedAt
        }
    }

}

extension AppflowClientTypes.ExecutionResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytesProcessed
        case bytesWritten
        case errorInfo
        case maxPageSize
        case numParallelProcesses
        case recordsProcessed
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bytesProcessed = self.bytesProcessed {
            try encodeContainer.encode(bytesProcessed, forKey: .bytesProcessed)
        }
        if let bytesWritten = self.bytesWritten {
            try encodeContainer.encode(bytesWritten, forKey: .bytesWritten)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let maxPageSize = self.maxPageSize {
            try encodeContainer.encode(maxPageSize, forKey: .maxPageSize)
        }
        if let numParallelProcesses = self.numParallelProcesses {
            try encodeContainer.encode(numParallelProcesses, forKey: .numParallelProcesses)
        }
        if let recordsProcessed = self.recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorInfoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let bytesProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesProcessed)
        bytesProcessed = bytesProcessedDecoded
        let bytesWrittenDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytesWritten)
        bytesWritten = bytesWrittenDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
        let numParallelProcessesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numParallelProcesses)
        numParallelProcesses = numParallelProcessesDecoded
        let maxPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPageSize)
        maxPageSize = maxPageSizeDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the end result of the flow run.
    public struct ExecutionResult: Swift.Equatable {
        /// The total number of bytes processed by the flow run.
        public var bytesProcessed: Swift.Int?
        /// The total number of bytes written as a result of the flow run.
        public var bytesWritten: Swift.Int?
        /// Provides any error message information related to the flow run.
        public var errorInfo: AppflowClientTypes.ErrorInfo?
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application.
        public var maxPageSize: Swift.Int?
        /// The number of processes that Amazon AppFlow ran at the same time when it retrieved your data.
        public var numParallelProcesses: Swift.Int?
        /// The number of records processed in the flow run.
        public var recordsProcessed: Swift.Int?

        public init(
            bytesProcessed: Swift.Int? = nil,
            bytesWritten: Swift.Int? = nil,
            errorInfo: AppflowClientTypes.ErrorInfo? = nil,
            maxPageSize: Swift.Int? = nil,
            numParallelProcesses: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil
        )
        {
            self.bytesProcessed = bytesProcessed
            self.bytesWritten = bytesWritten
            self.errorInfo = errorInfo
            self.maxPageSize = maxPageSize
            self.numParallelProcesses = numParallelProcesses
            self.recordsProcessed = recordsProcessed
        }
    }

}

extension AppflowClientTypes {
    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case cancelstarted
        case error
        case inprogress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .canceled,
                .cancelstarted,
                .error,
                .inprogress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "Canceled"
            case .cancelstarted: return "CancelStarted"
            case .error: return "Error"
            case .inprogress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionStatus(rawValue: rawValue) ?? ExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FieldTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLengthRange
        case fieldType
        case fieldValueRange
        case filterOperators
        case supportedDateFormat
        case supportedValues
        case valueRegexPattern
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldLengthRange = self.fieldLengthRange {
            try encodeContainer.encode(fieldLengthRange, forKey: .fieldLengthRange)
        }
        if let fieldType = self.fieldType {
            try encodeContainer.encode(fieldType, forKey: .fieldType)
        }
        if let fieldValueRange = self.fieldValueRange {
            try encodeContainer.encode(fieldValueRange, forKey: .fieldValueRange)
        }
        if let filterOperators = filterOperators {
            var filterOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterOperators)
            for operator0 in filterOperators {
                try filterOperatorsContainer.encode(operator0.rawValue)
            }
        }
        if let supportedDateFormat = self.supportedDateFormat {
            try encodeContainer.encode(supportedDateFormat, forKey: .supportedDateFormat)
        }
        if let supportedValues = supportedValues {
            var supportedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedValues)
            for value0 in supportedValues {
                try supportedValuesContainer.encode(value0)
            }
        }
        if let valueRegexPattern = self.valueRegexPattern {
            try encodeContainer.encode(valueRegexPattern, forKey: .valueRegexPattern)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldType)
        fieldType = fieldTypeDecoded
        let filterOperatorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Operator?].self, forKey: .filterOperators)
        var filterOperatorsDecoded0:[AppflowClientTypes.Operator]? = nil
        if let filterOperatorsContainer = filterOperatorsContainer {
            filterOperatorsDecoded0 = [AppflowClientTypes.Operator]()
            for enum0 in filterOperatorsContainer {
                if let enum0 = enum0 {
                    filterOperatorsDecoded0?.append(enum0)
                }
            }
        }
        filterOperators = filterOperatorsDecoded0
        let supportedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedValues)
        var supportedValuesDecoded0:[Swift.String]? = nil
        if let supportedValuesContainer = supportedValuesContainer {
            supportedValuesDecoded0 = [Swift.String]()
            for string0 in supportedValuesContainer {
                if let string0 = string0 {
                    supportedValuesDecoded0?.append(string0)
                }
            }
        }
        supportedValues = supportedValuesDecoded0
        let valueRegexPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .valueRegexPattern)
        valueRegexPattern = valueRegexPatternDecoded
        let supportedDateFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportedDateFormat)
        supportedDateFormat = supportedDateFormatDecoded
        let fieldValueRangeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.Range.self, forKey: .fieldValueRange)
        fieldValueRange = fieldValueRangeDecoded
        let fieldLengthRangeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.Range.self, forKey: .fieldLengthRange)
        fieldLengthRange = fieldLengthRangeDecoded
    }
}

extension AppflowClientTypes {
    /// Contains details regarding the supported field type and the operators that can be applied for filtering.
    public struct FieldTypeDetails: Swift.Equatable {
        /// This is the allowable length range for this field's value.
        public var fieldLengthRange: AppflowClientTypes.Range?
        /// The type of field, such as string, integer, date, and so on.
        /// This member is required.
        public var fieldType: Swift.String?
        /// The range of values this field can hold.
        public var fieldValueRange: AppflowClientTypes.Range?
        /// The list of operators supported by a field.
        /// This member is required.
        public var filterOperators: [AppflowClientTypes.Operator]?
        /// The date format that the field supports.
        public var supportedDateFormat: Swift.String?
        /// The list of values that a field can contain. For example, a Boolean fieldType can have two values: "true" and "false".
        public var supportedValues: [Swift.String]?
        /// The regular expression pattern for the field name.
        public var valueRegexPattern: Swift.String?

        public init(
            fieldLengthRange: AppflowClientTypes.Range? = nil,
            fieldType: Swift.String? = nil,
            fieldValueRange: AppflowClientTypes.Range? = nil,
            filterOperators: [AppflowClientTypes.Operator]? = nil,
            supportedDateFormat: Swift.String? = nil,
            supportedValues: [Swift.String]? = nil,
            valueRegexPattern: Swift.String? = nil
        )
        {
            self.fieldLengthRange = fieldLengthRange
            self.fieldType = fieldType
            self.fieldValueRange = fieldValueRange
            self.filterOperators = filterOperators
            self.supportedDateFormat = supportedDateFormat
            self.supportedValues = supportedValues
            self.valueRegexPattern = valueRegexPattern
        }
    }

}

extension AppflowClientTypes {
    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .csv,
                .json,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.FlowDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case destinationConnectorLabel
        case destinationConnectorType
        case flowArn
        case flowName
        case flowStatus
        case lastRunExecutionDetails
        case lastUpdatedAt
        case lastUpdatedBy
        case sourceConnectorLabel
        case sourceConnectorType
        case tags
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationConnectorLabel = self.destinationConnectorLabel {
            try encodeContainer.encode(destinationConnectorLabel, forKey: .destinationConnectorLabel)
        }
        if let destinationConnectorType = self.destinationConnectorType {
            try encodeContainer.encode(destinationConnectorType.rawValue, forKey: .destinationConnectorType)
        }
        if let flowArn = self.flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let flowStatus = self.flowStatus {
            try encodeContainer.encode(flowStatus.rawValue, forKey: .flowStatus)
        }
        if let lastRunExecutionDetails = self.lastRunExecutionDetails {
            try encodeContainer.encode(lastRunExecutionDetails, forKey: .lastRunExecutionDetails)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = self.lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let sourceConnectorLabel = self.sourceConnectorLabel {
            try encodeContainer.encode(sourceConnectorLabel, forKey: .sourceConnectorLabel)
        }
        if let sourceConnectorType = self.sourceConnectorType {
            try encodeContainer.encode(sourceConnectorType.rawValue, forKey: .sourceConnectorType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let sourceConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .sourceConnectorType)
        sourceConnectorType = sourceConnectorTypeDecoded
        let sourceConnectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceConnectorLabel)
        sourceConnectorLabel = sourceConnectorLabelDecoded
        let destinationConnectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .destinationConnectorType)
        destinationConnectorType = destinationConnectorTypeDecoded
        let destinationConnectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationConnectorLabel)
        destinationConnectorLabel = destinationConnectorLabelDecoded
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let lastRunExecutionDetailsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionDetails.self, forKey: .lastRunExecutionDetails)
        lastRunExecutionDetails = lastRunExecutionDetailsDecoded
    }
}

extension AppflowClientTypes {
    /// The properties of the flow, such as its source, destination, trigger type, and so on.
    public struct FlowDefinition: Swift.Equatable {
        /// Specifies when the flow was created.
        public var createdAt: ClientRuntime.Date?
        /// The ARN of the user who created the flow.
        public var createdBy: Swift.String?
        /// A user-entered description of the flow.
        public var description: Swift.String?
        /// The label of the destination connector in the flow.
        public var destinationConnectorLabel: Swift.String?
        /// Specifies the destination connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var destinationConnectorType: AppflowClientTypes.ConnectorType?
        /// The flow's Amazon Resource Name (ARN).
        public var flowArn: Swift.String?
        /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
        public var flowName: Swift.String?
        /// Indicates the current status of the flow.
        public var flowStatus: AppflowClientTypes.FlowStatus?
        /// Describes the details of the most recent flow run.
        public var lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails?
        /// Specifies when the flow was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Specifies the account user name that most recently updated the flow.
        public var lastUpdatedBy: Swift.String?
        /// The label of the source connector in the flow.
        public var sourceConnectorLabel: Swift.String?
        /// Specifies the source connector type, such as Salesforce, Amazon S3, Amplitude, and so on.
        public var sourceConnectorType: AppflowClientTypes.ConnectorType?
        /// The tags used to organize, track, or control access for your flow.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            destinationConnectorLabel: Swift.String? = nil,
            destinationConnectorType: AppflowClientTypes.ConnectorType? = nil,
            flowArn: Swift.String? = nil,
            flowName: Swift.String? = nil,
            flowStatus: AppflowClientTypes.FlowStatus? = nil,
            lastRunExecutionDetails: AppflowClientTypes.ExecutionDetails? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            sourceConnectorLabel: Swift.String? = nil,
            sourceConnectorType: AppflowClientTypes.ConnectorType? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.destinationConnectorLabel = destinationConnectorLabel
            self.destinationConnectorType = destinationConnectorType
            self.flowArn = flowArn
            self.flowName = flowName
            self.flowStatus = flowStatus
            self.lastRunExecutionDetails = lastRunExecutionDetails
            self.lastUpdatedAt = lastUpdatedAt
            self.lastUpdatedBy = lastUpdatedBy
            self.sourceConnectorLabel = sourceConnectorLabel
            self.sourceConnectorType = sourceConnectorType
            self.tags = tags
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes {
    public enum FlowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deprecated
        case draft
        case errored
        case suspended
        case sdkUnknown(Swift.String)

        public static var allCases: [FlowStatus] {
            return [
                .active,
                .deleted,
                .deprecated,
                .draft,
                .errored,
                .suspended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case .deprecated: return "Deprecated"
            case .draft: return "Draft"
            case .errored: return "Errored"
            case .suspended: return "Suspended"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FlowStatus(rawValue: rawValue) ?? FlowStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.GlueDataCatalogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case roleArn
        case tablePrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tablePrefix = self.tablePrefix {
            try encodeContainer.encode(tablePrefix, forKey: .tablePrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tablePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tablePrefix)
        tablePrefix = tablePrefixDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data with the Glue Data Catalog. When Amazon AppFlow catalogs your data, it stores metadata in Data Catalog tables. This metadata represents the data that's transferred by the flow that you configure with these settings. You can configure a flow with these settings only when the flow destination is Amazon S3.
    public struct GlueDataCatalogConfig: Swift.Equatable {
        /// The name of the Data Catalog database that stores the metadata tables that Amazon AppFlow creates in your Amazon Web Services account. These tables contain metadata for the data that's transferred by the flow that you configure with this parameter. When you configure a new flow with this parameter, you must specify an existing database.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that grants Amazon AppFlow the permissions it needs to create Data Catalog tables, databases, and partitions. For an example IAM policy that has the required permissions, see [Identity-based policy examples for Amazon AppFlow](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_id-based-policy-examples.html).
        /// This member is required.
        public var roleArn: Swift.String?
        /// A naming prefix for each Data Catalog table that Amazon AppFlow creates for the flow that you configure with this setting. Amazon AppFlow adds the prefix to the beginning of the each table name.
        /// This member is required.
        public var tablePrefix: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            tablePrefix: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.roleArn = roleArn
            self.tablePrefix = tablePrefix
        }
    }

}

extension AppflowClientTypes {
    public enum GoogleAnalyticsConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case projection
        case sdkUnknown(Swift.String)

        public static var allCases: [GoogleAnalyticsConnectorOperator] {
            return [
                .between,
                .projection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .projection: return "PROJECTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GoogleAnalyticsConnectorOperator(rawValue: rawValue) ?? GoogleAnalyticsConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GoogleAnalyticsConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Google Analytics resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens. This is required only for OAuth2 access tokens, and is not required for OAuth1 access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Google Analytics.
    public struct GoogleAnalyticsConnectorProfileProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.GoogleAnalyticsMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Google Analytics.
    public struct GoogleAnalyticsMetadata: Swift.Equatable {
        /// The desired authorization scope for the Google Analytics account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.GoogleAnalyticsSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Google Analytics is being used as a source.
    public struct GoogleAnalyticsSourceProperties: Swift.Equatable {
        /// The object specified in the Google Analytics flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.HoneycodeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "HoneycodeConnectorProfileCredentials(oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific credentials required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Amazon Honeycode resources.
        public var accessToken: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.HoneycodeConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific properties required when using Amazon Honeycode.
    public struct HoneycodeConnectorProfileProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.HoneycodeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Honeycode is used as a destination.
    public struct HoneycodeDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Amazon Honeycode flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.HoneycodeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Honeycode.
    public struct HoneycodeMetadata: Swift.Equatable {
        /// The desired authorization scope for the Amazon Honeycode account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.IncrementalPullConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datetimeTypeFieldName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datetimeTypeFieldName = self.datetimeTypeFieldName {
            try encodeContainer.encode(datetimeTypeFieldName, forKey: .datetimeTypeFieldName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datetimeTypeFieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datetimeTypeFieldName)
        datetimeTypeFieldName = datetimeTypeFieldNameDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration used when importing incremental records from the source.
    public struct IncrementalPullConfig: Swift.Equatable {
        /// A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        public var datetimeTypeFieldName: Swift.String?

        public init(
            datetimeTypeFieldName: Swift.String? = nil
        )
        {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }
    }

}

extension AppflowClientTypes {
    public enum InforNexusConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [InforNexusConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InforNexusConnectorOperator(rawValue: rawValue) ?? InforNexusConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case datakey
        case secretAccessKey
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let datakey = self.datakey {
            try encodeContainer.encode(datakey, forKey: .datakey)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let datakeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datakey)
        datakey = datakeyDecoded
    }
}

extension AppflowClientTypes.InforNexusConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InforNexusConnectorProfileCredentials(datakey: \(Swift.String(describing: datakey)), secretAccessKey: \(Swift.String(describing: secretAccessKey)), userId: \(Swift.String(describing: userId)), accessKeyId: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Infor Nexus.
    public struct InforNexusConnectorProfileCredentials: Swift.Equatable {
        /// The Access Key portion of the credentials.
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// The encryption keys used to encrypt data.
        /// This member is required.
        public var datakey: Swift.String?
        /// The secret key used to sign requests.
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// The identifier for the user.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            datakey: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.datakey = datakey
            self.secretAccessKey = secretAccessKey
            self.userId = userId
        }
    }

}

extension AppflowClientTypes.InforNexusConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required by Infor Nexus.
    public struct InforNexusConnectorProfileProperties: Swift.Equatable {
        /// The location of the Infor Nexus resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.InforNexusMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Infor Nexus.
    public struct InforNexusMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.InforNexusSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Infor Nexus is being used as a source.
    public struct InforNexusSourceProperties: Swift.Equatable {
        /// The object specified in the Infor Nexus flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal service error occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes.LambdaConnectorProvisioningConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaArn = self.lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of the lambda which is being registered as the connector.
    public struct LambdaConnectorProvisioningConfig: Swift.Equatable {
        /// Lambda ARN of the connector being registered.
        /// This member is required.
        public var lambdaArn: Swift.String?

        public init(
            lambdaArn: Swift.String? = nil
        )
        {
            self.lambdaArn = lambdaArn
        }
    }

}

extension ListConnectorEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorProfileName
        case connectorType
        case entitiesPath
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiVersion = self.apiVersion {
            try encodeContainer.encode(apiVersion, forKey: .apiVersion)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let entitiesPath = self.entitiesPath {
            try encodeContainer.encode(entitiesPath, forKey: .entitiesPath)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectorEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-connector-entities"
    }
}

public struct ListConnectorEntitiesInput: Swift.Equatable {
    /// The version of the API that's used by the connector.
    public var apiVersion: Swift.String?
    /// The name of the connector profile. The name is unique for each ConnectorProfile in the Amazon Web Services account, and is used to query the downstream connector.
    public var connectorProfileName: Swift.String?
    /// The type of connector, such as Salesforce, Amplitude, and so on.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// This optional parameter is specific to connector implementation. Some connectors support multiple levels or categories of entities. You can find out the list of roots for such providers by sending a request without the entitiesPath parameter. If the connector supports entities at different roots, this initial request returns the list of roots. Otherwise, this request returns all entities supported by the provider.
    public var entitiesPath: Swift.String?
    /// The maximum number of items that the operation returns in the response.
    public var maxResults: Swift.Int?
    /// A token that was provided by your prior ListConnectorEntities operation if the response was too big for the page size. You specify this token to get the next page of results in paginated response.
    public var nextToken: Swift.String?

    public init(
        apiVersion: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorEntitiesInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let entitiesPath: Swift.String?
    let apiVersion: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectorEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorProfileName
        case connectorType
        case entitiesPath
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let entitiesPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitiesPath)
        entitiesPath = entitiesPathDecoded
        let apiVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiVersion)
        apiVersion = apiVersionDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorEntityMap = output.connectorEntityMap
            self.nextToken = output.nextToken
        } else {
            self.connectorEntityMap = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorEntitiesOutput: Swift.Equatable {
    /// The response of ListConnectorEntities lists entities grouped by category. This map's key represents the group name, and its value contains the list of entities belonging to that group.
    /// This member is required.
    public var connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?
    /// A token that you specify in your next ListConnectorEntities operation to get the next page of results in paginated response. The ListConnectorEntities operation provides this token if the response is too big for the page size.
    public var nextToken: Swift.String?

    public init(
        connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorEntityMap = connectorEntityMap
        self.nextToken = nextToken
    }
}

struct ListConnectorEntitiesOutputBody: Swift.Equatable {
    let connectorEntityMap: [Swift.String:[AppflowClientTypes.ConnectorEntity]]?
    let nextToken: Swift.String?
}

extension ListConnectorEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorEntityMap
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorEntityMapContainer = try containerValues.decodeIfPresent([Swift.String: [AppflowClientTypes.ConnectorEntity?]?].self, forKey: .connectorEntityMap)
        var connectorEntityMapDecoded0: [Swift.String:[AppflowClientTypes.ConnectorEntity]]? = nil
        if let connectorEntityMapContainer = connectorEntityMapContainer {
            connectorEntityMapDecoded0 = [Swift.String:[AppflowClientTypes.ConnectorEntity]]()
            for (key0, connectorentitylist0) in connectorEntityMapContainer {
                var connectorentitylist0Decoded0: [AppflowClientTypes.ConnectorEntity]? = nil
                if let connectorentitylist0 = connectorentitylist0 {
                    connectorentitylist0Decoded0 = [AppflowClientTypes.ConnectorEntity]()
                    for structure1 in connectorentitylist0 {
                        if let structure1 = structure1 {
                            connectorentitylist0Decoded0?.append(structure1)
                        }
                    }
                }
                connectorEntityMapDecoded0?[key0] = connectorentitylist0Decoded0
            }
        }
        connectorEntityMap = connectorEntityMapDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConnectorEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-connectors"
    }
}

public struct ListConnectorsInput: Swift.Equatable {
    /// Specifies the maximum number of items that should be returned in the result set. The default for maxResults is 20 (for all paginated API operations).
    public var maxResults: Swift.Int?
    /// The pagination token for the next page of data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectors = output.connectors
            self.nextToken = output.nextToken
        } else {
            self.connectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorsOutput: Swift.Equatable {
    /// Contains information about the connectors supported by Amazon AppFlow.
    public var connectors: [AppflowClientTypes.ConnectorDetail]?
    /// The pagination token for the next page of data. If nextToken=null, this means that all records have been fetched.
    public var nextToken: Swift.String?

    public init(
        connectors: [AppflowClientTypes.ConnectorDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

struct ListConnectorsOutputBody: Swift.Equatable {
    let connectors: [AppflowClientTypes.ConnectorDetail]?
    let nextToken: Swift.String?
}

extension ListConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.ConnectorDetail?].self, forKey: .connectors)
        var connectorsDecoded0:[AppflowClientTypes.ConnectorDetail]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [AppflowClientTypes.ConnectorDetail]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFlowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-flows"
    }
}

public struct ListFlowsInput: Swift.Equatable {
    /// Specifies the maximum number of items that should be returned in the result set.
    public var maxResults: Swift.Int?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFlowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFlowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutput: Swift.Equatable {
    /// The list of flows associated with your account.
    public var flows: [AppflowClientTypes.FlowDefinition]?
    /// The pagination token for next page of data.
    public var nextToken: Swift.String?

    public init(
        flows: [AppflowClientTypes.FlowDefinition]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputBody: Swift.Equatable {
    let flows: [AppflowClientTypes.FlowDefinition]?
    let nextToken: Swift.String?
}

extension ListFlowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flows
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([AppflowClientTypes.FlowDefinition?].self, forKey: .flows)
        var flowsDecoded0:[AppflowClientTypes.FlowDefinition]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [AppflowClientTypes.FlowDefinition]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFlowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the specified flow.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags used to organize, track, or control access for your flow.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.LookoutMetricsDestinationProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Lookout for Metrics is used as a destination.
    public struct LookoutMetricsDestinationProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes {
    public enum MarketoConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case greaterThan
        case lessThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketoConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .greaterThan,
                .lessThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MarketoConnectorOperator(rawValue: rawValue) ?? MarketoConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.MarketoConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarketoConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required by Marketo.
    public struct MarketoConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Marketo resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.MarketoConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Marketo.
    public struct MarketoConnectorProfileProperties: Swift.Equatable {
        /// The location of the Marketo resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.MarketoDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that Amazon AppFlow applies when you use Marketo as a flow destination.
    public struct MarketoDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The object specified in the Marketo flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            object: Swift.String? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.object = object
        }
    }

}

extension AppflowClientTypes.MarketoMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Marketo.
    public struct MarketoMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.MarketoSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Marketo is being used as a source.
    public struct MarketoSourceProperties: Swift.Equatable {
        /// The object specified in the Marketo flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.MetadataCatalogConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glueDataCatalog
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let glueDataCatalog = self.glueDataCatalog {
            try encodeContainer.encode(glueDataCatalog, forKey: .glueDataCatalog)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let glueDataCatalogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GlueDataCatalogConfig.self, forKey: .glueDataCatalog)
        glueDataCatalog = glueDataCatalogDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data. When Amazon AppFlow catalogs your data, it stores metadata in a data catalog.
    public struct MetadataCatalogConfig: Swift.Equatable {
        /// Specifies the configuration that Amazon AppFlow uses when it catalogs your data with the Glue Data Catalog.
        public var glueDataCatalog: AppflowClientTypes.GlueDataCatalogConfig?

        public init(
            glueDataCatalog: AppflowClientTypes.GlueDataCatalogConfig? = nil
        )
        {
            self.glueDataCatalog = glueDataCatalog
        }
    }

}

extension AppflowClientTypes.MetadataCatalogDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case catalogType
        case partitionRegistrationOutput
        case tableName
        case tableRegistrationOutput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let catalogType = self.catalogType {
            try encodeContainer.encode(catalogType.rawValue, forKey: .catalogType)
        }
        if let partitionRegistrationOutput = self.partitionRegistrationOutput {
            try encodeContainer.encode(partitionRegistrationOutput, forKey: .partitionRegistrationOutput)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableRegistrationOutput = self.tableRegistrationOutput {
            try encodeContainer.encode(tableRegistrationOutput, forKey: .tableRegistrationOutput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let catalogTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CatalogType.self, forKey: .catalogType)
        catalogType = catalogTypeDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let tableRegistrationOutputDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RegistrationOutput.self, forKey: .tableRegistrationOutput)
        tableRegistrationOutput = tableRegistrationOutputDecoded
        let partitionRegistrationOutputDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.RegistrationOutput.self, forKey: .partitionRegistrationOutput)
        partitionRegistrationOutput = partitionRegistrationOutputDecoded
    }
}

extension AppflowClientTypes {
    /// Describes the metadata catalog, metadata table, and data partitions that Amazon AppFlow used for the associated flow run.
    public struct MetadataCatalogDetail: Swift.Equatable {
        /// The type of metadata catalog that Amazon AppFlow used for the associated flow run. This parameter returns the following value: GLUE The metadata catalog is provided by the Glue Data Catalog. Glue includes the Glue Data Catalog as a component.
        public var catalogType: AppflowClientTypes.CatalogType?
        /// Describes the status of the attempt from Amazon AppFlow to register the data partitions with the metadata catalog. The data partitions organize the flow output into a hierarchical path, such as a folder path in an S3 bucket. Amazon AppFlow creates the partitions (if they don't already exist) based on your flow configuration.
        public var partitionRegistrationOutput: AppflowClientTypes.RegistrationOutput?
        /// The name of the table that stores the metadata for the associated flow run. The table stores metadata that represents the data that the flow transferred. Amazon AppFlow stores the table in the metadata catalog.
        public var tableName: Swift.String?
        /// Describes the status of the attempt from Amazon AppFlow to register the metadata table with the metadata catalog. Amazon AppFlow creates or updates this table for the associated flow run.
        public var tableRegistrationOutput: AppflowClientTypes.RegistrationOutput?

        public init(
            catalogType: AppflowClientTypes.CatalogType? = nil,
            partitionRegistrationOutput: AppflowClientTypes.RegistrationOutput? = nil,
            tableName: Swift.String? = nil,
            tableRegistrationOutput: AppflowClientTypes.RegistrationOutput? = nil
        )
        {
            self.catalogType = catalogType
            self.partitionRegistrationOutput = partitionRegistrationOutput
            self.tableName = tableName
            self.tableRegistrationOutput = tableRegistrationOutput
        }
    }

}

extension AppflowClientTypes.OAuth2Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.OAuth2Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OAuth2Credentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The OAuth 2.0 credentials required for OAuth 2.0 authentication.
    public struct OAuth2Credentials: Swift.Equatable {
        /// The access token used to access the connector on your behalf.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        public var clientSecret: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The refresh token used to refresh an expired access token.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.OAuth2CustomParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorSuppliedValues
        case description
        case isRequired
        case isSensitiveField
        case key
        case label
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorSuppliedValues = connectorSuppliedValues {
            var connectorSuppliedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectorSuppliedValues)
            for connectorsuppliedvalue0 in connectorSuppliedValues {
                try connectorSuppliedValuesContainer.encode(connectorsuppliedvalue0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isRequired != false {
            try encodeContainer.encode(isRequired, forKey: .isRequired)
        }
        if isSensitiveField != false {
            try encodeContainer.encode(isSensitiveField, forKey: .isSensitiveField)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let label = self.label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let isRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRequired) ?? false
        isRequired = isRequiredDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isSensitiveFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSensitiveField) ?? false
        isSensitiveField = isSensitiveFieldDecoded
        let connectorSuppliedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .connectorSuppliedValues)
        var connectorSuppliedValuesDecoded0:[Swift.String]? = nil
        if let connectorSuppliedValuesContainer = connectorSuppliedValuesContainer {
            connectorSuppliedValuesDecoded0 = [Swift.String]()
            for string0 in connectorSuppliedValuesContainer {
                if let string0 = string0 {
                    connectorSuppliedValuesDecoded0?.append(string0)
                }
            }
        }
        connectorSuppliedValues = connectorSuppliedValuesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2CustomPropType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppflowClientTypes {
    /// Custom parameter required for OAuth 2.0 authentication.
    public struct OAuth2CustomParameter: Swift.Equatable {
        /// Contains default values for this authentication parameter that are supplied by the connector.
        public var connectorSuppliedValues: [Swift.String]?
        /// A description about the custom parameter used for OAuth 2.0 authentication.
        public var description: Swift.String?
        /// Indicates whether the custom parameter for OAuth 2.0 authentication is required.
        public var isRequired: Swift.Bool
        /// Indicates whether this authentication custom parameter is a sensitive field.
        public var isSensitiveField: Swift.Bool
        /// The key of the custom parameter required for OAuth 2.0 authentication.
        public var key: Swift.String?
        /// The label of the custom parameter used for OAuth 2.0 authentication.
        public var label: Swift.String?
        /// Indicates whether custom parameter is used with TokenUrl or AuthUrl.
        public var type: AppflowClientTypes.OAuth2CustomPropType?

        public init(
            connectorSuppliedValues: [Swift.String]? = nil,
            description: Swift.String? = nil,
            isRequired: Swift.Bool = false,
            isSensitiveField: Swift.Bool = false,
            key: Swift.String? = nil,
            label: Swift.String? = nil,
            type: AppflowClientTypes.OAuth2CustomPropType? = nil
        )
        {
            self.connectorSuppliedValues = connectorSuppliedValues
            self.description = description
            self.isRequired = isRequired
            self.isSensitiveField = isSensitiveField
            self.key = key
            self.label = label
            self.type = type
        }
    }

}

extension AppflowClientTypes {
    public enum OAuth2CustomPropType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authUrl
        case tokenUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2CustomPropType] {
            return [
                .authUrl,
                .tokenUrl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authUrl: return "AUTH_URL"
            case .tokenUrl: return "TOKEN_URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuth2CustomPropType(rawValue: rawValue) ?? OAuth2CustomPropType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.OAuth2Defaults: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCodeUrls
        case oauth2CustomProperties
        case oauth2GrantTypesSupported
        case oauthScopes
        case tokenUrls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCodeUrls = authCodeUrls {
            var authCodeUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authCodeUrls)
            for authcodeurl0 in authCodeUrls {
                try authCodeUrlsContainer.encode(authcodeurl0)
            }
        }
        if let oauth2CustomProperties = oauth2CustomProperties {
            var oauth2CustomPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oauth2CustomProperties)
            for oauth2customparameter0 in oauth2CustomProperties {
                try oauth2CustomPropertiesContainer.encode(oauth2customparameter0)
            }
        }
        if let oauth2GrantTypesSupported = oauth2GrantTypesSupported {
            var oauth2GrantTypesSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oauth2GrantTypesSupported)
            for oauth2granttype0 in oauth2GrantTypesSupported {
                try oauth2GrantTypesSupportedContainer.encode(oauth2granttype0.rawValue)
            }
        }
        if let oauthScopes = oauthScopes {
            var oauthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oauthScopes)
            for oauthscope0 in oauthScopes {
                try oauthScopesContainer.encode(oauthscope0)
            }
        }
        if let tokenUrls = tokenUrls {
            var tokenUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tokenUrls)
            for tokenurl0 in tokenUrls {
                try tokenUrlsContainer.encode(tokenurl0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oauthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oauthScopes)
        var oauthScopesDecoded0:[Swift.String]? = nil
        if let oauthScopesContainer = oauthScopesContainer {
            oauthScopesDecoded0 = [Swift.String]()
            for string0 in oauthScopesContainer {
                if let string0 = string0 {
                    oauthScopesDecoded0?.append(string0)
                }
            }
        }
        oauthScopes = oauthScopesDecoded0
        let tokenUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tokenUrls)
        var tokenUrlsDecoded0:[Swift.String]? = nil
        if let tokenUrlsContainer = tokenUrlsContainer {
            tokenUrlsDecoded0 = [Swift.String]()
            for string0 in tokenUrlsContainer {
                if let string0 = string0 {
                    tokenUrlsDecoded0?.append(string0)
                }
            }
        }
        tokenUrls = tokenUrlsDecoded0
        let authCodeUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authCodeUrls)
        var authCodeUrlsDecoded0:[Swift.String]? = nil
        if let authCodeUrlsContainer = authCodeUrlsContainer {
            authCodeUrlsDecoded0 = [Swift.String]()
            for string0 in authCodeUrlsContainer {
                if let string0 = string0 {
                    authCodeUrlsDecoded0?.append(string0)
                }
            }
        }
        authCodeUrls = authCodeUrlsDecoded0
        let oauth2GrantTypesSupportedContainer = try containerValues.decodeIfPresent([AppflowClientTypes.OAuth2GrantType?].self, forKey: .oauth2GrantTypesSupported)
        var oauth2GrantTypesSupportedDecoded0:[AppflowClientTypes.OAuth2GrantType]? = nil
        if let oauth2GrantTypesSupportedContainer = oauth2GrantTypesSupportedContainer {
            oauth2GrantTypesSupportedDecoded0 = [AppflowClientTypes.OAuth2GrantType]()
            for enum0 in oauth2GrantTypesSupportedContainer {
                if let enum0 = enum0 {
                    oauth2GrantTypesSupportedDecoded0?.append(enum0)
                }
            }
        }
        oauth2GrantTypesSupported = oauth2GrantTypesSupportedDecoded0
        let oauth2CustomPropertiesContainer = try containerValues.decodeIfPresent([AppflowClientTypes.OAuth2CustomParameter?].self, forKey: .oauth2CustomProperties)
        var oauth2CustomPropertiesDecoded0:[AppflowClientTypes.OAuth2CustomParameter]? = nil
        if let oauth2CustomPropertiesContainer = oauth2CustomPropertiesContainer {
            oauth2CustomPropertiesDecoded0 = [AppflowClientTypes.OAuth2CustomParameter]()
            for structure0 in oauth2CustomPropertiesContainer {
                if let structure0 = structure0 {
                    oauth2CustomPropertiesDecoded0?.append(structure0)
                }
            }
        }
        oauth2CustomProperties = oauth2CustomPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// Contains the default values required for OAuth 2.0 authentication.
    public struct OAuth2Defaults: Swift.Equatable {
        /// Auth code URLs that can be used for OAuth 2.0 authentication.
        public var authCodeUrls: [Swift.String]?
        /// List of custom parameters required for OAuth 2.0 authentication.
        public var oauth2CustomProperties: [AppflowClientTypes.OAuth2CustomParameter]?
        /// OAuth 2.0 grant types supported by the connector.
        public var oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]?
        /// OAuth 2.0 scopes that the connector supports.
        public var oauthScopes: [Swift.String]?
        /// Token URLs that can be used for OAuth 2.0 authentication.
        public var tokenUrls: [Swift.String]?

        public init(
            authCodeUrls: [Swift.String]? = nil,
            oauth2CustomProperties: [AppflowClientTypes.OAuth2CustomParameter]? = nil,
            oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]? = nil,
            oauthScopes: [Swift.String]? = nil,
            tokenUrls: [Swift.String]? = nil
        )
        {
            self.authCodeUrls = authCodeUrls
            self.oauth2CustomProperties = oauth2CustomProperties
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
            self.oauthScopes = oauthScopes
            self.tokenUrls = tokenUrls
        }
    }

}

extension AppflowClientTypes {
    public enum OAuth2GrantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizationCode
        case clientCredentials
        case jwtBearer
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2GrantType] {
            return [
                .authorizationCode,
                .clientCredentials,
                .jwtBearer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizationCode: return "AUTHORIZATION_CODE"
            case .clientCredentials: return "CLIENT_CREDENTIALS"
            case .jwtBearer: return "JWT_BEARER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OAuth2GrantType(rawValue: rawValue) ?? OAuth2GrantType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.OAuth2Properties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuth2GrantType
        case tokenUrl
        case tokenUrlCustomProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuth2GrantType = self.oAuth2GrantType {
            try encodeContainer.encode(oAuth2GrantType.rawValue, forKey: .oAuth2GrantType)
        }
        if let tokenUrl = self.tokenUrl {
            try encodeContainer.encode(tokenUrl, forKey: .tokenUrl)
        }
        if let tokenUrlCustomProperties = tokenUrlCustomProperties {
            var tokenUrlCustomPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tokenUrlCustomProperties)
            for (dictKey0, tokenUrlCustomProperties0) in tokenUrlCustomProperties {
                try tokenUrlCustomPropertiesContainer.encode(tokenUrlCustomProperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenUrl)
        tokenUrl = tokenUrlDecoded
        let oAuth2GrantTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2GrantType.self, forKey: .oAuth2GrantType)
        oAuth2GrantType = oAuth2GrantTypeDecoded
        let tokenUrlCustomPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tokenUrlCustomProperties)
        var tokenUrlCustomPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let tokenUrlCustomPropertiesContainer = tokenUrlCustomPropertiesContainer {
            tokenUrlCustomPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, custompropertyvalue0) in tokenUrlCustomPropertiesContainer {
                if let custompropertyvalue0 = custompropertyvalue0 {
                    tokenUrlCustomPropertiesDecoded0?[key0] = custompropertyvalue0
                }
            }
        }
        tokenUrlCustomProperties = tokenUrlCustomPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// The OAuth 2.0 properties required for OAuth 2.0 authentication.
    public struct OAuth2Properties: Swift.Equatable {
        /// The OAuth 2.0 grant type used by connector for OAuth 2.0 authentication.
        /// This member is required.
        public var oAuth2GrantType: AppflowClientTypes.OAuth2GrantType?
        /// The token URL required for OAuth 2.0 authentication.
        /// This member is required.
        public var tokenUrl: Swift.String?
        /// Associates your token URL with a map of properties that you define. Use this parameter to provide any additional details that the connector requires to authenticate your request.
        public var tokenUrlCustomProperties: [Swift.String:Swift.String]?

        public init(
            oAuth2GrantType: AppflowClientTypes.OAuth2GrantType? = nil,
            tokenUrl: Swift.String? = nil,
            tokenUrlCustomProperties: [Swift.String:Swift.String]? = nil
        )
        {
            self.oAuth2GrantType = oAuth2GrantType
            self.tokenUrl = tokenUrl
            self.tokenUrlCustomProperties = tokenUrlCustomProperties
        }
    }

}

extension AppflowClientTypes.OAuthCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.OAuthCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OAuthCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The OAuth credentials required for OAuth type authentication.
    public struct OAuthCredentials: Swift.Equatable {
        /// The access token used to access protected SAPOData resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The refresh token used to refresh expired access token.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.OAuthProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authCodeUrl
        case oAuthScopes
        case tokenUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authCodeUrl = self.authCodeUrl {
            try encodeContainer.encode(authCodeUrl, forKey: .authCodeUrl)
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
        if let tokenUrl = self.tokenUrl {
            try encodeContainer.encode(tokenUrl, forKey: .tokenUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenUrl)
        tokenUrl = tokenUrlDecoded
        let authCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authCodeUrl)
        authCodeUrl = authCodeUrlDecoded
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The OAuth properties required for OAuth type authentication.
    public struct OAuthProperties: Swift.Equatable {
        /// The authorization code url required to redirect to SAP Login Page to fetch authorization code for OAuth type authentication.
        /// This member is required.
        public var authCodeUrl: Swift.String?
        /// The OAuth scopes required for OAuth type authentication.
        /// This member is required.
        public var oAuthScopes: [Swift.String]?
        /// The token url required to fetch access/refresh tokens using authorization code and also to refresh expired access token using refresh token.
        /// This member is required.
        public var tokenUrl: Swift.String?

        public init(
            authCodeUrl: Swift.String? = nil,
            oAuthScopes: [Swift.String]? = nil,
            tokenUrl: Swift.String? = nil
        )
        {
            self.authCodeUrl = authCodeUrl
            self.oAuthScopes = oAuthScopes
            self.tokenUrl = tokenUrl
        }
    }

}

extension AppflowClientTypes {
    public enum Operator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum OperatorPropertiesKeys: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case concatFormat
        case dataType
        case destinationDataType
        case excludeSourceFieldsList
        case includeNewFields
        case lowerBound
        case maskLength
        case maskValue
        case mathOperationFieldsOrder
        case orderedPartitionKeysList
        case sourceDataType
        case subfieldCategoryMap
        case truncateLength
        case upperBound
        case validationAction
        case value
        case values
        case sdkUnknown(Swift.String)

        public static var allCases: [OperatorPropertiesKeys] {
            return [
                .concatFormat,
                .dataType,
                .destinationDataType,
                .excludeSourceFieldsList,
                .includeNewFields,
                .lowerBound,
                .maskLength,
                .maskValue,
                .mathOperationFieldsOrder,
                .orderedPartitionKeysList,
                .sourceDataType,
                .subfieldCategoryMap,
                .truncateLength,
                .upperBound,
                .validationAction,
                .value,
                .values,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .concatFormat: return "CONCAT_FORMAT"
            case .dataType: return "DATA_TYPE"
            case .destinationDataType: return "DESTINATION_DATA_TYPE"
            case .excludeSourceFieldsList: return "EXCLUDE_SOURCE_FIELDS_LIST"
            case .includeNewFields: return "INCLUDE_NEW_FIELDS"
            case .lowerBound: return "LOWER_BOUND"
            case .maskLength: return "MASK_LENGTH"
            case .maskValue: return "MASK_VALUE"
            case .mathOperationFieldsOrder: return "MATH_OPERATION_FIELDS_ORDER"
            case .orderedPartitionKeysList: return "ORDERED_PARTITION_KEYS_LIST"
            case .sourceDataType: return "SOURCE_DATA_TYPE"
            case .subfieldCategoryMap: return "SUBFIELD_CATEGORY_MAP"
            case .truncateLength: return "TRUNCATE_LENGTH"
            case .upperBound: return "UPPER_BOUND"
            case .validationAction: return "VALIDATION_ACTION"
            case .value: return "VALUE"
            case .values: return "VALUES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperatorPropertiesKeys(rawValue: rawValue) ?? OperatorPropertiesKeys.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum Operators: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [Operators] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Operators(rawValue: rawValue) ?? Operators.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PardotConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [PardotConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PardotConnectorOperator(rawValue: rawValue) ?? PardotConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PardotConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientCredentialsArn
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientCredentialsArn = self.clientCredentialsArn {
            try encodeContainer.encode(clientCredentialsArn, forKey: .clientCredentialsArn)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
        let clientCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCredentialsArn)
        clientCredentialsArn = clientCredentialsArnDecoded
    }
}

extension AppflowClientTypes.PardotConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PardotConnectorProfileCredentials(oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientCredentialsArn: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Salesforce Pardot.
    public struct PardotConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Salesforce Pardot resources.
        public var accessToken: Swift.String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public var clientCredentialsArn: Swift.String?
        /// Used by select connectors for which the OAuth workflow is supported, such as Salesforce, Google Analytics, Marketo, Zendesk, and Slack.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.PardotConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessUnitId
        case instanceUrl
        case isSandboxEnvironment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessUnitId = self.businessUnitId {
            try encodeContainer.encode(businessUnitId, forKey: .businessUnitId)
        }
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
        if isSandboxEnvironment != false {
            try encodeContainer.encode(isSandboxEnvironment, forKey: .isSandboxEnvironment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
        let isSandboxEnvironmentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSandboxEnvironment) ?? false
        isSandboxEnvironment = isSandboxEnvironmentDecoded
        let businessUnitIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessUnitId)
        businessUnitId = businessUnitIdDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Salesforce Pardot.
    public struct PardotConnectorProfileProperties: Swift.Equatable {
        /// The business unit id of Salesforce Pardot instance.
        public var businessUnitId: Swift.String?
        /// The location of the Salesforce Pardot resource.
        public var instanceUrl: Swift.String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public var isSandboxEnvironment: Swift.Bool

        public init(
            businessUnitId: Swift.String? = nil,
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false
        )
        {
            self.businessUnitId = businessUnitId
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
        }
    }

}

extension AppflowClientTypes.PardotMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Salesforce Pardot.
    public struct PardotMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.PardotSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Salesforce Pardot is being used as a source.
    public struct PardotSourceProperties: Swift.Equatable {
        /// The object specified in the Salesforce Pardot flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum PathPrefix: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executionId
        case schemaVersion
        case sdkUnknown(Swift.String)

        public static var allCases: [PathPrefix] {
            return [
                .executionId,
                .schemaVersion,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executionId: return "EXECUTION_ID"
            case .schemaVersion: return "SCHEMA_VERSION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PathPrefix(rawValue: rawValue) ?? PathPrefix.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PrefixConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pathPrefixHierarchy
        case prefixFormat
        case prefixType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pathPrefixHierarchy = pathPrefixHierarchy {
            var pathPrefixHierarchyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathPrefixHierarchy)
            for pathprefix0 in pathPrefixHierarchy {
                try pathPrefixHierarchyContainer.encode(pathprefix0.rawValue)
            }
        }
        if let prefixFormat = self.prefixFormat {
            try encodeContainer.encode(prefixFormat.rawValue, forKey: .prefixFormat)
        }
        if let prefixType = self.prefixType {
            try encodeContainer.encode(prefixType.rawValue, forKey: .prefixType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixType.self, forKey: .prefixType)
        prefixType = prefixTypeDecoded
        let prefixFormatDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixFormat.self, forKey: .prefixFormat)
        prefixFormat = prefixFormatDecoded
        let pathPrefixHierarchyContainer = try containerValues.decodeIfPresent([AppflowClientTypes.PathPrefix?].self, forKey: .pathPrefixHierarchy)
        var pathPrefixHierarchyDecoded0:[AppflowClientTypes.PathPrefix]? = nil
        if let pathPrefixHierarchyContainer = pathPrefixHierarchyContainer {
            pathPrefixHierarchyDecoded0 = [AppflowClientTypes.PathPrefix]()
            for enum0 in pathPrefixHierarchyContainer {
                if let enum0 = enum0 {
                    pathPrefixHierarchyDecoded0?.append(enum0)
                }
            }
        }
        pathPrefixHierarchy = pathPrefixHierarchyDecoded0
    }
}

extension AppflowClientTypes {
    /// Specifies elements that Amazon AppFlow includes in the file and folder names in the flow destination.
    public struct PrefixConfig: Swift.Equatable {
        /// Specifies whether the destination file path includes either or both of the following elements: EXECUTION_ID The ID that Amazon AppFlow assigns to the flow run. SCHEMA_VERSION The version number of your data schema. Amazon AppFlow assigns this version number. The version number increases by one when you change any of the following settings in your flow configuration:
        ///
        /// * Source-to-destination field mappings
        ///
        /// * Field data types
        ///
        /// * Partition keys
        public var pathPrefixHierarchy: [AppflowClientTypes.PathPrefix]?
        /// Determines the level of granularity for the date and time that's included in the prefix.
        public var prefixFormat: AppflowClientTypes.PrefixFormat?
        /// Determines the format of the prefix, and whether it applies to the file name, file path, or both.
        public var prefixType: AppflowClientTypes.PrefixType?

        public init(
            pathPrefixHierarchy: [AppflowClientTypes.PathPrefix]? = nil,
            prefixFormat: AppflowClientTypes.PrefixFormat? = nil,
            prefixType: AppflowClientTypes.PrefixType? = nil
        )
        {
            self.pathPrefixHierarchy = pathPrefixHierarchy
            self.prefixFormat = prefixFormat
            self.prefixType = prefixType
        }
    }

}

extension AppflowClientTypes {
    public enum PrefixFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixFormat] {
            return [
                .day,
                .hour,
                .minute,
                .month,
                .year,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixFormat(rawValue: rawValue) ?? PrefixFormat.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PrefixType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filename
        case path
        case pathAndFilename
        case sdkUnknown(Swift.String)

        public static var allCases: [PrefixType] {
            return [
                .filename,
                .path,
                .pathAndFilename,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filename: return "FILENAME"
            case .path: return "PATH"
            case .pathAndFilename: return "PATH_AND_FILENAME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrefixType(rawValue: rawValue) ?? PrefixType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum PrivateConnectionProvisioningFailureCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case connectorAuthentication
        case connectorServer
        case internalServer
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningFailureCause] {
            return [
                .accessDenied,
                .connectorAuthentication,
                .connectorServer,
                .internalServer,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .connectorAuthentication: return "CONNECTOR_AUTHENTICATION"
            case .connectorServer: return "CONNECTOR_SERVER"
            case .internalServer: return "INTERNAL_SERVER"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateConnectionProvisioningFailureCause(rawValue: rawValue) ?? PrivateConnectionProvisioningFailureCause.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.PrivateConnectionProvisioningState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCause
        case failureMessage
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCause = self.failureCause {
            try encodeContainer.encode(failureCause.rawValue, forKey: .failureCause)
        }
        if let failureMessage = self.failureMessage {
            try encodeContainer.encode(failureMessage, forKey: .failureMessage)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningStatus.self, forKey: .status)
        status = statusDecoded
        let failureMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureMessage)
        failureMessage = failureMessageDecoded
        let failureCauseDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrivateConnectionProvisioningFailureCause.self, forKey: .failureCause)
        failureCause = failureCauseDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the private connection provisioning state.
    public struct PrivateConnectionProvisioningState: Swift.Equatable {
        /// Specifies the private connection provisioning failure cause.
        public var failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause?
        /// Specifies the private connection provisioning failure reason.
        public var failureMessage: Swift.String?
        /// Specifies the private connection provisioning status.
        public var status: AppflowClientTypes.PrivateConnectionProvisioningStatus?

        public init(
            failureCause: AppflowClientTypes.PrivateConnectionProvisioningFailureCause? = nil,
            failureMessage: Swift.String? = nil,
            status: AppflowClientTypes.PrivateConnectionProvisioningStatus? = nil
        )
        {
            self.failureCause = failureCause
            self.failureMessage = failureMessage
            self.status = status
        }
    }

}

extension AppflowClientTypes {
    public enum PrivateConnectionProvisioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivateConnectionProvisioningStatus] {
            return [
                .created,
                .failed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivateConnectionProvisioningStatus(rawValue: rawValue) ?? PrivateConnectionProvisioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.Range: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum
        case minimum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximum != 0.0 {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if minimum != 0.0 {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum) ?? 0.0
        maximum = maximumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum) ?? 0.0
        minimum = minimumDecoded
    }
}

extension AppflowClientTypes {
    /// The range of values that the property supports.
    public struct Range: Swift.Equatable {
        /// Maximum value supported by the field.
        public var maximum: Swift.Double
        /// Minimum value supported by the field.
        public var minimum: Swift.Double

        public init(
            maximum: Swift.Double = 0.0,
            minimum: Swift.Double = 0.0
        )
        {
            self.maximum = maximum
            self.minimum = minimum
        }
    }

}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.RedshiftConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RedshiftConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Amazon Redshift.
    public struct RedshiftConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        public var password: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.RedshiftConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case clusterIdentifier
        case dataApiRoleArn
        case databaseName
        case databaseUrl
        case isRedshiftServerless
        case roleArn
        case workgroupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let clusterIdentifier = self.clusterIdentifier {
            try encodeContainer.encode(clusterIdentifier, forKey: .clusterIdentifier)
        }
        if let dataApiRoleArn = self.dataApiRoleArn {
            try encodeContainer.encode(dataApiRoleArn, forKey: .dataApiRoleArn)
        }
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let databaseUrl = self.databaseUrl {
            try encodeContainer.encode(databaseUrl, forKey: .databaseUrl)
        }
        if isRedshiftServerless != false {
            try encodeContainer.encode(isRedshiftServerless, forKey: .isRedshiftServerless)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let workgroupName = self.workgroupName {
            try encodeContainer.encode(workgroupName, forKey: .workgroupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseUrl)
        databaseUrl = databaseUrlDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let dataApiRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataApiRoleArn)
        dataApiRoleArn = dataApiRoleArnDecoded
        let isRedshiftServerlessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRedshiftServerless) ?? false
        isRedshiftServerless = isRedshiftServerlessDecoded
        let clusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterIdentifier)
        clusterIdentifier = clusterIdentifierDecoded
        let workgroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workgroupName)
        workgroupName = workgroupNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties when using Amazon Redshift.
    public struct RedshiftConnectorProfileProperties: Swift.Equatable {
        /// A name for the associated Amazon S3 bucket.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The unique ID that's assigned to an Amazon Redshift cluster.
        public var clusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that permits Amazon AppFlow to access your Amazon Redshift database through the Data API. For more information, and for the polices that you attach to this role, see [Allow Amazon AppFlow to access Amazon Redshift databases with the Data API](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_service-role-policies.html#access-redshift).
        public var dataApiRoleArn: Swift.String?
        /// The name of an Amazon Redshift database.
        public var databaseName: Swift.String?
        /// The JDBC URL of the Amazon Redshift cluster.
        public var databaseUrl: Swift.String?
        /// Indicates whether the connector profile defines a connection to an Amazon Redshift Serverless data warehouse.
        public var isRedshiftServerless: Swift.Bool
        /// The Amazon Resource Name (ARN) of IAM role that grants Amazon Redshift read-only access to Amazon S3. For more information, and for the polices that you attach to this role, see [Allow Amazon Redshift to access your Amazon AppFlow data in Amazon S3](https://docs.aws.amazon.com/appflow/latest/userguide/security_iam_service-role-policies.html#redshift-access-s3).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The name of an Amazon Redshift workgroup.
        public var workgroupName: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            clusterIdentifier: Swift.String? = nil,
            dataApiRoleArn: Swift.String? = nil,
            databaseName: Swift.String? = nil,
            databaseUrl: Swift.String? = nil,
            isRedshiftServerless: Swift.Bool = false,
            roleArn: Swift.String? = nil,
            workgroupName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.clusterIdentifier = clusterIdentifier
            self.dataApiRoleArn = dataApiRoleArn
            self.databaseName = databaseName
            self.databaseUrl = databaseUrl
            self.isRedshiftServerless = isRedshiftServerless
            self.roleArn = roleArn
            self.workgroupName = workgroupName
        }
    }

}

extension AppflowClientTypes.RedshiftDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = self.intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon Redshift is being used as a destination.
    public struct RedshiftDestinationProperties: Swift.Equatable {
        /// The object key for the bucket in which Amazon AppFlow places the destination files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Amazon Redshift destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Amazon Redshift.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Amazon Redshift flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.RedshiftMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon Redshift.
    public struct RedshiftMetadata: Swift.Equatable {

        public init() { }
    }

}

extension RegisterConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectorLabel
        case connectorProvisioningConfig
        case connectorProvisioningType
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorProvisioningConfig = self.connectorProvisioningConfig {
            try encodeContainer.encode(connectorProvisioningConfig, forKey: .connectorProvisioningConfig)
        }
        if let connectorProvisioningType = self.connectorProvisioningType {
            try encodeContainer.encode(connectorProvisioningType.rawValue, forKey: .connectorProvisioningType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension RegisterConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/register-connector"
    }
}

public struct RegisterConnectorInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your RegisterConnector request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to RegisterConnector. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the connector. The name is unique for each ConnectorRegistration in your Amazon Web Services account.
    public var connectorLabel: Swift.String?
    /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
    public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    /// The provisioning type of the connector. Currently the only supported value is LAMBDA.
    public var connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
    /// A description about the connector that's being registered.
    public var description: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
        connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType? = nil,
        description: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectorLabel = connectorLabel
        self.connectorProvisioningConfig = connectorProvisioningConfig
        self.connectorProvisioningType = connectorProvisioningType
        self.description = description
    }
}

struct RegisterConnectorInputBody: Swift.Equatable {
    let connectorLabel: Swift.String?
    let description: Swift.String?
    let connectorProvisioningType: AppflowClientTypes.ConnectorProvisioningType?
    let connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    let clientToken: Swift.String?
}

extension RegisterConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectorLabel
        case connectorProvisioningConfig
        case connectorProvisioningType
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectorProvisioningTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningType.self, forKey: .connectorProvisioningType)
        connectorProvisioningType = connectorProvisioningTypeDecoded
        let connectorProvisioningConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningConfig.self, forKey: .connectorProvisioningConfig)
        connectorProvisioningConfig = connectorProvisioningConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension RegisterConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterConnectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorArn = output.connectorArn
        } else {
            self.connectorArn = nil
        }
    }
}

public struct RegisterConnectorOutput: Swift.Equatable {
    /// The ARN of the connector being registered.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

struct RegisterConnectorOutputBody: Swift.Equatable {
    let connectorArn: Swift.String?
}

extension RegisterConnectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
    }
}

enum RegisterConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.RegistrationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case result
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppflowClientTypes {
    /// Describes the status of an attempt from Amazon AppFlow to register a resource. When you run a flow that you've configured to use a metadata catalog, Amazon AppFlow registers a metadata table and data partitions with that catalog. This operation provides the status of that registration attempt. The operation also indicates how many related resources Amazon AppFlow created or updated.
    public struct RegistrationOutput: Swift.Equatable {
        /// Explains the status of the registration attempt from Amazon AppFlow. If the attempt fails, the message explains why.
        public var message: Swift.String?
        /// Indicates the number of resources that Amazon AppFlow created or updated. Possible resources include metadata tables and data partitions.
        public var result: Swift.String?
        /// Indicates the status of the registration attempt from Amazon AppFlow.
        public var status: AppflowClientTypes.ExecutionStatus?

        public init(
            message: Swift.String? = nil,
            result: Swift.String? = nil,
            status: AppflowClientTypes.ExecutionStatus? = nil
        )
        {
            self.message = message
            self.result = result
            self.status = status
        }
    }

}

extension ResetConnectorMetadataCacheInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorEntityName
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiVersion = self.apiVersion {
            try encodeContainer.encode(apiVersion, forKey: .apiVersion)
        }
        if let connectorEntityName = self.connectorEntityName {
            try encodeContainer.encode(connectorEntityName, forKey: .connectorEntityName)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let entitiesPath = self.entitiesPath {
            try encodeContainer.encode(entitiesPath, forKey: .entitiesPath)
        }
    }
}

extension ResetConnectorMetadataCacheInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reset-connector-metadata-cache"
    }
}

public struct ResetConnectorMetadataCacheInput: Swift.Equatable {
    /// The API version that you specified in the connector profile that youre resetting cached metadata for. You must use this parameter only if the connector supports multiple API versions or if the connector type is CustomConnector. To look up how many versions a connector supports, use the DescribeConnectors action. In the response, find the value that Amazon AppFlow returns for the connectorVersion parameter. To look up the connector type, use the DescribeConnectorProfiles action. In the response, find the value that Amazon AppFlow returns for the connectorType parameter. To look up the API version that you specified in a connector profile, use the DescribeConnectorProfiles action.
    public var apiVersion: Swift.String?
    /// Use this parameter if you want to reset cached metadata about the details for an individual entity. If you don't include this parameter in your request, Amazon AppFlow only resets cached metadata about entity names, not entity details.
    public var connectorEntityName: Swift.String?
    /// The name of the connector profile that you want to reset cached metadata for. You can omit this parameter if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you must include this parameter in your request.
    public var connectorProfileName: Swift.String?
    /// The type of connector to reset cached metadata for. You must include this parameter in your request if you're resetting the cache for any of the following connectors: Amazon Connect, Amazon EventBridge, Amazon Lookout for Metrics, Amazon S3, or Upsolver. If you're resetting the cache for any other connector, you can omit this parameter from your request.
    public var connectorType: AppflowClientTypes.ConnectorType?
    /// Use this parameter only if youre resetting the cached metadata about a nested entity. Only some connectors support nested entities. A nested entity is one that has another entity as a parent. To use this parameter, specify the name of the parent entity. To look up the parent-child relationship of entities, you can send a ListConnectorEntities request that omits the entitiesPath parameter. Amazon AppFlow will return a list of top-level entities. For each one, it indicates whether the entity has nested entities. Then, in a subsequent ListConnectorEntities request, you can specify a parent entity name for the entitiesPath parameter. Amazon AppFlow will return a list of the child entities for that parent.
    public var entitiesPath: Swift.String?

    public init(
        apiVersion: Swift.String? = nil,
        connectorEntityName: Swift.String? = nil,
        connectorProfileName: Swift.String? = nil,
        connectorType: AppflowClientTypes.ConnectorType? = nil,
        entitiesPath: Swift.String? = nil
    )
    {
        self.apiVersion = apiVersion
        self.connectorEntityName = connectorEntityName
        self.connectorProfileName = connectorProfileName
        self.connectorType = connectorType
        self.entitiesPath = entitiesPath
    }
}

struct ResetConnectorMetadataCacheInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let connectorType: AppflowClientTypes.ConnectorType?
    let connectorEntityName: Swift.String?
    let entitiesPath: Swift.String?
    let apiVersion: Swift.String?
}

extension ResetConnectorMetadataCacheInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorEntityName
        case connectorProfileName
        case connectorType
        case entitiesPath
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let connectorEntityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorEntityName)
        connectorEntityName = connectorEntityNameDecoded
        let entitiesPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitiesPath)
        entitiesPath = entitiesPathDecoded
        let apiVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiVersion)
        apiVersion = apiVersionDecoded
    }
}

extension ResetConnectorMetadataCacheOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ResetConnectorMetadataCacheOutput: Swift.Equatable {

    public init() { }
}

enum ResetConnectorMetadataCacheOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request (such as the source or destination connector profile) is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum S3ConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ConnectorOperator(rawValue: rawValue) ?? S3ConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.S3DestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = self.s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon S3 is used as a destination.
    public struct S3DestinationProperties: Swift.Equatable {
        /// The Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
        public var s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.S3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes {
    public enum S3InputFileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [S3InputFileType] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3InputFileType(rawValue: rawValue) ?? S3InputFileType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.S3InputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3InputFileType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3InputFileType = self.s3InputFileType {
            try encodeContainer.encode(s3InputFileType.rawValue, forKey: .s3InputFileType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3InputFileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3InputFileType.self, forKey: .s3InputFileType)
        s3InputFileType = s3InputFileTypeDecoded
    }
}

extension AppflowClientTypes {
    /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
    public struct S3InputFormatConfig: Swift.Equatable {
        /// The file type that Amazon AppFlow gets from your Amazon S3 bucket.
        public var s3InputFileType: AppflowClientTypes.S3InputFileType?

        public init(
            s3InputFileType: AppflowClientTypes.S3InputFileType? = nil
        )
        {
            self.s3InputFileType = s3InputFileType
        }
    }

}

extension AppflowClientTypes.S3Metadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Amazon S3.
    public struct S3Metadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.S3OutputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
        case preserveSourceDataTyping
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = self.aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = self.prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
        if let preserveSourceDataTyping = self.preserveSourceDataTyping {
            try encodeContainer.encode(preserveSourceDataTyping, forKey: .preserveSourceDataTyping)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
        let preserveSourceDataTypingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveSourceDataTyping)
        preserveSourceDataTyping = preserveSourceDataTypingDecoded
    }
}

extension AppflowClientTypes {
    /// The configuration that determines how Amazon AppFlow should format the flow output data when Amazon S3 is used as the destination.
    public struct S3OutputFormatConfig: Swift.Equatable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Determines the prefix that Amazon AppFlow applies to the folder name in the Amazon S3 bucket. You can name folders according to the flow frequency and date.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?
        /// If your file output format is Parquet, use this parameter to set whether Amazon AppFlow preserves the data types in your source data when it writes the output to Amazon S3.
        ///
        /// * true: Amazon AppFlow preserves the data types when it writes to Amazon S3. For example, an integer or 1 in your source data is still an integer in your output.
        ///
        /// * false: Amazon AppFlow converts all of the source data into strings when it writes to Amazon S3. For example, an integer of 1 in your source data becomes the string "1" in the output.
        public var preserveSourceDataTyping: Swift.Bool?

        public init(
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil,
            preserveSourceDataTyping: Swift.Bool? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
            self.preserveSourceDataTyping = preserveSourceDataTyping
        }
    }

}

extension AppflowClientTypes.S3SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3InputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3InputFormatConfig = self.s3InputFormatConfig {
            try encodeContainer.encode(s3InputFormatConfig, forKey: .s3InputFormatConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3InputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3InputFormatConfig.self, forKey: .s3InputFormatConfig)
        s3InputFormatConfig = s3InputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Amazon S3 is being used as the flow source.
    public struct S3SourceProperties: Swift.Equatable {
        /// The Amazon S3 bucket name where the source files are stored.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the Amazon S3 bucket in which the source files are stored.
        public var bucketPrefix: Swift.String?
        /// When you use Amazon S3 as the source, the configuration format that you provide the flow input data.
        public var s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3InputFormatConfig: AppflowClientTypes.S3InputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3InputFormatConfig = s3InputFormatConfig
        }
    }

}

extension AppflowClientTypes {
    public enum SAPODataConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SAPODataConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SAPODataConnectorOperator(rawValue: rawValue) ?? SAPODataConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SAPODataConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case basicAuthCredentials
        case oAuthCredentials
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let basicAuthCredentials = self.basicAuthCredentials {
            try encodeContainer.encode(basicAuthCredentials, forKey: .basicAuthCredentials)
        }
        if let oAuthCredentials = self.oAuthCredentials {
            try encodeContainer.encode(oAuthCredentials, forKey: .oAuthCredentials)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.BasicAuthCredentials.self, forKey: .basicAuthCredentials)
        basicAuthCredentials = basicAuthCredentialsDecoded
        let oAuthCredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuthCredentials.self, forKey: .oAuthCredentials)
        oAuthCredentials = oAuthCredentialsDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using SAPOData.
    public struct SAPODataConnectorProfileCredentials: Swift.Equatable {
        /// The SAPOData basic authentication credentials.
        public var basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials?
        /// The SAPOData OAuth type authentication credentials.
        public var oAuthCredentials: AppflowClientTypes.OAuthCredentials?

        public init(
            basicAuthCredentials: AppflowClientTypes.BasicAuthCredentials? = nil,
            oAuthCredentials: AppflowClientTypes.OAuthCredentials? = nil
        )
        {
            self.basicAuthCredentials = basicAuthCredentials
            self.oAuthCredentials = oAuthCredentials
        }
    }

}

extension AppflowClientTypes.SAPODataConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationHostUrl
        case applicationServicePath
        case clientNumber
        case disableSSO
        case logonLanguage
        case oAuthProperties
        case portNumber
        case privateLinkServiceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationHostUrl = self.applicationHostUrl {
            try encodeContainer.encode(applicationHostUrl, forKey: .applicationHostUrl)
        }
        if let applicationServicePath = self.applicationServicePath {
            try encodeContainer.encode(applicationServicePath, forKey: .applicationServicePath)
        }
        if let clientNumber = self.clientNumber {
            try encodeContainer.encode(clientNumber, forKey: .clientNumber)
        }
        if disableSSO != false {
            try encodeContainer.encode(disableSSO, forKey: .disableSSO)
        }
        if let logonLanguage = self.logonLanguage {
            try encodeContainer.encode(logonLanguage, forKey: .logonLanguage)
        }
        if let oAuthProperties = self.oAuthProperties {
            try encodeContainer.encode(oAuthProperties, forKey: .oAuthProperties)
        }
        if let portNumber = self.portNumber {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
        if let privateLinkServiceName = self.privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationHostUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationHostUrl)
        applicationHostUrl = applicationHostUrlDecoded
        let applicationServicePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationServicePath)
        applicationServicePath = applicationServicePathDecoded
        let portNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .portNumber)
        portNumber = portNumberDecoded
        let clientNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientNumber)
        clientNumber = clientNumberDecoded
        let logonLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logonLanguage)
        logonLanguage = logonLanguageDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let oAuthPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuthProperties.self, forKey: .oAuthProperties)
        oAuthProperties = oAuthPropertiesDecoded
        let disableSSODecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableSSO) ?? false
        disableSSO = disableSSODecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using SAPOData.
    public struct SAPODataConnectorProfileProperties: Swift.Equatable {
        /// The location of the SAPOData resource.
        /// This member is required.
        public var applicationHostUrl: Swift.String?
        /// The application path to catalog service.
        /// This member is required.
        public var applicationServicePath: Swift.String?
        /// The client number for the client creating the connection.
        /// This member is required.
        public var clientNumber: Swift.String?
        /// If you set this parameter to true, Amazon AppFlow bypasses the single sign-on (SSO) settings in your SAP account when it accesses your SAP OData instance. Whether you need this option depends on the types of credentials that you applied to your SAP OData connection profile. If your profile uses basic authentication credentials, SAP SSO can prevent Amazon AppFlow from connecting to your account with your username and password. In this case, bypassing SSO makes it possible for Amazon AppFlow to connect successfully. However, if your profile uses OAuth credentials, this parameter has no affect.
        public var disableSSO: Swift.Bool
        /// The logon language of SAPOData instance.
        public var logonLanguage: Swift.String?
        /// The SAPOData OAuth properties required for OAuth type authentication.
        public var oAuthProperties: AppflowClientTypes.OAuthProperties?
        /// The port number of the SAPOData instance.
        /// This member is required.
        public var portNumber: Swift.Int?
        /// The SAPOData Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?

        public init(
            applicationHostUrl: Swift.String? = nil,
            applicationServicePath: Swift.String? = nil,
            clientNumber: Swift.String? = nil,
            disableSSO: Swift.Bool = false,
            logonLanguage: Swift.String? = nil,
            oAuthProperties: AppflowClientTypes.OAuthProperties? = nil,
            portNumber: Swift.Int? = nil,
            privateLinkServiceName: Swift.String? = nil
        )
        {
            self.applicationHostUrl = applicationHostUrl
            self.applicationServicePath = applicationServicePath
            self.clientNumber = clientNumber
            self.disableSSO = disableSSO
            self.logonLanguage = logonLanguage
            self.oAuthProperties = oAuthProperties
            self.portNumber = portNumber
            self.privateLinkServiceName = privateLinkServiceName
        }
    }

}

extension AppflowClientTypes.SAPODataDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case objectPath
        case successResponseHandlingConfig
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for name0 in idFieldNames {
                try idFieldNamesContainer.encode(name0)
            }
        }
        if let objectPath = self.objectPath {
            try encodeContainer.encode(objectPath, forKey: .objectPath)
        }
        if let successResponseHandlingConfig = self.successResponseHandlingConfig {
            try encodeContainer.encode(successResponseHandlingConfig, forKey: .successResponseHandlingConfig)
        }
        if let writeOperationType = self.writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectPath)
        objectPath = objectPathDecoded
        let successResponseHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SuccessResponseHandlingConfig.self, forKey: .successResponseHandlingConfig)
        successResponseHandlingConfig = successResponseHandlingConfigDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using SAPOData as a flow destination
    public struct SAPODataDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// A list of field names that can be used as an ID field when performing a write operation.
        public var idFieldNames: [Swift.String]?
        /// The object path specified in the SAPOData flow destination.
        /// This member is required.
        public var objectPath: Swift.String?
        /// Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. For example, this setting would determine where to write the response from a destination connector upon a successful insert operation.
        public var successResponseHandlingConfig: AppflowClientTypes.SuccessResponseHandlingConfig?
        /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            objectPath: Swift.String? = nil,
            successResponseHandlingConfig: AppflowClientTypes.SuccessResponseHandlingConfig? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.objectPath = objectPath
            self.successResponseHandlingConfig = successResponseHandlingConfig
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.SAPODataMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to SAPOData.
    public struct SAPODataMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.SAPODataPaginationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxPageSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxPageSize = self.maxPageSize {
            try encodeContainer.encode(maxPageSize, forKey: .maxPageSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxPageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxPageSize)
        maxPageSize = maxPageSizeDecoded
    }
}

extension AppflowClientTypes {
    /// Sets the page size for each concurrent process that transfers OData records from your SAP instance. A concurrent process is query that retrieves a batch of records as part of a flow run. Amazon AppFlow can run multiple concurrent processes in parallel to transfer data faster.
    public struct SAPODataPaginationConfig: Swift.Equatable {
        /// The maximum number of records that Amazon AppFlow receives in each page of the response from your SAP application. For transfers of OData records, the maximum page size is 3,000. For transfers of data that comes from an ODP provider, the maximum page size is 10,000.
        /// This member is required.
        public var maxPageSize: Swift.Int?

        public init(
            maxPageSize: Swift.Int? = nil
        )
        {
            self.maxPageSize = maxPageSize
        }
    }

}

extension AppflowClientTypes.SAPODataParallelismConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxParallelism
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxParallelism = self.maxParallelism {
            try encodeContainer.encode(maxParallelism, forKey: .maxParallelism)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxParallelismDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxParallelism)
        maxParallelism = maxParallelismDecoded
    }
}

extension AppflowClientTypes {
    /// Sets the number of concurrent processes that transfer OData records from your SAP instance. A concurrent process is query that retrieves a batch of records as part of a flow run. Amazon AppFlow can run multiple concurrent processes in parallel to transfer data faster.
    public struct SAPODataParallelismConfig: Swift.Equatable {
        /// The maximum number of processes that Amazon AppFlow runs at the same time when it retrieves your data from your SAP application.
        /// This member is required.
        public var maxParallelism: Swift.Int?

        public init(
            maxParallelism: Swift.Int? = nil
        )
        {
            self.maxParallelism = maxParallelism
        }
    }

}

extension AppflowClientTypes.SAPODataSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case objectPath
        case paginationConfig
        case parallelismConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let objectPath = self.objectPath {
            try encodeContainer.encode(objectPath, forKey: .objectPath)
        }
        if let paginationConfig = self.paginationConfig {
            try encodeContainer.encode(paginationConfig, forKey: .paginationConfig)
        }
        if let parallelismConfig = self.parallelismConfig {
            try encodeContainer.encode(parallelismConfig, forKey: .parallelismConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectPath)
        objectPath = objectPathDecoded
        let parallelismConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataParallelismConfig.self, forKey: .parallelismConfig)
        parallelismConfig = parallelismConfigDecoded
        let paginationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataPaginationConfig.self, forKey: .paginationConfig)
        paginationConfig = paginationConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using SAPOData as a flow source.
    public struct SAPODataSourceProperties: Swift.Equatable {
        /// The object path specified in the SAPOData flow source.
        public var objectPath: Swift.String?
        /// Sets the page size for each concurrent process that transfers OData records from your SAP instance.
        public var paginationConfig: AppflowClientTypes.SAPODataPaginationConfig?
        /// Sets the number of concurrent processes that transfers OData records from your SAP instance.
        public var parallelismConfig: AppflowClientTypes.SAPODataParallelismConfig?

        public init(
            objectPath: Swift.String? = nil,
            paginationConfig: AppflowClientTypes.SAPODataPaginationConfig? = nil,
            parallelismConfig: AppflowClientTypes.SAPODataParallelismConfig? = nil
        )
        {
            self.objectPath = objectPath
            self.paginationConfig = paginationConfig
            self.parallelismConfig = parallelismConfig
        }
    }

}

extension AppflowClientTypes {
    public enum SalesforceConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceConnectorOperator(rawValue: rawValue) ?? SalesforceConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientCredentialsArn
        case jwtToken
        case oAuth2GrantType
        case oAuthRequest
        case refreshToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientCredentialsArn = self.clientCredentialsArn {
            try encodeContainer.encode(clientCredentialsArn, forKey: .clientCredentialsArn)
        }
        if let jwtToken = self.jwtToken {
            try encodeContainer.encode(jwtToken, forKey: .jwtToken)
        }
        if let oAuth2GrantType = self.oAuth2GrantType {
            try encodeContainer.encode(oAuth2GrantType.rawValue, forKey: .oAuth2GrantType)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
        if let refreshToken = self.refreshToken {
            try encodeContainer.encode(refreshToken, forKey: .refreshToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
        let clientCredentialsArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientCredentialsArn)
        clientCredentialsArn = clientCredentialsArnDecoded
        let oAuth2GrantTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2GrantType.self, forKey: .oAuth2GrantType)
        oAuth2GrantType = oAuth2GrantTypeDecoded
        let jwtTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jwtToken)
        jwtToken = jwtTokenDecoded
    }
}

extension AppflowClientTypes.SalesforceConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SalesforceConnectorProfileCredentials(oAuth2GrantType: \(Swift.String(describing: oAuth2GrantType)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), refreshToken: \(Swift.String(describing: refreshToken)), accessToken: \"CONTENT_REDACTED\", clientCredentialsArn: \"CONTENT_REDACTED\", jwtToken: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Salesforce.
    public struct SalesforceConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Salesforce resources.
        public var accessToken: Swift.String?
        /// The secret manager ARN, which contains the client ID and client secret of the connected app.
        public var clientCredentialsArn: Swift.String?
        /// A JSON web token (JWT) that authorizes Amazon AppFlow to access your Salesforce records.
        public var jwtToken: Swift.String?
        /// Specifies the OAuth 2.0 grant type that Amazon AppFlow uses when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records. You can specify one of the following values: AUTHORIZATION_CODE Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records. CLIENT_CREDENTIALS Amazon AppFlow passes client credentials (a client ID and client secret) when it requests the access token from Salesforce. You provide these credentials to Amazon AppFlow when you define the connection to your Salesforce account. JWT_BEARER Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records.
        public var oAuth2GrantType: AppflowClientTypes.OAuth2GrantType?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?
        /// The credentials used to acquire new access tokens.
        public var refreshToken: Swift.String?

        public init(
            accessToken: Swift.String? = nil,
            clientCredentialsArn: Swift.String? = nil,
            jwtToken: Swift.String? = nil,
            oAuth2GrantType: AppflowClientTypes.OAuth2GrantType? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil,
            refreshToken: Swift.String? = nil
        )
        {
            self.accessToken = accessToken
            self.clientCredentialsArn = clientCredentialsArn
            self.jwtToken = jwtToken
            self.oAuth2GrantType = oAuth2GrantType
            self.oAuthRequest = oAuthRequest
            self.refreshToken = refreshToken
        }
    }

}

extension AppflowClientTypes.SalesforceConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
        case isSandboxEnvironment
        case usePrivateLinkForMetadataAndAuthorization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
        if isSandboxEnvironment != false {
            try encodeContainer.encode(isSandboxEnvironment, forKey: .isSandboxEnvironment)
        }
        if usePrivateLinkForMetadataAndAuthorization != false {
            try encodeContainer.encode(usePrivateLinkForMetadataAndAuthorization, forKey: .usePrivateLinkForMetadataAndAuthorization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
        let isSandboxEnvironmentDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isSandboxEnvironment) ?? false
        isSandboxEnvironment = isSandboxEnvironmentDecoded
        let usePrivateLinkForMetadataAndAuthorizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePrivateLinkForMetadataAndAuthorization) ?? false
        usePrivateLinkForMetadataAndAuthorization = usePrivateLinkForMetadataAndAuthorizationDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Salesforce.
    public struct SalesforceConnectorProfileProperties: Swift.Equatable {
        /// The location of the Salesforce resource.
        public var instanceUrl: Swift.String?
        /// Indicates whether the connector profile applies to a sandbox or production environment.
        public var isSandboxEnvironment: Swift.Bool
        /// If the connection mode for the connector profile is private, this parameter sets whether Amazon AppFlow uses the private network to send metadata and authorization calls to Salesforce. Amazon AppFlow sends private calls through Amazon Web Services PrivateLink. These calls travel through Amazon Web Services infrastructure without being exposed to the public internet. Set either of the following values: true Amazon AppFlow sends all calls to Salesforce over the private network. These private calls are:
        ///
        /// * Calls to get metadata about your Salesforce records. This metadata describes your Salesforce objects and their fields.
        ///
        /// * Calls to get or refresh access tokens that allow Amazon AppFlow to access your Salesforce records.
        ///
        /// * Calls to transfer your Salesforce records as part of a flow run.
        ///
        ///
        /// false The default value. Amazon AppFlow sends some calls to Salesforce privately and other calls over the public internet. The public calls are:
        ///
        /// * Calls to get metadata about your Salesforce records.
        ///
        /// * Calls to get or refresh access tokens.
        ///
        ///
        /// The private calls are:
        ///
        /// * Calls to transfer your Salesforce records as part of a flow run.
        public var usePrivateLinkForMetadataAndAuthorization: Swift.Bool

        public init(
            instanceUrl: Swift.String? = nil,
            isSandboxEnvironment: Swift.Bool = false,
            usePrivateLinkForMetadataAndAuthorization: Swift.Bool = false
        )
        {
            self.instanceUrl = instanceUrl
            self.isSandboxEnvironment = isSandboxEnvironment
            self.usePrivateLinkForMetadataAndAuthorization = usePrivateLinkForMetadataAndAuthorization
        }
    }

}

extension AppflowClientTypes {
    public enum SalesforceDataTransferApi: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case bulkv2
        case restSync
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesforceDataTransferApi] {
            return [
                .automatic,
                .bulkv2,
                .restSync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .bulkv2: return "BULKV2"
            case .restSync: return "REST_SYNC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SalesforceDataTransferApi(rawValue: rawValue) ?? SalesforceDataTransferApi.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SalesforceDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferApi
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferApi = self.dataTransferApi {
            try encodeContainer.encode(dataTransferApi.rawValue, forKey: .dataTransferApi)
        }
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for name0 in idFieldNames {
                try idFieldNamesContainer.encode(name0)
            }
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = self.writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
        let dataTransferApiDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceDataTransferApi.self, forKey: .dataTransferApi)
        dataTransferApi = dataTransferApiDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Salesforce is being used as a destination.
    public struct SalesforceDestinationProperties: Swift.Equatable {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data to Salesforce. AUTOMATIC The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers to Salesforce. If your flow transfers fewer than 1,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900 records, and it might use Bulk API 2.0 on the next day to transfer 1,100 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output. BULKV2 Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields. REST_SYNC Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail with a timed out error.
        public var dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Salesforce destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The name of the field that Amazon AppFlow uses as an ID when performing a write operation such as update or delete.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Salesforce flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// This specifies the type of write operation to be performed in Salesforce. When the value is UPSERT, then idFieldNames is required.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.dataTransferApi = dataTransferApi
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.SalesforceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferApis
        case oAuthScopes
        case oauth2GrantTypesSupported
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferApis = dataTransferApis {
            var dataTransferApisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataTransferApis)
            for salesforcedatatransferapi0 in dataTransferApis {
                try dataTransferApisContainer.encode(salesforcedatatransferapi0.rawValue)
            }
        }
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
        if let oauth2GrantTypesSupported = oauth2GrantTypesSupported {
            var oauth2GrantTypesSupportedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oauth2GrantTypesSupported)
            for oauth2granttype0 in oauth2GrantTypesSupported {
                try oauth2GrantTypesSupportedContainer.encode(oauth2granttype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
        let dataTransferApisContainer = try containerValues.decodeIfPresent([AppflowClientTypes.SalesforceDataTransferApi?].self, forKey: .dataTransferApis)
        var dataTransferApisDecoded0:[AppflowClientTypes.SalesforceDataTransferApi]? = nil
        if let dataTransferApisContainer = dataTransferApisContainer {
            dataTransferApisDecoded0 = [AppflowClientTypes.SalesforceDataTransferApi]()
            for enum0 in dataTransferApisContainer {
                if let enum0 = enum0 {
                    dataTransferApisDecoded0?.append(enum0)
                }
            }
        }
        dataTransferApis = dataTransferApisDecoded0
        let oauth2GrantTypesSupportedContainer = try containerValues.decodeIfPresent([AppflowClientTypes.OAuth2GrantType?].self, forKey: .oauth2GrantTypesSupported)
        var oauth2GrantTypesSupportedDecoded0:[AppflowClientTypes.OAuth2GrantType]? = nil
        if let oauth2GrantTypesSupportedContainer = oauth2GrantTypesSupportedContainer {
            oauth2GrantTypesSupportedDecoded0 = [AppflowClientTypes.OAuth2GrantType]()
            for enum0 in oauth2GrantTypesSupportedContainer {
                if let enum0 = enum0 {
                    oauth2GrantTypesSupportedDecoded0?.append(enum0)
                }
            }
        }
        oauth2GrantTypesSupported = oauth2GrantTypesSupportedDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Salesforce.
    public struct SalesforceMetadata: Swift.Equatable {
        /// The Salesforce APIs that you can have Amazon AppFlow use when your flows transfers data to or from Salesforce.
        public var dataTransferApis: [AppflowClientTypes.SalesforceDataTransferApi]?
        /// The desired authorization scope for the Salesforce account.
        public var oAuthScopes: [Swift.String]?
        /// The OAuth 2.0 grant types that Amazon AppFlow can use when it requests an access token from Salesforce. Amazon AppFlow requires an access token each time it attempts to access your Salesforce records. AUTHORIZATION_CODE Amazon AppFlow passes an authorization code when it requests the access token from Salesforce. Amazon AppFlow receives the authorization code from Salesforce after you log in to your Salesforce account and authorize Amazon AppFlow to access your records. CLIENT_CREDENTIALS Amazon AppFlow passes client credentials (a client ID and client secret) when it requests the access token from Salesforce. You provide these credentials to Amazon AppFlow when you define the connection to your Salesforce account. JWT_BEARER Amazon AppFlow passes a JSON web token (JWT) when it requests the access token from Salesforce. You provide the JWT to Amazon AppFlow when you define the connection to your Salesforce account. When you use this grant type, you don't need to log in to your Salesforce account to authorize Amazon AppFlow to access your records.
        public var oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]?

        public init(
            dataTransferApis: [AppflowClientTypes.SalesforceDataTransferApi]? = nil,
            oAuthScopes: [Swift.String]? = nil,
            oauth2GrantTypesSupported: [AppflowClientTypes.OAuth2GrantType]? = nil
        )
        {
            self.dataTransferApis = dataTransferApis
            self.oAuthScopes = oAuthScopes
            self.oauth2GrantTypesSupported = oauth2GrantTypesSupported
        }
    }

}

extension AppflowClientTypes.SalesforceSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferApi
        case enableDynamicFieldUpdate
        case includeDeletedRecords
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferApi = self.dataTransferApi {
            try encodeContainer.encode(dataTransferApi.rawValue, forKey: .dataTransferApi)
        }
        if enableDynamicFieldUpdate != false {
            try encodeContainer.encode(enableDynamicFieldUpdate, forKey: .enableDynamicFieldUpdate)
        }
        if includeDeletedRecords != false {
            try encodeContainer.encode(includeDeletedRecords, forKey: .includeDeletedRecords)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let enableDynamicFieldUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDynamicFieldUpdate) ?? false
        enableDynamicFieldUpdate = enableDynamicFieldUpdateDecoded
        let includeDeletedRecordsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeletedRecords) ?? false
        includeDeletedRecords = includeDeletedRecordsDecoded
        let dataTransferApiDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceDataTransferApi.self, forKey: .dataTransferApi)
        dataTransferApi = dataTransferApiDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Salesforce is being used as a source.
    public struct SalesforceSourceProperties: Swift.Equatable {
        /// Specifies which Salesforce API is used by Amazon AppFlow when your flow transfers data from Salesforce. AUTOMATIC The default. Amazon AppFlow selects which API to use based on the number of records that your flow transfers from Salesforce. If your flow transfers fewer than 1,000,000 records, Amazon AppFlow uses Salesforce REST API. If your flow transfers 1,000,000 records or more, Amazon AppFlow uses Salesforce Bulk API 2.0. Each of these Salesforce APIs structures data differently. If Amazon AppFlow selects the API automatically, be aware that, for recurring flows, the data output might vary from one flow run to the next. For example, if a flow runs daily, it might use REST API on one day to transfer 900,000 records, and it might use Bulk API 2.0 on the next day to transfer 1,100,000 records. For each of these flow runs, the respective Salesforce API formats the data differently. Some of the differences include how dates are formatted and null values are represented. Also, Bulk API 2.0 doesn't transfer Salesforce compound fields. By choosing this option, you optimize flow performance for both small and large data transfers, but the tradeoff is inconsistent formatting in the output. BULKV2 Amazon AppFlow uses only Salesforce Bulk API 2.0. This API runs asynchronous data transfers, and it's optimal for large sets of data. By choosing this option, you ensure that your flow writes consistent output, but you optimize performance only for large data transfers. Note that Bulk API 2.0 does not transfer Salesforce compound fields. REST_SYNC Amazon AppFlow uses only Salesforce REST API. By choosing this option, you ensure that your flow writes consistent output, but you decrease performance for large data transfers that are better suited for Bulk API 2.0. In some cases, if your flow attempts to transfer a vary large set of data, it might fail wituh a timed out error.
        public var dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi?
        /// The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        public var enableDynamicFieldUpdate: Swift.Bool
        /// Indicates whether Amazon AppFlow includes deleted files in the flow run.
        public var includeDeletedRecords: Swift.Bool
        /// The object specified in the Salesforce flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            dataTransferApi: AppflowClientTypes.SalesforceDataTransferApi? = nil,
            enableDynamicFieldUpdate: Swift.Bool = false,
            includeDeletedRecords: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.dataTransferApi = dataTransferApi
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum ScheduleFrequencyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case byminute
        case daily
        case hourly
        case monthly
        case once
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [ScheduleFrequencyType] {
            return [
                .byminute,
                .daily,
                .hourly,
                .monthly,
                .once,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .byminute: return "BYMINUTE"
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case .once: return "ONCE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScheduleFrequencyType(rawValue: rawValue) ?? ScheduleFrequencyType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ScheduledTriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataPullMode
        case firstExecutionFrom
        case flowErrorDeactivationThreshold
        case scheduleEndTime
        case scheduleExpression
        case scheduleOffset
        case scheduleStartTime
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataPullMode = self.dataPullMode {
            try encodeContainer.encode(dataPullMode.rawValue, forKey: .dataPullMode)
        }
        if let firstExecutionFrom = self.firstExecutionFrom {
            try encodeContainer.encodeTimestamp(firstExecutionFrom, format: .epochSeconds, forKey: .firstExecutionFrom)
        }
        if let flowErrorDeactivationThreshold = self.flowErrorDeactivationThreshold {
            try encodeContainer.encode(flowErrorDeactivationThreshold, forKey: .flowErrorDeactivationThreshold)
        }
        if let scheduleEndTime = self.scheduleEndTime {
            try encodeContainer.encodeTimestamp(scheduleEndTime, format: .epochSeconds, forKey: .scheduleEndTime)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let scheduleOffset = self.scheduleOffset {
            try encodeContainer.encode(scheduleOffset, forKey: .scheduleOffset)
        }
        if let scheduleStartTime = self.scheduleStartTime {
            try encodeContainer.encodeTimestamp(scheduleStartTime, format: .epochSeconds, forKey: .scheduleStartTime)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let dataPullModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DataPullMode.self, forKey: .dataPullMode)
        dataPullMode = dataPullModeDecoded
        let scheduleStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduleStartTime)
        scheduleStartTime = scheduleStartTimeDecoded
        let scheduleEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduleEndTime)
        scheduleEndTime = scheduleEndTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let scheduleOffsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .scheduleOffset)
        scheduleOffset = scheduleOffsetDecoded
        let firstExecutionFromDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstExecutionFrom)
        firstExecutionFrom = firstExecutionFromDecoded
        let flowErrorDeactivationThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .flowErrorDeactivationThreshold)
        flowErrorDeactivationThreshold = flowErrorDeactivationThresholdDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
    public struct ScheduledTriggerProperties: Swift.Equatable {
        /// Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        public var dataPullMode: AppflowClientTypes.DataPullMode?
        /// Specifies the date range for the records to import from the connector in the first flow run.
        public var firstExecutionFrom: ClientRuntime.Date?
        /// Defines how many times a scheduled flow fails consecutively before Amazon AppFlow deactivates it.
        public var flowErrorDeactivationThreshold: Swift.Int?
        /// The time at which the scheduled flow ends. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-27T13:00:00-07:00.
        public var scheduleEndTime: ClientRuntime.Date?
        /// The scheduling expression that determines the rate at which the schedule will run, for example rate(5minutes).
        /// This member is required.
        public var scheduleExpression: Swift.String?
        /// Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        public var scheduleOffset: Swift.Int?
        /// The time at which the scheduled flow starts. The time is formatted as a timestamp that follows the ISO 8601 standard, such as 2022-04-26T13:00:00-07:00.
        public var scheduleStartTime: ClientRuntime.Date?
        /// Specifies the time zone used when referring to the dates and times of a scheduled flow, such as America/New_York. This time zone is only a descriptive label. It doesn't affect how Amazon AppFlow interprets the timestamps that you specify to schedule the flow. If you want to schedule a flow by using times in a particular time zone, indicate the time zone as a UTC offset in your timestamps. For example, the UTC offsets for the America/New_York timezone are -04:00 EDT and -05:00 EST.
        public var timezone: Swift.String?

        public init(
            dataPullMode: AppflowClientTypes.DataPullMode? = nil,
            firstExecutionFrom: ClientRuntime.Date? = nil,
            flowErrorDeactivationThreshold: Swift.Int? = nil,
            scheduleEndTime: ClientRuntime.Date? = nil,
            scheduleExpression: Swift.String? = nil,
            scheduleOffset: Swift.Int? = nil,
            scheduleStartTime: ClientRuntime.Date? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.flowErrorDeactivationThreshold = flowErrorDeactivationThreshold
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }
    }

}

extension AppflowClientTypes {
    public enum ServiceNowConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceNowConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceNowConnectorOperator(rawValue: rawValue) ?? ServiceNowConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuth2Credentials
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuth2Credentials = self.oAuth2Credentials {
            try encodeContainer.encode(oAuth2Credentials, forKey: .oAuth2Credentials)
        }
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
        let oAuth2CredentialsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.OAuth2Credentials.self, forKey: .oAuth2Credentials)
        oAuth2Credentials = oAuth2CredentialsDecoded
    }
}

extension AppflowClientTypes.ServiceNowConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceNowConnectorProfileCredentials(oAuth2Credentials: \(Swift.String(describing: oAuth2Credentials)), username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using ServiceNow.
    public struct ServiceNowConnectorProfileCredentials: Swift.Equatable {
        /// The OAuth 2.0 credentials required to authenticate the user.
        public var oAuth2Credentials: AppflowClientTypes.OAuth2Credentials?
        /// The password that corresponds to the user name.
        public var password: Swift.String?
        /// The name of the user.
        public var username: Swift.String?

        public init(
            oAuth2Credentials: AppflowClientTypes.OAuth2Credentials? = nil,
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.oAuth2Credentials = oAuth2Credentials
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.ServiceNowConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using ServiceNow.
    public struct ServiceNowConnectorProfileProperties: Swift.Equatable {
        /// The location of the ServiceNow resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ServiceNowMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to ServiceNow.
    public struct ServiceNowMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.ServiceNowSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when ServiceNow is being used as a source.
    public struct ServiceNowSourceProperties: Swift.Equatable {
        /// The object specified in the ServiceNow flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request would cause a service quota (such as the number of flows) to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum SingularConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SingularConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SingularConnectorOperator(rawValue: rawValue) ?? SingularConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = self.apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
    }
}

extension AppflowClientTypes.SingularConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SingularConnectorProfileCredentials(apiKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Singular.
    public struct SingularConnectorProfileCredentials: Swift.Equatable {
        /// A unique alphanumeric identifier used to authenticate a user, developer, or calling program to your API.
        /// This member is required.
        public var apiKey: Swift.String?

        public init(
            apiKey: Swift.String? = nil
        )
        {
            self.apiKey = apiKey
        }
    }

}

extension AppflowClientTypes.SingularConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Singular.
    public struct SingularConnectorProfileProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.SingularMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Singular.
    public struct SingularMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.SingularSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Singular is being used as a source.
    public struct SingularSourceProperties: Swift.Equatable {
        /// The object specified in the Singular flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    public enum SlackConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [SlackConnectorOperator] {
            return [
                .addition,
                .between,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SlackConnectorOperator(rawValue: rawValue) ?? SlackConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.SlackConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SlackConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Slack.
    public struct SlackConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Slack resources.
        public var accessToken: Swift.String?
        /// The identifier for the client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.SlackConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Slack.
    public struct SlackConnectorProfileProperties: Swift.Equatable {
        /// The location of the Slack resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.SlackMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Slack.
    public struct SlackMetadata: Swift.Equatable {
        /// The desired authorization scope for the Slack account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.SlackSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Slack is being used as a source.
    public struct SlackSourceProperties: Swift.Equatable {
        /// The object specified in the Slack flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.SnowflakeConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SnowflakeConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Snowflake.
    public struct SnowflakeConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.SnowflakeConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName
        case bucketName
        case bucketPrefix
        case privateLinkServiceName
        case region
        case stage
        case warehouse
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = self.accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let privateLinkServiceName = self.privateLinkServiceName {
            try encodeContainer.encode(privateLinkServiceName, forKey: .privateLinkServiceName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let warehouse = self.warehouse {
            try encodeContainer.encode(warehouse, forKey: .warehouse)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let warehouseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warehouse)
        warehouse = warehouseDecoded
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let privateLinkServiceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateLinkServiceName)
        privateLinkServiceName = privateLinkServiceNameDecoded
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Snowflake.
    public struct SnowflakeConnectorProfileProperties: Swift.Equatable {
        /// The name of the account.
        public var accountName: Swift.String?
        /// The name of the Amazon S3 bucket associated with Snowflake.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The bucket path that refers to the Amazon S3 bucket associated with Snowflake.
        public var bucketPrefix: Swift.String?
        /// The Snowflake Private Link service name to be used for private data transfers.
        public var privateLinkServiceName: Swift.String?
        /// The Amazon Web Services Region of the Snowflake account.
        public var region: Swift.String?
        /// The name of the Amazon S3 stage that was created while setting up an Amazon S3 stage in the Snowflake account. This is written in the following format: < Database>< Schema>.
        /// This member is required.
        public var stage: Swift.String?
        /// The name of the Snowflake warehouse.
        /// This member is required.
        public var warehouse: Swift.String?

        public init(
            accountName: Swift.String? = nil,
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            privateLinkServiceName: Swift.String? = nil,
            region: Swift.String? = nil,
            stage: Swift.String? = nil,
            warehouse: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.privateLinkServiceName = privateLinkServiceName
            self.region = region
            self.stage = stage
            self.warehouse = warehouse
        }
    }

}

extension AppflowClientTypes.SnowflakeDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketPrefix
        case errorHandlingConfig
        case intermediateBucketName
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let intermediateBucketName = self.intermediateBucketName {
            try encodeContainer.encode(intermediateBucketName, forKey: .intermediateBucketName)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let intermediateBucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intermediateBucketName)
        intermediateBucketName = intermediateBucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Snowflake is being used as a destination.
    public struct SnowflakeDestinationProperties: Swift.Equatable {
        /// The object key for the destination bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the Snowflake destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// The intermediate bucket that Amazon AppFlow uses when moving data into Snowflake.
        /// This member is required.
        public var intermediateBucketName: Swift.String?
        /// The object specified in the Snowflake flow destination.
        /// This member is required.
        public var object: Swift.String?

        public init(
            bucketPrefix: Swift.String? = nil,
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            intermediateBucketName: Swift.String? = nil,
            object: Swift.String? = nil
        )
        {
            self.bucketPrefix = bucketPrefix
            self.errorHandlingConfig = errorHandlingConfig
            self.intermediateBucketName = intermediateBucketName
            self.object = object
        }
    }

}

extension AppflowClientTypes.SnowflakeMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case supportedRegions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let supportedRegions = supportedRegions {
            var supportedRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedRegions)
            for region0 in supportedRegions {
                try supportedRegionsContainer.encode(region0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportedRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedRegions)
        var supportedRegionsDecoded0:[Swift.String]? = nil
        if let supportedRegionsContainer = supportedRegionsContainer {
            supportedRegionsDecoded0 = [Swift.String]()
            for string0 in supportedRegionsContainer {
                if let string0 = string0 {
                    supportedRegionsDecoded0?.append(string0)
                }
            }
        }
        supportedRegions = supportedRegionsDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Snowflake.
    public struct SnowflakeMetadata: Swift.Equatable {
        /// Specifies the supported Amazon Web Services Regions when using Snowflake.
        public var supportedRegions: [Swift.String]?

        public init(
            supportedRegions: [Swift.String]? = nil
        )
        {
            self.supportedRegions = supportedRegions
        }
    }

}

extension AppflowClientTypes.SourceConnectorProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amplitude = "Amplitude"
        case customConnector = "CustomConnector"
        case datadog = "Datadog"
        case dynatrace = "Dynatrace"
        case googleAnalytics = "GoogleAnalytics"
        case inforNexus = "InforNexus"
        case marketo = "Marketo"
        case pardot = "Pardot"
        case s3 = "S3"
        case sapoData = "SAPOData"
        case salesforce = "Salesforce"
        case serviceNow = "ServiceNow"
        case singular = "Singular"
        case slack = "Slack"
        case trendmicro = "Trendmicro"
        case veeva = "Veeva"
        case zendesk = "Zendesk"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amplitude = self.amplitude {
            try encodeContainer.encode(amplitude, forKey: .amplitude)
        }
        if let customConnector = self.customConnector {
            try encodeContainer.encode(customConnector, forKey: .customConnector)
        }
        if let datadog = self.datadog {
            try encodeContainer.encode(datadog, forKey: .datadog)
        }
        if let dynatrace = self.dynatrace {
            try encodeContainer.encode(dynatrace, forKey: .dynatrace)
        }
        if let googleAnalytics = self.googleAnalytics {
            try encodeContainer.encode(googleAnalytics, forKey: .googleAnalytics)
        }
        if let inforNexus = self.inforNexus {
            try encodeContainer.encode(inforNexus, forKey: .inforNexus)
        }
        if let marketo = self.marketo {
            try encodeContainer.encode(marketo, forKey: .marketo)
        }
        if let pardot = self.pardot {
            try encodeContainer.encode(pardot, forKey: .pardot)
        }
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
        if let sapoData = self.sapoData {
            try encodeContainer.encode(sapoData, forKey: .sapoData)
        }
        if let salesforce = self.salesforce {
            try encodeContainer.encode(salesforce, forKey: .salesforce)
        }
        if let serviceNow = self.serviceNow {
            try encodeContainer.encode(serviceNow, forKey: .serviceNow)
        }
        if let singular = self.singular {
            try encodeContainer.encode(singular, forKey: .singular)
        }
        if let slack = self.slack {
            try encodeContainer.encode(slack, forKey: .slack)
        }
        if let trendmicro = self.trendmicro {
            try encodeContainer.encode(trendmicro, forKey: .trendmicro)
        }
        if let veeva = self.veeva {
            try encodeContainer.encode(veeva, forKey: .veeva)
        }
        if let zendesk = self.zendesk {
            try encodeContainer.encode(zendesk, forKey: .zendesk)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amplitudeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AmplitudeSourceProperties.self, forKey: .amplitude)
        amplitude = amplitudeDecoded
        let datadogDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DatadogSourceProperties.self, forKey: .datadog)
        datadog = datadogDecoded
        let dynatraceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.DynatraceSourceProperties.self, forKey: .dynatrace)
        dynatrace = dynatraceDecoded
        let googleAnalyticsDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.GoogleAnalyticsSourceProperties.self, forKey: .googleAnalytics)
        googleAnalytics = googleAnalyticsDecoded
        let inforNexusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.InforNexusSourceProperties.self, forKey: .inforNexus)
        inforNexus = inforNexusDecoded
        let marketoDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MarketoSourceProperties.self, forKey: .marketo)
        marketo = marketoDecoded
        let s3Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.S3SourceProperties.self, forKey: .s3)
        s3 = s3Decoded
        let salesforceDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SalesforceSourceProperties.self, forKey: .salesforce)
        salesforce = salesforceDecoded
        let serviceNowDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ServiceNowSourceProperties.self, forKey: .serviceNow)
        serviceNow = serviceNowDecoded
        let singularDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SingularSourceProperties.self, forKey: .singular)
        singular = singularDecoded
        let slackDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SlackSourceProperties.self, forKey: .slack)
        slack = slackDecoded
        let trendmicroDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TrendmicroSourceProperties.self, forKey: .trendmicro)
        trendmicro = trendmicroDecoded
        let veevaDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.VeevaSourceProperties.self, forKey: .veeva)
        veeva = veevaDecoded
        let zendeskDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ZendeskSourceProperties.self, forKey: .zendesk)
        zendesk = zendeskDecoded
        let sapoDataDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SAPODataSourceProperties.self, forKey: .sapoData)
        sapoData = sapoDataDecoded
        let customConnectorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.CustomConnectorSourceProperties.self, forKey: .customConnector)
        customConnector = customConnectorDecoded
        let pardotDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PardotSourceProperties.self, forKey: .pardot)
        pardot = pardotDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the information that is required to query a particular connector.
    public struct SourceConnectorProperties: Swift.Equatable {
        /// Specifies the information that is required for querying Amplitude.
        public var amplitude: AppflowClientTypes.AmplitudeSourceProperties?
        /// The properties that are applied when the custom connector is being used as a source.
        public var customConnector: AppflowClientTypes.CustomConnectorSourceProperties?
        /// Specifies the information that is required for querying Datadog.
        public var datadog: AppflowClientTypes.DatadogSourceProperties?
        /// Specifies the information that is required for querying Dynatrace.
        public var dynatrace: AppflowClientTypes.DynatraceSourceProperties?
        /// Specifies the information that is required for querying Google Analytics.
        public var googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties?
        /// Specifies the information that is required for querying Infor Nexus.
        public var inforNexus: AppflowClientTypes.InforNexusSourceProperties?
        /// Specifies the information that is required for querying Marketo.
        public var marketo: AppflowClientTypes.MarketoSourceProperties?
        /// Specifies the information that is required for querying Salesforce Pardot.
        public var pardot: AppflowClientTypes.PardotSourceProperties?
        /// Specifies the information that is required for querying Amazon S3.
        public var s3: AppflowClientTypes.S3SourceProperties?
        /// Specifies the information that is required for querying Salesforce.
        public var salesforce: AppflowClientTypes.SalesforceSourceProperties?
        /// The properties that are applied when using SAPOData as a flow source.
        public var sapoData: AppflowClientTypes.SAPODataSourceProperties?
        /// Specifies the information that is required for querying ServiceNow.
        public var serviceNow: AppflowClientTypes.ServiceNowSourceProperties?
        /// Specifies the information that is required for querying Singular.
        public var singular: AppflowClientTypes.SingularSourceProperties?
        /// Specifies the information that is required for querying Slack.
        public var slack: AppflowClientTypes.SlackSourceProperties?
        /// Specifies the information that is required for querying Trend Micro.
        public var trendmicro: AppflowClientTypes.TrendmicroSourceProperties?
        /// Specifies the information that is required for querying Veeva.
        public var veeva: AppflowClientTypes.VeevaSourceProperties?
        /// Specifies the information that is required for querying Zendesk.
        public var zendesk: AppflowClientTypes.ZendeskSourceProperties?

        public init(
            amplitude: AppflowClientTypes.AmplitudeSourceProperties? = nil,
            customConnector: AppflowClientTypes.CustomConnectorSourceProperties? = nil,
            datadog: AppflowClientTypes.DatadogSourceProperties? = nil,
            dynatrace: AppflowClientTypes.DynatraceSourceProperties? = nil,
            googleAnalytics: AppflowClientTypes.GoogleAnalyticsSourceProperties? = nil,
            inforNexus: AppflowClientTypes.InforNexusSourceProperties? = nil,
            marketo: AppflowClientTypes.MarketoSourceProperties? = nil,
            pardot: AppflowClientTypes.PardotSourceProperties? = nil,
            s3: AppflowClientTypes.S3SourceProperties? = nil,
            salesforce: AppflowClientTypes.SalesforceSourceProperties? = nil,
            sapoData: AppflowClientTypes.SAPODataSourceProperties? = nil,
            serviceNow: AppflowClientTypes.ServiceNowSourceProperties? = nil,
            singular: AppflowClientTypes.SingularSourceProperties? = nil,
            slack: AppflowClientTypes.SlackSourceProperties? = nil,
            trendmicro: AppflowClientTypes.TrendmicroSourceProperties? = nil,
            veeva: AppflowClientTypes.VeevaSourceProperties? = nil,
            zendesk: AppflowClientTypes.ZendeskSourceProperties? = nil
        )
        {
            self.amplitude = amplitude
            self.customConnector = customConnector
            self.datadog = datadog
            self.dynatrace = dynatrace
            self.googleAnalytics = googleAnalytics
            self.inforNexus = inforNexus
            self.marketo = marketo
            self.pardot = pardot
            self.s3 = s3
            self.salesforce = salesforce
            self.sapoData = sapoData
            self.serviceNow = serviceNow
            self.singular = singular
            self.slack = slack
            self.trendmicro = trendmicro
            self.veeva = veeva
            self.zendesk = zendesk
        }
    }

}

extension AppflowClientTypes.SourceFieldProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isQueryable
        case isRetrievable
        case isTimestampFieldForIncrementalQueries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isQueryable != false {
            try encodeContainer.encode(isQueryable, forKey: .isQueryable)
        }
        if isRetrievable != false {
            try encodeContainer.encode(isRetrievable, forKey: .isRetrievable)
        }
        if isTimestampFieldForIncrementalQueries != false {
            try encodeContainer.encode(isTimestampFieldForIncrementalQueries, forKey: .isTimestampFieldForIncrementalQueries)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isRetrievableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isRetrievable) ?? false
        isRetrievable = isRetrievableDecoded
        let isQueryableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isQueryable) ?? false
        isQueryable = isQueryableDecoded
        let isTimestampFieldForIncrementalQueriesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isTimestampFieldForIncrementalQueries) ?? false
        isTimestampFieldForIncrementalQueries = isTimestampFieldForIncrementalQueriesDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that can be applied to a field when the connector is being used as a source.
    public struct SourceFieldProperties: Swift.Equatable {
        /// Indicates if the field can be queried.
        public var isQueryable: Swift.Bool
        /// Indicates whether the field can be returned in a search result.
        public var isRetrievable: Swift.Bool
        /// Indicates if this timestamp field can be used for incremental queries.
        public var isTimestampFieldForIncrementalQueries: Swift.Bool

        public init(
            isQueryable: Swift.Bool = false,
            isRetrievable: Swift.Bool = false,
            isTimestampFieldForIncrementalQueries: Swift.Bool = false
        )
        {
            self.isQueryable = isQueryable
            self.isRetrievable = isRetrievable
            self.isTimestampFieldForIncrementalQueries = isTimestampFieldForIncrementalQueries
        }
    }

}

extension AppflowClientTypes.SourceFlowConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiVersion
        case connectorProfileName
        case connectorType
        case incrementalPullConfig
        case sourceConnectorProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiVersion = self.apiVersion {
            try encodeContainer.encode(apiVersion, forKey: .apiVersion)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
        if let connectorType = self.connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let incrementalPullConfig = self.incrementalPullConfig {
            try encodeContainer.encode(incrementalPullConfig, forKey: .incrementalPullConfig)
        }
        if let sourceConnectorProperties = self.sourceConnectorProperties {
            try encodeContainer.encode(sourceConnectorProperties, forKey: .sourceConnectorProperties)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let apiVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiVersion)
        apiVersion = apiVersionDecoded
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let sourceConnectorPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceConnectorProperties.self, forKey: .sourceConnectorProperties)
        sourceConnectorProperties = sourceConnectorPropertiesDecoded
        let incrementalPullConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.IncrementalPullConfig.self, forKey: .incrementalPullConfig)
        incrementalPullConfig = incrementalPullConfigDecoded
    }
}

extension AppflowClientTypes {
    /// Contains information about the configuration of the source connector used in the flow.
    public struct SourceFlowConfig: Swift.Equatable {
        /// The API version of the connector when it's used as a source in the flow.
        public var apiVersion: Swift.String?
        /// The name of the connector profile. This name must be unique for each connector profile in the Amazon Web Services account.
        public var connectorProfileName: Swift.String?
        /// The type of connector, such as Salesforce, Amplitude, and so on.
        /// This member is required.
        public var connectorType: AppflowClientTypes.ConnectorType?
        /// Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        public var incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig?
        /// Specifies the information that is required to query a particular source connector.
        /// This member is required.
        public var sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties?

        public init(
            apiVersion: Swift.String? = nil,
            connectorProfileName: Swift.String? = nil,
            connectorType: AppflowClientTypes.ConnectorType? = nil,
            incrementalPullConfig: AppflowClientTypes.IncrementalPullConfig? = nil,
            sourceConnectorProperties: AppflowClientTypes.SourceConnectorProperties? = nil
        )
        {
            self.apiVersion = apiVersion
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }
    }

}

extension StartFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension StartFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-flow"
    }
}

public struct StartFlowInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your StartFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs for flows that run on a schedule or based on an event. However, the error doesn't occur for flows that run on demand. You set the conditions that initiate your flow for the triggerConfig parameter. If you use a different value for clientToken, Amazon AppFlow considers it a new call to StartFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        flowName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.flowName = flowName
    }
}

struct StartFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let clientToken: Swift.String?
}

extension StartFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case flowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.executionId = nil
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StartFlowOutput: Swift.Equatable {
    /// Returns the internal execution ID of an on-demand flow when the flow is started. For scheduled or event-triggered flows, this value is null.
    public var executionId: Swift.String?
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        executionId: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.executionId = executionId
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StartFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
    let executionId: Swift.String?
}

extension StartFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
        case flowArn
        case flowStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
    }
}

enum StartFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
    }
}

extension StopFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stop-flow"
    }
}

public struct StopFlowInput: Swift.Equatable {
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?

    public init(
        flowName: Swift.String? = nil
    )
    {
        self.flowName = flowName
    }
}

struct StopFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
}

extension StopFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
    }
}

extension StopFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.flowStatus = output.flowStatus
        } else {
            self.flowArn = nil
            self.flowStatus = nil
        }
    }
}

public struct StopFlowOutput: Swift.Equatable {
    /// The flow's Amazon Resource Name (ARN).
    public var flowArn: Swift.String?
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowArn: Swift.String? = nil,
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowArn = flowArn
        self.flowStatus = flowStatus
    }
}

struct StopFlowOutputBody: Swift.Equatable {
    let flowArn: Swift.String?
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension StopFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn
        case flowStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

enum StopFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedOperationException": return try await UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.SuccessResponseHandlingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AppflowClientTypes {
    /// Determines how Amazon AppFlow handles the success response that it gets from the connector after placing data. For example, this setting would determine where to write the response from the destination connector upon a successful insert operation.
    public struct SuccessResponseHandlingConfig: Swift.Equatable {
        /// The name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// The Amazon S3 bucket prefix.
        public var bucketPrefix: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }
    }

}

extension AppflowClientTypes {
    public enum SupportedDataTransferType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case file
        case record
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedDataTransferType] {
            return [
                .file,
                .record,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .file: return "FILE"
            case .record: return "RECORD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedDataTransferType(rawValue: rawValue) ?? SupportedDataTransferType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.SupportedFieldTypeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case v1
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let v1 = self.v1 {
            try encodeContainer.encode(v1, forKey: .v1)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try containerValues.decodeIfPresent(AppflowClientTypes.FieldTypeDetails.self, forKey: .v1)
        v1 = v1Decoded
    }
}

extension AppflowClientTypes {
    /// Contains details regarding all the supported FieldTypes and their corresponding filterOperators and supportedValues.
    public struct SupportedFieldTypeDetails: Swift.Equatable {
        /// The initial supported version for fieldType. If this is later changed to a different version, v2 will be introduced.
        /// This member is required.
        public var v1: AppflowClientTypes.FieldTypeDetails?

        public init(
            v1: AppflowClientTypes.FieldTypeDetails? = nil
        )
        {
            self.v1 = v1
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags used to organize, track, or control access for your flow.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.Task: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorOperator
        case destinationField
        case sourceFields
        case taskProperties
        case taskType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorOperator = self.connectorOperator {
            try encodeContainer.encode(connectorOperator, forKey: .connectorOperator)
        }
        if let destinationField = self.destinationField {
            try encodeContainer.encode(destinationField, forKey: .destinationField)
        }
        if let sourceFields = sourceFields {
            var sourceFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceFields)
            for string0 in sourceFields {
                try sourceFieldsContainer.encode(string0)
            }
        }
        if let taskProperties = taskProperties {
            var taskPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .taskProperties)
            for (dictKey0, taskPropertiesMap0) in taskProperties {
                try taskPropertiesContainer.encode(taskPropertiesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskType = self.taskType {
            try encodeContainer.encode(taskType.rawValue, forKey: .taskType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFieldsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceFields)
        var sourceFieldsDecoded0:[Swift.String]? = nil
        if let sourceFieldsContainer = sourceFieldsContainer {
            sourceFieldsDecoded0 = [Swift.String]()
            for string0 in sourceFieldsContainer {
                if let string0 = string0 {
                    sourceFieldsDecoded0?.append(string0)
                }
            }
        }
        sourceFields = sourceFieldsDecoded0
        let connectorOperatorDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOperator.self, forKey: .connectorOperator)
        connectorOperator = connectorOperatorDecoded
        let destinationFieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationField)
        destinationField = destinationFieldDecoded
        let taskTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TaskType.self, forKey: .taskType)
        taskType = taskTypeDecoded
        let taskPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .taskProperties)
        var taskPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let taskPropertiesContainer = taskPropertiesContainer {
            taskPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, property0) in taskPropertiesContainer {
                if let property0 = property0 {
                    taskPropertiesDecoded0?[key0] = property0
                }
            }
        }
        taskProperties = taskPropertiesDecoded0
    }
}

extension AppflowClientTypes {
    /// A class for modeling different type of tasks. Task implementation varies based on the TaskType.
    public struct Task: Swift.Equatable {
        /// The operation to be performed on the provided source fields.
        public var connectorOperator: AppflowClientTypes.ConnectorOperator?
        /// A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        public var destinationField: Swift.String?
        /// The source fields to which a particular task is applied.
        /// This member is required.
        public var sourceFields: [Swift.String]?
        /// A map used to store task-related information. The execution service looks for particular information based on the TaskType.
        public var taskProperties: [Swift.String:Swift.String]?
        /// Specifies the particular task implementation that Amazon AppFlow performs.
        /// This member is required.
        public var taskType: AppflowClientTypes.TaskType?

        public init(
            connectorOperator: AppflowClientTypes.ConnectorOperator? = nil,
            destinationField: Swift.String? = nil,
            sourceFields: [Swift.String]? = nil,
            taskProperties: [Swift.String:Swift.String]? = nil,
            taskType: AppflowClientTypes.TaskType? = nil
        )
        {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }
    }

}

extension AppflowClientTypes {
    public enum TaskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case arithmetic
        case filter
        case map
        case mapAll
        case mask
        case merge
        case partition
        case passthrough
        case truncate
        case validate
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskType] {
            return [
                .arithmetic,
                .filter,
                .map,
                .mapAll,
                .mask,
                .merge,
                .partition,
                .passthrough,
                .truncate,
                .validate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .arithmetic: return "Arithmetic"
            case .filter: return "Filter"
            case .map: return "Map"
            case .mapAll: return "Map_all"
            case .mask: return "Mask"
            case .merge: return "Merge"
            case .partition: return "Partition"
            case .passthrough: return "Passthrough"
            case .truncate: return "Truncate"
            case .validate: return "Validate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskType(rawValue: rawValue) ?? TaskType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// API calls have exceeded the maximum allowed API request rate per account and per Region.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum TrendmicroConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case equalTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [TrendmicroConnectorOperator] {
            return [
                .addition,
                .division,
                .equalTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrendmicroConnectorOperator(rawValue: rawValue) ?? TrendmicroConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiSecretKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiSecretKey = self.apiSecretKey {
            try encodeContainer.encode(apiSecretKey, forKey: .apiSecretKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiSecretKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiSecretKey)
        apiSecretKey = apiSecretKeyDecoded
    }
}

extension AppflowClientTypes.TrendmicroConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TrendmicroConnectorProfileCredentials(apiSecretKey: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Trend Micro.
    public struct TrendmicroConnectorProfileCredentials: Swift.Equatable {
        /// The Secret Access Key portion of the credentials.
        /// This member is required.
        public var apiSecretKey: Swift.String?

        public init(
            apiSecretKey: Swift.String? = nil
        )
        {
            self.apiSecretKey = apiSecretKey
        }
    }

}

extension AppflowClientTypes.TrendmicroConnectorProfileProperties: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Trend Micro.
    public struct TrendmicroConnectorProfileProperties: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.TrendmicroMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Trend Micro.
    public struct TrendmicroMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.TrendmicroSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Trend Micro as a flow source.
    public struct TrendmicroSourceProperties: Swift.Equatable {
        /// The object specified in the Trend Micro flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}

extension AppflowClientTypes.TriggerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerProperties
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerProperties = self.triggerProperties {
            try encodeContainer.encode(triggerProperties, forKey: .triggerProperties)
        }
        if let triggerType = self.triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerPropertiesDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerProperties.self, forKey: .triggerProperties)
        triggerProperties = triggerPropertiesDecoded
    }
}

extension AppflowClientTypes {
    /// The trigger settings that determine how and when Amazon AppFlow runs the specified flow.
    public struct TriggerConfig: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user. Currently, these settings only apply to the Scheduled trigger type.
        public var triggerProperties: AppflowClientTypes.TriggerProperties?
        /// Specifies the type of flow trigger. This can be OnDemand, Scheduled, or Event.
        /// This member is required.
        public var triggerType: AppflowClientTypes.TriggerType?

        public init(
            triggerProperties: AppflowClientTypes.TriggerProperties? = nil,
            triggerType: AppflowClientTypes.TriggerType? = nil
        )
        {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }
    }

}

extension AppflowClientTypes.TriggerProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduled = "Scheduled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduled = self.scheduled {
            try encodeContainer.encode(scheduled, forKey: .scheduled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduledDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ScheduledTriggerProperties.self, forKey: .scheduled)
        scheduled = scheduledDecoded
    }
}

extension AppflowClientTypes {
    /// Specifies the configuration details that control the trigger for a flow. Currently, these settings only apply to the Scheduled trigger type.
    public struct TriggerProperties: Swift.Equatable {
        /// Specifies the configuration details of a schedule-triggered flow as defined by the user.
        public var scheduled: AppflowClientTypes.ScheduledTriggerProperties?

        public init(
            scheduled: AppflowClientTypes.ScheduledTriggerProperties? = nil
        )
        {
            self.scheduled = scheduled
        }
    }

}

extension AppflowClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case ondemand
        case scheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .event,
                .ondemand,
                .scheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "Event"
            case .ondemand: return "OnDemand"
            case .scheduled: return "Scheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

extension UnregisterConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case forceDelete
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let forceDelete = self.forceDelete {
            try encodeContainer.encode(forceDelete, forKey: .forceDelete)
        }
    }
}

extension UnregisterConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/unregister-connector"
    }
}

public struct UnregisterConnectorInput: Swift.Equatable {
    /// The label of the connector. The label is unique for each ConnectorRegistration in your Amazon Web Services account.
    /// This member is required.
    public var connectorLabel: Swift.String?
    /// Indicates whether Amazon AppFlow should unregister the connector, even if it is currently in use in one or more connector profiles. The default value is false.
    public var forceDelete: Swift.Bool?

    public init(
        connectorLabel: Swift.String? = nil,
        forceDelete: Swift.Bool? = nil
    )
    {
        self.connectorLabel = connectorLabel
        self.forceDelete = forceDelete
    }
}

struct UnregisterConnectorInputBody: Swift.Equatable {
    let connectorLabel: Swift.String?
    let forceDelete: Swift.Bool?
}

extension UnregisterConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorLabel
        case forceDelete
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let forceDeleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceDelete)
        forceDelete = forceDeleteDecoded
    }
}

extension UnregisterConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnregisterConnectorOutput: Swift.Equatable {

    public init() { }
}

enum UnregisterConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnsupportedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation is not supported for the current flow.
public struct UnsupportedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the tag that you want to remove from your flow.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectorProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectionMode = self.connectionMode {
            try encodeContainer.encode(connectionMode.rawValue, forKey: .connectionMode)
        }
        if let connectorProfileConfig = self.connectorProfileConfig {
            try encodeContainer.encode(connectorProfileConfig, forKey: .connectorProfileConfig)
        }
        if let connectorProfileName = self.connectorProfileName {
            try encodeContainer.encode(connectorProfileName, forKey: .connectorProfileName)
        }
    }
}

extension UpdateConnectorProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-connector-profile"
    }
}

public struct UpdateConnectorProfileInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorProfile request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorProfile. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// Indicates the connection mode and if it is public or private.
    /// This member is required.
    public var connectionMode: AppflowClientTypes.ConnectionMode?
    /// Defines the connector-specific profile configuration and credentials.
    /// This member is required.
    public var connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    /// The name of the connector profile and is unique for each ConnectorProfile in the Amazon Web Services account.
    /// This member is required.
    public var connectorProfileName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionMode: AppflowClientTypes.ConnectionMode? = nil,
        connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig? = nil,
        connectorProfileName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionMode = connectionMode
        self.connectorProfileConfig = connectorProfileConfig
        self.connectorProfileName = connectorProfileName
    }
}

struct UpdateConnectorProfileInputBody: Swift.Equatable {
    let connectorProfileName: Swift.String?
    let connectionMode: AppflowClientTypes.ConnectionMode?
    let connectorProfileConfig: AppflowClientTypes.ConnectorProfileConfig?
    let clientToken: Swift.String?
}

extension UpdateConnectorProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectionMode
        case connectorProfileConfig
        case connectorProfileName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileName)
        connectorProfileName = connectorProfileNameDecoded
        let connectionModeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectionMode.self, forKey: .connectionMode)
        connectionMode = connectionModeDecoded
        let connectorProfileConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProfileConfig.self, forKey: .connectorProfileConfig)
        connectorProfileConfig = connectorProfileConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateConnectorProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectorProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorProfileArn = output.connectorProfileArn
        } else {
            self.connectorProfileArn = nil
        }
    }
}

public struct UpdateConnectorProfileOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the connector profile.
    public var connectorProfileArn: Swift.String?

    public init(
        connectorProfileArn: Swift.String? = nil
    )
    {
        self.connectorProfileArn = connectorProfileArn
    }
}

struct UpdateConnectorProfileOutputBody: Swift.Equatable {
    let connectorProfileArn: Swift.String?
}

extension UpdateConnectorProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorProfileArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorProfileArn)
        connectorProfileArn = connectorProfileArnDecoded
    }
}

enum UpdateConnectorProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectorRegistrationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectorLabel
        case connectorProvisioningConfig
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let connectorLabel = self.connectorLabel {
            try encodeContainer.encode(connectorLabel, forKey: .connectorLabel)
        }
        if let connectorProvisioningConfig = self.connectorProvisioningConfig {
            try encodeContainer.encode(connectorProvisioningConfig, forKey: .connectorProvisioningConfig)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateConnectorRegistrationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-connector-registration"
    }
}

public struct UpdateConnectorRegistrationInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateConnectorRegistration request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateConnectorRegistration. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// The name of the connector. The name is unique for each connector registration in your AWS account.
    /// This member is required.
    public var connectorLabel: Swift.String?
    /// Contains information about the configuration of the connector being registered.
    public var connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    /// A description about the update that you're applying to the connector.
    public var description: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectorLabel: Swift.String? = nil,
        connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig? = nil,
        description: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectorLabel = connectorLabel
        self.connectorProvisioningConfig = connectorProvisioningConfig
        self.description = description
    }
}

struct UpdateConnectorRegistrationInputBody: Swift.Equatable {
    let connectorLabel: Swift.String?
    let description: Swift.String?
    let connectorProvisioningConfig: AppflowClientTypes.ConnectorProvisioningConfig?
    let clientToken: Swift.String?
}

extension UpdateConnectorRegistrationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case connectorLabel
        case connectorProvisioningConfig
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorLabel)
        connectorLabel = connectorLabelDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let connectorProvisioningConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorProvisioningConfig.self, forKey: .connectorProvisioningConfig)
        connectorProvisioningConfig = connectorProvisioningConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateConnectorRegistrationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectorRegistrationOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorArn = output.connectorArn
        } else {
            self.connectorArn = nil
        }
    }
}

public struct UpdateConnectorRegistrationOutput: Swift.Equatable {
    /// The ARN of the connector being updated.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

struct UpdateConnectorRegistrationOutputBody: Swift.Equatable {
    let connectorArn: Swift.String?
}

extension UpdateConnectorRegistrationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
    }
}

enum UpdateConnectorRegistrationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case destinationFlowConfigList
        case flowName
        case metadataCatalogConfig
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationFlowConfigList = destinationFlowConfigList {
            var destinationFlowConfigListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationFlowConfigList)
            for destinationflowconfig0 in destinationFlowConfigList {
                try destinationFlowConfigListContainer.encode(destinationflowconfig0)
            }
        }
        if let flowName = self.flowName {
            try encodeContainer.encode(flowName, forKey: .flowName)
        }
        if let metadataCatalogConfig = self.metadataCatalogConfig {
            try encodeContainer.encode(metadataCatalogConfig, forKey: .metadataCatalogConfig)
        }
        if let sourceFlowConfig = self.sourceFlowConfig {
            try encodeContainer.encode(sourceFlowConfig, forKey: .sourceFlowConfig)
        }
        if let tasks = tasks {
            var tasksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tasks)
            for task0 in tasks {
                try tasksContainer.encode(task0)
            }
        }
        if let triggerConfig = self.triggerConfig {
            try encodeContainer.encode(triggerConfig, forKey: .triggerConfig)
        }
    }
}

extension UpdateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-flow"
    }
}

public struct UpdateFlowInput: Swift.Equatable {
    /// The clientToken parameter is an idempotency token. It ensures that your UpdateFlow request completes only once. You choose the value to pass. For example, if you don't receive a response from your request, you can safely retry the request with the same clientToken parameter value. If you omit a clientToken value, the Amazon Web Services SDK that you are using inserts a value for you. This way, the SDK can safely retry requests multiple times after a network error. You must provide your own value for other use cases. If you specify input parameters that differ from your first request, an error occurs. If you use a different value for clientToken, Amazon AppFlow considers it a new call to UpdateFlow. The token is active for 8 hours.
    public var clientToken: Swift.String?
    /// A description of the flow.
    public var description: Swift.String?
    /// The configuration that controls how Amazon AppFlow transfers data to the destination connector.
    /// This member is required.
    public var destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    /// The specified name of the flow. Spaces are not allowed. Use underscores (_) or hyphens (-) only.
    /// This member is required.
    public var flowName: Swift.String?
    /// Specifies the configuration that Amazon AppFlow uses when it catalogs the data that's transferred by the associated flow. When Amazon AppFlow catalogs the data from a flow, it stores metadata in a data catalog.
    public var metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    /// Contains information about the configuration of the source connector used in the flow.
    /// This member is required.
    public var sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    /// A list of tasks that Amazon AppFlow performs while transferring the data in the flow run.
    /// This member is required.
    public var tasks: [AppflowClientTypes.Task]?
    /// The trigger settings that determine how and when the flow runs.
    /// This member is required.
    public var triggerConfig: AppflowClientTypes.TriggerConfig?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]? = nil,
        flowName: Swift.String? = nil,
        metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig? = nil,
        sourceFlowConfig: AppflowClientTypes.SourceFlowConfig? = nil,
        tasks: [AppflowClientTypes.Task]? = nil,
        triggerConfig: AppflowClientTypes.TriggerConfig? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.destinationFlowConfigList = destinationFlowConfigList
        self.flowName = flowName
        self.metadataCatalogConfig = metadataCatalogConfig
        self.sourceFlowConfig = sourceFlowConfig
        self.tasks = tasks
        self.triggerConfig = triggerConfig
    }
}

struct UpdateFlowInputBody: Swift.Equatable {
    let flowName: Swift.String?
    let description: Swift.String?
    let triggerConfig: AppflowClientTypes.TriggerConfig?
    let sourceFlowConfig: AppflowClientTypes.SourceFlowConfig?
    let destinationFlowConfigList: [AppflowClientTypes.DestinationFlowConfig]?
    let tasks: [AppflowClientTypes.Task]?
    let metadataCatalogConfig: AppflowClientTypes.MetadataCatalogConfig?
    let clientToken: Swift.String?
}

extension UpdateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case destinationFlowConfigList
        case flowName
        case metadataCatalogConfig
        case sourceFlowConfig
        case tasks
        case triggerConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowName)
        flowName = flowNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let triggerConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.TriggerConfig.self, forKey: .triggerConfig)
        triggerConfig = triggerConfigDecoded
        let sourceFlowConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.SourceFlowConfig.self, forKey: .sourceFlowConfig)
        sourceFlowConfig = sourceFlowConfigDecoded
        let destinationFlowConfigListContainer = try containerValues.decodeIfPresent([AppflowClientTypes.DestinationFlowConfig?].self, forKey: .destinationFlowConfigList)
        var destinationFlowConfigListDecoded0:[AppflowClientTypes.DestinationFlowConfig]? = nil
        if let destinationFlowConfigListContainer = destinationFlowConfigListContainer {
            destinationFlowConfigListDecoded0 = [AppflowClientTypes.DestinationFlowConfig]()
            for structure0 in destinationFlowConfigListContainer {
                if let structure0 = structure0 {
                    destinationFlowConfigListDecoded0?.append(structure0)
                }
            }
        }
        destinationFlowConfigList = destinationFlowConfigListDecoded0
        let tasksContainer = try containerValues.decodeIfPresent([AppflowClientTypes.Task?].self, forKey: .tasks)
        var tasksDecoded0:[AppflowClientTypes.Task]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [AppflowClientTypes.Task]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let metadataCatalogConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.MetadataCatalogConfig.self, forKey: .metadataCatalogConfig)
        metadataCatalogConfig = metadataCatalogConfigDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateFlowOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFlowOutputBody = try responseDecoder.decode(responseBody: data)
            self.flowStatus = output.flowStatus
        } else {
            self.flowStatus = nil
        }
    }
}

public struct UpdateFlowOutput: Swift.Equatable {
    /// Indicates the current status of the flow.
    public var flowStatus: AppflowClientTypes.FlowStatus?

    public init(
        flowStatus: AppflowClientTypes.FlowStatus? = nil
    )
    {
        self.flowStatus = flowStatus
    }
}

struct UpdateFlowOutputBody: Swift.Equatable {
    let flowStatus: AppflowClientTypes.FlowStatus?
}

extension UpdateFlowOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowStatusDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FlowStatus.self, forKey: .flowStatus)
        flowStatus = flowStatusDecoded
    }
}

enum UpdateFlowOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorAuthenticationException": return try await ConnectorAuthenticationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConnectorServerException": return try await ConnectorServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AppflowClientTypes.UpsolverDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case bucketPrefix
        case s3OutputFormatConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let bucketPrefix = self.bucketPrefix {
            try encodeContainer.encode(bucketPrefix, forKey: .bucketPrefix)
        }
        if let s3OutputFormatConfig = self.s3OutputFormatConfig {
            try encodeContainer.encode(s3OutputFormatConfig, forKey: .s3OutputFormatConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let bucketPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPrefix)
        bucketPrefix = bucketPrefixDecoded
        let s3OutputFormatConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.UpsolverS3OutputFormatConfig.self, forKey: .s3OutputFormatConfig)
        s3OutputFormatConfig = s3OutputFormatConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Upsolver is used as a destination.
    public struct UpsolverDestinationProperties: Swift.Equatable {
        /// The Upsolver Amazon S3 bucket name in which Amazon AppFlow places the transferred data.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The object key for the destination Upsolver Amazon S3 bucket in which Amazon AppFlow places the files.
        public var bucketPrefix: Swift.String?
        /// The configuration that determines how data is formatted when Upsolver is used as the flow destination.
        /// This member is required.
        public var s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig?

        public init(
            bucketName: Swift.String? = nil,
            bucketPrefix: Swift.String? = nil,
            s3OutputFormatConfig: AppflowClientTypes.UpsolverS3OutputFormatConfig? = nil
        )
        {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
            self.s3OutputFormatConfig = s3OutputFormatConfig
        }
    }

}

extension AppflowClientTypes.UpsolverMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Upsolver.
    public struct UpsolverMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.UpsolverS3OutputFormatConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationConfig
        case fileType
        case prefixConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationConfig = self.aggregationConfig {
            try encodeContainer.encode(aggregationConfig, forKey: .aggregationConfig)
        }
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let prefixConfig = self.prefixConfig {
            try encodeContainer.encode(prefixConfig, forKey: .prefixConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let prefixConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.PrefixConfig.self, forKey: .prefixConfig)
        prefixConfig = prefixConfigDecoded
        let aggregationConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.AggregationConfig.self, forKey: .aggregationConfig)
        aggregationConfig = aggregationConfigDecoded
    }
}

extension AppflowClientTypes {
    /// The configuration that determines how Amazon AppFlow formats the flow output data when Upsolver is used as the destination.
    public struct UpsolverS3OutputFormatConfig: Swift.Equatable {
        /// The aggregation settings that you can use to customize the output format of your flow data.
        public var aggregationConfig: AppflowClientTypes.AggregationConfig?
        /// Indicates the file type that Amazon AppFlow places in the Upsolver Amazon S3 bucket.
        public var fileType: AppflowClientTypes.FileType?
        /// Specifies elements that Amazon AppFlow includes in the file and folder names in the flow destination.
        /// This member is required.
        public var prefixConfig: AppflowClientTypes.PrefixConfig?

        public init(
            aggregationConfig: AppflowClientTypes.AggregationConfig? = nil,
            fileType: AppflowClientTypes.FileType? = nil,
            prefixConfig: AppflowClientTypes.PrefixConfig? = nil
        )
        {
            self.aggregationConfig = aggregationConfig
            self.fileType = fileType
            self.prefixConfig = prefixConfig
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request has invalid or missing parameters.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppflowClientTypes {
    public enum VeevaConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case between
        case contains
        case division
        case equalTo
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case notEqualTo
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [VeevaConnectorOperator] {
            return [
                .addition,
                .between,
                .contains,
                .division,
                .equalTo,
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .notEqualTo,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .between: return "BETWEEN"
            case .contains: return "CONTAINS"
            case .division: return "DIVISION"
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqualTo: return "GREATER_THAN_OR_EQUAL_TO"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqualTo: return "LESS_THAN_OR_EQUAL_TO"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .notEqualTo: return "NOT_EQUAL_TO"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VeevaConnectorOperator(rawValue: rawValue) ?? VeevaConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case password
        case username
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = self.password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension AppflowClientTypes.VeevaConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VeevaConnectorProfileCredentials(username: \(Swift.String(describing: username)), password: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Veeva.
    public struct VeevaConnectorProfileCredentials: Swift.Equatable {
        /// The password that corresponds to the user name.
        /// This member is required.
        public var password: Swift.String?
        /// The name of the user.
        /// This member is required.
        public var username: Swift.String?

        public init(
            password: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.password = password
            self.username = username
        }
    }

}

extension AppflowClientTypes.VeevaConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Veeva.
    public struct VeevaConnectorProfileProperties: Swift.Equatable {
        /// The location of the Veeva resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.VeevaMetadata: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Veeva.
    public struct VeevaMetadata: Swift.Equatable {

        public init() { }
    }

}

extension AppflowClientTypes.VeevaSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case documentType
        case includeAllVersions
        case includeRenditions
        case includeSourceFiles
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentType = self.documentType {
            try encodeContainer.encode(documentType, forKey: .documentType)
        }
        if includeAllVersions != false {
            try encodeContainer.encode(includeAllVersions, forKey: .includeAllVersions)
        }
        if includeRenditions != false {
            try encodeContainer.encode(includeRenditions, forKey: .includeRenditions)
        }
        if includeSourceFiles != false {
            try encodeContainer.encode(includeSourceFiles, forKey: .includeSourceFiles)
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let documentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentType)
        documentType = documentTypeDecoded
        let includeSourceFilesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSourceFiles) ?? false
        includeSourceFiles = includeSourceFilesDecoded
        let includeRenditionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRenditions) ?? false
        includeRenditions = includeRenditionsDecoded
        let includeAllVersionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAllVersions) ?? false
        includeAllVersions = includeAllVersionsDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Veeva as a flow source.
    public struct VeevaSourceProperties: Swift.Equatable {
        /// The document type specified in the Veeva document extract flow.
        public var documentType: Swift.String?
        /// Boolean value to include All Versions of files in Veeva document extract flow.
        public var includeAllVersions: Swift.Bool
        /// Boolean value to include file renditions in Veeva document extract flow.
        public var includeRenditions: Swift.Bool
        /// Boolean value to include source files in Veeva document extract flow.
        public var includeSourceFiles: Swift.Bool
        /// The object specified in the Veeva flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            documentType: Swift.String? = nil,
            includeAllVersions: Swift.Bool = false,
            includeRenditions: Swift.Bool = false,
            includeSourceFiles: Swift.Bool = false,
            object: Swift.String? = nil
        )
        {
            self.documentType = documentType
            self.includeAllVersions = includeAllVersions
            self.includeRenditions = includeRenditions
            self.includeSourceFiles = includeSourceFiles
            self.object = object
        }
    }

}

extension AppflowClientTypes {
    /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
    public enum WriteOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case insert
        case update
        case upsert
        case sdkUnknown(Swift.String)

        public static var allCases: [WriteOperationType] {
            return [
                .delete,
                .insert,
                .update,
                .upsert,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .insert: return "INSERT"
            case .update: return "UPDATE"
            case .upsert: return "UPSERT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WriteOperationType(rawValue: rawValue) ?? WriteOperationType.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes {
    public enum ZendeskConnectorOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case addition
        case division
        case greaterThan
        case maskAll
        case maskFirstN
        case maskLastN
        case multiplication
        case noOp
        case projection
        case subtraction
        case validateNonNegative
        case validateNonNull
        case validateNonZero
        case validateNumeric
        case sdkUnknown(Swift.String)

        public static var allCases: [ZendeskConnectorOperator] {
            return [
                .addition,
                .division,
                .greaterThan,
                .maskAll,
                .maskFirstN,
                .maskLastN,
                .multiplication,
                .noOp,
                .projection,
                .subtraction,
                .validateNonNegative,
                .validateNonNull,
                .validateNonZero,
                .validateNumeric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .addition: return "ADDITION"
            case .division: return "DIVISION"
            case .greaterThan: return "GREATER_THAN"
            case .maskAll: return "MASK_ALL"
            case .maskFirstN: return "MASK_FIRST_N"
            case .maskLastN: return "MASK_LAST_N"
            case .multiplication: return "MULTIPLICATION"
            case .noOp: return "NO_OP"
            case .projection: return "PROJECTION"
            case .subtraction: return "SUBTRACTION"
            case .validateNonNegative: return "VALIDATE_NON_NEGATIVE"
            case .validateNonNull: return "VALIDATE_NON_NULL"
            case .validateNonZero: return "VALIDATE_NON_ZERO"
            case .validateNumeric: return "VALIDATE_NUMERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ZendeskConnectorOperator(rawValue: rawValue) ?? ZendeskConnectorOperator.sdkUnknown(rawValue)
        }
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case clientId
        case clientSecret
        case oAuthRequest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessToken = self.accessToken {
            try encodeContainer.encode(accessToken, forKey: .accessToken)
        }
        if let clientId = self.clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = self.clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if let oAuthRequest = self.oAuthRequest {
            try encodeContainer.encode(oAuthRequest, forKey: .oAuthRequest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let oAuthRequestDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ConnectorOAuthRequest.self, forKey: .oAuthRequest)
        oAuthRequest = oAuthRequestDecoded
    }
}

extension AppflowClientTypes.ZendeskConnectorProfileCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ZendeskConnectorProfileCredentials(clientId: \(Swift.String(describing: clientId)), oAuthRequest: \(Swift.String(describing: oAuthRequest)), accessToken: \"CONTENT_REDACTED\", clientSecret: \"CONTENT_REDACTED\")"}
}

extension AppflowClientTypes {
    /// The connector-specific profile credentials required when using Zendesk.
    public struct ZendeskConnectorProfileCredentials: Swift.Equatable {
        /// The credentials used to access protected Zendesk resources.
        public var accessToken: Swift.String?
        /// The identifier for the desired client.
        /// This member is required.
        public var clientId: Swift.String?
        /// The client secret used by the OAuth client to authenticate to the authorization server.
        /// This member is required.
        public var clientSecret: Swift.String?
        /// The OAuth requirement needed to request security tokens from the connector endpoint.
        public var oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest?

        public init(
            accessToken: Swift.String? = nil,
            clientId: Swift.String? = nil,
            clientSecret: Swift.String? = nil,
            oAuthRequest: AppflowClientTypes.ConnectorOAuthRequest? = nil
        )
        {
            self.accessToken = accessToken
            self.clientId = clientId
            self.clientSecret = clientSecret
            self.oAuthRequest = oAuthRequest
        }
    }

}

extension AppflowClientTypes.ZendeskConnectorProfileProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceUrl = self.instanceUrl {
            try encodeContainer.encode(instanceUrl, forKey: .instanceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceUrl)
        instanceUrl = instanceUrlDecoded
    }
}

extension AppflowClientTypes {
    /// The connector-specific profile properties required when using Zendesk.
    public struct ZendeskConnectorProfileProperties: Swift.Equatable {
        /// The location of the Zendesk resource.
        /// This member is required.
        public var instanceUrl: Swift.String?

        public init(
            instanceUrl: Swift.String? = nil
        )
        {
            self.instanceUrl = instanceUrl
        }
    }

}

extension AppflowClientTypes.ZendeskDestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorHandlingConfig
        case idFieldNames
        case object
        case writeOperationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorHandlingConfig = self.errorHandlingConfig {
            try encodeContainer.encode(errorHandlingConfig, forKey: .errorHandlingConfig)
        }
        if let idFieldNames = idFieldNames {
            var idFieldNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .idFieldNames)
            for name0 in idFieldNames {
                try idFieldNamesContainer.encode(name0)
            }
        }
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
        if let writeOperationType = self.writeOperationType {
            try encodeContainer.encode(writeOperationType.rawValue, forKey: .writeOperationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
        let idFieldNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .idFieldNames)
        var idFieldNamesDecoded0:[Swift.String]? = nil
        if let idFieldNamesContainer = idFieldNamesContainer {
            idFieldNamesDecoded0 = [Swift.String]()
            for string0 in idFieldNamesContainer {
                if let string0 = string0 {
                    idFieldNamesDecoded0?.append(string0)
                }
            }
        }
        idFieldNames = idFieldNamesDecoded0
        let errorHandlingConfigDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.ErrorHandlingConfig.self, forKey: .errorHandlingConfig)
        errorHandlingConfig = errorHandlingConfigDecoded
        let writeOperationTypeDecoded = try containerValues.decodeIfPresent(AppflowClientTypes.WriteOperationType.self, forKey: .writeOperationType)
        writeOperationType = writeOperationTypeDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when Zendesk is used as a destination.
    public struct ZendeskDestinationProperties: Swift.Equatable {
        /// The settings that determine how Amazon AppFlow handles an error when placing data in the destination. For example, this setting would determine if the flow should fail after one insertion error, or continue and attempt to insert every record regardless of the initial failure. ErrorHandlingConfig is a part of the destination connector details.
        public var errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig?
        /// A list of field names that can be used as an ID field when performing a write operation.
        public var idFieldNames: [Swift.String]?
        /// The object specified in the Zendesk flow destination.
        /// This member is required.
        public var object: Swift.String?
        /// The possible write operations in the destination connector. When this value is not provided, this defaults to the INSERT operation.
        public var writeOperationType: AppflowClientTypes.WriteOperationType?

        public init(
            errorHandlingConfig: AppflowClientTypes.ErrorHandlingConfig? = nil,
            idFieldNames: [Swift.String]? = nil,
            object: Swift.String? = nil,
            writeOperationType: AppflowClientTypes.WriteOperationType? = nil
        )
        {
            self.errorHandlingConfig = errorHandlingConfig
            self.idFieldNames = idFieldNames
            self.object = object
            self.writeOperationType = writeOperationType
        }
    }

}

extension AppflowClientTypes.ZendeskMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oAuthScopes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let oAuthScopes = oAuthScopes {
            var oAuthScopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .oAuthScopes)
            for oauthscope0 in oAuthScopes {
                try oAuthScopesContainer.encode(oauthscope0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let oAuthScopesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .oAuthScopes)
        var oAuthScopesDecoded0:[Swift.String]? = nil
        if let oAuthScopesContainer = oAuthScopesContainer {
            oAuthScopesDecoded0 = [Swift.String]()
            for string0 in oAuthScopesContainer {
                if let string0 = string0 {
                    oAuthScopesDecoded0?.append(string0)
                }
            }
        }
        oAuthScopes = oAuthScopesDecoded0
    }
}

extension AppflowClientTypes {
    /// The connector metadata specific to Zendesk.
    public struct ZendeskMetadata: Swift.Equatable {
        /// The desired authorization scope for the Zendesk account.
        public var oAuthScopes: [Swift.String]?

        public init(
            oAuthScopes: [Swift.String]? = nil
        )
        {
            self.oAuthScopes = oAuthScopes
        }
    }

}

extension AppflowClientTypes.ZendeskSourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case object
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let object = self.object {
            try encodeContainer.encode(object, forKey: .object)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .object)
        object = objectDecoded
    }
}

extension AppflowClientTypes {
    /// The properties that are applied when using Zendesk as a flow source.
    public struct ZendeskSourceProperties: Swift.Equatable {
        /// The object specified in the Zendesk flow source.
        /// This member is required.
        public var object: Swift.String?

        public init(
            object: Swift.String? = nil
        )
        {
            self.object = object
        }
    }

}
