//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension KafkaConnectClientTypes {
    /// The description of the scale-in policy for the connector.
    public struct ScaleInPolicyDescription {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the scale-out policy for the connector.
    public struct ScaleOutPolicyDescription {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// Information about the auto scaling parameters for the connector.
    public struct AutoScalingDescription {
        /// The maximum number of workers allocated to the connector.
        public var maxWorkerCount: Swift.Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public var mcuCount: Swift.Int
        /// The minimum number of workers allocated to the connector.
        public var minWorkerCount: Swift.Int
        /// The sacle-in policy for the connector.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyDescription?
        /// The sacle-out policy for the connector.>
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyDescription?

        public init(
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyDescription? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyDescription? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of a connector's provisioned capacity.
    public struct ProvisionedCapacityDescription {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        public var workerCount: Swift.Int

        public init(
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes {
    /// A description of the connector's capacity.
    public struct CapacityDescription {
        /// Describes the connector's auto scaling capacity.
        public var autoScaling: KafkaConnectClientTypes.AutoScalingDescription?
        /// Describes a connector's provisioned capacity.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityDescription?

        public init(
            autoScaling: KafkaConnectClientTypes.AutoScalingDescription? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityDescription? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes {

    public enum ConnectorState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case failed
        case running
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorState] {
            return [
                .creating,
                .deleting,
                .failed,
                .running,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {
    /// The description of the VPC in which the connector resides.
    public struct VpcDescription {
        /// The security groups for the connector.
        public var securityGroups: [Swift.String]?
        /// The subnets for the connector.
        public var subnets: [Swift.String]?

        public init(
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the Apache Kafka cluster to which the connector is connected.
    public struct ApacheKafkaClusterDescription {
        /// The bootstrap servers of the cluster.
        public var bootstrapServers: Swift.String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        public var vpc: KafkaConnectClientTypes.VpcDescription?

        public init(
            bootstrapServers: Swift.String? = nil,
            vpc: KafkaConnectClientTypes.VpcDescription? = nil
        )
        {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details of how to connect to the Apache Kafka cluster.
    public struct KafkaClusterDescription {
        /// The Apache Kafka cluster to which the connector is connected.
        public var apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaClusterDescription?

        public init(
            apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaClusterDescription? = nil
        )
        {
            self.apacheKafkaCluster = apacheKafkaCluster
        }
    }

}

extension KafkaConnectClientTypes {

    public enum KafkaClusterClientAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaClusterClientAuthenticationType] {
            return [
                .iam,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {
    /// The client authentication information used in order to authenticate with the Apache Kafka cluster.
    public struct KafkaClusterClientAuthenticationDescription {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        public var authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType?

        public init(
            authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType? = nil
        )
        {
            self.authenticationType = authenticationType
        }
    }

}

extension KafkaConnectClientTypes {

    public enum KafkaClusterEncryptionInTransitType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case plaintext
        case tls
        case sdkUnknown(Swift.String)

        public static var allCases: [KafkaClusterEncryptionInTransitType] {
            return [
                .plaintext,
                .tls
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .plaintext: return "PLAINTEXT"
            case .tls: return "TLS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {
    /// The description of the encryption in transit to the Apache Kafka cluster.
    public struct KafkaClusterEncryptionInTransitDescription {
        /// The type of encryption in transit to the Apache Kafka cluster.
        public var encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType?

        public init(
            encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType? = nil
        )
        {
            self.encryptionType = encryptionType
        }
    }

}

extension KafkaConnectClientTypes {
    /// A description of the log delivery settings.
    public struct CloudWatchLogsLogDeliveryDescription {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        public var enabled: Swift.Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public var logGroup: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

extension KafkaConnectClientTypes {
    /// A description of the settings for delivering logs to Amazon Kinesis Data Firehose.
    public struct FirehoseLogDeliveryDescription {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public var deliveryStream: Swift.String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        public var enabled: Swift.Bool

        public init(
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the details about delivering logs to Amazon S3.
    public struct S3LogDeliveryDescription {
        /// The name of the S3 bucket that is the destination for log delivery.
        public var bucket: Swift.String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        public var enabled: Swift.Bool
        /// The S3 prefix that is the destination for log delivery.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaConnectClientTypes {
    /// Workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
    public struct WorkerLogDeliveryDescription {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public var cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public var firehose: KafkaConnectClientTypes.FirehoseLogDeliveryDescription?
        /// Details about delivering logs to Amazon S3.
        public var s3: KafkaConnectClientTypes.S3LogDeliveryDescription?

        public init(
            cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription? = nil,
            firehose: KafkaConnectClientTypes.FirehoseLogDeliveryDescription? = nil,
            s3: KafkaConnectClientTypes.S3LogDeliveryDescription? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the log delivery settings.
    public struct LogDeliveryDescription {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        public var workerLogDelivery: KafkaConnectClientTypes.WorkerLogDeliveryDescription?

        public init(
            workerLogDelivery: KafkaConnectClientTypes.WorkerLogDeliveryDescription? = nil
        )
        {
            self.workerLogDelivery = workerLogDelivery
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details about a custom plugin.
    public struct CustomPluginDescription {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public var customPluginArn: Swift.String?
        /// The revision of the custom plugin.
        public var revision: Swift.Int

        public init(
            customPluginArn: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the plugin.
    public struct PluginDescription {
        /// Details about a custom plugin.
        public var customPlugin: KafkaConnectClientTypes.CustomPluginDescription?

        public init(
            customPlugin: KafkaConnectClientTypes.CustomPluginDescription? = nil
        )
        {
            self.customPlugin = customPlugin
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the worker configuration.
    public struct WorkerConfigurationDescription {
        /// The revision of the worker configuration.
        public var revision: Swift.Int
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public var workerConfigurationArn: Swift.String?

        public init(
            revision: Swift.Int = 0,
            workerConfigurationArn: Swift.String? = nil
        )
        {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }
    }

}

extension KafkaConnectClientTypes {
    /// Summary of a connector.
    public struct ConnectorSummary {
        /// The connector's compute capacity settings.
        public var capacity: KafkaConnectClientTypes.CapacityDescription?
        /// The Amazon Resource Name (ARN) of the connector.
        public var connectorArn: Swift.String?
        /// The description of the connector.
        public var connectorDescription: Swift.String?
        /// The name of the connector.
        public var connectorName: Swift.String?
        /// The state of the connector.
        public var connectorState: KafkaConnectClientTypes.ConnectorState?
        /// The time that the connector was created.
        public var creationTime: Foundation.Date?
        /// The current version of the connector.
        public var currentVersion: Swift.String?
        /// The details of the Apache Kafka cluster to which the connector is connected.
        public var kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription?
        /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
        public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription?
        /// Details of encryption in transit to the Apache Kafka cluster.
        public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription?
        /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
        public var kafkaConnectVersion: Swift.String?
        /// The settings for delivering connector logs to Amazon CloudWatch Logs.
        public var logDelivery: KafkaConnectClientTypes.LogDeliveryDescription?
        /// Specifies which plugins were used for this connector.
        public var plugins: [KafkaConnectClientTypes.PluginDescription]?
        /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
        public var serviceExecutionRoleArn: Swift.String?
        /// The worker configurations that are in use with the connector.
        public var workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription?

        public init(
            capacity: KafkaConnectClientTypes.CapacityDescription? = nil,
            connectorArn: Swift.String? = nil,
            connectorDescription: Swift.String? = nil,
            connectorName: Swift.String? = nil,
            connectorState: KafkaConnectClientTypes.ConnectorState? = nil,
            creationTime: Foundation.Date? = nil,
            currentVersion: Swift.String? = nil,
            kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription? = nil,
            kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription? = nil,
            kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription? = nil,
            kafkaConnectVersion: Swift.String? = nil,
            logDelivery: KafkaConnectClientTypes.LogDeliveryDescription? = nil,
            plugins: [KafkaConnectClientTypes.PluginDescription]? = nil,
            serviceExecutionRoleArn: Swift.String? = nil,
            workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription? = nil
        )
        {
            self.capacity = capacity
            self.connectorArn = connectorArn
            self.connectorDescription = connectorDescription
            self.connectorName = connectorName
            self.connectorState = connectorState
            self.creationTime = creationTime
            self.currentVersion = currentVersion
            self.kafkaCluster = kafkaCluster
            self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
            self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
            self.kafkaConnectVersion = kafkaConnectVersion
            self.logDelivery = logDelivery
            self.plugins = plugins
            self.serviceExecutionRoleArn = serviceExecutionRoleArn
            self.workerConfiguration = workerConfiguration
        }
    }

}

extension KafkaConnectClientTypes {

    public enum CustomPluginState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case creating
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomPluginState] {
            return [
                .active,
                .createFailed,
                .creating,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {

    public enum CustomPluginContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jar
        case zip
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomPluginContentType] {
            return [
                .jar,
                .zip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jar: return "JAR"
            case .zip: return "ZIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {
    /// Details about a custom plugin file.
    public struct CustomPluginFileDescription {
        /// The hex-encoded MD5 checksum of the custom plugin file. You can use it to validate the file.
        public var fileMd5: Swift.String?
        /// The size in bytes of the custom plugin file. You can use it to validate the file.
        public var fileSize: Swift.Int

        public init(
            fileMd5: Swift.String? = nil,
            fileSize: Swift.Int = 0
        )
        {
            self.fileMd5 = fileMd5
            self.fileSize = fileSize
        }
    }

}

extension KafkaConnectClientTypes {
    /// The description of the location of an object in Amazon S3.
    public struct S3LocationDescription {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        public var bucketArn: Swift.String?
        /// The file key for an object in an S3 bucket.
        public var fileKey: Swift.String?
        /// The version of an object in an S3 bucket.
        public var objectVersion: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KafkaConnectClientTypes {
    /// Information about the location of a custom plugin.
    public struct CustomPluginLocationDescription {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        public var s3Location: KafkaConnectClientTypes.S3LocationDescription?

        public init(
            s3Location: KafkaConnectClientTypes.S3LocationDescription? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details about the revision of a custom plugin.
    public struct CustomPluginRevisionSummary {
        /// The format of the plugin file.
        public var contentType: KafkaConnectClientTypes.CustomPluginContentType?
        /// The time that the custom plugin was created.
        public var creationTime: Foundation.Date?
        /// The description of the custom plugin.
        public var description: Swift.String?
        /// Details about the custom plugin file.
        public var fileDescription: KafkaConnectClientTypes.CustomPluginFileDescription?
        /// Information about the location of the custom plugin.
        public var location: KafkaConnectClientTypes.CustomPluginLocationDescription?
        /// The revision of the custom plugin.
        public var revision: Swift.Int

        public init(
            contentType: KafkaConnectClientTypes.CustomPluginContentType? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            fileDescription: KafkaConnectClientTypes.CustomPluginFileDescription? = nil,
            location: KafkaConnectClientTypes.CustomPluginLocationDescription? = nil,
            revision: Swift.Int = 0
        )
        {
            self.contentType = contentType
            self.creationTime = creationTime
            self.description = description
            self.fileDescription = fileDescription
            self.location = location
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {
    /// A summary of the custom plugin.
    public struct CustomPluginSummary {
        /// The time that the custom plugin was created.
        public var creationTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the custom plugin.
        public var customPluginArn: Swift.String?
        /// The state of the custom plugin.
        public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
        /// A description of the custom plugin.
        public var description: Swift.String?
        /// The latest revision of the custom plugin.
        public var latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary?
        /// The name of the custom plugin.
        public var name: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            customPluginArn: Swift.String? = nil,
            customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
            description: Swift.String? = nil,
            latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.customPluginArn = customPluginArn
            self.customPluginState = customPluginState
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
        }
    }

}

extension KafkaConnectClientTypes {
    /// A plugin is an Amazon Web Services resource that contains the code that defines a connector's logic.
    public struct CustomPlugin {
        /// The Amazon Resource Name (ARN) of the custom plugin.
        /// This member is required.
        public var customPluginArn: Swift.String?
        /// The revision of the custom plugin.
        /// This member is required.
        public var revision: Swift.Int

        public init(
            customPluginArn: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.customPluginArn = customPluginArn
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {
    /// A plugin is an Amazon Web Services resource that contains the code that defines your connector logic.
    public struct Plugin {
        /// Details about a custom plugin.
        /// This member is required.
        public var customPlugin: KafkaConnectClientTypes.CustomPlugin?

        public init(
            customPlugin: KafkaConnectClientTypes.CustomPlugin? = nil
        )
        {
            self.customPlugin = customPlugin
        }
    }

}

extension KafkaConnectClientTypes {
    /// The summary of a worker configuration revision.
    public struct WorkerConfigurationRevisionSummary {
        /// The time that a worker configuration revision was created.
        public var creationTime: Foundation.Date?
        /// The description of a worker configuration revision.
        public var description: Swift.String?
        /// The revision of a worker configuration.
        public var revision: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes {

    public enum WorkerConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkerConfigurationState] {
            return [
                .active,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KafkaConnectClientTypes {
    /// The summary of a worker configuration.
    public struct WorkerConfigurationSummary {
        /// The time that a worker configuration was created.
        public var creationTime: Foundation.Date?
        /// The description of a worker configuration.
        public var description: Swift.String?
        /// The latest revision of a worker configuration.
        public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary?
        /// The name of the worker configuration.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the worker configuration.
        public var workerConfigurationArn: Swift.String?
        /// The state of the worker configuration.
        public var workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState?

        public init(
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary? = nil,
            name: Swift.String? = nil,
            workerConfigurationArn: Swift.String? = nil,
            workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.latestRevision = latestRevision
            self.name = name
            self.workerConfigurationArn = workerConfigurationArn
            self.workerConfigurationState = workerConfigurationState
        }
    }

}

extension KafkaConnectClientTypes {
    /// Information about the VPC in which the connector resides.
    public struct Vpc {
        /// The security groups for the connector.
        public var securityGroups: [Swift.String]?
        /// The subnets for the connector.
        /// This member is required.
        public var subnets: [Swift.String]?

        public init(
            securityGroups: [Swift.String]? = nil,
            subnets: [Swift.String]? = nil
        )
        {
            self.securityGroups = securityGroups
            self.subnets = subnets
        }
    }

}

extension KafkaConnectClientTypes {
    /// The details of the Apache Kafka cluster to which the connector is connected.
    public struct ApacheKafkaCluster {
        /// The bootstrap servers of the cluster.
        /// This member is required.
        public var bootstrapServers: Swift.String?
        /// Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        /// This member is required.
        public var vpc: KafkaConnectClientTypes.Vpc?

        public init(
            bootstrapServers: Swift.String? = nil,
            vpc: KafkaConnectClientTypes.Vpc? = nil
        )
        {
            self.bootstrapServers = bootstrapServers
            self.vpc = vpc
        }
    }

}

extension KafkaConnectClientTypes {
    /// The scale-in policy for the connector.
    public struct ScaleInPolicy {
        /// Specifies the CPU utilization percentage threshold at which you want connector scale in to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// The scale-out policy for the connector.
    public struct ScaleOutPolicy {
        /// The CPU utilization percentage threshold at which you want connector scale out to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// Specifies how the connector scales.
    public struct AutoScaling {
        /// The maximum number of workers allocated to the connector.
        /// This member is required.
        public var maxWorkerCount: Swift.Int
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The minimum number of workers allocated to the connector.
        /// This member is required.
        public var minWorkerCount: Swift.Int
        /// The sacle-in policy for the connector.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicy?
        /// The sacle-out policy for the connector.
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicy?

        public init(
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicy? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicy? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

extension KafkaConnectClientTypes {
    /// An update to the connector's scale-in policy.
    public struct ScaleInPolicyUpdate {
        /// The target CPU utilization percentage threshold at which you want connector scale in to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// An update to the connector's scale-out policy.
    public struct ScaleOutPolicyUpdate {
        /// The target CPU utilization percentage threshold at which you want connector scale out to be triggered.
        /// This member is required.
        public var cpuUtilizationPercentage: Swift.Int

        public init(
            cpuUtilizationPercentage: Swift.Int = 0
        )
        {
            self.cpuUtilizationPercentage = cpuUtilizationPercentage
        }
    }

}

extension KafkaConnectClientTypes {
    /// The updates to the auto scaling parameters for the connector.
    public struct AutoScalingUpdate {
        /// The target maximum number of workers allocated to the connector.
        /// This member is required.
        public var maxWorkerCount: Swift.Int
        /// The target number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The target minimum number of workers allocated to the connector.
        /// This member is required.
        public var minWorkerCount: Swift.Int
        /// The target sacle-in policy for the connector.
        /// This member is required.
        public var scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyUpdate?
        /// The target sacle-out policy for the connector.
        /// This member is required.
        public var scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyUpdate?

        public init(
            maxWorkerCount: Swift.Int = 0,
            mcuCount: Swift.Int = 0,
            minWorkerCount: Swift.Int = 0,
            scaleInPolicy: KafkaConnectClientTypes.ScaleInPolicyUpdate? = nil,
            scaleOutPolicy: KafkaConnectClientTypes.ScaleOutPolicyUpdate? = nil
        )
        {
            self.maxWorkerCount = maxWorkerCount
            self.mcuCount = mcuCount
            self.minWorkerCount = minWorkerCount
            self.scaleInPolicy = scaleInPolicy
            self.scaleOutPolicy = scaleOutPolicy
        }
    }

}

/// HTTP Status Code 400: Bad request due to incorrect input. Correct your request and then retry it.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KafkaConnectClientTypes {
    /// Details about a connector's provisioned capacity.
    public struct ProvisionedCapacity {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        /// This member is required.
        public var workerCount: Swift.Int

        public init(
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes {
    /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
    public struct Capacity {
        /// Information about the auto scaling parameters for the connector.
        public var autoScaling: KafkaConnectClientTypes.AutoScaling?
        /// Details about a fixed capacity allocated to a connector.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacity?

        public init(
            autoScaling: KafkaConnectClientTypes.AutoScaling? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacity? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes {
    /// An update to a connector's fixed capacity.
    public struct ProvisionedCapacityUpdate {
        /// The number of microcontroller units (MCUs) allocated to each connector worker. The valid values are 1,2,4,8.
        /// This member is required.
        public var mcuCount: Swift.Int
        /// The number of workers that are allocated to the connector.
        /// This member is required.
        public var workerCount: Swift.Int

        public init(
            mcuCount: Swift.Int = 0,
            workerCount: Swift.Int = 0
        )
        {
            self.mcuCount = mcuCount
            self.workerCount = workerCount
        }
    }

}

extension KafkaConnectClientTypes {
    /// The target capacity for the connector. The capacity can be auto scaled or provisioned.
    public struct CapacityUpdate {
        /// The target auto scaling setting.
        public var autoScaling: KafkaConnectClientTypes.AutoScalingUpdate?
        /// The target settings for provisioned capacity.
        public var provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityUpdate?

        public init(
            autoScaling: KafkaConnectClientTypes.AutoScalingUpdate? = nil,
            provisionedCapacity: KafkaConnectClientTypes.ProvisionedCapacityUpdate? = nil
        )
        {
            self.autoScaling = autoScaling
            self.provisionedCapacity = provisionedCapacity
        }
    }

}

extension KafkaConnectClientTypes {
    /// The settings for delivering connector logs to Amazon CloudWatch Logs.
    public struct CloudWatchLogsLogDelivery {
        /// Whether log delivery to Amazon CloudWatch Logs is enabled.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The name of the CloudWatch log group that is the destination for log delivery.
        public var logGroup: Swift.String?

        public init(
            enabled: Swift.Bool = false,
            logGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.logGroup = logGroup
        }
    }

}

/// HTTP Status Code 409: Conflict. A resource with this name already exists. Retry your request with another name.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 403: Access forbidden. Correct your credentials and then retry your request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 500: Unexpected internal server error. Retrying your request might resolve the issue.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 404: Resource not found due to incorrect input. Correct your request and then retry it.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 503: Service Unavailable. Retrying your request in some time might resolve the issue.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 429: Limit exceeded. Resource limit reached.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// HTTP Status Code 401: Unauthorized request. The provided credentials couldn't be validated.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KafkaConnectClientTypes {
    /// The details of the Apache Kafka cluster to which the connector is connected.
    public struct KafkaCluster {
        /// The Apache Kafka cluster to which the connector is connected.
        /// This member is required.
        public var apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaCluster?

        public init(
            apacheKafkaCluster: KafkaConnectClientTypes.ApacheKafkaCluster? = nil
        )
        {
            self.apacheKafkaCluster = apacheKafkaCluster
        }
    }

}

extension KafkaConnectClientTypes {
    /// The client authentication information used in order to authenticate with the Apache Kafka cluster.
    public struct KafkaClusterClientAuthentication {
        /// The type of client authentication used to connect to the Apache Kafka cluster. Value NONE means that no client authentication is used.
        /// This member is required.
        public var authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType?

        public init(
            authenticationType: KafkaConnectClientTypes.KafkaClusterClientAuthenticationType? = nil
        )
        {
            self.authenticationType = authenticationType
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details of encryption in transit to the Apache Kafka cluster.
    public struct KafkaClusterEncryptionInTransit {
        /// The type of encryption in transit to the Apache Kafka cluster.
        /// This member is required.
        public var encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType?

        public init(
            encryptionType: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitType? = nil
        )
        {
            self.encryptionType = encryptionType
        }
    }

}

extension KafkaConnectClientTypes {
    /// The settings for delivering logs to Amazon Kinesis Data Firehose.
    public struct FirehoseLogDelivery {
        /// The name of the Kinesis Data Firehose delivery stream that is the destination for log delivery.
        public var deliveryStream: Swift.String?
        /// Specifies whether connector logs get delivered to Amazon Kinesis Data Firehose.
        /// This member is required.
        public var enabled: Swift.Bool

        public init(
            deliveryStream: Swift.String? = nil,
            enabled: Swift.Bool = false
        )
        {
            self.deliveryStream = deliveryStream
            self.enabled = enabled
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details about delivering logs to Amazon S3.
    public struct S3LogDelivery {
        /// The name of the S3 bucket that is the destination for log delivery.
        public var bucket: Swift.String?
        /// Specifies whether connector logs get sent to the specified Amazon S3 destination.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The S3 prefix that is the destination for log delivery.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            enabled: Swift.Bool = false,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.enabled = enabled
            self.`prefix` = `prefix`
        }
    }

}

extension KafkaConnectClientTypes {
    /// Workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
    public struct WorkerLogDelivery {
        /// Details about delivering logs to Amazon CloudWatch Logs.
        public var cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDelivery?
        /// Details about delivering logs to Amazon Kinesis Data Firehose.
        public var firehose: KafkaConnectClientTypes.FirehoseLogDelivery?
        /// Details about delivering logs to Amazon S3.
        public var s3: KafkaConnectClientTypes.S3LogDelivery?

        public init(
            cloudWatchLogs: KafkaConnectClientTypes.CloudWatchLogsLogDelivery? = nil,
            firehose: KafkaConnectClientTypes.FirehoseLogDelivery? = nil,
            s3: KafkaConnectClientTypes.S3LogDelivery? = nil
        )
        {
            self.cloudWatchLogs = cloudWatchLogs
            self.firehose = firehose
            self.s3 = s3
        }
    }

}

extension KafkaConnectClientTypes {
    /// Details about log delivery.
    public struct LogDelivery {
        /// The workers can send worker logs to different destination types. This configuration specifies the details of these destinations.
        /// This member is required.
        public var workerLogDelivery: KafkaConnectClientTypes.WorkerLogDelivery?

        public init(
            workerLogDelivery: KafkaConnectClientTypes.WorkerLogDelivery? = nil
        )
        {
            self.workerLogDelivery = workerLogDelivery
        }
    }

}

extension KafkaConnectClientTypes {
    /// The configuration of the workers, which are the processes that run the connector logic.
    public struct WorkerConfiguration {
        /// The revision of the worker configuration.
        /// This member is required.
        public var revision: Swift.Int
        /// The Amazon Resource Name (ARN) of the worker configuration.
        /// This member is required.
        public var workerConfigurationArn: Swift.String?

        public init(
            revision: Swift.Int = 0,
            workerConfigurationArn: Swift.String? = nil
        )
        {
            self.revision = revision
            self.workerConfigurationArn = workerConfigurationArn
        }
    }

}

public struct CreateConnectorInput {
    /// Information about the capacity allocated to the connector. Exactly one of the two properties must be specified.
    /// This member is required.
    public var capacity: KafkaConnectClientTypes.Capacity?
    /// A map of keys to values that represent the configuration for the connector.
    /// This member is required.
    public var connectorConfiguration: [Swift.String: Swift.String]?
    /// A summary description of the connector.
    public var connectorDescription: Swift.String?
    /// The name of the connector.
    /// This member is required.
    public var connectorName: Swift.String?
    /// Specifies which Apache Kafka cluster to connect to.
    /// This member is required.
    public var kafkaCluster: KafkaConnectClientTypes.KafkaCluster?
    /// Details of the client authentication used by the Apache Kafka cluster.
    /// This member is required.
    public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthentication?
    /// Details of encryption in transit to the Apache Kafka cluster.
    /// This member is required.
    public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit?
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    /// This member is required.
    public var kafkaConnectVersion: Swift.String?
    /// Details about log delivery.
    public var logDelivery: KafkaConnectClientTypes.LogDelivery?
    /// Amazon MSK Connect does not currently support specifying multiple plugins as a list. To use more than one plugin for your connector, you can create a single custom plugin using a ZIP file that bundles multiple plugins together. Specifies which plugin to use for the connector. You must specify a single-element list containing one customPlugin object.
    /// This member is required.
    public var plugins: [KafkaConnectClientTypes.Plugin]?
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access the Amazon Web Services resources that it needs. The types of resources depends on the logic of the connector. For example, a connector that has Amazon S3 as a destination must have permissions that allow it to write to the S3 destination bucket.
    /// This member is required.
    public var serviceExecutionRoleArn: Swift.String?
    /// The tags you want to attach to the connector.
    public var tags: [Swift.String: Swift.String]?
    /// Specifies which worker configuration to use with the connector.
    public var workerConfiguration: KafkaConnectClientTypes.WorkerConfiguration?

    public init(
        capacity: KafkaConnectClientTypes.Capacity? = nil,
        connectorConfiguration: [Swift.String: Swift.String]? = nil,
        connectorDescription: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        kafkaCluster: KafkaConnectClientTypes.KafkaCluster? = nil,
        kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthentication? = nil,
        kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit? = nil,
        kafkaConnectVersion: Swift.String? = nil,
        logDelivery: KafkaConnectClientTypes.LogDelivery? = nil,
        plugins: [KafkaConnectClientTypes.Plugin]? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workerConfiguration: KafkaConnectClientTypes.WorkerConfiguration? = nil
    )
    {
        self.capacity = capacity
        self.connectorConfiguration = connectorConfiguration
        self.connectorDescription = connectorDescription
        self.connectorName = connectorName
        self.kafkaCluster = kafkaCluster
        self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
        self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
        self.kafkaConnectVersion = kafkaConnectVersion
        self.logDelivery = logDelivery
        self.plugins = plugins
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.tags = tags
        self.workerConfiguration = workerConfiguration
    }
}

extension CreateConnectorInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectorInput(capacity: \(Swift.String(describing: capacity)), connectorDescription: \(Swift.String(describing: connectorDescription)), connectorName: \(Swift.String(describing: connectorName)), kafkaCluster: \(Swift.String(describing: kafkaCluster)), kafkaClusterClientAuthentication: \(Swift.String(describing: kafkaClusterClientAuthentication)), kafkaClusterEncryptionInTransit: \(Swift.String(describing: kafkaClusterEncryptionInTransit)), kafkaConnectVersion: \(Swift.String(describing: kafkaConnectVersion)), logDelivery: \(Swift.String(describing: logDelivery)), plugins: \(Swift.String(describing: plugins)), serviceExecutionRoleArn: \(Swift.String(describing: serviceExecutionRoleArn)), tags: \(Swift.String(describing: tags)), workerConfiguration: \(Swift.String(describing: workerConfiguration)), connectorConfiguration: \"CONTENT_REDACTED\")"}
}

public struct CreateConnectorOutput {
    /// The Amazon Resource Name (ARN) that Amazon assigned to the connector.
    public var connectorArn: Swift.String?
    /// The name of the connector.
    public var connectorName: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init(
        connectorArn: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorName = connectorName
        self.connectorState = connectorState
    }
}

extension KafkaConnectClientTypes {
    /// The location of an object in Amazon S3.
    public struct S3Location {
        /// The Amazon Resource Name (ARN) of an S3 bucket.
        /// This member is required.
        public var bucketArn: Swift.String?
        /// The file key for an object in an S3 bucket.
        /// This member is required.
        public var fileKey: Swift.String?
        /// The version of an object in an S3 bucket.
        public var objectVersion: Swift.String?

        public init(
            bucketArn: Swift.String? = nil,
            fileKey: Swift.String? = nil,
            objectVersion: Swift.String? = nil
        )
        {
            self.bucketArn = bucketArn
            self.fileKey = fileKey
            self.objectVersion = objectVersion
        }
    }

}

extension KafkaConnectClientTypes {
    /// Information about the location of a custom plugin.
    public struct CustomPluginLocation {
        /// The S3 bucket Amazon Resource Name (ARN), file key, and object version of the plugin file stored in Amazon S3.
        /// This member is required.
        public var s3Location: KafkaConnectClientTypes.S3Location?

        public init(
            s3Location: KafkaConnectClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

public struct CreateCustomPluginInput {
    /// The type of the plugin file.
    /// This member is required.
    public var contentType: KafkaConnectClientTypes.CustomPluginContentType?
    /// A summary description of the custom plugin.
    public var description: Swift.String?
    /// Information about the location of a custom plugin.
    /// This member is required.
    public var location: KafkaConnectClientTypes.CustomPluginLocation?
    /// The name of the custom plugin.
    /// This member is required.
    public var name: Swift.String?
    /// The tags you want to attach to the custom plugin.
    public var tags: [Swift.String: Swift.String]?

    public init(
        contentType: KafkaConnectClientTypes.CustomPluginContentType? = nil,
        description: Swift.String? = nil,
        location: KafkaConnectClientTypes.CustomPluginLocation? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.contentType = contentType
        self.description = description
        self.location = location
        self.name = name
        self.tags = tags
    }
}

public struct CreateCustomPluginOutput {
    /// The Amazon Resource Name (ARN) that Amazon assigned to the custom plugin.
    public var customPluginArn: Swift.String?
    /// The state of the custom plugin.
    public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
    /// The name of the custom plugin.
    public var name: Swift.String?
    /// The revision of the custom plugin.
    public var revision: Swift.Int

    public init(
        customPluginArn: Swift.String? = nil,
        customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
        name: Swift.String? = nil,
        revision: Swift.Int = 0
    )
    {
        self.customPluginArn = customPluginArn
        self.customPluginState = customPluginState
        self.name = name
        self.revision = revision
    }
}

public struct CreateWorkerConfigurationInput {
    /// A summary description of the worker configuration.
    public var description: Swift.String?
    /// The name of the worker configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Base64 encoded contents of connect-distributed.properties file.
    /// This member is required.
    public var propertiesFileContent: Swift.String?
    /// The tags you want to attach to the worker configuration.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        propertiesFileContent: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.propertiesFileContent = propertiesFileContent
        self.tags = tags
    }
}

extension CreateWorkerConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkerConfigurationInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), propertiesFileContent: \"CONTENT_REDACTED\")"}
}

public struct CreateWorkerConfigurationOutput {
    /// The time that the worker configuration was created.
    public var creationTime: Foundation.Date?
    /// The latest revision of the worker configuration.
    public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary?
    /// The name of the worker configuration.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) that Amazon assigned to the worker configuration.
    public var workerConfigurationArn: Swift.String?
    /// The state of the worker configuration.
    public var workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState?

    public init(
        creationTime: Foundation.Date? = nil,
        latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary? = nil,
        name: Swift.String? = nil,
        workerConfigurationArn: Swift.String? = nil,
        workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState? = nil
    )
    {
        self.creationTime = creationTime
        self.latestRevision = latestRevision
        self.name = name
        self.workerConfigurationArn = workerConfigurationArn
        self.workerConfigurationState = workerConfigurationState
    }
}

public struct DeleteConnectorInput {
    /// The Amazon Resource Name (ARN) of the connector that you want to delete.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The current version of the connector that you want to delete.
    public var currentVersion: Swift.String?

    public init(
        connectorArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
        self.currentVersion = currentVersion
    }
}

public struct DeleteConnectorOutput {
    /// The Amazon Resource Name (ARN) of the connector that you requested to delete.
    public var connectorArn: Swift.String?
    /// The state of the connector that you requested to delete.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init(
        connectorArn: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorState = connectorState
    }
}

public struct DeleteCustomPluginInput {
    /// The Amazon Resource Name (ARN) of the custom plugin that you want to delete.
    /// This member is required.
    public var customPluginArn: Swift.String?

    public init(
        customPluginArn: Swift.String? = nil
    )
    {
        self.customPluginArn = customPluginArn
    }
}

public struct DeleteCustomPluginOutput {
    /// The Amazon Resource Name (ARN) of the custom plugin that you requested to delete.
    public var customPluginArn: Swift.String?
    /// The state of the custom plugin.
    public var customPluginState: KafkaConnectClientTypes.CustomPluginState?

    public init(
        customPluginArn: Swift.String? = nil,
        customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil
    )
    {
        self.customPluginArn = customPluginArn
        self.customPluginState = customPluginState
    }
}

public struct DeleteWorkerConfigurationInput {
    /// The Amazon Resource Name (ARN) of the worker configuration that you want to delete.
    /// This member is required.
    public var workerConfigurationArn: Swift.String?

    public init(
        workerConfigurationArn: Swift.String? = nil
    )
    {
        self.workerConfigurationArn = workerConfigurationArn
    }
}

public struct DeleteWorkerConfigurationOutput {
    /// The Amazon Resource Name (ARN) of the worker configuration that you requested to delete.
    public var workerConfigurationArn: Swift.String?
    /// The state of the worker configuration.
    public var workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState?

    public init(
        workerConfigurationArn: Swift.String? = nil,
        workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState? = nil
    )
    {
        self.workerConfigurationArn = workerConfigurationArn
        self.workerConfigurationState = workerConfigurationState
    }
}

public struct DescribeConnectorInput {
    /// The Amazon Resource Name (ARN) of the connector that you want to describe.
    /// This member is required.
    public var connectorArn: Swift.String?

    public init(
        connectorArn: Swift.String? = nil
    )
    {
        self.connectorArn = connectorArn
    }
}

extension KafkaConnectClientTypes {
    /// Details about the state of a resource.
    public struct StateDescription {
        /// A code that describes the state of a resource.
        public var code: Swift.String?
        /// A message that describes the state of a resource.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

public struct DescribeConnectorOutput {
    /// Information about the capacity of the connector, whether it is auto scaled or provisioned.
    public var capacity: KafkaConnectClientTypes.CapacityDescription?
    /// The Amazon Resource Name (ARN) of the connector.
    public var connectorArn: Swift.String?
    /// A map of keys to values that represent the configuration for the connector.
    public var connectorConfiguration: [Swift.String: Swift.String]?
    /// A summary description of the connector.
    public var connectorDescription: Swift.String?
    /// The name of the connector.
    public var connectorName: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?
    /// The time the connector was created.
    public var creationTime: Foundation.Date?
    /// The current version of the connector.
    public var currentVersion: Swift.String?
    /// The Apache Kafka cluster that the connector is connected to.
    public var kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription?
    /// The type of client authentication used to connect to the Apache Kafka cluster. The value is NONE when no client authentication is used.
    public var kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription?
    /// Details of encryption in transit to the Apache Kafka cluster.
    public var kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription?
    /// The version of Kafka Connect. It has to be compatible with both the Apache Kafka cluster's version and the plugins.
    public var kafkaConnectVersion: Swift.String?
    /// Details about delivering logs to Amazon CloudWatch Logs.
    public var logDelivery: KafkaConnectClientTypes.LogDeliveryDescription?
    /// Specifies which plugins were used for this connector.
    public var plugins: [KafkaConnectClientTypes.PluginDescription]?
    /// The Amazon Resource Name (ARN) of the IAM role used by the connector to access Amazon Web Services resources.
    public var serviceExecutionRoleArn: Swift.String?
    /// Details about the state of a connector.
    public var stateDescription: KafkaConnectClientTypes.StateDescription?
    /// Specifies which worker configuration was used for the connector.
    public var workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription?

    public init(
        capacity: KafkaConnectClientTypes.CapacityDescription? = nil,
        connectorArn: Swift.String? = nil,
        connectorConfiguration: [Swift.String: Swift.String]? = nil,
        connectorDescription: Swift.String? = nil,
        connectorName: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil,
        creationTime: Foundation.Date? = nil,
        currentVersion: Swift.String? = nil,
        kafkaCluster: KafkaConnectClientTypes.KafkaClusterDescription? = nil,
        kafkaClusterClientAuthentication: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription? = nil,
        kafkaClusterEncryptionInTransit: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription? = nil,
        kafkaConnectVersion: Swift.String? = nil,
        logDelivery: KafkaConnectClientTypes.LogDeliveryDescription? = nil,
        plugins: [KafkaConnectClientTypes.PluginDescription]? = nil,
        serviceExecutionRoleArn: Swift.String? = nil,
        stateDescription: KafkaConnectClientTypes.StateDescription? = nil,
        workerConfiguration: KafkaConnectClientTypes.WorkerConfigurationDescription? = nil
    )
    {
        self.capacity = capacity
        self.connectorArn = connectorArn
        self.connectorConfiguration = connectorConfiguration
        self.connectorDescription = connectorDescription
        self.connectorName = connectorName
        self.connectorState = connectorState
        self.creationTime = creationTime
        self.currentVersion = currentVersion
        self.kafkaCluster = kafkaCluster
        self.kafkaClusterClientAuthentication = kafkaClusterClientAuthentication
        self.kafkaClusterEncryptionInTransit = kafkaClusterEncryptionInTransit
        self.kafkaConnectVersion = kafkaConnectVersion
        self.logDelivery = logDelivery
        self.plugins = plugins
        self.serviceExecutionRoleArn = serviceExecutionRoleArn
        self.stateDescription = stateDescription
        self.workerConfiguration = workerConfiguration
    }
}

extension DescribeConnectorOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConnectorOutput(capacity: \(Swift.String(describing: capacity)), connectorArn: \(Swift.String(describing: connectorArn)), connectorDescription: \(Swift.String(describing: connectorDescription)), connectorName: \(Swift.String(describing: connectorName)), connectorState: \(Swift.String(describing: connectorState)), creationTime: \(Swift.String(describing: creationTime)), currentVersion: \(Swift.String(describing: currentVersion)), kafkaCluster: \(Swift.String(describing: kafkaCluster)), kafkaClusterClientAuthentication: \(Swift.String(describing: kafkaClusterClientAuthentication)), kafkaClusterEncryptionInTransit: \(Swift.String(describing: kafkaClusterEncryptionInTransit)), kafkaConnectVersion: \(Swift.String(describing: kafkaConnectVersion)), logDelivery: \(Swift.String(describing: logDelivery)), plugins: \(Swift.String(describing: plugins)), serviceExecutionRoleArn: \(Swift.String(describing: serviceExecutionRoleArn)), stateDescription: \(Swift.String(describing: stateDescription)), workerConfiguration: \(Swift.String(describing: workerConfiguration)), connectorConfiguration: \"CONTENT_REDACTED\")"}
}

public struct DescribeCustomPluginInput {
    /// Returns information about a custom plugin.
    /// This member is required.
    public var customPluginArn: Swift.String?

    public init(
        customPluginArn: Swift.String? = nil
    )
    {
        self.customPluginArn = customPluginArn
    }
}

public struct DescribeCustomPluginOutput {
    /// The time that the custom plugin was created.
    public var creationTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the custom plugin.
    public var customPluginArn: Swift.String?
    /// The state of the custom plugin.
    public var customPluginState: KafkaConnectClientTypes.CustomPluginState?
    /// The description of the custom plugin.
    public var description: Swift.String?
    /// The latest successfully created revision of the custom plugin. If there are no successfully created revisions, this field will be absent.
    public var latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary?
    /// The name of the custom plugin.
    public var name: Swift.String?
    /// Details about the state of a custom plugin.
    public var stateDescription: KafkaConnectClientTypes.StateDescription?

    public init(
        creationTime: Foundation.Date? = nil,
        customPluginArn: Swift.String? = nil,
        customPluginState: KafkaConnectClientTypes.CustomPluginState? = nil,
        description: Swift.String? = nil,
        latestRevision: KafkaConnectClientTypes.CustomPluginRevisionSummary? = nil,
        name: Swift.String? = nil,
        stateDescription: KafkaConnectClientTypes.StateDescription? = nil
    )
    {
        self.creationTime = creationTime
        self.customPluginArn = customPluginArn
        self.customPluginState = customPluginState
        self.description = description
        self.latestRevision = latestRevision
        self.name = name
        self.stateDescription = stateDescription
    }
}

public struct DescribeWorkerConfigurationInput {
    /// The Amazon Resource Name (ARN) of the worker configuration that you want to get information about.
    /// This member is required.
    public var workerConfigurationArn: Swift.String?

    public init(
        workerConfigurationArn: Swift.String? = nil
    )
    {
        self.workerConfigurationArn = workerConfigurationArn
    }
}

extension KafkaConnectClientTypes {
    /// The description of the worker configuration revision.
    public struct WorkerConfigurationRevisionDescription {
        /// The time that the worker configuration was created.
        public var creationTime: Foundation.Date?
        /// The description of the worker configuration revision.
        public var description: Swift.String?
        /// Base64 encoded contents of the connect-distributed.properties file.
        public var propertiesFileContent: Swift.String?
        /// The description of a revision of the worker configuration.
        public var revision: Swift.Int

        public init(
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            propertiesFileContent: Swift.String? = nil,
            revision: Swift.Int = 0
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.propertiesFileContent = propertiesFileContent
            self.revision = revision
        }
    }

}

extension KafkaConnectClientTypes.WorkerConfigurationRevisionDescription: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WorkerConfigurationRevisionDescription(creationTime: \(Swift.String(describing: creationTime)), description: \(Swift.String(describing: description)), revision: \(Swift.String(describing: revision)), propertiesFileContent: \"CONTENT_REDACTED\")"}
}

public struct DescribeWorkerConfigurationOutput {
    /// The time that the worker configuration was created.
    public var creationTime: Foundation.Date?
    /// The description of the worker configuration.
    public var description: Swift.String?
    /// The latest revision of the custom configuration.
    public var latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription?
    /// The name of the worker configuration.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the custom configuration.
    public var workerConfigurationArn: Swift.String?
    /// The state of the worker configuration.
    public var workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState?

    public init(
        creationTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        latestRevision: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription? = nil,
        name: Swift.String? = nil,
        workerConfigurationArn: Swift.String? = nil,
        workerConfigurationState: KafkaConnectClientTypes.WorkerConfigurationState? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.latestRevision = latestRevision
        self.name = name
        self.workerConfigurationArn = workerConfigurationArn
        self.workerConfigurationState = workerConfigurationState
    }
}

public struct ListConnectorsInput {
    /// The name prefix that you want to use to search for and list connectors.
    public var connectorNamePrefix: Swift.String?
    /// The maximum number of connectors to list in one response.
    public var maxResults: Swift.Int
    /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init(
        connectorNamePrefix: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorNamePrefix = connectorNamePrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorsOutput {
    /// An array of connector descriptions.
    public var connectors: [KafkaConnectClientTypes.ConnectorSummary]?
    /// If the response of a ListConnectors operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where it left off.
    public var nextToken: Swift.String?

    public init(
        connectors: [KafkaConnectClientTypes.ConnectorSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectors = connectors
        self.nextToken = nextToken
    }
}

public struct ListCustomPluginsInput {
    /// The maximum number of custom plugins to list in one response.
    public var maxResults: Swift.Int
    /// Lists custom plugin names that start with the specified text string.
    public var namePrefix: Swift.String?
    /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

public struct ListCustomPluginsOutput {
    /// An array of custom plugin descriptions.
    public var customPlugins: [KafkaConnectClientTypes.CustomPluginSummary]?
    /// If the response of a ListCustomPlugins operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init(
        customPlugins: [KafkaConnectClientTypes.CustomPluginSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customPlugins = customPlugins
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which you want to list all attached tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// Lists the tags attached to the specified resource in the corresponding request.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListWorkerConfigurationsInput {
    /// The maximum number of worker configurations to list in one response.
    public var maxResults: Swift.Int
    /// Lists worker configuration names that start with the specified text string.
    public var namePrefix: Swift.String?
    /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        namePrefix: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

public struct ListWorkerConfigurationsOutput {
    /// If the response of a ListWorkerConfigurations operation is truncated, it will include a NextToken. Send this NextToken in a subsequent request to continue listing from where the previous operation left off.
    public var nextToken: Swift.String?
    /// An array of worker configuration descriptions.
    public var workerConfigurations: [KafkaConnectClientTypes.WorkerConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workerConfigurations: [KafkaConnectClientTypes.WorkerConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workerConfigurations = workerConfigurations
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource to which you want to attach tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags that you want to attach to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource from which you want to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateConnectorInput {
    /// The target capacity.
    /// This member is required.
    public var capacity: KafkaConnectClientTypes.CapacityUpdate?
    /// The Amazon Resource Name (ARN) of the connector that you want to update.
    /// This member is required.
    public var connectorArn: Swift.String?
    /// The current version of the connector that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?

    public init(
        capacity: KafkaConnectClientTypes.CapacityUpdate? = nil,
        connectorArn: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.capacity = capacity
        self.connectorArn = connectorArn
        self.currentVersion = currentVersion
    }
}

public struct UpdateConnectorOutput {
    /// The Amazon Resource Name (ARN) of the connector.
    public var connectorArn: Swift.String?
    /// The state of the connector.
    public var connectorState: KafkaConnectClientTypes.ConnectorState?

    public init(
        connectorArn: Swift.String? = nil,
        connectorState: KafkaConnectClientTypes.ConnectorState? = nil
    )
    {
        self.connectorArn = connectorArn
        self.connectorState = connectorState
    }
}

extension CreateConnectorInput {

    static func urlPathProvider(_ value: CreateConnectorInput) -> Swift.String? {
        return "/v1/connectors"
    }
}

extension CreateCustomPluginInput {

    static func urlPathProvider(_ value: CreateCustomPluginInput) -> Swift.String? {
        return "/v1/custom-plugins"
    }
}

extension CreateWorkerConfigurationInput {

    static func urlPathProvider(_ value: CreateWorkerConfigurationInput) -> Swift.String? {
        return "/v1/worker-configurations"
    }
}

extension DeleteConnectorInput {

    static func urlPathProvider(_ value: DeleteConnectorInput) -> Swift.String? {
        guard let connectorArn = value.connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

extension DeleteConnectorInput {

    static func queryItemProvider(_ value: DeleteConnectorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let currentVersion = value.currentVersion {
            let currentVersionQueryItem = Smithy.URIQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
            items.append(currentVersionQueryItem)
        }
        return items
    }
}

extension DeleteCustomPluginInput {

    static func urlPathProvider(_ value: DeleteCustomPluginInput) -> Swift.String? {
        guard let customPluginArn = value.customPluginArn else {
            return nil
        }
        return "/v1/custom-plugins/\(customPluginArn.urlPercentEncoding())"
    }
}

extension DeleteWorkerConfigurationInput {

    static func urlPathProvider(_ value: DeleteWorkerConfigurationInput) -> Swift.String? {
        guard let workerConfigurationArn = value.workerConfigurationArn else {
            return nil
        }
        return "/v1/worker-configurations/\(workerConfigurationArn.urlPercentEncoding())"
    }
}

extension DescribeConnectorInput {

    static func urlPathProvider(_ value: DescribeConnectorInput) -> Swift.String? {
        guard let connectorArn = value.connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

extension DescribeCustomPluginInput {

    static func urlPathProvider(_ value: DescribeCustomPluginInput) -> Swift.String? {
        guard let customPluginArn = value.customPluginArn else {
            return nil
        }
        return "/v1/custom-plugins/\(customPluginArn.urlPercentEncoding())"
    }
}

extension DescribeWorkerConfigurationInput {

    static func urlPathProvider(_ value: DescribeWorkerConfigurationInput) -> Swift.String? {
        guard let workerConfigurationArn = value.workerConfigurationArn else {
            return nil
        }
        return "/v1/worker-configurations/\(workerConfigurationArn.urlPercentEncoding())"
    }
}

extension ListConnectorsInput {

    static func urlPathProvider(_ value: ListConnectorsInput) -> Swift.String? {
        return "/v1/connectors"
    }
}

extension ListConnectorsInput {

    static func queryItemProvider(_ value: ListConnectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let connectorNamePrefix = value.connectorNamePrefix {
            let connectorNamePrefixQueryItem = Smithy.URIQueryItem(name: "connectorNamePrefix".urlPercentEncoding(), value: Swift.String(connectorNamePrefix).urlPercentEncoding())
            items.append(connectorNamePrefixQueryItem)
        }
        return items
    }
}

extension ListCustomPluginsInput {

    static func urlPathProvider(_ value: ListCustomPluginsInput) -> Swift.String? {
        return "/v1/custom-plugins"
    }
}

extension ListCustomPluginsInput {

    static func queryItemProvider(_ value: ListCustomPluginsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let namePrefix = value.namePrefix {
            let namePrefixQueryItem = Smithy.URIQueryItem(name: "namePrefix".urlPercentEncoding(), value: Swift.String(namePrefix).urlPercentEncoding())
            items.append(namePrefixQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ListWorkerConfigurationsInput {

    static func urlPathProvider(_ value: ListWorkerConfigurationsInput) -> Swift.String? {
        return "/v1/worker-configurations"
    }
}

extension ListWorkerConfigurationsInput {

    static func queryItemProvider(_ value: ListWorkerConfigurationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if value.maxResults != 0 {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(value.maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let namePrefix = value.namePrefix {
            let namePrefixQueryItem = Smithy.URIQueryItem(name: "namePrefix".urlPercentEncoding(), value: Swift.String(namePrefix).urlPercentEncoding())
            items.append(namePrefixQueryItem)
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/v1/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateConnectorInput {

    static func urlPathProvider(_ value: UpdateConnectorInput) -> Swift.String? {
        guard let connectorArn = value.connectorArn else {
            return nil
        }
        return "/v1/connectors/\(connectorArn.urlPercentEncoding())"
    }
}

extension UpdateConnectorInput {

    static func queryItemProvider(_ value: UpdateConnectorInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let currentVersion = value.currentVersion else {
            let message = "Creating a URL Query Item failed. currentVersion is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let currentVersionQueryItem = Smithy.URIQueryItem(name: "currentVersion".urlPercentEncoding(), value: Swift.String(currentVersion).urlPercentEncoding())
        items.append(currentVersionQueryItem)
        return items
    }
}

extension CreateConnectorInput {

    static func write(value: CreateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacity"].write(value.capacity, with: KafkaConnectClientTypes.Capacity.write(value:to:))
        try writer["connectorConfiguration"].writeMap(value.connectorConfiguration, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["connectorDescription"].write(value.connectorDescription)
        try writer["connectorName"].write(value.connectorName)
        try writer["kafkaCluster"].write(value.kafkaCluster, with: KafkaConnectClientTypes.KafkaCluster.write(value:to:))
        try writer["kafkaClusterClientAuthentication"].write(value.kafkaClusterClientAuthentication, with: KafkaConnectClientTypes.KafkaClusterClientAuthentication.write(value:to:))
        try writer["kafkaClusterEncryptionInTransit"].write(value.kafkaClusterEncryptionInTransit, with: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit.write(value:to:))
        try writer["kafkaConnectVersion"].write(value.kafkaConnectVersion)
        try writer["logDelivery"].write(value.logDelivery, with: KafkaConnectClientTypes.LogDelivery.write(value:to:))
        try writer["plugins"].writeList(value.plugins, memberWritingClosure: KafkaConnectClientTypes.Plugin.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceExecutionRoleArn"].write(value.serviceExecutionRoleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["workerConfiguration"].write(value.workerConfiguration, with: KafkaConnectClientTypes.WorkerConfiguration.write(value:to:))
    }
}

extension CreateCustomPluginInput {

    static func write(value: CreateCustomPluginInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["description"].write(value.description)
        try writer["location"].write(value.location, with: KafkaConnectClientTypes.CustomPluginLocation.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorkerConfigurationInput {

    static func write(value: CreateWorkerConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["propertiesFileContent"].write(value.propertiesFileContent)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateConnectorInput {

    static func write(value: UpdateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capacity"].write(value.capacity, with: KafkaConnectClientTypes.CapacityUpdate.write(value:to:))
    }
}

extension CreateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorOutput()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorName = try reader["connectorName"].readIfPresent()
        value.connectorState = try reader["connectorState"].readIfPresent()
        return value
    }
}

extension CreateCustomPluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCustomPluginOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCustomPluginOutput()
        value.customPluginArn = try reader["customPluginArn"].readIfPresent()
        value.customPluginState = try reader["customPluginState"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension CreateWorkerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkerConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkerConfigurationOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.workerConfigurationArn = try reader["workerConfigurationArn"].readIfPresent()
        value.workerConfigurationState = try reader["workerConfigurationState"].readIfPresent()
        return value
    }
}

extension DeleteConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteConnectorOutput()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorState = try reader["connectorState"].readIfPresent()
        return value
    }
}

extension DeleteCustomPluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCustomPluginOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCustomPluginOutput()
        value.customPluginArn = try reader["customPluginArn"].readIfPresent()
        value.customPluginState = try reader["customPluginState"].readIfPresent()
        return value
    }
}

extension DeleteWorkerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkerConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkerConfigurationOutput()
        value.workerConfigurationArn = try reader["workerConfigurationArn"].readIfPresent()
        value.workerConfigurationState = try reader["workerConfigurationState"].readIfPresent()
        return value
    }
}

extension DescribeConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeConnectorOutput()
        value.capacity = try reader["capacity"].readIfPresent(with: KafkaConnectClientTypes.CapacityDescription.read(from:))
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorConfiguration = try reader["connectorConfiguration"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.connectorDescription = try reader["connectorDescription"].readIfPresent()
        value.connectorName = try reader["connectorName"].readIfPresent()
        value.connectorState = try reader["connectorState"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.kafkaCluster = try reader["kafkaCluster"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterDescription.read(from:))
        value.kafkaClusterClientAuthentication = try reader["kafkaClusterClientAuthentication"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription.read(from:))
        value.kafkaClusterEncryptionInTransit = try reader["kafkaClusterEncryptionInTransit"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription.read(from:))
        value.kafkaConnectVersion = try reader["kafkaConnectVersion"].readIfPresent()
        value.logDelivery = try reader["logDelivery"].readIfPresent(with: KafkaConnectClientTypes.LogDeliveryDescription.read(from:))
        value.plugins = try reader["plugins"].readListIfPresent(memberReadingClosure: KafkaConnectClientTypes.PluginDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceExecutionRoleArn = try reader["serviceExecutionRoleArn"].readIfPresent()
        value.stateDescription = try reader["stateDescription"].readIfPresent(with: KafkaConnectClientTypes.StateDescription.read(from:))
        value.workerConfiguration = try reader["workerConfiguration"].readIfPresent(with: KafkaConnectClientTypes.WorkerConfigurationDescription.read(from:))
        return value
    }
}

extension DescribeCustomPluginOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCustomPluginOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCustomPluginOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customPluginArn = try reader["customPluginArn"].readIfPresent()
        value.customPluginState = try reader["customPluginState"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaConnectClientTypes.CustomPluginRevisionSummary.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.stateDescription = try reader["stateDescription"].readIfPresent(with: KafkaConnectClientTypes.StateDescription.read(from:))
        return value
    }
}

extension DescribeWorkerConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeWorkerConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeWorkerConfigurationOutput()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaConnectClientTypes.WorkerConfigurationRevisionDescription.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.workerConfigurationArn = try reader["workerConfigurationArn"].readIfPresent()
        value.workerConfigurationState = try reader["workerConfigurationState"].readIfPresent()
        return value
    }
}

extension ListConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorsOutput()
        value.connectors = try reader["connectors"].readListIfPresent(memberReadingClosure: KafkaConnectClientTypes.ConnectorSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCustomPluginsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomPluginsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomPluginsOutput()
        value.customPlugins = try reader["customPlugins"].readListIfPresent(memberReadingClosure: KafkaConnectClientTypes.CustomPluginSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkerConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkerConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkerConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workerConfigurations = try reader["workerConfigurations"].readListIfPresent(memberReadingClosure: KafkaConnectClientTypes.WorkerConfigurationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectorOutput()
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorState = try reader["connectorState"].readIfPresent()
        return value
    }
}

enum CreateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCustomPluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCustomPluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCustomPluginOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeWorkerConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomPluginsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkerConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KafkaConnectClientTypes.WorkerConfigurationRevisionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.WorkerConfigurationRevisionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.WorkerConfigurationRevisionSummary()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.CapacityDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CapacityDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CapacityDescription()
        value.autoScaling = try reader["autoScaling"].readIfPresent(with: KafkaConnectClientTypes.AutoScalingDescription.read(from:))
        value.provisionedCapacity = try reader["provisionedCapacity"].readIfPresent(with: KafkaConnectClientTypes.ProvisionedCapacityDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.ProvisionedCapacityDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.ProvisionedCapacityDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.ProvisionedCapacityDescription()
        value.mcuCount = try reader["mcuCount"].readIfPresent() ?? 0
        value.workerCount = try reader["workerCount"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.AutoScalingDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.AutoScalingDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.AutoScalingDescription()
        value.maxWorkerCount = try reader["maxWorkerCount"].readIfPresent() ?? 0
        value.mcuCount = try reader["mcuCount"].readIfPresent() ?? 0
        value.minWorkerCount = try reader["minWorkerCount"].readIfPresent() ?? 0
        value.scaleInPolicy = try reader["scaleInPolicy"].readIfPresent(with: KafkaConnectClientTypes.ScaleInPolicyDescription.read(from:))
        value.scaleOutPolicy = try reader["scaleOutPolicy"].readIfPresent(with: KafkaConnectClientTypes.ScaleOutPolicyDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.ScaleOutPolicyDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.ScaleOutPolicyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.ScaleOutPolicyDescription()
        value.cpuUtilizationPercentage = try reader["cpuUtilizationPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.ScaleInPolicyDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.ScaleInPolicyDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.ScaleInPolicyDescription()
        value.cpuUtilizationPercentage = try reader["cpuUtilizationPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.KafkaClusterDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.KafkaClusterDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.KafkaClusterDescription()
        value.apacheKafkaCluster = try reader["apacheKafkaCluster"].readIfPresent(with: KafkaConnectClientTypes.ApacheKafkaClusterDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.ApacheKafkaClusterDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.ApacheKafkaClusterDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.ApacheKafkaClusterDescription()
        value.bootstrapServers = try reader["bootstrapServers"].readIfPresent()
        value.vpc = try reader["vpc"].readIfPresent(with: KafkaConnectClientTypes.VpcDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.VpcDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.VpcDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.VpcDescription()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.subnets = try reader["subnets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription()
        value.authenticationType = try reader["authenticationType"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription()
        value.encryptionType = try reader["encryptionType"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.LogDeliveryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.LogDeliveryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.LogDeliveryDescription()
        value.workerLogDelivery = try reader["workerLogDelivery"].readIfPresent(with: KafkaConnectClientTypes.WorkerLogDeliveryDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.WorkerLogDeliveryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.WorkerLogDeliveryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.WorkerLogDeliveryDescription()
        value.cloudWatchLogs = try reader["cloudWatchLogs"].readIfPresent(with: KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription.read(from:))
        value.firehose = try reader["firehose"].readIfPresent(with: KafkaConnectClientTypes.FirehoseLogDeliveryDescription.read(from:))
        value.s3 = try reader["s3"].readIfPresent(with: KafkaConnectClientTypes.S3LogDeliveryDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.S3LogDeliveryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.S3LogDeliveryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.S3LogDeliveryDescription()
        value.bucket = try reader["bucket"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.`prefix` = try reader["prefix"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.FirehoseLogDeliveryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.FirehoseLogDeliveryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.FirehoseLogDeliveryDescription()
        value.deliveryStream = try reader["deliveryStream"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        return value
    }
}

extension KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CloudWatchLogsLogDeliveryDescription()
        value.enabled = try reader["enabled"].readIfPresent() ?? false
        value.logGroup = try reader["logGroup"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.PluginDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.PluginDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.PluginDescription()
        value.customPlugin = try reader["customPlugin"].readIfPresent(with: KafkaConnectClientTypes.CustomPluginDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.CustomPluginDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CustomPluginDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CustomPluginDescription()
        value.customPluginArn = try reader["customPluginArn"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.WorkerConfigurationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.WorkerConfigurationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.WorkerConfigurationDescription()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        value.workerConfigurationArn = try reader["workerConfigurationArn"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.StateDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.StateDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.StateDescription()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.CustomPluginRevisionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CustomPluginRevisionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CustomPluginRevisionSummary()
        value.contentType = try reader["contentType"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.fileDescription = try reader["fileDescription"].readIfPresent(with: KafkaConnectClientTypes.CustomPluginFileDescription.read(from:))
        value.location = try reader["location"].readIfPresent(with: KafkaConnectClientTypes.CustomPluginLocationDescription.read(from:))
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.CustomPluginLocationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CustomPluginLocationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CustomPluginLocationDescription()
        value.s3Location = try reader["s3Location"].readIfPresent(with: KafkaConnectClientTypes.S3LocationDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.S3LocationDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.S3LocationDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.S3LocationDescription()
        value.bucketArn = try reader["bucketArn"].readIfPresent()
        value.fileKey = try reader["fileKey"].readIfPresent()
        value.objectVersion = try reader["objectVersion"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.CustomPluginFileDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CustomPluginFileDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CustomPluginFileDescription()
        value.fileMd5 = try reader["fileMd5"].readIfPresent()
        value.fileSize = try reader["fileSize"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.WorkerConfigurationRevisionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.WorkerConfigurationRevisionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.WorkerConfigurationRevisionDescription()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.propertiesFileContent = try reader["propertiesFileContent"].readIfPresent()
        value.revision = try reader["revision"].readIfPresent() ?? 0
        return value
    }
}

extension KafkaConnectClientTypes.ConnectorSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.ConnectorSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.ConnectorSummary()
        value.capacity = try reader["capacity"].readIfPresent(with: KafkaConnectClientTypes.CapacityDescription.read(from:))
        value.connectorArn = try reader["connectorArn"].readIfPresent()
        value.connectorDescription = try reader["connectorDescription"].readIfPresent()
        value.connectorName = try reader["connectorName"].readIfPresent()
        value.connectorState = try reader["connectorState"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.currentVersion = try reader["currentVersion"].readIfPresent()
        value.kafkaCluster = try reader["kafkaCluster"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterDescription.read(from:))
        value.kafkaClusterClientAuthentication = try reader["kafkaClusterClientAuthentication"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterClientAuthenticationDescription.read(from:))
        value.kafkaClusterEncryptionInTransit = try reader["kafkaClusterEncryptionInTransit"].readIfPresent(with: KafkaConnectClientTypes.KafkaClusterEncryptionInTransitDescription.read(from:))
        value.kafkaConnectVersion = try reader["kafkaConnectVersion"].readIfPresent()
        value.logDelivery = try reader["logDelivery"].readIfPresent(with: KafkaConnectClientTypes.LogDeliveryDescription.read(from:))
        value.plugins = try reader["plugins"].readListIfPresent(memberReadingClosure: KafkaConnectClientTypes.PluginDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serviceExecutionRoleArn = try reader["serviceExecutionRoleArn"].readIfPresent()
        value.workerConfiguration = try reader["workerConfiguration"].readIfPresent(with: KafkaConnectClientTypes.WorkerConfigurationDescription.read(from:))
        return value
    }
}

extension KafkaConnectClientTypes.CustomPluginSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.CustomPluginSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.CustomPluginSummary()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customPluginArn = try reader["customPluginArn"].readIfPresent()
        value.customPluginState = try reader["customPluginState"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaConnectClientTypes.CustomPluginRevisionSummary.read(from:))
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.WorkerConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> KafkaConnectClientTypes.WorkerConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KafkaConnectClientTypes.WorkerConfigurationSummary()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.latestRevision = try reader["latestRevision"].readIfPresent(with: KafkaConnectClientTypes.WorkerConfigurationRevisionSummary.read(from:))
        value.name = try reader["name"].readIfPresent()
        value.workerConfigurationArn = try reader["workerConfigurationArn"].readIfPresent()
        value.workerConfigurationState = try reader["workerConfigurationState"].readIfPresent()
        return value
    }
}

extension KafkaConnectClientTypes.Capacity {

    static func write(value: KafkaConnectClientTypes.Capacity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScaling"].write(value.autoScaling, with: KafkaConnectClientTypes.AutoScaling.write(value:to:))
        try writer["provisionedCapacity"].write(value.provisionedCapacity, with: KafkaConnectClientTypes.ProvisionedCapacity.write(value:to:))
    }
}

extension KafkaConnectClientTypes.ProvisionedCapacity {

    static func write(value: KafkaConnectClientTypes.ProvisionedCapacity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mcuCount"].write(value.mcuCount)
        try writer["workerCount"].write(value.workerCount)
    }
}

extension KafkaConnectClientTypes.AutoScaling {

    static func write(value: KafkaConnectClientTypes.AutoScaling?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxWorkerCount"].write(value.maxWorkerCount)
        try writer["mcuCount"].write(value.mcuCount)
        try writer["minWorkerCount"].write(value.minWorkerCount)
        try writer["scaleInPolicy"].write(value.scaleInPolicy, with: KafkaConnectClientTypes.ScaleInPolicy.write(value:to:))
        try writer["scaleOutPolicy"].write(value.scaleOutPolicy, with: KafkaConnectClientTypes.ScaleOutPolicy.write(value:to:))
    }
}

extension KafkaConnectClientTypes.ScaleOutPolicy {

    static func write(value: KafkaConnectClientTypes.ScaleOutPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpuUtilizationPercentage"].write(value.cpuUtilizationPercentage)
    }
}

extension KafkaConnectClientTypes.ScaleInPolicy {

    static func write(value: KafkaConnectClientTypes.ScaleInPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpuUtilizationPercentage"].write(value.cpuUtilizationPercentage)
    }
}

extension KafkaConnectClientTypes.KafkaCluster {

    static func write(value: KafkaConnectClientTypes.KafkaCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["apacheKafkaCluster"].write(value.apacheKafkaCluster, with: KafkaConnectClientTypes.ApacheKafkaCluster.write(value:to:))
    }
}

extension KafkaConnectClientTypes.ApacheKafkaCluster {

    static func write(value: KafkaConnectClientTypes.ApacheKafkaCluster?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bootstrapServers"].write(value.bootstrapServers)
        try writer["vpc"].write(value.vpc, with: KafkaConnectClientTypes.Vpc.write(value:to:))
    }
}

extension KafkaConnectClientTypes.Vpc {

    static func write(value: KafkaConnectClientTypes.Vpc?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnets"].writeList(value.subnets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension KafkaConnectClientTypes.KafkaClusterClientAuthentication {

    static func write(value: KafkaConnectClientTypes.KafkaClusterClientAuthentication?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["authenticationType"].write(value.authenticationType)
    }
}

extension KafkaConnectClientTypes.KafkaClusterEncryptionInTransit {

    static func write(value: KafkaConnectClientTypes.KafkaClusterEncryptionInTransit?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionType"].write(value.encryptionType)
    }
}

extension KafkaConnectClientTypes.LogDelivery {

    static func write(value: KafkaConnectClientTypes.LogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workerLogDelivery"].write(value.workerLogDelivery, with: KafkaConnectClientTypes.WorkerLogDelivery.write(value:to:))
    }
}

extension KafkaConnectClientTypes.WorkerLogDelivery {

    static func write(value: KafkaConnectClientTypes.WorkerLogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudWatchLogs"].write(value.cloudWatchLogs, with: KafkaConnectClientTypes.CloudWatchLogsLogDelivery.write(value:to:))
        try writer["firehose"].write(value.firehose, with: KafkaConnectClientTypes.FirehoseLogDelivery.write(value:to:))
        try writer["s3"].write(value.s3, with: KafkaConnectClientTypes.S3LogDelivery.write(value:to:))
    }
}

extension KafkaConnectClientTypes.S3LogDelivery {

    static func write(value: KafkaConnectClientTypes.S3LogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["enabled"].write(value.enabled)
        try writer["prefix"].write(value.`prefix`)
    }
}

extension KafkaConnectClientTypes.FirehoseLogDelivery {

    static func write(value: KafkaConnectClientTypes.FirehoseLogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deliveryStream"].write(value.deliveryStream)
        try writer["enabled"].write(value.enabled)
    }
}

extension KafkaConnectClientTypes.CloudWatchLogsLogDelivery {

    static func write(value: KafkaConnectClientTypes.CloudWatchLogsLogDelivery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
        try writer["logGroup"].write(value.logGroup)
    }
}

extension KafkaConnectClientTypes.Plugin {

    static func write(value: KafkaConnectClientTypes.Plugin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customPlugin"].write(value.customPlugin, with: KafkaConnectClientTypes.CustomPlugin.write(value:to:))
    }
}

extension KafkaConnectClientTypes.CustomPlugin {

    static func write(value: KafkaConnectClientTypes.CustomPlugin?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customPluginArn"].write(value.customPluginArn)
        try writer["revision"].write(value.revision)
    }
}

extension KafkaConnectClientTypes.WorkerConfiguration {

    static func write(value: KafkaConnectClientTypes.WorkerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["revision"].write(value.revision)
        try writer["workerConfigurationArn"].write(value.workerConfigurationArn)
    }
}

extension KafkaConnectClientTypes.CustomPluginLocation {

    static func write(value: KafkaConnectClientTypes.CustomPluginLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: KafkaConnectClientTypes.S3Location.write(value:to:))
    }
}

extension KafkaConnectClientTypes.S3Location {

    static func write(value: KafkaConnectClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketArn"].write(value.bucketArn)
        try writer["fileKey"].write(value.fileKey)
        try writer["objectVersion"].write(value.objectVersion)
    }
}

extension KafkaConnectClientTypes.CapacityUpdate {

    static func write(value: KafkaConnectClientTypes.CapacityUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoScaling"].write(value.autoScaling, with: KafkaConnectClientTypes.AutoScalingUpdate.write(value:to:))
        try writer["provisionedCapacity"].write(value.provisionedCapacity, with: KafkaConnectClientTypes.ProvisionedCapacityUpdate.write(value:to:))
    }
}

extension KafkaConnectClientTypes.ProvisionedCapacityUpdate {

    static func write(value: KafkaConnectClientTypes.ProvisionedCapacityUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mcuCount"].write(value.mcuCount)
        try writer["workerCount"].write(value.workerCount)
    }
}

extension KafkaConnectClientTypes.AutoScalingUpdate {

    static func write(value: KafkaConnectClientTypes.AutoScalingUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxWorkerCount"].write(value.maxWorkerCount)
        try writer["mcuCount"].write(value.mcuCount)
        try writer["minWorkerCount"].write(value.minWorkerCount)
        try writer["scaleInPolicy"].write(value.scaleInPolicy, with: KafkaConnectClientTypes.ScaleInPolicyUpdate.write(value:to:))
        try writer["scaleOutPolicy"].write(value.scaleOutPolicy, with: KafkaConnectClientTypes.ScaleOutPolicyUpdate.write(value:to:))
    }
}

extension KafkaConnectClientTypes.ScaleOutPolicyUpdate {

    static func write(value: KafkaConnectClientTypes.ScaleOutPolicyUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpuUtilizationPercentage"].write(value.cpuUtilizationPercentage)
    }
}

extension KafkaConnectClientTypes.ScaleInPolicyUpdate {

    static func write(value: KafkaConnectClientTypes.ScaleInPolicyUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cpuUtilizationPercentage"].write(value.cpuUtilizationPercentage)
    }
}

public enum KafkaConnectClientTypes {}
