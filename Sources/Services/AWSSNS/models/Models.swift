// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyReadWrite
import SmithyXML

extension AddPermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId = "AWSAccountId"
        case actionName = "ActionName"
        case label = "Label"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let awsAccountId = awsAccountId {
            if !awsAccountId.isEmpty {
                var awsAccountIdContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AWSAccountId"))
                for (index0, delegate0) in awsAccountId.enumerated() {
                    try awsAccountIdContainer.encode(delegate0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var awsAccountIdContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("AWSAccountId"))
                try awsAccountIdContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let actionName = actionName {
            if !actionName.isEmpty {
                var actionNameContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionName"))
                for (index0, action0) in actionName.enumerated() {
                    try actionNameContainer.encode(action0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var actionNameContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("ActionName"))
                try actionNameContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("AddPermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension AddPermissionInput {

    static func urlPathProvider(_ value: AddPermissionInput) -> Swift.String? {
        return "/"
    }
}

public struct AddPermissionInput: Swift.Equatable {
    /// The action you want to allow for the specified principal(s). Valid values: Any Amazon SNS action name, for example Publish.
    /// This member is required.
    public var actionName: [Swift.String]?
    /// The Amazon Web Services account IDs of the users (principals) who will be given access to the specified actions. The users must have Amazon Web Services account, but do not need to be signed up for this service.
    /// This member is required.
    public var awsAccountId: [Swift.String]?
    /// A unique identifier for the new policy statement.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        actionName: [Swift.String]? = nil,
        awsAccountId: [Swift.String]? = nil,
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.awsAccountId = awsAccountId
        self.label = label
        self.topicArn = topicArn
    }
}

extension AddPermissionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<AddPermissionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return AddPermissionOutput()
        }
    }
}

public struct AddPermissionOutput: Swift.Equatable {

    public init() { }
}

enum AddPermissionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension AuthorizationErrorException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = AuthorizationErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the user has been denied access to the requested resource.
public struct AuthorizationErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationError" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BatchEntryIdsNotDistinctException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BatchEntryIdsNotDistinctException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Two or more batch entries in the request have the same Id.
public struct BatchEntryIdsNotDistinctException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchEntryIdsNotDistinct" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BatchRequestTooLongException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = BatchRequestTooLongException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The length of all the batch messages put together is more than the limit.
public struct BatchRequestTooLongException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchRequestTooLong" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes.BatchResultErrorEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case id = "Id"
        case message = "Message"
        case senderFault = "SenderFault"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let code = code {
            try container.encode(code, forKey: ClientRuntime.Key("Code"))
        }
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if senderFault != false {
            try container.encode(senderFault, forKey: ClientRuntime.Key("SenderFault"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.BatchResultErrorEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.BatchResultErrorEntry()
            value.id = try reader["Id"].readIfPresent()
            value.code = try reader["Code"].readIfPresent()
            value.message = try reader["Message"].readIfPresent()
            value.senderFault = try reader["SenderFault"].readIfPresent() ?? false
            return value
        }
    }
}

extension SNSClientTypes {
    /// Gives a detailed description of failed messages in the batch.
    public struct BatchResultErrorEntry: Swift.Equatable {
        /// An error code representing why the action failed on this entry.
        /// This member is required.
        public var code: Swift.String?
        /// The Id of an entry in a batch request
        /// This member is required.
        public var id: Swift.String?
        /// A message explaining why the action failed on this entry.
        public var message: Swift.String?
        /// Specifies whether the error happened due to the caller of the batch API action.
        /// This member is required.
        public var senderFault: Swift.Bool

        public init(
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            senderFault: Swift.Bool = false
        )
        {
            self.code = code
            self.id = id
            self.message = message
            self.senderFault = senderFault
        }
    }

}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckIfPhoneNumberIsOptedOutInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("CheckIfPhoneNumberIsOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CheckIfPhoneNumberIsOptedOutInput {

    static func urlPathProvider(_ value: CheckIfPhoneNumberIsOptedOutInput) -> Swift.String? {
        return "/"
    }
}

/// The input for the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutInput: Swift.Equatable {
    /// The phone number for which you want to check the opt out status.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension CheckIfPhoneNumberIsOptedOutOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CheckIfPhoneNumberIsOptedOutOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CheckIfPhoneNumberIsOptedOutResult"]
            var value = CheckIfPhoneNumberIsOptedOutOutput()
            value.isOptedOut = try reader["isOptedOut"].readIfPresent() ?? false
            return value
        }
    }
}

/// The response from the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutOutput: Swift.Equatable {
    /// Indicates whether the phone number is opted out:
    ///
    /// * true – The phone number is opted out, meaning you cannot publish SMS messages to it.
    ///
    /// * false – The phone number is opted in, meaning you can publish SMS messages to it.
    public var isOptedOut: Swift.Bool

    public init(
        isOptedOut: Swift.Bool = false
    )
    {
        self.isOptedOut = isOptedOut
    }
}

enum CheckIfPhoneNumberIsOptedOutOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ConcurrentAccessException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ConcurrentAccessException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Can't perform multiple operations on a tag simultaneously. Perform the operations sequentially.
public struct ConcurrentAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentAccess" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfirmSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticateOnUnsubscribe = "AuthenticateOnUnsubscribe"
        case token = "Token"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let authenticateOnUnsubscribe = authenticateOnUnsubscribe {
            try container.encode(authenticateOnUnsubscribe, forKey: ClientRuntime.Key("AuthenticateOnUnsubscribe"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ConfirmSubscription", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ConfirmSubscriptionInput {

    static func urlPathProvider(_ value: ConfirmSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

/// Input for ConfirmSubscription action.
public struct ConfirmSubscriptionInput: Swift.Equatable {
    /// Disallows unauthenticated unsubscribes of the subscription. If the value of this parameter is true and the request has an Amazon Web Services signature, then only the topic owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action requires Amazon Web Services authentication.
    public var authenticateOnUnsubscribe: Swift.String?
    /// Short-lived token sent to an endpoint during the Subscribe action.
    /// This member is required.
    public var token: Swift.String?
    /// The ARN of the topic for which you wish to confirm a subscription.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        authenticateOnUnsubscribe: Swift.String? = nil,
        token: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.authenticateOnUnsubscribe = authenticateOnUnsubscribe
        self.token = token
        self.topicArn = topicArn
    }
}

extension ConfirmSubscriptionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ConfirmSubscriptionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ConfirmSubscriptionResult"]
            var value = ConfirmSubscriptionOutput()
            value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
            return value
        }
    }
}

/// Response for ConfirmSubscriptions action.
public struct ConfirmSubscriptionOutput: Swift.Equatable {
    /// The ARN of the created subscription.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

enum ConfirmSubscriptionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "FilterPolicyLimitExceeded": return try await FilterPolicyLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ReplayLimitExceeded": return try await ReplayLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "SubscriptionLimitExceeded": return try await SubscriptionLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreatePlatformApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case name = "Name"
        case platform = "Platform"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let platform = platform {
            try container.encode(platform, forKey: ClientRuntime.Key("Platform"))
        }
        try container.encode("CreatePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePlatformApplicationInput {

    static func urlPathProvider(_ value: CreatePlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

/// Input for CreatePlatformApplication action.
public struct CreatePlatformApplicationInput: Swift.Equatable {
    /// For a list of attributes, see [SetPlatformApplicationAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html).
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// Application names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).
    /// This member is required.
    public var platform: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        name: Swift.String? = nil,
        platform: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.platform = platform
    }
}

extension CreatePlatformApplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreatePlatformApplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreatePlatformApplicationResult"]
            var value = CreatePlatformApplicationOutput()
            value.platformApplicationArn = try reader["PlatformApplicationArn"].readIfPresent()
            return value
        }
    }
}

/// Response from CreatePlatformApplication action.
public struct CreatePlatformApplicationOutput: Swift.Equatable {
    /// PlatformApplicationArn is returned.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

enum CreatePlatformApplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreatePlatformEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case customUserData = "CustomUserData"
        case platformApplicationArn = "PlatformApplicationArn"
        case token = "Token"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let customUserData = customUserData {
            try container.encode(customUserData, forKey: ClientRuntime.Key("CustomUserData"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        if let token = token {
            try container.encode(token, forKey: ClientRuntime.Key("Token"))
        }
        try container.encode("CreatePlatformEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreatePlatformEndpointInput {

    static func urlPathProvider(_ value: CreatePlatformEndpointInput) -> Swift.String? {
        return "/"
    }
}

/// Input for CreatePlatformEndpoint action.
public struct CreatePlatformEndpointInput: Swift.Equatable {
    /// For a list of attributes, see [SetEndpointAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html).
    public var attributes: [Swift.String:Swift.String]?
    /// Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    public var customUserData: Swift.String?
    /// PlatformApplicationArn returned from CreatePlatformApplication is used to create a an endpoint.
    /// This member is required.
    public var platformApplicationArn: Swift.String?
    /// Unique identifier created by the notification service for an app on a device. The specific name for Token will vary, depending on which notification service is being used. For example, when using APNS as the notification service, you need the device token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token equivalent is called the registration ID.
    /// This member is required.
    public var token: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        customUserData: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.customUserData = customUserData
        self.platformApplicationArn = platformApplicationArn
        self.token = token
    }
}

extension CreatePlatformEndpointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreatePlatformEndpointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreatePlatformEndpointResult"]
            var value = CreatePlatformEndpointOutput()
            value.endpointArn = try reader["EndpointArn"].readIfPresent()
            return value
        }
    }
}

/// Response from CreateEndpoint action.
public struct CreatePlatformEndpointOutput: Swift.Equatable {
    /// EndpointArn returned from CreateEndpoint action.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

enum CreatePlatformEndpointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMSSandboxPhoneNumberInput(languageCode: \(Swift.String(describing: languageCode)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension CreateSMSSandboxPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let languageCode = languageCode {
            try container.encode(languageCode, forKey: ClientRuntime.Key("LanguageCode"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("CreateSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateSMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: CreateSMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The language to use for sending the OTP. The default value is en-US.
    public var languageCode: SNSClientTypes.LanguageCodeString?
    /// The destination phone number to verify. On verification, Amazon SNS adds this phone number to the list of verified phone numbers that you can send SMS messages to.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        languageCode: SNSClientTypes.LanguageCodeString? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.phoneNumber = phoneNumber
    }
}

extension CreateSMSSandboxPhoneNumberOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateSMSSandboxPhoneNumberOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return CreateSMSSandboxPhoneNumberOutput()
        }
    }
}

public struct CreateSMSSandboxPhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum CreateSMSSandboxPhoneNumberOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "OptedOut": return try await OptedOutException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UserError": return try await UserErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension CreateTopicInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case dataProtectionPolicy = "DataProtectionPolicy"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let dataProtectionPolicy = dataProtectionPolicy {
            try container.encode(dataProtectionPolicy, forKey: ClientRuntime.Key("DataProtectionPolicy"))
        }
        if let name = name {
            try container.encode(name, forKey: ClientRuntime.Key("Name"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("CreateTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension CreateTopicInput {

    static func urlPathProvider(_ value: CreateTopicInput) -> Swift.String? {
        return "/"
    }
}

/// Input for CreateTopic action.
public struct CreateTopicInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the CreateTopic action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * FifoTopic – Set to true to create a FIFO topic.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, SignatureVersion is set to 1.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    ///
    /// The following attribute applies only to [server-side encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ArchivePolicy – Adds or updates an inline policy document to archive messages stored in the specified Amazon SNS topic.
    ///
    /// * BeginningArchiveTime – The earliest starting point at which a message in the topic’s archive can be replayed from. This point in time is based on the configured message retention period set by the topic’s message archiving policy.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String:Swift.String]?
    /// The body of the policy document you want to use for this topic. You can only add one policy per topic. The policy must be in JSON string format. Length Constraints: Maximum length of 30,720.
    public var dataProtectionPolicy: Swift.String?
    /// The name of the topic you want to create. Constraints: Topic names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. For a FIFO (first-in-first-out) topic, the name must end with the .fifo suffix.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to add to a new topic. To be able to tag a topic on creation, you must have the sns:CreateTopic and sns:TagResource permissions.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        dataProtectionPolicy: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.attributes = attributes
        self.dataProtectionPolicy = dataProtectionPolicy
        self.name = name
        self.tags = tags
    }
}

extension CreateTopicOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<CreateTopicOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["CreateTopicResult"]
            var value = CreateTopicOutput()
            value.topicArn = try reader["TopicArn"].readIfPresent()
            return value
        }
    }
}

/// Response from CreateTopic action.
public struct CreateTopicOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) assigned to the created topic.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

enum CreateTopicOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ConcurrentAccess": return try await ConcurrentAccessException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "StaleTag": return try await StaleTagException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagLimitExceeded": return try await TagLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagPolicy": return try await TagPolicyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TopicLimitExceeded": return try await TopicLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("DeleteEndpoint", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteEndpointInput {

    static func urlPathProvider(_ value: DeleteEndpointInput) -> Swift.String? {
        return "/"
    }
}

/// Input for DeleteEndpoint action.
public struct DeleteEndpointInput: Swift.Equatable {
    /// EndpointArn of endpoint to delete.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension DeleteEndpointOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteEndpointOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteEndpointOutput()
        }
    }
}

public struct DeleteEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEndpointOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeletePlatformApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("DeletePlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeletePlatformApplicationInput {

    static func urlPathProvider(_ value: DeletePlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

/// Input for DeletePlatformApplication action.
public struct DeletePlatformApplicationInput: Swift.Equatable {
    /// PlatformApplicationArn of platform application object to delete.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension DeletePlatformApplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeletePlatformApplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeletePlatformApplicationOutput()
        }
    }
}

public struct DeletePlatformApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeletePlatformApplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSMSSandboxPhoneNumberInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

extension DeleteSMSSandboxPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("DeleteSMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteSMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: DeleteSMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteSMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The destination phone number to delete.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension DeleteSMSSandboxPhoneNumberOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteSMSSandboxPhoneNumberOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteSMSSandboxPhoneNumberOutput()
        }
    }
}

public struct DeleteSMSSandboxPhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSMSSandboxPhoneNumberOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "UserError": return try await UserErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension DeleteTopicInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("DeleteTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension DeleteTopicInput {

    static func urlPathProvider(_ value: DeleteTopicInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteTopicInput: Swift.Equatable {
    /// The ARN of the topic you want to delete.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension DeleteTopicOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<DeleteTopicOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return DeleteTopicOutput()
        }
    }
}

public struct DeleteTopicOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTopicOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ConcurrentAccess": return try await ConcurrentAccessException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidState": return try await InvalidStateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "StaleTag": return try await StaleTagException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagPolicy": return try await TagPolicyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension EmptyBatchRequestException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EmptyBatchRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The batch request doesn't contain any entries.
public struct EmptyBatchRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EmptyBatchRequest" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes.Endpoint: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.Endpoint, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.Endpoint()
            value.endpointArn = try reader["EndpointArn"].readIfPresent()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

extension SNSClientTypes {
    /// The endpoint for mobile app and device.
    public struct Endpoint: Swift.Equatable {
        /// Attributes for endpoint.
        public var attributes: [Swift.String:Swift.String]?
        /// The EndpointArn for mobile app and device.
        public var endpointArn: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            endpointArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.endpointArn = endpointArn
        }
    }

}

extension EndpointDisabledException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = EndpointDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Exception error indicating endpoint disabled.
public struct EndpointDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message for endpoint disabled.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FilterPolicyLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = FilterPolicyLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the number of filter polices in your Amazon Web Services account exceeds the limit. To add more filter polices, submit an Amazon SNS Limit Increase case in the Amazon Web Services Support Center.
public struct FilterPolicyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilterPolicyLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension GetDataProtectionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("GetDataProtectionPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetDataProtectionPolicyInput {

    static func urlPathProvider(_ value: GetDataProtectionPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct GetDataProtectionPolicyInput: Swift.Equatable {
    /// The ARN of the topic whose DataProtectionPolicy you want to get. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension GetDataProtectionPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetDataProtectionPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetDataProtectionPolicyResult"]
            var value = GetDataProtectionPolicyOutput()
            value.dataProtectionPolicy = try reader["DataProtectionPolicy"].readIfPresent()
            return value
        }
    }
}

public struct GetDataProtectionPolicyOutput: Swift.Equatable {
    /// Retrieves the DataProtectionPolicy in JSON string format.
    public var dataProtectionPolicy: Swift.String?

    public init(
        dataProtectionPolicy: Swift.String? = nil
    )
    {
        self.dataProtectionPolicy = dataProtectionPolicy
    }
}

enum GetDataProtectionPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetEndpointAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("GetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetEndpointAttributesInput {

    static func urlPathProvider(_ value: GetEndpointAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for GetEndpointAttributes action.
public struct GetEndpointAttributesInput: Swift.Equatable {
    /// EndpointArn for GetEndpointAttributes input.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

extension GetEndpointAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetEndpointAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetEndpointAttributesResult"]
            var value = GetEndpointAttributesOutput()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// Response from GetEndpointAttributes of the EndpointArn.
public struct GetEndpointAttributesOutput: Swift.Equatable {
    /// Attributes include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service. The device token for the iOS platform is returned in lowercase.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

enum GetEndpointAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetPlatformApplicationAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("GetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetPlatformApplicationAttributesInput {

    static func urlPathProvider(_ value: GetPlatformApplicationAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesInput: Swift.Equatable {
    /// PlatformApplicationArn for GetPlatformApplicationAttributesInput.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

extension GetPlatformApplicationAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetPlatformApplicationAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetPlatformApplicationAttributesResult"]
            var value = GetPlatformApplicationAttributesOutput()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// Response for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesOutput: Swift.Equatable {
    /// Attributes include the following:
    ///
    /// * AppleCertificateExpiryDate – The expiry date of the SSL certificate used to configure certificate-based authentication.
    ///
    /// * ApplePlatformTeamID – The Apple developer account ID used to configure token-based authentication.
    ///
    /// * ApplePlatformBundleID – The app identifier used to configure token-based authentication.
    ///
    /// * AuthenticationMethod – Returns the credential type used when sending push notifications from application to APNS/APNS_Sandbox, or application to GCM.
    ///
    /// * APNS – Returns the token or certificate.
    ///
    /// * GCM – Returns the token or key.
    ///
    ///
    ///
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications should be sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications should be sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications should be sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications should be sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

enum GetPlatformApplicationAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetSMSAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            if !attributes.isEmpty {
                var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
                for (index0, string0) in attributes.enumerated() {
                    try attributesContainer.encode(string0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
                try attributesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("GetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSMSAttributesInput {

    static func urlPathProvider(_ value: GetSMSAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// The input for the GetSMSAttributes request.
public struct GetSMSAttributesInput: Swift.Equatable {
    /// A list of the individual attribute names, such as MonthlySpendLimit, for which you want values. For all attribute names, see [SetSMSAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html). If you don't use this parameter, Amazon SNS returns all SMS attributes.
    public var attributes: [Swift.String]?

    public init(
        attributes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension GetSMSAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetSMSAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetSMSAttributesResult"]
            var value = GetSMSAttributesOutput()
            value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// The response from the GetSMSAttributes request.
public struct GetSMSAttributesOutput: Swift.Equatable {
    /// The SMS attribute names and their values.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

enum GetSMSAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetSMSSandboxAccountStatusInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        try container.encode("GetSMSSandboxAccountStatus", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSMSSandboxAccountStatusInput {

    static func urlPathProvider(_ value: GetSMSSandboxAccountStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct GetSMSSandboxAccountStatusInput: Swift.Equatable {

    public init() { }
}

extension GetSMSSandboxAccountStatusOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetSMSSandboxAccountStatusOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetSMSSandboxAccountStatusResult"]
            var value = GetSMSSandboxAccountStatusOutput()
            value.isInSandbox = try reader["IsInSandbox"].readIfPresent() ?? false
            return value
        }
    }
}

public struct GetSMSSandboxAccountStatusOutput: Swift.Equatable {
    /// Indicates whether the calling Amazon Web Services account is in the SMS sandbox.
    /// This member is required.
    public var isInSandbox: Swift.Bool

    public init(
        isInSandbox: Swift.Bool = false
    )
    {
        self.isInSandbox = isInSandbox
    }
}

enum GetSMSSandboxAccountStatusOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetSubscriptionAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("GetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetSubscriptionAttributesInput {

    static func urlPathProvider(_ value: GetSubscriptionAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for GetSubscriptionAttributes.
public struct GetSubscriptionAttributesInput: Swift.Equatable {
    /// The ARN of the subscription whose properties you want to get.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension GetSubscriptionAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetSubscriptionAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetSubscriptionAttributesResult"]
            var value = GetSubscriptionAttributesOutput()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// Response for GetSubscriptionAttributes action.
public struct GetSubscriptionAttributesOutput: Swift.Equatable {
    /// A map of the subscription's attributes. Attributes in this map include the following:
    ///
    /// * ConfirmationWasAuthenticated – true if the subscription confirmation request was authenticated.
    ///
    /// * DeliveryPolicy – The JSON serialization of the subscription's delivery policy.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy that takes into account the topic delivery policy and account system defaults.
    ///
    /// * FilterPolicy – The filter policy JSON that is assigned to the subscription. For more information, see [Amazon SNS Message Filtering](https://docs.aws.amazon.com/sns/latest/dg/sns-message-filtering.html) in the Amazon SNS Developer Guide.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * Owner – The Amazon Web Services account ID of the subscription's owner.
    ///
    /// * PendingConfirmation – true if the subscription hasn't been confirmed. To confirm a pending subscription, call the ConfirmSubscription action with a confirmation token.
    ///
    /// * RawMessageDelivery – true if raw message delivery is enabled for the subscription. Raw messages are free of JSON formatting and can be sent to HTTP/S and Amazon SQS endpoints.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    /// * SubscriptionArn – The subscription's ARN.
    ///
    /// * TopicArn – The topic ARN that the subscription is associated with.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

enum GetSubscriptionAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension GetTopicAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("GetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension GetTopicAttributesInput {

    static func urlPathProvider(_ value: GetTopicAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for GetTopicAttributes action.
public struct GetTopicAttributesInput: Swift.Equatable {
    /// The ARN of the topic whose properties you want to get.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension GetTopicAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<GetTopicAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["GetTopicAttributesResult"]
            var value = GetTopicAttributesOutput()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

/// Response for GetTopicAttributes action.
public struct GetTopicAttributesOutput: Swift.Equatable {
    /// A map of the topic's attributes. Attributes in this map include the following:
    ///
    /// * DeliveryPolicy – The JSON serialization of the topic's delivery policy.
    ///
    /// * DisplayName – The human-readable name used in the From field for notifications to email and email-json endpoints.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy, taking system defaults into account.
    ///
    /// * Owner – The Amazon Web Services account ID of the topic's owner.
    ///
    /// * Policy – The JSON serialization of the topic's access control policy.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
    ///
    /// * By default, SignatureVersion is set to 1. The signature is a Base64-encoded SHA1withRSA signature.
    ///
    /// * When you set SignatureVersion to 2. Amazon SNS uses a Base64-encoded SHA256withRSA signature. If the API response does not include the SignatureVersion attribute, it means that the SignatureVersion for the topic has value 1.
    ///
    ///
    ///
    ///
    /// * SubscriptionsConfirmed – The number of confirmed subscriptions for the topic.
    ///
    /// * SubscriptionsDeleted – The number of deleted subscriptions for the topic.
    ///
    /// * SubscriptionsPending – The number of subscriptions pending confirmation for the topic.
    ///
    /// * TopicArn – The topic's ARN.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    ///
    /// The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId - The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * FifoTopic – When this is set to true, a FIFO topic is created.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

enum GetTopicAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension InternalErrorException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InternalErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates an internal service error.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidBatchEntryIdException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidBatchEntryIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Id of a batch entry in a batch request doesn't abide by the specification.
public struct InvalidBatchEntryIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBatchEntryId" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidParameterException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidParameterValueException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter of an entry in a request doesn't abide by the specification.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterValueInvalid" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidSecurityException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidSecurityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The credential signature isn't valid. You must use an HTTPS endpoint and sign your request using Signature Version 4.
public struct InvalidSecurityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurity" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension InvalidStateException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = InvalidStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the specified state is not a valid state for an event source.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSAccessDeniedException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSAccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The ciphertext references a key that doesn't exist or that you don't have access to.
public struct KMSAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDenied" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSDisabledException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the specified Amazon Web Services KMS key isn't enabled.
public struct KMSDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSInvalidStateException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSInvalidStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the state of the specified resource isn't valid for this request. For more information, see [Key states of Amazon Web Services KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the Key Management Service Developer Guide.
public struct KMSInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was rejected because the specified entity or resource can't be found.
public struct KMSNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSOptInRequired {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSOptInRequired()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The Amazon Web Services access key ID needs a subscription for the service.
public struct KMSOptInRequired: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSOptInRequired" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KMSThrottlingException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = KMSThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request was denied due to request throttling. For more information about throttling, see [Limits](https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second) in the Key Management Service Developer Guide.
public struct KMSThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSThrottling" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {
    /// Supported language code for sending OTP message
    public enum LanguageCodeString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jpJp
        case krKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeString] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jpJp,
                .krKr,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .es419: return "es-419"
            case .esEs: return "es-ES"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jpJp: return "ja-JP"
            case .krKr: return "kr-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LanguageCodeString(rawValue: rawValue) ?? LanguageCodeString.sdkUnknown(rawValue)
        }
    }
}

extension ListEndpointsByPlatformApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("ListEndpointsByPlatformApplication", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListEndpointsByPlatformApplicationInput {

    static func urlPathProvider(_ value: ListEndpointsByPlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

/// Input for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationInput: Swift.Equatable {
    /// NextToken string is used when calling ListEndpointsByPlatformApplication action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?
    /// PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplicationArn = platformApplicationArn
    }
}

extension ListEndpointsByPlatformApplicationOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListEndpointsByPlatformApplicationOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListEndpointsByPlatformApplicationResult"]
            var value = ListEndpointsByPlatformApplicationOutput()
            value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: SNSClientTypes.Endpoint.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.nextToken = try reader["NextToken"].readIfPresent()
            return value
        }
    }
}

/// Response for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationOutput: Swift.Equatable {
    /// Endpoints returned for ListEndpointsByPlatformApplication action.
    public var endpoints: [SNSClientTypes.Endpoint]?
    /// NextToken string is returned when calling ListEndpointsByPlatformApplication action if additional records are available after the first page results.
    public var nextToken: Swift.String?

    public init(
        endpoints: [SNSClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

enum ListEndpointsByPlatformApplicationOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListOriginationNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListOriginationNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListOriginationNumbersInput {

    static func urlPathProvider(_ value: ListOriginationNumbersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListOriginationNumbersInput: Swift.Equatable {
    /// The maximum number of origination numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListOriginationNumbers request returns.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListOriginationNumbersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListOriginationNumbersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListOriginationNumbersResult"]
            var value = ListOriginationNumbersOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: SNSClientTypes.PhoneNumberInformation.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListOriginationNumbersOutput: Swift.Equatable {
    /// A NextToken string is returned when you call the ListOriginationNumbers operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's verified and pending origination numbers.
    public var phoneNumbers: [SNSClientTypes.PhoneNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [SNSClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

enum ListOriginationNumbersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListPhoneNumbersOptedOutInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("nextToken"))
        }
        try container.encode("ListPhoneNumbersOptedOut", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPhoneNumbersOptedOutInput {

    static func urlPathProvider(_ value: ListPhoneNumbersOptedOutInput) -> Swift.String? {
        return "/"
    }
}

/// The input for the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutInput: Swift.Equatable {
    /// A NextToken string is used when you call the ListPhoneNumbersOptedOut action to retrieve additional records that are available after the first page of results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPhoneNumbersOptedOutOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPhoneNumbersOptedOutOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPhoneNumbersOptedOutResult"]
            var value = ListPhoneNumbersOptedOutOutput()
            value.nextToken = try reader["nextToken"].readIfPresent()
            value.phoneNumbers = try reader["phoneNumbers"].readListIfPresent(memberReadingClosure: Swift.String.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// The response from the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutOutput: Swift.Equatable {
    /// A NextToken string is returned when you call the ListPhoneNumbersOptedOut action if additional records are available after the first page of results.
    public var nextToken: Swift.String?
    /// A list of phone numbers that are opted out of receiving SMS messages. The list is paginated, and each page can contain up to 100 phone numbers.
    public var phoneNumbers: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

enum ListPhoneNumbersOptedOutOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListPlatformApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListPlatformApplications", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListPlatformApplicationsInput {

    static func urlPathProvider(_ value: ListPlatformApplicationsInput) -> Swift.String? {
        return "/"
    }
}

/// Input for ListPlatformApplications action.
public struct ListPlatformApplicationsInput: Swift.Equatable {
    /// NextToken string is used when calling ListPlatformApplications action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListPlatformApplicationsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListPlatformApplicationsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListPlatformApplicationsResult"]
            var value = ListPlatformApplicationsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.platformApplications = try reader["PlatformApplications"].readListIfPresent(memberReadingClosure: SNSClientTypes.PlatformApplication.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Response for ListPlatformApplications action.
public struct ListPlatformApplicationsOutput: Swift.Equatable {
    /// NextToken string is returned when calling ListPlatformApplications action if additional records are available after the first page results.
    public var nextToken: Swift.String?
    /// Platform applications returned when calling ListPlatformApplications action.
    public var platformApplications: [SNSClientTypes.PlatformApplication]?

    public init(
        nextToken: Swift.String? = nil,
        platformApplications: [SNSClientTypes.PlatformApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplications = platformApplications
    }
}

enum ListPlatformApplicationsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSMSSandboxPhoneNumbersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let maxResults = maxResults {
            try container.encode(maxResults, forKey: ClientRuntime.Key("MaxResults"))
        }
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSMSSandboxPhoneNumbers", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSMSSandboxPhoneNumbersInput {

    static func urlPathProvider(_ value: ListSMSSandboxPhoneNumbersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListSMSSandboxPhoneNumbersInput: Swift.Equatable {
    /// The maximum number of phone numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListSMSSandboxPhoneNumbersInput request returns.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSMSSandboxPhoneNumbersOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSMSSandboxPhoneNumbersOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSMSSandboxPhoneNumbersResult"]
            var value = ListSMSSandboxPhoneNumbersOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: SNSClientTypes.SMSSandboxPhoneNumber.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListSMSSandboxPhoneNumbersOutput: Swift.Equatable {
    /// A NextToken string is returned when you call the ListSMSSandboxPhoneNumbersInput operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's pending and verified phone numbers.
    /// This member is required.
    public var phoneNumbers: [SNSClientTypes.SMSSandboxPhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [SNSClientTypes.SMSSandboxPhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

enum ListSMSSandboxPhoneNumbersOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSubscriptionsByTopicInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("ListSubscriptionsByTopic", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSubscriptionsByTopicInput {

    static func urlPathProvider(_ value: ListSubscriptionsByTopicInput) -> Swift.String? {
        return "/"
    }
}

/// Input for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicInput: Swift.Equatable {
    /// Token returned by the previous ListSubscriptionsByTopic request.
    public var nextToken: Swift.String?
    /// The ARN of the topic for which you wish to find subscriptions.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.topicArn = topicArn
    }
}

extension ListSubscriptionsByTopicOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSubscriptionsByTopicOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSubscriptionsByTopicResult"]
            var value = ListSubscriptionsByTopicOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: SNSClientTypes.Subscription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Response for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicOutput: Swift.Equatable {
    /// Token to pass along to the next ListSubscriptionsByTopic request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SNSClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [SNSClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

enum ListSubscriptionsByTopicOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListSubscriptions", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListSubscriptionsInput {

    static func urlPathProvider(_ value: ListSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

/// Input for ListSubscriptions action.
public struct ListSubscriptionsInput: Swift.Equatable {
    /// Token returned by the previous ListSubscriptions request.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListSubscriptionsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListSubscriptionsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListSubscriptionsResult"]
            var value = ListSubscriptionsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: SNSClientTypes.Subscription.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Response for ListSubscriptions action
public struct ListSubscriptionsOutput: Swift.Equatable {
    /// Token to pass along to the next ListSubscriptions request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SNSClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [SNSClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

enum ListSubscriptionsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("ListTagsForResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the topic for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListTagsForResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListTagsForResourceResult"]
            var value = ListTagsForResourceOutput()
            value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SNSClientTypes.Tag.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the specified topic.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ConcurrentAccess": return try await ConcurrentAccessException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagPolicy": return try await TagPolicyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ListTopicsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let nextToken = nextToken {
            try container.encode(nextToken, forKey: ClientRuntime.Key("NextToken"))
        }
        try container.encode("ListTopics", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension ListTopicsInput {

    static func urlPathProvider(_ value: ListTopicsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTopicsInput: Swift.Equatable {
    /// Token returned by the previous ListTopics request.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension ListTopicsOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<ListTopicsOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["ListTopicsResult"]
            var value = ListTopicsOutput()
            value.nextToken = try reader["NextToken"].readIfPresent()
            value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SNSClientTypes.Topic.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

/// Response for ListTopics action.
public struct ListTopicsOutput: Swift.Equatable {
    /// Token to pass along to the next ListTopics request. This element is returned if there are additional topics to retrieve.
    public var nextToken: Swift.String?
    /// A list of topic ARNs.
    public var topics: [SNSClientTypes.Topic]?

    public init(
        nextToken: Swift.String? = nil,
        topics: [SNSClientTypes.Topic]? = nil
    )
    {
        self.nextToken = nextToken
        self.topics = topics
    }
}

enum ListTopicsOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SNSClientTypes.MessageAttributeValue: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryValue = "BinaryValue"
        case dataType = "DataType"
        case stringValue = "StringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let binaryValue = binaryValue {
            try container.encode(binaryValue.base64EncodedString(), forKey: ClientRuntime.Key("BinaryValue"))
        }
        if let dataType = dataType {
            try container.encode(dataType, forKey: ClientRuntime.Key("DataType"))
        }
        if let stringValue = stringValue {
            try container.encode(stringValue, forKey: ClientRuntime.Key("StringValue"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.MessageAttributeValue, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.MessageAttributeValue()
            value.dataType = try reader["DataType"].readIfPresent()
            value.stringValue = try reader["StringValue"].readIfPresent()
            value.binaryValue = try reader["BinaryValue"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// The user-specified message attribute value. For string data types, the value attribute has the same restrictions on the content as the message body. For more information, see [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html). Name, type, and value must not be empty or null. In addition, the message body should not be empty or null. All parts of the message attribute, including name, type, and value, are included in the message size restriction, which is currently 256 KB (262,144 bytes). For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html) and [Publishing to a mobile phone](https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html) in the Amazon SNS Developer Guide.
    public struct MessageAttributeValue: Swift.Equatable {
        /// Binary type attributes can store any binary data, for example, compressed data, encrypted data, or images.
        public var binaryValue: ClientRuntime.Data?
        /// Amazon SNS supports the following logical data types: String, String.Array, Number, and Binary. For more information, see [Message Attribute Data Types](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html#SNSMessageAttributes.DataTypes).
        /// This member is required.
        public var dataType: Swift.String?
        /// Strings are Unicode with UTF8 binary encoding. For a list of code values, see [ASCII Printable Characters](https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
        public var stringValue: Swift.String?

        public init(
            binaryValue: ClientRuntime.Data? = nil,
            dataType: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.binaryValue = binaryValue
            self.dataType = dataType
            self.stringValue = stringValue
        }
    }

}

extension NotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the requested resource does not exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {
    /// Enum listing out all supported number capabilities.
    public enum NumberCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mms
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .mms,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mms: return "MMS"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumberCapability(rawValue: rawValue) ?? NumberCapability.sdkUnknown(rawValue)
        }
    }
}

extension OptInPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptInPhoneNumberInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

extension OptInPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("phoneNumber"))
        }
        try container.encode("OptInPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension OptInPhoneNumberInput {

    static func urlPathProvider(_ value: OptInPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

/// Input for the OptInPhoneNumber action.
public struct OptInPhoneNumberInput: Swift.Equatable {
    /// The phone number to opt in. Use E.164 format.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension OptInPhoneNumberOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<OptInPhoneNumberOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return OptInPhoneNumberOutput()
        }
    }
}

/// The response for the OptInPhoneNumber action.
public struct OptInPhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum OptInPhoneNumberOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension OptedOutException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = OptedOutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the specified phone number opted out of receiving SMS messages from your Amazon Web Services account. You can't send SMS messages to phone numbers that opt out.
public struct OptedOutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OptedOut" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes.PhoneNumberInformation: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case iso2CountryCode = "Iso2CountryCode"
        case numberCapabilities = "NumberCapabilities"
        case phoneNumber = "PhoneNumber"
        case routeType = "RouteType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let createdAt = createdAt {
            try container.encodeTimestamp(createdAt, format: .dateTime, forKey: ClientRuntime.Key("CreatedAt"))
        }
        if let iso2CountryCode = iso2CountryCode {
            try container.encode(iso2CountryCode, forKey: ClientRuntime.Key("Iso2CountryCode"))
        }
        if let numberCapabilities = numberCapabilities {
            if !numberCapabilities.isEmpty {
                var numberCapabilitiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NumberCapabilities"))
                for (index0, numbercapability0) in numberCapabilities.enumerated() {
                    try numberCapabilitiesContainer.encode(numbercapability0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var numberCapabilitiesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("NumberCapabilities"))
                try numberCapabilitiesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let routeType = routeType {
            try container.encode(routeType, forKey: ClientRuntime.Key("RouteType"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.PhoneNumberInformation, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.PhoneNumberInformation()
            value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: .dateTime)
            value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            value.iso2CountryCode = try reader["Iso2CountryCode"].readIfPresent()
            value.routeType = try reader["RouteType"].readIfPresent()
            value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SNSClientTypes.NumberCapability.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

extension SNSClientTypes.PhoneNumberInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberInformation(createdAt: \(Swift.String(describing: createdAt)), iso2CountryCode: \(Swift.String(describing: iso2CountryCode)), numberCapabilities: \(Swift.String(describing: numberCapabilities)), routeType: \(Swift.String(describing: routeType)), status: \(Swift.String(describing: status)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension SNSClientTypes {
    /// A list of phone numbers and their metadata.
    public struct PhoneNumberInformation: Swift.Equatable {
        /// The date and time when the phone number was created.
        public var createdAt: ClientRuntime.Date?
        /// The two-character code for the country or region, in ISO 3166-1 alpha-2 format.
        public var iso2CountryCode: Swift.String?
        /// The capabilities of each phone number.
        public var numberCapabilities: [SNSClientTypes.NumberCapability]?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The list of supported routes.
        public var routeType: SNSClientTypes.RouteType?
        /// The status of the phone number.
        public var status: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            iso2CountryCode: Swift.String? = nil,
            numberCapabilities: [SNSClientTypes.NumberCapability]? = nil,
            phoneNumber: Swift.String? = nil,
            routeType: SNSClientTypes.RouteType? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.iso2CountryCode = iso2CountryCode
            self.numberCapabilities = numberCapabilities
            self.phoneNumber = phoneNumber
            self.routeType = routeType
            self.status = status
        }
    }

}

extension SNSClientTypes.PlatformApplication: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.PlatformApplication, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.PlatformApplication()
            value.platformApplicationArn = try reader["PlatformApplicationArn"].readIfPresent()
            value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: Swift.String.readingClosure, keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            return value
        }
    }
}

extension SNSClientTypes {
    /// Platform application object.
    public struct PlatformApplication: Swift.Equatable {
        /// Attributes for platform application object.
        public var attributes: [Swift.String:Swift.String]?
        /// PlatformApplicationArn for platform application object.
        public var platformApplicationArn: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            platformApplicationArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.platformApplicationArn = platformApplicationArn
        }
    }

}

extension PlatformApplicationDisabledException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = PlatformApplicationDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Exception error indicating platform application disabled.
public struct PlatformApplicationDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message for platform application disabled.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PlatformApplicationDisabled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension PublishBatchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publishBatchRequestEntries = "PublishBatchRequestEntries"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let publishBatchRequestEntries = publishBatchRequestEntries {
            if !publishBatchRequestEntries.isEmpty {
                var publishBatchRequestEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PublishBatchRequestEntries"))
                for (index0, publishbatchrequestentry0) in publishBatchRequestEntries.enumerated() {
                    try publishBatchRequestEntriesContainer.encode(publishbatchrequestentry0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var publishBatchRequestEntriesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("PublishBatchRequestEntries"))
                try publishBatchRequestEntriesContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("PublishBatch", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PublishBatchInput {

    static func urlPathProvider(_ value: PublishBatchInput) -> Swift.String? {
        return "/"
    }
}

public struct PublishBatchInput: Swift.Equatable {
    /// A list of PublishBatch request entries to be sent to the SNS topic.
    /// This member is required.
    public var publishBatchRequestEntries: [SNSClientTypes.PublishBatchRequestEntry]?
    /// The Amazon resource name (ARN) of the topic you want to batch publish to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        publishBatchRequestEntries: [SNSClientTypes.PublishBatchRequestEntry]? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.publishBatchRequestEntries = publishBatchRequestEntries
        self.topicArn = topicArn
    }
}

extension PublishBatchOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PublishBatchOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["PublishBatchResult"]
            var value = PublishBatchOutput()
            value.failed = try reader["Failed"].readListIfPresent(memberReadingClosure: SNSClientTypes.BatchResultErrorEntry.readingClosure, memberNodeInfo: "member", isFlattened: false)
            value.successful = try reader["Successful"].readListIfPresent(memberReadingClosure: SNSClientTypes.PublishBatchResultEntry.readingClosure, memberNodeInfo: "member", isFlattened: false)
            return value
        }
    }
}

public struct PublishBatchOutput: Swift.Equatable {
    /// A list of failed PublishBatch responses.
    public var failed: [SNSClientTypes.BatchResultErrorEntry]?
    /// A list of successful PublishBatch responses.
    public var successful: [SNSClientTypes.PublishBatchResultEntry]?

    public init(
        failed: [SNSClientTypes.BatchResultErrorEntry]? = nil,
        successful: [SNSClientTypes.PublishBatchResultEntry]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

enum PublishBatchOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "BatchEntryIdsNotDistinct": return try await BatchEntryIdsNotDistinctException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "BatchRequestTooLong": return try await BatchRequestTooLongException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EmptyBatchRequest": return try await EmptyBatchRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EndpointDisabled": return try await EndpointDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidBatchEntryId": return try await InvalidBatchEntryIdException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ParameterValueInvalid": return try await InvalidParameterValueException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSAccessDenied": return try await KMSAccessDeniedException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSDisabled": return try await KMSDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSInvalidState": return try await KMSInvalidStateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSNotFound": return try await KMSNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSOptInRequired": return try await KMSOptInRequired.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSThrottling": return try await KMSThrottlingException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PlatformApplicationDisabled": return try await PlatformApplicationDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TooManyEntriesInBatchRequest": return try await TooManyEntriesInBatchRequestException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SNSClientTypes.PublishBatchRequestEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case message = "Message"
        case messageAttributes = "MessageAttributes"
        case messageDeduplicationId = "MessageDeduplicationId"
        case messageGroupId = "MessageGroupId"
        case messageStructure = "MessageStructure"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: ClientRuntime.Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: ClientRuntime.Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: ClientRuntime.Key("MessageStructure"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: ClientRuntime.Key("Subject"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.PublishBatchRequestEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.PublishBatchRequestEntry()
            value.id = try reader["Id"].readIfPresent()
            value.message = try reader["Message"].readIfPresent()
            value.subject = try reader["Subject"].readIfPresent()
            value.messageStructure = try reader["MessageStructure"].readIfPresent()
            value.messageAttributes = try reader["MessageAttributes"].readMapIfPresent(valueReadingClosure: SNSClientTypes.MessageAttributeValue.readingClosure, keyNodeInfo: "Name", valueNodeInfo: "Value", isFlattened: false)
            value.messageDeduplicationId = try reader["MessageDeduplicationId"].readIfPresent()
            value.messageGroupId = try reader["MessageGroupId"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// Contains the details of a single Amazon SNS message along with an Id that identifies a message within the batch.
    public struct PublishBatchRequestEntry: Swift.Equatable {
        /// An identifier for the message in this batch. The Ids of a batch request must be unique within a request. This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).
        /// This member is required.
        public var id: Swift.String?
        /// The body of the message.
        /// This member is required.
        public var message: Swift.String?
        /// Each message attribute consists of a Name, Type, and Value. For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html) in the Amazon SNS Developer Guide.
        public var messageAttributes: [Swift.String:SNSClientTypes.MessageAttributeValue]?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular MessageDeduplicationId is sent successfully, subsequent messages with the same MessageDeduplicationId are accepted successfully but aren't delivered.
        ///
        /// * Every message must have a unique MessageDeduplicationId.
        ///
        /// * You may provide a MessageDeduplicationId explicitly.
        ///
        /// * If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your topic, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).
        ///
        /// * If you don't provide a MessageDeduplicationId and the topic doesn't have ContentBasedDeduplication set, the action fails with an error.
        ///
        /// * If the topic has a ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.
        ///
        ///
        ///
        ///
        /// * When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.
        ///
        /// * If you send one message with ContentBasedDeduplication enabled, and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.
        ///
        ///
        /// The MessageDeduplicationId is available to the consumer of the message (this can be useful for troubleshooting delivery issues). If a message is sent successfully but the acknowledgement is lost and the message is resent with the same MessageDeduplicationId after the deduplication interval, Amazon SNS can't detect duplicate messages. Amazon SNS continues to keep track of the message deduplication ID even after the message is received and deleted. The length of MessageDeduplicationId is 128 characters. MessageDeduplicationId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~).
        public var messageDeduplicationId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). To interleave multiple ordered streams within a single topic, use MessageGroupId values (for example, session data for multiple users). In this scenario, multiple consumers can process the topic, but the session data of each user is processed in a FIFO fashion. You must associate a non-empty MessageGroupId with a message. If you don't provide a MessageGroupId, the action fails. The length of MessageGroupId is 128 characters. MessageGroupId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). MessageGroupId is required for FIFO topics. You can't use it for standard topics.
        public var messageGroupId: Swift.String?
        /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
        ///
        /// * be a syntactically valid JSON object; and
        ///
        /// * contain at least a top-level JSON key of "default" with a value that is a string.
        ///
        ///
        /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g. http).
        public var messageStructure: Swift.String?
        /// The subject of the batch message.
        public var subject: Swift.String?

        public init(
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            messageAttributes: [Swift.String:SNSClientTypes.MessageAttributeValue]? = nil,
            messageDeduplicationId: Swift.String? = nil,
            messageGroupId: Swift.String? = nil,
            messageStructure: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.id = id
            self.message = message
            self.messageAttributes = messageAttributes
            self.messageDeduplicationId = messageDeduplicationId
            self.messageGroupId = messageGroupId
            self.messageStructure = messageStructure
            self.subject = subject
        }
    }

}

extension SNSClientTypes.PublishBatchResultEntry: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case messageId = "MessageId"
        case sequenceNumber = "SequenceNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let id = id {
            try container.encode(id, forKey: ClientRuntime.Key("Id"))
        }
        if let messageId = messageId {
            try container.encode(messageId, forKey: ClientRuntime.Key("MessageId"))
        }
        if let sequenceNumber = sequenceNumber {
            try container.encode(sequenceNumber, forKey: ClientRuntime.Key("SequenceNumber"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.PublishBatchResultEntry, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.PublishBatchResultEntry()
            value.id = try reader["Id"].readIfPresent()
            value.messageId = try reader["MessageId"].readIfPresent()
            value.sequenceNumber = try reader["SequenceNumber"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// Encloses data related to a successful message in a batch request for topic.
    public struct PublishBatchResultEntry: Swift.Equatable {
        /// The Id of an entry in a batch request.
        public var id: Swift.String?
        /// An identifier for the message.
        public var messageId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for a particular MessageGroupId.
        public var sequenceNumber: Swift.String?

        public init(
            id: Swift.String? = nil,
            messageId: Swift.String? = nil,
            sequenceNumber: Swift.String? = nil
        )
        {
            self.id = id
            self.messageId = messageId
            self.sequenceNumber = sequenceNumber
        }
    }

}

extension PublishInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishInput(message: \(Swift.String(describing: message)), messageAttributes: \(Swift.String(describing: messageAttributes)), messageDeduplicationId: \(Swift.String(describing: messageDeduplicationId)), messageGroupId: \(Swift.String(describing: messageGroupId)), messageStructure: \(Swift.String(describing: messageStructure)), subject: \(Swift.String(describing: subject)), targetArn: \(Swift.String(describing: targetArn)), topicArn: \(Swift.String(describing: topicArn)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension PublishInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case messageAttributes = "MessageAttributes"
        case messageDeduplicationId = "MessageDeduplicationId"
        case messageGroupId = "MessageGroupId"
        case messageStructure = "MessageStructure"
        case phoneNumber = "PhoneNumber"
        case subject = "Subject"
        case targetArn = "TargetArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let message = message {
            try container.encode(message, forKey: ClientRuntime.Key("Message"))
        }
        if let messageAttributes = messageAttributes {
            var messageAttributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("MessageAttributes"))
            for (index0, element0) in messageAttributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let messageattributevalueValue0 = element0.value
                var entryContainer0 = messageAttributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Name"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Value"))
                try valueContainer0.encode(messageattributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let messageDeduplicationId = messageDeduplicationId {
            try container.encode(messageDeduplicationId, forKey: ClientRuntime.Key("MessageDeduplicationId"))
        }
        if let messageGroupId = messageGroupId {
            try container.encode(messageGroupId, forKey: ClientRuntime.Key("MessageGroupId"))
        }
        if let messageStructure = messageStructure {
            try container.encode(messageStructure, forKey: ClientRuntime.Key("MessageStructure"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let subject = subject {
            try container.encode(subject, forKey: ClientRuntime.Key("Subject"))
        }
        if let targetArn = targetArn {
            try container.encode(targetArn, forKey: ClientRuntime.Key("TargetArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Publish", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PublishInput {

    static func urlPathProvider(_ value: PublishInput) -> Swift.String? {
        return "/"
    }
}

/// Input for Publish action.
public struct PublishInput: Swift.Equatable {
    /// The message you want to send. If you are publishing to a topic and you want to send the same message to all transport protocols, include the text of the message as a String value. If you want to send different messages for each transport protocol, set the value of the MessageStructure parameter to json and use a JSON object for the Message parameter. Constraints:
    ///
    /// * With the exception of SMS, messages must be UTF-8 encoded strings and at most 256 KB in size (262,144 bytes, not 262,144 characters).
    ///
    /// * For SMS, each message can contain up to 140 characters. This character limit depends on the encoding schema. For example, an SMS message can contain 160 GSM characters, 140 ASCII characters, or 70 UCS-2 characters. If you publish a message that exceeds this size limit, Amazon SNS sends the message as multiple messages, each fitting within the size limit. Messages aren't truncated mid-word but are cut off at whole-word boundaries. The total size limit for a single SMS Publish action is 1,600 characters.
    ///
    ///
    /// JSON-specific constraints:
    ///
    /// * Keys in the JSON object that correspond to supported transport protocols must have simple JSON string values.
    ///
    /// * The values will be parsed (unescaped) before they are used in outgoing messages.
    ///
    /// * Outbound notifications are JSON encoded (meaning that the characters will be reescaped for sending).
    ///
    /// * Values have a minimum length of 0 (the empty string, "", is allowed).
    ///
    /// * Values have a maximum length bounded by the overall message size (so, including multiple protocols may limit message sizes).
    ///
    /// * Non-string values will cause the key to be ignored.
    ///
    /// * Keys that do not correspond to supported transport protocols are ignored.
    ///
    /// * Duplicate keys are not allowed.
    ///
    /// * Failure to parse or validate any key or value in the message will cause the Publish call to return an error (no partial delivery).
    /// This member is required.
    public var message: Swift.String?
    /// Message attributes for Publish action.
    public var messageAttributes: [Swift.String:SNSClientTypes.MessageAttributeValue]?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageDeduplicationId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). Every message must have a unique MessageDeduplicationId, which is a token used for deduplication of sent messages. If a message with a particular MessageDeduplicationId is sent successfully, any message sent with the same MessageDeduplicationId during the 5-minute deduplication interval is treated as a duplicate. If the topic has ContentBasedDeduplication set, the system generates a MessageDeduplicationId based on the contents of the message. Your MessageDeduplicationId overrides the generated one.
    public var messageDeduplicationId: Swift.String?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageGroupId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). The MessageGroupId is a tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). Every message must include a MessageGroupId.
    public var messageGroupId: Swift.String?
    /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
    ///
    /// * be a syntactically valid JSON object; and
    ///
    /// * contain at least a top-level JSON key of "default" with a value that is a string.
    ///
    ///
    /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g., "http"). Valid value: json
    public var messageStructure: Swift.String?
    /// The phone number to which you want to deliver an SMS message. Use E.164 format. If you don't specify a value for the PhoneNumber parameter, you must specify a value for the TargetArn or TopicArn parameters.
    public var phoneNumber: Swift.String?
    /// Optional parameter to be used as the "Subject" line when the message is delivered to email endpoints. This field will also be included, if present, in the standard JSON messages delivered to other endpoints. Constraints: Subjects must be ASCII text that begins with a letter, number, or punctuation mark; must not include line breaks or control characters; and must be less than 100 characters long.
    public var subject: Swift.String?
    /// If you don't specify a value for the TargetArn parameter, you must specify a value for the PhoneNumber or TopicArn parameters.
    public var targetArn: Swift.String?
    /// The topic you want to publish to. If you don't specify a value for the TopicArn parameter, you must specify a value for the PhoneNumber or TargetArn parameters.
    public var topicArn: Swift.String?

    public init(
        message: Swift.String? = nil,
        messageAttributes: [Swift.String:SNSClientTypes.MessageAttributeValue]? = nil,
        messageDeduplicationId: Swift.String? = nil,
        messageGroupId: Swift.String? = nil,
        messageStructure: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        subject: Swift.String? = nil,
        targetArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.message = message
        self.messageAttributes = messageAttributes
        self.messageDeduplicationId = messageDeduplicationId
        self.messageGroupId = messageGroupId
        self.messageStructure = messageStructure
        self.phoneNumber = phoneNumber
        self.subject = subject
        self.targetArn = targetArn
        self.topicArn = topicArn
    }
}

extension PublishOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PublishOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["PublishResult"]
            var value = PublishOutput()
            value.messageId = try reader["MessageId"].readIfPresent()
            value.sequenceNumber = try reader["SequenceNumber"].readIfPresent()
            return value
        }
    }
}

/// Response for Publish action.
public struct PublishOutput: Swift.Equatable {
    /// Unique identifier assigned to the published message. Length Constraint: Maximum 100 characters
    public var messageId: Swift.String?
    /// This response element applies only to FIFO (first-in-first-out) topics. The sequence number is a large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for each MessageGroupId.
    public var sequenceNumber: Swift.String?

    public init(
        messageId: Swift.String? = nil,
        sequenceNumber: Swift.String? = nil
    )
    {
        self.messageId = messageId
        self.sequenceNumber = sequenceNumber
    }
}

enum PublishOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "EndpointDisabled": return try await EndpointDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ParameterValueInvalid": return try await InvalidParameterValueException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSAccessDenied": return try await KMSAccessDeniedException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSDisabled": return try await KMSDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSInvalidState": return try await KMSInvalidStateException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSNotFound": return try await KMSNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSOptInRequired": return try await KMSOptInRequired.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "KMSThrottling": return try await KMSThrottlingException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "PlatformApplicationDisabled": return try await PlatformApplicationDisabledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ValidationException": return try await ValidationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension PutDataProtectionPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataProtectionPolicy = "DataProtectionPolicy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let dataProtectionPolicy = dataProtectionPolicy {
            try container.encode(dataProtectionPolicy, forKey: ClientRuntime.Key("DataProtectionPolicy"))
        }
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        try container.encode("PutDataProtectionPolicy", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension PutDataProtectionPolicyInput {

    static func urlPathProvider(_ value: PutDataProtectionPolicyInput) -> Swift.String? {
        return "/"
    }
}

public struct PutDataProtectionPolicyInput: Swift.Equatable {
    /// The JSON serialization of the topic's DataProtectionPolicy. The DataProtectionPolicy must be in JSON string format. Length Constraints: Maximum length of 30,720.
    /// This member is required.
    public var dataProtectionPolicy: Swift.String?
    /// The ARN of the topic whose DataProtectionPolicy you want to add or update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        dataProtectionPolicy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.dataProtectionPolicy = dataProtectionPolicy
        self.resourceArn = resourceArn
    }
}

extension PutDataProtectionPolicyOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<PutDataProtectionPolicyOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return PutDataProtectionPolicyOutput()
        }
    }
}

public struct PutDataProtectionPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutDataProtectionPolicyOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension RemovePermissionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case label = "Label"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let label = label {
            try container.encode(label, forKey: ClientRuntime.Key("Label"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("RemovePermission", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension RemovePermissionInput {

    static func urlPathProvider(_ value: RemovePermissionInput) -> Swift.String? {
        return "/"
    }
}

/// Input for RemovePermission action.
public struct RemovePermissionInput: Swift.Equatable {
    /// The unique label of the statement you want to remove.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.label = label
        self.topicArn = topicArn
    }
}

extension RemovePermissionOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<RemovePermissionOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return RemovePermissionOutput()
        }
    }
}

public struct RemovePermissionOutput: Swift.Equatable {

    public init() { }
}

enum RemovePermissionOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ReplayLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ReplayLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the request parameter has exceeded the maximum number of concurrent message replays.
public struct ReplayLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplayLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Can’t perform the action on the specified resource. Make sure that the resource exists.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {
    /// Enum listing out all supported route types. The following enum values are supported. 1. Transactional : Non-marketing traffic 2. Promotional : Marketing 3. Premium : Premium routes for OTP delivery to the carriers
    public enum RouteType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case premium
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .premium,
                .promotional,
                .transactional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .premium: return "Premium"
            case .promotional: return "Promotional"
            case .transactional: return "Transactional"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RouteType(rawValue: rawValue) ?? RouteType.sdkUnknown(rawValue)
        }
    }
}

extension SNSClientTypes.SMSSandboxPhoneNumber: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case phoneNumber = "PhoneNumber"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        if let status = status {
            try container.encode(status, forKey: ClientRuntime.Key("Status"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.SMSSandboxPhoneNumber, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.SMSSandboxPhoneNumber()
            value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
            value.status = try reader["Status"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes.SMSSandboxPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SMSSandboxPhoneNumber(status: \(Swift.String(describing: status)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension SNSClientTypes {
    /// A verified or pending destination phone number in the SMS sandbox. When you start using Amazon SNS to send SMS messages, your Amazon Web Services account is in the SMS sandbox. The SMS sandbox provides a safe environment for you to try Amazon SNS features without risking your reputation as an SMS sender. While your Amazon Web Services account is in the SMS sandbox, you can use all of the features of Amazon SNS. However, you can send SMS messages only to verified destination phone numbers. For more information, including how to move out of the sandbox to send messages without restrictions, see [SMS sandbox](https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html) in the Amazon SNS Developer Guide.
    public struct SMSSandboxPhoneNumber: Swift.Equatable {
        /// The destination phone number.
        public var phoneNumber: Swift.String?
        /// The destination phone number's verification status.
        public var status: SNSClientTypes.SMSSandboxPhoneNumberVerificationStatus?

        public init(
            phoneNumber: Swift.String? = nil,
            status: SNSClientTypes.SMSSandboxPhoneNumberVerificationStatus? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.status = status
        }
    }

}

extension SNSClientTypes {
    /// Enum listing out all supported destination phone number verification statuses. The following enum values are supported. 1. PENDING : The destination phone number is pending verification. 2. VERIFIED : The destination phone number is verified.
    public enum SMSSandboxPhoneNumberVerificationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [SMSSandboxPhoneNumberVerificationStatus] {
            return [
                .pending,
                .verified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pending: return "Pending"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SMSSandboxPhoneNumberVerificationStatus(rawValue: rawValue) ?? SMSSandboxPhoneNumberVerificationStatus.sdkUnknown(rawValue)
        }
    }
}

public enum SNSClientTypes {}

extension SetEndpointAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpointArn = "EndpointArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpointArn = endpointArn {
            try container.encode(endpointArn, forKey: ClientRuntime.Key("EndpointArn"))
        }
        try container.encode("SetEndpointAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetEndpointAttributesInput {

    static func urlPathProvider(_ value: SetEndpointAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for SetEndpointAttributes action.
public struct SetEndpointAttributesInput: Swift.Equatable {
    /// A map of the endpoint attributes. Attributes in this map include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// EndpointArn used for SetEndpointAttributes action.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        endpointArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

extension SetEndpointAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetEndpointAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetEndpointAttributesOutput()
        }
    }
}

public struct SetEndpointAttributesOutput: Swift.Equatable {

    public init() { }
}

enum SetEndpointAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetPlatformApplicationAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case platformApplicationArn = "PlatformApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let platformApplicationArn = platformApplicationArn {
            try container.encode(platformApplicationArn, forKey: ClientRuntime.Key("PlatformApplicationArn"))
        }
        try container.encode("SetPlatformApplicationAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetPlatformApplicationAttributesInput {

    static func urlPathProvider(_ value: SetPlatformApplicationAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for SetPlatformApplicationAttributes action.
public struct SetPlatformApplicationAttributesInput: Swift.Equatable {
    /// A map of the platform application attributes. Attributes in this map include the following:
    ///
    /// * PlatformCredential – The credential received from the notification service.
    ///
    /// * For ADM, PlatformCredentialis client secret.
    ///
    /// * For Apple Services using certificate credentials, PlatformCredential is private key.
    ///
    /// * For Apple Services using token credentials, PlatformCredential is signing key.
    ///
    /// * For GCM (Firebase Cloud Messaging) using key credentials, there is no PlatformPrincipal. The PlatformCredential is API key.
    ///
    /// * For GCM (Firebase Cloud Messaging) using token credentials, there is no PlatformPrincipal. The PlatformCredential is a JSON formatted private key file. When using the Amazon Web Services CLI, the file must be in string format and special characters must be ignored. To format the file correctly, Amazon SNS recommends using the following command: SERVICE_JSON=`jq @json <<< cat service.json`.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * PlatformPrincipal – The principal received from the notification service.
    ///
    /// * For ADM, PlatformPrincipalis client id.
    ///
    /// * For Apple Services using certificate credentials, PlatformPrincipal is SSL certificate.
    ///
    /// * For Apple Services using token credentials, PlatformPrincipal is signing key ID.
    ///
    /// * For GCM (Firebase Cloud Messaging), there is no PlatformPrincipal.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications are sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications are sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications are sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications are sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    ///
    /// * SuccessFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * FailureFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * SuccessFeedbackSampleRate – Sample rate percentage (0-100) of successfully delivered messages.
    ///
    ///
    /// The following attributes only apply to APNs token-based authentication:
    ///
    /// * ApplePlatformTeamID – The identifier that's assigned to your Apple developer account team.
    ///
    /// * ApplePlatformBundleID – The bundle identifier that's assigned to your iOS app.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?
    /// PlatformApplicationArn for SetPlatformApplicationAttributes action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

extension SetPlatformApplicationAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetPlatformApplicationAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetPlatformApplicationAttributesOutput()
        }
    }
}

public struct SetPlatformApplicationAttributesOutput: Swift.Equatable {

    public init() { }
}

enum SetPlatformApplicationAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetSMSAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let stringKey0 = element0.key
                let stringValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(stringKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(stringValue0, forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("SetSMSAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSMSAttributesInput {

    static func urlPathProvider(_ value: SetSMSAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// The input for the SetSMSAttributes action.
public struct SetSMSAttributesInput: Swift.Equatable {
    /// The default settings for sending SMS messages from your Amazon Web Services account. You can set values for the following attribute names: MonthlySpendLimit – The maximum amount in USD that you are willing to spend each month to send SMS messages. When Amazon SNS determines that sending an SMS message would incur a cost that exceeds this limit, it stops sending SMS messages within minutes. Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During that interval, if you continue to send SMS messages, you will incur costs that exceed your limit. By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to raise the limit, submit an [SNS Limit Increase case](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns). For New limit value, enter your desired monthly spend limit. In the Use Case Description field, explain that you are requesting an SMS monthly spend limit increase. DeliveryStatusIAMRole – The ARN of the IAM role that allows Amazon SNS to write logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS writes a log that includes the message price, the success or failure status, the reason for failure (if the message failed), the message dwell time, and other information. DeliveryStatusSuccessSamplingRate – The percentage of successful SMS deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an integer from 0 - 100. For example, to write logs only for failed deliveries, set this value to 0. To write logs for 10% of your successful deliveries, set it to 10. DefaultSenderID – A string, such as your business brand, that is displayed as the sender on the receiving device. Support for sender IDs varies by country. The sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one letter. DefaultSMSType – The type of SMS message that you will send by default. You can assign the following values:
    ///
    /// * Promotional – (Default) Noncritical messages, such as marketing messages. Amazon SNS optimizes the message delivery to incur the lowest cost.
    ///
    /// * Transactional – Critical messages that support customer transactions, such as one-time passcodes for multi-factor authentication. Amazon SNS optimizes the message delivery to achieve the highest reliability.
    ///
    ///
    /// UsageReportS3Bucket – The name of the Amazon S3 bucket to receive daily SMS usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to the bucket. The report includes the following information for each SMS message that was successfully delivered by your Amazon Web Services account:
    ///
    /// * Time that the message was published (in UTC)
    ///
    /// * Message ID
    ///
    /// * Destination phone number
    ///
    /// * Message type
    ///
    /// * Delivery status
    ///
    /// * Message price (in USD)
    ///
    /// * Part number (a message is split into multiple parts if it is too long for a single message)
    ///
    /// * Total number of parts
    ///
    ///
    /// To receive the report, the bucket must have a policy that allows the Amazon SNS service principal to perform the s3:PutObject and s3:GetBucketLocation actions. For an example bucket policy and usage report, see [Monitoring SMS Activity](https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributes: [Swift.String:Swift.String]?

    public init(
        attributes: [Swift.String:Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension SetSMSAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetSMSAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetSMSAttributesOutput()
        }
    }
}

/// The response for the SetSMSAttributes action.
public struct SetSMSAttributesOutput: Swift.Equatable {

    public init() { }
}

enum SetSMSAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetSubscriptionAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("SetSubscriptionAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetSubscriptionAttributesInput {

    static func urlPathProvider(_ value: SetSubscriptionAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for SetSubscriptionAttributes action.
public struct SetSubscriptionAttributesInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that this action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute in JSON format.
    public var attributeValue: Swift.String?
    /// The ARN of the subscription to modify.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        subscriptionArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.subscriptionArn = subscriptionArn
    }
}

extension SetSubscriptionAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetSubscriptionAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetSubscriptionAttributesOutput()
        }
    }
}

public struct SetSubscriptionAttributesOutput: Swift.Equatable {

    public init() { }
}

enum SetSubscriptionAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "FilterPolicyLimitExceeded": return try await FilterPolicyLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ReplayLimitExceeded": return try await ReplayLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SetTopicAttributesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributeName = attributeName {
            try container.encode(attributeName, forKey: ClientRuntime.Key("AttributeName"))
        }
        if let attributeValue = attributeValue {
            try container.encode(attributeValue, forKey: ClientRuntime.Key("AttributeValue"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("SetTopicAttributes", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SetTopicAttributesInput {

    static func urlPathProvider(_ value: SetTopicAttributesInput) -> Swift.String? {
        return "/"
    }
}

/// Input for SetTopicAttributes action.
public struct SetTopicAttributesInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the SetTopicAttributes action uses:
    ///
    /// * ApplicationSuccessFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    /// * HTTP
    ///
    /// * HTTPSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    /// * HTTPSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    /// * HTTPFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    ///
    ///
    ///
    /// * Amazon Kinesis Data Firehose
    ///
    /// * FirehoseSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    /// * FirehoseSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    /// * FirehoseFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    ///
    ///
    ///
    /// * Lambda
    ///
    /// * LambdaSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    /// * LambdaSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    /// * LambdaFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    ///
    ///
    ///
    /// * Platform application endpoint
    ///
    /// * ApplicationSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    /// * ApplicationSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    /// * ApplicationFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    ///
    /// In addition to being able to configure topic attributes for message delivery status of notification messages sent to Amazon SNS application endpoints, you can also configure application attributes for the delivery status of push notification messages sent to push notification services. For example, For more information, see [Using Amazon SNS Application Attributes for Message Delivery Status](https://docs.aws.amazon.com/sns/latest/dg/sns-msg-status.html).
    ///
    /// * Amazon SQS
    ///
    /// * SQSSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    /// * SQSSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    /// * SQSFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    ///
    ///
    ///
    ///
    /// The SuccessFeedbackRoleArn and FailureFeedbackRoleArn attributes are used to give Amazon SNS write access to use CloudWatch Logs on your behalf. The SuccessFeedbackSampleRate attribute is for specifying the sample rate percentage (0-100) of successfully delivered messages. After you configure the FailureFeedbackRoleArn attribute, then all failed message deliveries generate CloudWatch Logs. The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, SignatureVersion is set to 1.
    ///
    ///
    /// The following attribute applies only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute.
    public var attributeValue: Swift.String?
    /// The ARN of the topic to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.topicArn = topicArn
    }
}

extension SetTopicAttributesOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SetTopicAttributesOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return SetTopicAttributesOutput()
        }
    }
}

public struct SetTopicAttributesOutput: Swift.Equatable {

    public init() { }
}

enum SetTopicAttributesOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension StaleTagException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = StaleTagException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// A tag has been added to a resource with the same ARN as a deleted resource. Wait a short while and then retry the operation.
public struct StaleTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StaleTag" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SubscribeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case endpoint = "Endpoint"
        case `protocol` = "Protocol"
        case returnSubscriptionArn = "ReturnSubscriptionArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Attributes"))
            for (index0, element0) in attributes.sorted(by: { $0.key < $1.key }).enumerated() {
                let attributenameKey0 = element0.key
                let attributevalueValue0 = element0.value
                var entryContainer0 = attributesContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("key"))
                try keyContainer0.encode(attributenameKey0, forKey: ClientRuntime.Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("value"))
                try valueContainer0.encode(attributevalueValue0, forKey: ClientRuntime.Key(""))
            }
        }
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let returnSubscriptionArn = returnSubscriptionArn {
            try container.encode(returnSubscriptionArn, forKey: ClientRuntime.Key("ReturnSubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
        try container.encode("Subscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension SubscribeInput {

    static func urlPathProvider(_ value: SubscribeInput) -> Swift.String? {
        return "/"
    }
}

/// Input for Subscribe action.
public struct SubscribeInput: Swift.Equatable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the Subscribe action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Kinesis Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Kinesis Data Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Kinesis Data Firehose delivery stream subscriptions. For more information, see [Fanout to Kinesis Data Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ReplayPolicy – Adds or updates an inline policy document for a subscription to replay messages stored in the specified Amazon SNS topic.
    ///
    /// * ReplayStatus – Retrieves the status of the subscription message replay, which can be one of the following:
    ///
    /// * Completed – The replay has successfully redelivered all messages, and is now delivering newly published messages. If an ending point was specified in the ReplayPolicy then the subscription will no longer receive newly published messages.
    ///
    /// * In progress – The replay is currently replaying the selected messages.
    ///
    /// * Failed – The replay was unable to complete.
    ///
    /// * Pending – The default state while the replay initiates.
    public var attributes: [Swift.String:Swift.String]?
    /// The endpoint that you want to receive notifications. Endpoints vary by protocol:
    ///
    /// * For the http protocol, the (public) endpoint is a URL beginning with http://.
    ///
    /// * For the https protocol, the (public) endpoint is a URL beginning with https://.
    ///
    /// * For the email protocol, the endpoint is an email address.
    ///
    /// * For the email-json protocol, the endpoint is an email address.
    ///
    /// * For the sms protocol, the endpoint is a phone number of an SMS-enabled device.
    ///
    /// * For the sqs protocol, the endpoint is the ARN of an Amazon SQS queue.
    ///
    /// * For the application protocol, the endpoint is the EndpointArn of a mobile app and device.
    ///
    /// * For the lambda protocol, the endpoint is the ARN of an Lambda function.
    ///
    /// * For the firehose protocol, the endpoint is the ARN of an Amazon Kinesis Data Firehose delivery stream.
    public var endpoint: Swift.String?
    /// The protocol that you want to use. Supported protocols include:
    ///
    /// * http – delivery of JSON-encoded message via HTTP POST
    ///
    /// * https – delivery of JSON-encoded message via HTTPS POST
    ///
    /// * email – delivery of message via SMTP
    ///
    /// * email-json – delivery of JSON-encoded message via SMTP
    ///
    /// * sms – delivery of message via SMS
    ///
    /// * sqs – delivery of JSON-encoded message to an Amazon SQS queue
    ///
    /// * application – delivery of JSON-encoded message to an EndpointArn for a mobile app and device
    ///
    /// * lambda – delivery of JSON-encoded message to an Lambda function
    ///
    /// * firehose – delivery of JSON-encoded message to an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var `protocol`: Swift.String?
    /// Sets whether the response from the Subscribe request includes the subscription ARN, even if the subscription is not yet confirmed. If you set this parameter to true, the response includes the ARN in all cases, even if the subscription is not yet confirmed. In addition to the ARN for confirmed subscriptions, the response also includes the pending subscription ARN value for subscriptions that aren't yet confirmed. A subscription becomes confirmed when the subscriber calls the ConfirmSubscription action with a confirmation token. The default value is false.
    public var returnSubscriptionArn: Swift.Bool?
    /// The ARN of the topic you want to subscribe to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        attributes: [Swift.String:Swift.String]? = nil,
        endpoint: Swift.String? = nil,
        `protocol`: Swift.String? = nil,
        returnSubscriptionArn: Swift.Bool? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpoint = endpoint
        self.`protocol` = `protocol`
        self.returnSubscriptionArn = returnSubscriptionArn
        self.topicArn = topicArn
    }
}

extension SubscribeOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<SubscribeOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["SubscribeResult"]
            var value = SubscribeOutput()
            value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
            return value
        }
    }
}

/// Response for Subscribe action.
public struct SubscribeOutput: Swift.Equatable {
    /// The ARN of the subscription if it is confirmed, or the string "pending confirmation" if the subscription requires confirmation. However, if the API request parameter ReturnSubscriptionArn is true, then the value is always the subscription ARN, even if the subscription requires confirmation.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

enum SubscribeOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "FilterPolicyLimitExceeded": return try await FilterPolicyLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ReplayLimitExceeded": return try await ReplayLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "SubscriptionLimitExceeded": return try await SubscriptionLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension SNSClientTypes.Subscription: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint = "Endpoint"
        case owner = "Owner"
        case `protocol` = "Protocol"
        case subscriptionArn = "SubscriptionArn"
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let endpoint = endpoint {
            try container.encode(endpoint, forKey: ClientRuntime.Key("Endpoint"))
        }
        if let owner = owner {
            try container.encode(owner, forKey: ClientRuntime.Key("Owner"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: ClientRuntime.Key("Protocol"))
        }
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.Subscription, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.Subscription()
            value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
            value.owner = try reader["Owner"].readIfPresent()
            value.`protocol` = try reader["Protocol"].readIfPresent()
            value.endpoint = try reader["Endpoint"].readIfPresent()
            value.topicArn = try reader["TopicArn"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// A wrapper type for the attributes of an Amazon SNS subscription.
    public struct Subscription: Swift.Equatable {
        /// The subscription's endpoint (format depends on the protocol).
        public var endpoint: Swift.String?
        /// The subscription's owner.
        public var owner: Swift.String?
        /// The subscription's protocol.
        public var `protocol`: Swift.String?
        /// The subscription's ARN.
        public var subscriptionArn: Swift.String?
        /// The ARN of the subscription's topic.
        public var topicArn: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            owner: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            subscriptionArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.owner = owner
            self.`protocol` = `protocol`
            self.subscriptionArn = subscriptionArn
            self.topicArn = topicArn
        }
    }

}

extension SubscriptionLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = SubscriptionLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the customer already owns the maximum allowed number of subscriptions.
public struct SubscriptionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubscriptionLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes.Tag: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let key = key {
            try container.encode(key, forKey: ClientRuntime.Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: ClientRuntime.Key("Value"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.Tag, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.Tag()
            value.key = try reader["Key"].readIfPresent()
            value.value = try reader["Value"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Equatable {
        /// The required key portion of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value portion of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TagLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Can't add more than 50 tags to a topic.
public struct TagLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TagPolicyException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The request doesn't comply with the IAM tag policy. Correct your request and then retry it.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicy" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tags = tags {
            if !tags.isEmpty {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                for (index0, tag0) in tags.enumerated() {
                    try tagsContainer.encode(tag0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagsContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("Tags"))
                try tagsContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("TagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the topic to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to the specified topic. A tag consists of a required key and an optional value.
    /// This member is required.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<TagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return TagResourceOutput()
        }
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ConcurrentAccess": return try await ConcurrentAccessException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "StaleTag": return try await StaleTagException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagLimitExceeded": return try await TagLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagPolicy": return try await TagPolicyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension ThrottledException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ThrottledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the rate at which requests have been submitted for this action exceeds the limit for your Amazon Web Services account.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Throttled request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Throttled" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TooManyEntriesInBatchRequestException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TooManyEntriesInBatchRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// The batch request contains more entries than permissible.
public struct TooManyEntriesInBatchRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyEntriesInBatchRequest" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes.Topic: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let topicArn = topicArn {
            try container.encode(topicArn, forKey: ClientRuntime.Key("TopicArn"))
        }
    }

    static var readingClosure: SmithyReadWrite.ReadingClosure<SNSClientTypes.Topic, SmithyXML.Reader> {
        return { reader in
            guard reader.content != nil else { return nil }
            var value = SNSClientTypes.Topic()
            value.topicArn = try reader["TopicArn"].readIfPresent()
            return value
        }
    }
}

extension SNSClientTypes {
    /// A wrapper type for the topic's Amazon Resource Name (ARN). To retrieve a topic's attributes, use GetTopicAttributes.
    public struct Topic: Swift.Equatable {
        /// The topic's ARN.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TopicLimitExceededException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = TopicLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the customer already owns the maximum allowed number of topics.
public struct TopicLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TopicLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UnsubscribeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let subscriptionArn = subscriptionArn {
            try container.encode(subscriptionArn, forKey: ClientRuntime.Key("SubscriptionArn"))
        }
        try container.encode("Unsubscribe", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension UnsubscribeInput {

    static func urlPathProvider(_ value: UnsubscribeInput) -> Swift.String? {
        return "/"
    }
}

/// Input for Unsubscribe action.
public struct UnsubscribeInput: Swift.Equatable {
    /// The ARN of the subscription to be deleted.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension UnsubscribeOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UnsubscribeOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UnsubscribeOutput()
        }
    }
}

public struct UnsubscribeOutput: Swift.Equatable {

    public init() { }
}

enum UnsubscribeOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidSecurity": return try await InvalidSecurityException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "NotFound": return try await NotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: ClientRuntime.Key("ResourceArn"))
        }
        if let tagKeys = tagKeys {
            if !tagKeys.isEmpty {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                for (index0, tagkey0) in tagKeys.enumerated() {
                    try tagKeysContainer.encode(tagkey0, forKey: ClientRuntime.Key("member.\(index0.advanced(by: 1))"))
                }
            }
            else {
                var tagKeysContainer = container.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key("TagKeys"))
                try tagKeysContainer.encode("", forKey: ClientRuntime.Key(""))
            }
        }
        try container.encode("UntagResource", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the topic from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified topic.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<UntagResourceOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return UntagResourceOutput()
        }
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ConcurrentAccess": return try await ConcurrentAccessException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "StaleTag": return try await StaleTagException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagLimitExceeded": return try await TagLimitExceededException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "TagPolicy": return try await TagPolicyException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}

extension UserErrorException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = UserErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct UserErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserError" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ValidationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that a parameter in the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension VerificationException {

    static func responseErrorBinding(httpResponse: ClientRuntime.HttpResponse, reader: SmithyXML.Reader, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws -> Swift.Error {
        var value = VerificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.status = try reader["Status"].readIfPresent()
        value.httpResponse = httpResponse
        value.requestID = requestID
        value.message = message
        return value
    }
}

/// Indicates that the one-time password (OTP) used for verification is invalid.
public struct VerificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The status of the verification error.
        /// This member is required.
        public internal(set) var status: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VerificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.status = status
    }
}

extension VerifySMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifySMSSandboxPhoneNumberInput(oneTimePassword: \(Swift.String(describing: oneTimePassword)), phoneNumber: \"CONTENT_REDACTED\")"}
}

extension VerifySMSSandboxPhoneNumberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oneTimePassword = "OneTimePassword"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: ClientRuntime.Key.self)
        if let oneTimePassword = oneTimePassword {
            try container.encode(oneTimePassword, forKey: ClientRuntime.Key("OneTimePassword"))
        }
        if let phoneNumber = phoneNumber {
            try container.encode(phoneNumber, forKey: ClientRuntime.Key("PhoneNumber"))
        }
        try container.encode("VerifySMSSandboxPhoneNumber", forKey:ClientRuntime.Key("Action"))
        try container.encode("2010-03-31", forKey:ClientRuntime.Key("Version"))
    }
}

extension VerifySMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: VerifySMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

public struct VerifySMSSandboxPhoneNumberInput: Swift.Equatable {
    /// The OTP sent to the destination number from the CreateSMSSandBoxPhoneNumber call.
    /// This member is required.
    public var oneTimePassword: Swift.String?
    /// The destination phone number to verify.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        oneTimePassword: Swift.String? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.oneTimePassword = oneTimePassword
        self.phoneNumber = phoneNumber
    }
}

extension VerifySMSSandboxPhoneNumberOutput {

    static var httpBinding: ClientRuntime.HTTPResponseOutputBinding<VerifySMSSandboxPhoneNumberOutput, SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            return VerifySMSSandboxPhoneNumberOutput()
        }
    }
}

/// The destination phone number's verification status.
public struct VerifySMSSandboxPhoneNumberOutput: Swift.Equatable {

    public init() { }
}

enum VerifySMSSandboxPhoneNumberOutputError {

    static var httpBinding: ClientRuntime.HTTPResponseErrorBinding<SmithyXML.Reader> {
        { httpResponse, responseDocumentClosure in
            let responseReader = try await responseDocumentClosure(httpResponse)
            let reader = responseReader["Error"]
            let requestID: String? = try responseReader["RequestId"].readIfPresent()
            let code: String? = try reader["Code"].readIfPresent()
            let message: String? = try reader["Message"].readIfPresent()
            switch code {
                case "AuthorizationError": return try await AuthorizationErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InternalError": return try await InternalErrorException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "InvalidParameter": return try await InvalidParameterException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "ResourceNotFound": return try await ResourceNotFoundException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "Throttled": return try await ThrottledException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                case "VerificationException": return try await VerificationException.responseErrorBinding(httpResponse: httpResponse, reader: reader, message: message, requestID: requestID)
                default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: message, requestID: requestID, typeName: code)
            }
        }
    }
}
