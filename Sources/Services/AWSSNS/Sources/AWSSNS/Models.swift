//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
@_spi(SmithyReadWrite) import class SmithyFormURL.Writer
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyXML.Reader
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSQueryError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox


public struct AddPermissionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEndpointOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePlatformApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTopicOutput: Swift.Sendable {

    public init() { }
}

public struct PutDataProtectionPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct RemovePermissionOutput: Swift.Sendable {

    public init() { }
}

public struct SetEndpointAttributesOutput: Swift.Sendable {

    public init() { }
}

public struct SetPlatformApplicationAttributesOutput: Swift.Sendable {

    public init() { }
}

public struct SetSubscriptionAttributesOutput: Swift.Sendable {

    public init() { }
}

public struct SetTopicAttributesOutput: Swift.Sendable {

    public init() { }
}

public struct UnsubscribeOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the user has been denied access to the requested resource.
public struct AuthorizationErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AuthorizationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates an internal service error.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the requested resource does not exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AddPermissionInput: Swift.Sendable {
    /// The action you want to allow for the specified principal(s). Valid values: Any Amazon SNS action name, for example Publish.
    /// This member is required.
    public var actionName: [Swift.String]?
    /// The Amazon Web Services account IDs of the users (principals) who will be given access to the specified actions. The users must have Amazon Web Services account, but do not need to be signed up for this service.
    /// This member is required.
    public var awsAccountId: [Swift.String]?
    /// A unique identifier for the new policy statement.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        actionName: [Swift.String]? = nil,
        awsAccountId: [Swift.String]? = nil,
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.awsAccountId = awsAccountId
        self.label = label
        self.topicArn = topicArn
    }
}

/// Indicates that the rate at which requests have been submitted for this action exceeds the limit for your Amazon Web Services account.
public struct ThrottledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Throttled request.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "Throttled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input for the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutInput: Swift.Sendable {
    /// The phone number for which you want to check the opt out status.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension CheckIfPhoneNumberIsOptedOutInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CheckIfPhoneNumberIsOptedOutInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

/// The response from the CheckIfPhoneNumberIsOptedOut action.
public struct CheckIfPhoneNumberIsOptedOutOutput: Swift.Sendable {
    /// Indicates whether the phone number is opted out:
    ///
    /// * true – The phone number is opted out, meaning you cannot publish SMS messages to it.
    ///
    /// * false – The phone number is opted in, meaning you can publish SMS messages to it.
    public var isOptedOut: Swift.Bool

    public init(
        isOptedOut: Swift.Bool = false
    )
    {
        self.isOptedOut = isOptedOut
    }
}

/// Indicates that the number of filter polices in your Amazon Web Services account exceeds the limit. To add more filter polices, submit an Amazon SNS Limit Increase case in the Amazon Web Services Support Center.
public struct FilterPolicyLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FilterPolicyLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the request parameter has exceeded the maximum number of concurrent message replays.
public struct ReplayLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplayLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the customer already owns the maximum allowed number of subscriptions.
public struct SubscriptionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubscriptionLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Input for ConfirmSubscription action.
public struct ConfirmSubscriptionInput: Swift.Sendable {
    /// Disallows unauthenticated unsubscribes of the subscription. If the value of this parameter is true and the request has an Amazon Web Services signature, then only the topic owner and the subscription owner can unsubscribe the endpoint. The unsubscribe action requires Amazon Web Services authentication.
    public var authenticateOnUnsubscribe: Swift.String?
    /// Short-lived token sent to an endpoint during the Subscribe action.
    /// This member is required.
    public var token: Swift.String?
    /// The ARN of the topic for which you wish to confirm a subscription.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        authenticateOnUnsubscribe: Swift.String? = nil,
        token: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.authenticateOnUnsubscribe = authenticateOnUnsubscribe
        self.token = token
        self.topicArn = topicArn
    }
}

/// Response for ConfirmSubscriptions action.
public struct ConfirmSubscriptionOutput: Swift.Sendable {
    /// The ARN of the created subscription.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

/// Input for CreatePlatformApplication action.
public struct CreatePlatformApplicationInput: Swift.Sendable {
    /// For a list of attributes, see [SetPlatformApplicationAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetPlatformApplicationAttributes.html).
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?
    /// Application names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters long.
    /// This member is required.
    public var name: Swift.String?
    /// The following platforms are supported: ADM (Amazon Device Messaging), APNS (Apple Push Notification Service), APNS_SANDBOX, and GCM (Firebase Cloud Messaging).
    /// This member is required.
    public var platform: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        name: Swift.String? = nil,
        platform: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.name = name
        self.platform = platform
    }
}

/// Response from CreatePlatformApplication action.
public struct CreatePlatformApplicationOutput: Swift.Sendable {
    /// PlatformApplicationArn is returned.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

/// Input for CreatePlatformEndpoint action.
public struct CreatePlatformEndpointInput: Swift.Sendable {
    /// For a list of attributes, see [SetEndpointAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetEndpointAttributes.html).
    public var attributes: [Swift.String: Swift.String]?
    /// Arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    public var customUserData: Swift.String?
    /// PlatformApplicationArn returned from CreatePlatformApplication is used to create a an endpoint.
    /// This member is required.
    public var platformApplicationArn: Swift.String?
    /// Unique identifier created by the notification service for an app on a device. The specific name for Token will vary, depending on which notification service is being used. For example, when using APNS as the notification service, you need the device token. Alternatively, when using GCM (Firebase Cloud Messaging) or ADM, the device token equivalent is called the registration ID.
    /// This member is required.
    public var token: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        customUserData: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.customUserData = customUserData
        self.platformApplicationArn = platformApplicationArn
        self.token = token
    }
}

/// Response from CreateEndpoint action.
public struct CreatePlatformEndpointOutput: Swift.Sendable {
    /// EndpointArn returned from CreateEndpoint action.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

/// Indicates that the specified phone number opted out of receiving SMS messages from your Amazon Web Services account. You can't send SMS messages to phone numbers that opt out.
public struct OptedOutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OptedOut" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct UserErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UserError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {

    /// Supported language code for sending OTP message
    public enum LanguageCodeString: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deDe
        case enGb
        case enUs
        case es419
        case esEs
        case frCa
        case frFr
        case itIt
        case jpJp
        case krKr
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [LanguageCodeString] {
            return [
                .deDe,
                .enGb,
                .enUs,
                .es419,
                .esEs,
                .frCa,
                .frFr,
                .itIt,
                .jpJp,
                .krKr,
                .ptBr,
                .zhCn,
                .zhTw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deDe: return "de-DE"
            case .enGb: return "en-GB"
            case .enUs: return "en-US"
            case .es419: return "es-419"
            case .esEs: return "es-ES"
            case .frCa: return "fr-CA"
            case .frFr: return "fr-FR"
            case .itIt: return "it-IT"
            case .jpJp: return "ja-JP"
            case .krKr: return "kr-KR"
            case .ptBr: return "pt-BR"
            case .zhCn: return "zh-CN"
            case .zhTw: return "zh-TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSMSSandboxPhoneNumberInput: Swift.Sendable {
    /// The language to use for sending the OTP. The default value is en-US.
    public var languageCode: SNSClientTypes.LanguageCodeString?
    /// The destination phone number to verify. On verification, Amazon SNS adds this phone number to the list of verified phone numbers that you can send SMS messages to.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        languageCode: SNSClientTypes.LanguageCodeString? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.languageCode = languageCode
        self.phoneNumber = phoneNumber
    }
}

extension CreateSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSMSSandboxPhoneNumberInput(languageCode: \(Swift.String(describing: languageCode)), phoneNumber: \"CONTENT_REDACTED\")"}
}

public struct CreateSMSSandboxPhoneNumberOutput: Swift.Sendable {

    public init() { }
}

/// Can't perform multiple operations on a tag simultaneously. Perform the operations sequentially.
public struct ConcurrentAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentAccess" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The credential signature isn't valid. You must use an HTTPS endpoint and sign your request using Signature Version 4.
public struct InvalidSecurityException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidSecurity" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A tag has been added to a resource with the same ARN as a deleted resource. Wait a short while and then retry the operation.
public struct StaleTagException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StaleTag" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Can't add more than 50 tags to a topic.
public struct TagLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request doesn't comply with the IAM tag policy. Correct your request and then retry it.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicy" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the customer already owns the maximum allowed number of topics.
public struct TopicLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TopicLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {

    /// The list of tags to be added to the specified topic.
    public struct Tag: Swift.Sendable {
        /// The required key portion of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The optional value portion of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// Input for CreateTopic action.
public struct CreateTopicInput: Swift.Sendable {
    /// A map of attributes with their corresponding values. The following lists names, descriptions, and values of the special request parameters that the CreateTopic action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * FifoTopic – Set to true to create a FIFO topic.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, SignatureVersion is set to 1.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    ///
    /// The following attribute applies only to [server-side encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ArchivePolicy – Adds or updates an inline policy document to archive messages stored in the specified Amazon SNS topic.
    ///
    /// * BeginningArchiveTime – The earliest starting point at which a message in the topic’s archive can be replayed from. This point in time is based on the configured message retention period set by the topic’s message archiving policy.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String: Swift.String]?
    /// The body of the policy document you want to use for this topic. You can only add one policy per topic. The policy must be in JSON string format. Length Constraints: Maximum length of 30,720.
    public var dataProtectionPolicy: Swift.String?
    /// The name of the topic you want to create. Constraints: Topic names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, and hyphens, and must be between 1 and 256 characters long. For a FIFO (first-in-first-out) topic, the name must end with the .fifo suffix.
    /// This member is required.
    public var name: Swift.String?
    /// The list of tags to add to a new topic. To be able to tag a topic on creation, you must have the sns:CreateTopic and sns:TagResource permissions.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        dataProtectionPolicy: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.attributes = attributes
        self.dataProtectionPolicy = dataProtectionPolicy
        self.name = name
        self.tags = tags
    }
}

/// Response from CreateTopic action.
public struct CreateTopicOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) assigned to the created topic.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

/// Input for DeleteEndpoint action.
public struct DeleteEndpointInput: Swift.Sendable {
    /// EndpointArn of endpoint to delete.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

/// Input for DeletePlatformApplication action.
public struct DeletePlatformApplicationInput: Swift.Sendable {
    /// PlatformApplicationArn of platform application object to delete.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

/// Can’t perform the action on the specified resource. Make sure that the resource exists.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteSMSSandboxPhoneNumberInput: Swift.Sendable {
    /// The destination phone number to delete.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension DeleteSMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteSMSSandboxPhoneNumberInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

public struct DeleteSMSSandboxPhoneNumberOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the specified state is not a valid state for an event source.
public struct InvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteTopicInput: Swift.Sendable {
    /// The ARN of the topic you want to delete.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

public struct GetDataProtectionPolicyInput: Swift.Sendable {
    /// The ARN of the topic whose DataProtectionPolicy you want to get. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct GetDataProtectionPolicyOutput: Swift.Sendable {
    /// Retrieves the DataProtectionPolicy in JSON string format.
    public var dataProtectionPolicy: Swift.String?

    public init(
        dataProtectionPolicy: Swift.String? = nil
    )
    {
        self.dataProtectionPolicy = dataProtectionPolicy
    }
}

/// Input for GetEndpointAttributes action.
public struct GetEndpointAttributesInput: Swift.Sendable {
    /// EndpointArn for GetEndpointAttributes input.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        endpointArn: Swift.String? = nil
    )
    {
        self.endpointArn = endpointArn
    }
}

/// Response from GetEndpointAttributes of the EndpointArn.
public struct GetEndpointAttributesOutput: Swift.Sendable {
    /// Attributes include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service. The device token for the iOS platform is returned in lowercase.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// Input for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesInput: Swift.Sendable {
    /// PlatformApplicationArn for GetPlatformApplicationAttributesInput.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.platformApplicationArn = platformApplicationArn
    }
}

/// Response for GetPlatformApplicationAttributes action.
public struct GetPlatformApplicationAttributesOutput: Swift.Sendable {
    /// Attributes include the following:
    ///
    /// * AppleCertificateExpiryDate – The expiry date of the SSL certificate used to configure certificate-based authentication.
    ///
    /// * ApplePlatformTeamID – The Apple developer account ID used to configure token-based authentication.
    ///
    /// * ApplePlatformBundleID – The app identifier used to configure token-based authentication.
    ///
    /// * AuthenticationMethod – Returns the credential type used when sending push notifications from application to APNS/APNS_Sandbox, or application to GCM.
    ///
    /// * APNS – Returns the token or certificate.
    ///
    /// * GCM – Returns the token or key.
    ///
    ///
    ///
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications should be sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications should be sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications should be sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications should be sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// The input for the GetSMSAttributes request.
public struct GetSMSAttributesInput: Swift.Sendable {
    /// A list of the individual attribute names, such as MonthlySpendLimit, for which you want values. For all attribute names, see [SetSMSAttributes](https://docs.aws.amazon.com/sns/latest/api/API_SetSMSAttributes.html). If you don't use this parameter, Amazon SNS returns all SMS attributes.
    public var attributes: [Swift.String]?

    public init(
        attributes: [Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// The response from the GetSMSAttributes request.
public struct GetSMSAttributesOutput: Swift.Sendable {
    /// The SMS attribute names and their values.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

public struct GetSMSSandboxAccountStatusInput: Swift.Sendable {

    public init() { }
}

public struct GetSMSSandboxAccountStatusOutput: Swift.Sendable {
    /// Indicates whether the calling Amazon Web Services account is in the SMS sandbox.
    /// This member is required.
    public var isInSandbox: Swift.Bool

    public init(
        isInSandbox: Swift.Bool = false
    )
    {
        self.isInSandbox = isInSandbox
    }
}

/// Input for GetSubscriptionAttributes.
public struct GetSubscriptionAttributesInput: Swift.Sendable {
    /// The ARN of the subscription whose properties you want to get.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

/// Response for GetSubscriptionAttributes action.
public struct GetSubscriptionAttributesOutput: Swift.Sendable {
    /// A map of the subscription's attributes. Attributes in this map include the following:
    ///
    /// * ConfirmationWasAuthenticated – true if the subscription confirmation request was authenticated.
    ///
    /// * DeliveryPolicy – The JSON serialization of the subscription's delivery policy.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy that takes into account the topic delivery policy and account system defaults.
    ///
    /// * FilterPolicy – The filter policy JSON that is assigned to the subscription. For more information, see [Amazon SNS Message Filtering](https://docs.aws.amazon.com/sns/latest/dg/sns-message-filtering.html) in the Amazon SNS Developer Guide.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * Owner – The Amazon Web Services account ID of the subscription's owner.
    ///
    /// * PendingConfirmation – true if the subscription hasn't been confirmed. To confirm a pending subscription, call the ConfirmSubscription action with a confirmation token.
    ///
    /// * RawMessageDelivery – true if raw message delivery is enabled for the subscription. Raw messages are free of JSON formatting and can be sent to HTTP/S and Amazon SQS endpoints.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    /// * SubscriptionArn – The subscription's ARN.
    ///
    /// * TopicArn – The topic ARN that the subscription is associated with.
    ///
    ///
    /// The following attribute applies only to Amazon Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Firehose delivery stream subscriptions. For more information, see [Fanout to Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// Input for GetTopicAttributes action.
public struct GetTopicAttributesInput: Swift.Sendable {
    /// The ARN of the topic whose properties you want to get.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        topicArn: Swift.String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

/// Response for GetTopicAttributes action.
public struct GetTopicAttributesOutput: Swift.Sendable {
    /// A map of the topic's attributes. Attributes in this map include the following:
    ///
    /// * DeliveryPolicy – The JSON serialization of the topic's delivery policy.
    ///
    /// * DisplayName – The human-readable name used in the From field for notifications to email and email-json endpoints.
    ///
    /// * EffectiveDeliveryPolicy – The JSON serialization of the effective delivery policy, taking system defaults into account.
    ///
    /// * Owner – The Amazon Web Services account ID of the topic's owner.
    ///
    /// * Policy – The JSON serialization of the topic's access control policy.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS.
    ///
    /// * By default, SignatureVersion is set to 1. The signature is a Base64-encoded SHA1withRSA signature.
    ///
    /// * When you set SignatureVersion to 2. Amazon SNS uses a Base64-encoded SHA256withRSA signature. If the API response does not include the SignatureVersion attribute, it means that the SignatureVersion for the topic has value 1.
    ///
    ///
    ///
    ///
    /// * SubscriptionsConfirmed – The number of confirmed subscriptions for the topic.
    ///
    /// * SubscriptionsDeleted – The number of deleted subscriptions for the topic.
    ///
    /// * SubscriptionsPending – The number of subscriptions pending confirmation for the topic.
    ///
    /// * TopicArn – The topic's ARN.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    ///
    /// The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId - The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * FifoTopic – When this is set to true, a FIFO topic is created.
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// Input for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationInput: Swift.Sendable {
    /// NextToken string is used when calling ListEndpointsByPlatformApplication action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?
    /// PlatformApplicationArn for ListEndpointsByPlatformApplicationInput action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplicationArn = platformApplicationArn
    }
}

extension SNSClientTypes {

    /// The endpoint for mobile app and device.
    public struct Endpoint: Swift.Sendable {
        /// Attributes for endpoint.
        public var attributes: [Swift.String: Swift.String]?
        /// The EndpointArn for mobile app and device.
        public var endpointArn: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            endpointArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.endpointArn = endpointArn
        }
    }
}

/// Response for ListEndpointsByPlatformApplication action.
public struct ListEndpointsByPlatformApplicationOutput: Swift.Sendable {
    /// Endpoints returned for ListEndpointsByPlatformApplication action.
    public var endpoints: [SNSClientTypes.Endpoint]?
    /// NextToken string is returned when calling ListEndpointsByPlatformApplication action if additional records are available after the first page results.
    public var nextToken: Swift.String?

    public init(
        endpoints: [SNSClientTypes.Endpoint]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.endpoints = endpoints
        self.nextToken = nextToken
    }
}

/// Indicates that a parameter in the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListOriginationNumbersInput: Swift.Sendable {
    /// The maximum number of origination numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListOriginationNumbers request returns.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SNSClientTypes {

    /// Enum listing out all supported number capabilities.
    public enum NumberCapability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mms
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [NumberCapability] {
            return [
                .mms,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mms: return "MMS"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SNSClientTypes {

    /// Enum listing out all supported route types. The following enum values are supported. 1. Transactional : Non-marketing traffic 2. Promotional : Marketing 3. Premium : Premium routes for OTP delivery to the carriers
    public enum RouteType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case premium
        case promotional
        case transactional
        case sdkUnknown(Swift.String)

        public static var allCases: [RouteType] {
            return [
                .premium,
                .promotional,
                .transactional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .premium: return "Premium"
            case .promotional: return "Promotional"
            case .transactional: return "Transactional"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SNSClientTypes {

    /// A list of phone numbers and their metadata.
    public struct PhoneNumberInformation: Swift.Sendable {
        /// The date and time when the phone number was created.
        public var createdAt: Foundation.Date?
        /// The two-character code for the country or region, in ISO 3166-1 alpha-2 format.
        public var iso2CountryCode: Swift.String?
        /// The capabilities of each phone number.
        public var numberCapabilities: [SNSClientTypes.NumberCapability]?
        /// The phone number.
        public var phoneNumber: Swift.String?
        /// The list of supported routes.
        public var routeType: SNSClientTypes.RouteType?
        /// The status of the phone number.
        public var status: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            iso2CountryCode: Swift.String? = nil,
            numberCapabilities: [SNSClientTypes.NumberCapability]? = nil,
            phoneNumber: Swift.String? = nil,
            routeType: SNSClientTypes.RouteType? = nil,
            status: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.iso2CountryCode = iso2CountryCode
            self.numberCapabilities = numberCapabilities
            self.phoneNumber = phoneNumber
            self.routeType = routeType
            self.status = status
        }
    }
}

extension SNSClientTypes.PhoneNumberInformation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PhoneNumberInformation(createdAt: \(Swift.String(describing: createdAt)), iso2CountryCode: \(Swift.String(describing: iso2CountryCode)), numberCapabilities: \(Swift.String(describing: numberCapabilities)), routeType: \(Swift.String(describing: routeType)), status: \(Swift.String(describing: status)), phoneNumber: \"CONTENT_REDACTED\")"}
}

public struct ListOriginationNumbersOutput: Swift.Sendable {
    /// A NextToken string is returned when you call the ListOriginationNumbers operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's verified and pending origination numbers.
    public var phoneNumbers: [SNSClientTypes.PhoneNumberInformation]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [SNSClientTypes.PhoneNumberInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

/// The input for the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutInput: Swift.Sendable {
    /// A NextToken string is used when you call the ListPhoneNumbersOptedOut action to retrieve additional records that are available after the first page of results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

/// The response from the ListPhoneNumbersOptedOut action.
public struct ListPhoneNumbersOptedOutOutput: Swift.Sendable {
    /// A NextToken string is returned when you call the ListPhoneNumbersOptedOut action if additional records are available after the first page of results.
    public var nextToken: Swift.String?
    /// A list of phone numbers that are opted out of receiving SMS messages. The list is paginated, and each page can contain up to 100 phone numbers.
    public var phoneNumbers: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

extension ListPhoneNumbersOptedOutOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPhoneNumbersOptedOutOutput(nextToken: \(Swift.String(describing: nextToken)), phoneNumbers: \"CONTENT_REDACTED\")"}
}

/// Input for ListPlatformApplications action.
public struct ListPlatformApplicationsInput: Swift.Sendable {
    /// NextToken string is used when calling ListPlatformApplications action to retrieve additional records that are available after the first page results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension SNSClientTypes {

    /// Platform application object.
    public struct PlatformApplication: Swift.Sendable {
        /// Attributes for platform application object.
        public var attributes: [Swift.String: Swift.String]?
        /// PlatformApplicationArn for platform application object.
        public var platformApplicationArn: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            platformApplicationArn: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.platformApplicationArn = platformApplicationArn
        }
    }
}

/// Response for ListPlatformApplications action.
public struct ListPlatformApplicationsOutput: Swift.Sendable {
    /// NextToken string is returned when calling ListPlatformApplications action if additional records are available after the first page results.
    public var nextToken: Swift.String?
    /// Platform applications returned when calling ListPlatformApplications action.
    public var platformApplications: [SNSClientTypes.PlatformApplication]?

    public init(
        nextToken: Swift.String? = nil,
        platformApplications: [SNSClientTypes.PlatformApplication]? = nil
    )
    {
        self.nextToken = nextToken
        self.platformApplications = platformApplications
    }
}

public struct ListSMSSandboxPhoneNumbersInput: Swift.Sendable {
    /// The maximum number of phone numbers to return.
    public var maxResults: Swift.Int?
    /// Token that the previous ListSMSSandboxPhoneNumbersInput request returns.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SNSClientTypes {

    /// Enum listing out all supported destination phone number verification statuses. The following enum values are supported. 1. PENDING : The destination phone number is pending verification. 2. VERIFIED : The destination phone number is verified.
    public enum SMSSandboxPhoneNumberVerificationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pending
        case verified
        case sdkUnknown(Swift.String)

        public static var allCases: [SMSSandboxPhoneNumberVerificationStatus] {
            return [
                .pending,
                .verified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pending: return "Pending"
            case .verified: return "Verified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SNSClientTypes {

    /// A verified or pending destination phone number in the SMS sandbox. When you start using Amazon SNS to send SMS messages, your Amazon Web Services account is in the SMS sandbox. The SMS sandbox provides a safe environment for you to try Amazon SNS features without risking your reputation as an SMS sender. While your Amazon Web Services account is in the SMS sandbox, you can use all of the features of Amazon SNS. However, you can send SMS messages only to verified destination phone numbers. For more information, including how to move out of the sandbox to send messages without restrictions, see [SMS sandbox](https://docs.aws.amazon.com/sns/latest/dg/sns-sms-sandbox.html) in the Amazon SNS Developer Guide.
    public struct SMSSandboxPhoneNumber: Swift.Sendable {
        /// The destination phone number.
        public var phoneNumber: Swift.String?
        /// The destination phone number's verification status.
        public var status: SNSClientTypes.SMSSandboxPhoneNumberVerificationStatus?

        public init(
            phoneNumber: Swift.String? = nil,
            status: SNSClientTypes.SMSSandboxPhoneNumberVerificationStatus? = nil
        )
        {
            self.phoneNumber = phoneNumber
            self.status = status
        }
    }
}

extension SNSClientTypes.SMSSandboxPhoneNumber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SMSSandboxPhoneNumber(status: \(Swift.String(describing: status)), phoneNumber: \"CONTENT_REDACTED\")"}
}

public struct ListSMSSandboxPhoneNumbersOutput: Swift.Sendable {
    /// A NextToken string is returned when you call the ListSMSSandboxPhoneNumbersInput operation if additional pages of records are available.
    public var nextToken: Swift.String?
    /// A list of the calling account's pending and verified phone numbers.
    /// This member is required.
    public var phoneNumbers: [SNSClientTypes.SMSSandboxPhoneNumber]?

    public init(
        nextToken: Swift.String? = nil,
        phoneNumbers: [SNSClientTypes.SMSSandboxPhoneNumber]? = nil
    )
    {
        self.nextToken = nextToken
        self.phoneNumbers = phoneNumbers
    }
}

/// Input for ListSubscriptions action.
public struct ListSubscriptionsInput: Swift.Sendable {
    /// Token returned by the previous ListSubscriptions request.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension SNSClientTypes {

    /// A wrapper type for the attributes of an Amazon SNS subscription.
    public struct Subscription: Swift.Sendable {
        /// The subscription's endpoint (format depends on the protocol).
        public var endpoint: Swift.String?
        /// The subscription's owner.
        public var owner: Swift.String?
        /// The subscription's protocol.
        public var `protocol`: Swift.String?
        /// The subscription's ARN.
        public var subscriptionArn: Swift.String?
        /// The ARN of the subscription's topic.
        public var topicArn: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            owner: Swift.String? = nil,
            `protocol`: Swift.String? = nil,
            subscriptionArn: Swift.String? = nil,
            topicArn: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.owner = owner
            self.`protocol` = `protocol`
            self.subscriptionArn = subscriptionArn
            self.topicArn = topicArn
        }
    }
}

/// Response for ListSubscriptions action
public struct ListSubscriptionsOutput: Swift.Sendable {
    /// Token to pass along to the next ListSubscriptions request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SNSClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [SNSClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

/// Input for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicInput: Swift.Sendable {
    /// Token returned by the previous ListSubscriptionsByTopic request.
    public var nextToken: Swift.String?
    /// The ARN of the topic for which you wish to find subscriptions.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.topicArn = topicArn
    }
}

/// Response for ListSubscriptionsByTopic action.
public struct ListSubscriptionsByTopicOutput: Swift.Sendable {
    /// Token to pass along to the next ListSubscriptionsByTopic request. This element is returned if there are more subscriptions to retrieve.
    public var nextToken: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [SNSClientTypes.Subscription]?

    public init(
        nextToken: Swift.String? = nil,
        subscriptions: [SNSClientTypes.Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the topic for which to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags associated with the specified topic.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTopicsInput: Swift.Sendable {
    /// Token returned by the previous ListTopics request.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension SNSClientTypes {

    /// A wrapper type for the topic's Amazon Resource Name (ARN). To retrieve a topic's attributes, use GetTopicAttributes.
    public struct Topic: Swift.Sendable {
        /// The topic's ARN.
        public var topicArn: Swift.String?

        public init(
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }
}

/// Response for ListTopics action.
public struct ListTopicsOutput: Swift.Sendable {
    /// Token to pass along to the next ListTopics request. This element is returned if there are additional topics to retrieve.
    public var nextToken: Swift.String?
    /// A list of topic ARNs.
    public var topics: [SNSClientTypes.Topic]?

    public init(
        nextToken: Swift.String? = nil,
        topics: [SNSClientTypes.Topic]? = nil
    )
    {
        self.nextToken = nextToken
        self.topics = topics
    }
}

/// Input for the OptInPhoneNumber action.
public struct OptInPhoneNumberInput: Swift.Sendable {
    /// The phone number to opt in. Use E.164 format.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        phoneNumber: Swift.String? = nil
    )
    {
        self.phoneNumber = phoneNumber
    }
}

extension OptInPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OptInPhoneNumberInput(phoneNumber: \"CONTENT_REDACTED\")"}
}

/// The response for the OptInPhoneNumber action.
public struct OptInPhoneNumberOutput: Swift.Sendable {

    public init() { }
}

/// Exception error indicating endpoint disabled.
public struct EndpointDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message for endpoint disabled.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EndpointDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a request parameter does not comply with the associated constraints.
public struct InvalidParameterValueException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The parameter of an entry in a request doesn't abide by the specification.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ParameterValueInvalid" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The ciphertext references a key that doesn't exist or that you don't have access to.
public struct KMSAccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSAccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the specified Amazon Web Services KMS key isn't enabled.
public struct KMSDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the state of the specified resource isn't valid for this request. For more information, see [Key states of Amazon Web Services KMS keys](https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html) in the Key Management Service Developer Guide.
public struct KMSInvalidStateException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSInvalidState" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was rejected because the specified entity or resource can't be found.
public struct KMSNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Amazon Web Services access key ID needs a subscription for the service.
public struct KMSOptInRequired: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSOptInRequired" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. For more information about throttling, see [Limits](https://docs.aws.amazon.com/kms/latest/developerguide/limits.html#requests-per-second) in the Key Management Service Developer Guide.
public struct KMSThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KMSThrottling" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception error indicating platform application disabled.
public struct PlatformApplicationDisabledException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Message for platform application disabled.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PlatformApplicationDisabled" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {

    /// The user-specified message attribute value. For string data types, the value attribute has the same restrictions on the content as the message body. For more information, see [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html). Name, type, and value must not be empty or null. In addition, the message body should not be empty or null. All parts of the message attribute, including name, type, and value, are included in the message size restriction, which is currently 256 KB (262,144 bytes). For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html) and [Publishing to a mobile phone](https://docs.aws.amazon.com/sns/latest/dg/sms_publish-to-phone.html) in the Amazon SNS Developer Guide.
    public struct MessageAttributeValue: Swift.Sendable {
        /// Binary type attributes can store any binary data, for example, compressed data, encrypted data, or images.
        public var binaryValue: Foundation.Data?
        /// Amazon SNS supports the following logical data types: String, String.Array, Number, and Binary. For more information, see [Message Attribute Data Types](https://docs.aws.amazon.com/sns/latest/dg/SNSMessageAttributes.html#SNSMessageAttributes.DataTypes).
        /// This member is required.
        public var dataType: Swift.String?
        /// Strings are Unicode with UTF8 binary encoding. For a list of code values, see [ASCII Printable Characters](https://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
        public var stringValue: Swift.String?

        public init(
            binaryValue: Foundation.Data? = nil,
            dataType: Swift.String? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.binaryValue = binaryValue
            self.dataType = dataType
            self.stringValue = stringValue
        }
    }
}

/// Input for Publish action.
public struct PublishInput: Swift.Sendable {
    /// The message you want to send. If you are publishing to a topic and you want to send the same message to all transport protocols, include the text of the message as a String value. If you want to send different messages for each transport protocol, set the value of the MessageStructure parameter to json and use a JSON object for the Message parameter. Constraints:
    ///
    /// * With the exception of SMS, messages must be UTF-8 encoded strings and at most 256 KB in size (262,144 bytes, not 262,144 characters).
    ///
    /// * For SMS, each message can contain up to 140 characters. This character limit depends on the encoding schema. For example, an SMS message can contain 160 GSM characters, 140 ASCII characters, or 70 UCS-2 characters. If you publish a message that exceeds this size limit, Amazon SNS sends the message as multiple messages, each fitting within the size limit. Messages aren't truncated mid-word but are cut off at whole-word boundaries. The total size limit for a single SMS Publish action is 1,600 characters.
    ///
    ///
    /// JSON-specific constraints:
    ///
    /// * Keys in the JSON object that correspond to supported transport protocols must have simple JSON string values.
    ///
    /// * The values will be parsed (unescaped) before they are used in outgoing messages.
    ///
    /// * Outbound notifications are JSON encoded (meaning that the characters will be reescaped for sending).
    ///
    /// * Values have a minimum length of 0 (the empty string, "", is allowed).
    ///
    /// * Values have a maximum length bounded by the overall message size (so, including multiple protocols may limit message sizes).
    ///
    /// * Non-string values will cause the key to be ignored.
    ///
    /// * Keys that do not correspond to supported transport protocols are ignored.
    ///
    /// * Duplicate keys are not allowed.
    ///
    /// * Failure to parse or validate any key or value in the message will cause the Publish call to return an error (no partial delivery).
    /// This member is required.
    public var message: Swift.String?
    /// Message attributes for Publish action.
    public var messageAttributes: [Swift.String: SNSClientTypes.MessageAttributeValue]?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageDeduplicationId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). Every message must have a unique MessageDeduplicationId, which is a token used for deduplication of sent messages. If a message with a particular MessageDeduplicationId is sent successfully, any message sent with the same MessageDeduplicationId during the 5-minute deduplication interval is treated as a duplicate. If the topic has ContentBasedDeduplication set, the system generates a MessageDeduplicationId based on the contents of the message. Your MessageDeduplicationId overrides the generated one.
    public var messageDeduplicationId: Swift.String?
    /// This parameter applies only to FIFO (first-in-first-out) topics. The MessageGroupId can contain up to 128 alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). The MessageGroupId is a tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). Every message must include a MessageGroupId.
    public var messageGroupId: Swift.String?
    /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
    ///
    /// * be a syntactically valid JSON object; and
    ///
    /// * contain at least a top-level JSON key of "default" with a value that is a string.
    ///
    ///
    /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g., "http"). Valid value: json
    public var messageStructure: Swift.String?
    /// The phone number to which you want to deliver an SMS message. Use E.164 format. If you don't specify a value for the PhoneNumber parameter, you must specify a value for the TargetArn or TopicArn parameters.
    public var phoneNumber: Swift.String?
    /// Optional parameter to be used as the "Subject" line when the message is delivered to email endpoints. This field will also be included, if present, in the standard JSON messages delivered to other endpoints. Constraints: Subjects must be UTF-8 text with no line breaks or control characters, and less than 100 characters long.
    public var subject: Swift.String?
    /// If you don't specify a value for the TargetArn parameter, you must specify a value for the PhoneNumber or TopicArn parameters.
    public var targetArn: Swift.String?
    /// The topic you want to publish to. If you don't specify a value for the TopicArn parameter, you must specify a value for the PhoneNumber or TargetArn parameters.
    public var topicArn: Swift.String?

    public init(
        message: Swift.String? = nil,
        messageAttributes: [Swift.String: SNSClientTypes.MessageAttributeValue]? = nil,
        messageDeduplicationId: Swift.String? = nil,
        messageGroupId: Swift.String? = nil,
        messageStructure: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        subject: Swift.String? = nil,
        targetArn: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.message = message
        self.messageAttributes = messageAttributes
        self.messageDeduplicationId = messageDeduplicationId
        self.messageGroupId = messageGroupId
        self.messageStructure = messageStructure
        self.phoneNumber = phoneNumber
        self.subject = subject
        self.targetArn = targetArn
        self.topicArn = topicArn
    }
}

extension PublishInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PublishInput(message: \(Swift.String(describing: message)), messageAttributes: \(Swift.String(describing: messageAttributes)), messageDeduplicationId: \(Swift.String(describing: messageDeduplicationId)), messageGroupId: \(Swift.String(describing: messageGroupId)), messageStructure: \(Swift.String(describing: messageStructure)), subject: \(Swift.String(describing: subject)), targetArn: \(Swift.String(describing: targetArn)), topicArn: \(Swift.String(describing: topicArn)), phoneNumber: \"CONTENT_REDACTED\")"}
}

/// Response for Publish action.
public struct PublishOutput: Swift.Sendable {
    /// Unique identifier assigned to the published message. Length Constraint: Maximum 100 characters
    public var messageId: Swift.String?
    /// This response element applies only to FIFO (first-in-first-out) topics. The sequence number is a large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for each MessageGroupId.
    public var sequenceNumber: Swift.String?

    public init(
        messageId: Swift.String? = nil,
        sequenceNumber: Swift.String? = nil
    )
    {
        self.messageId = messageId
        self.sequenceNumber = sequenceNumber
    }
}

/// Two or more batch entries in the request have the same Id.
public struct BatchEntryIdsNotDistinctException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchEntryIdsNotDistinct" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The length of all the batch messages put together is more than the limit.
public struct BatchRequestTooLongException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BatchRequestTooLong" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The batch request doesn't contain any entries.
public struct EmptyBatchRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EmptyBatchRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Id of a batch entry in a batch request doesn't abide by the specification.
public struct InvalidBatchEntryIdException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidBatchEntryId" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The batch request contains more entries than permissible.
public struct TooManyEntriesInBatchRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyEntriesInBatchRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SNSClientTypes {

    /// Contains the details of a single Amazon SNS message along with an Id that identifies a message within the batch.
    public struct PublishBatchRequestEntry: Swift.Sendable {
        /// An identifier for the message in this batch. The Ids of a batch request must be unique within a request. This identifier can have up to 80 characters. The following characters are accepted: alphanumeric characters, hyphens(-), and underscores (_).
        /// This member is required.
        public var id: Swift.String?
        /// The body of the message.
        /// This member is required.
        public var message: Swift.String?
        /// Each message attribute consists of a Name, Type, and Value. For more information, see [Amazon SNS message attributes](https://docs.aws.amazon.com/sns/latest/dg/sns-message-attributes.html) in the Amazon SNS Developer Guide.
        public var messageAttributes: [Swift.String: SNSClientTypes.MessageAttributeValue]?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The token used for deduplication of messages within a 5-minute minimum deduplication interval. If a message with a particular MessageDeduplicationId is sent successfully, subsequent messages with the same MessageDeduplicationId are accepted successfully but aren't delivered.
        ///
        /// * Every message must have a unique MessageDeduplicationId.
        ///
        /// * You may provide a MessageDeduplicationId explicitly.
        ///
        /// * If you aren't able to provide a MessageDeduplicationId and you enable ContentBasedDeduplication for your topic, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message).
        ///
        /// * If you don't provide a MessageDeduplicationId and the topic doesn't have ContentBasedDeduplication set, the action fails with an error.
        ///
        /// * If the topic has a ContentBasedDeduplication set, your MessageDeduplicationId overrides the generated one.
        ///
        ///
        ///
        ///
        /// * When ContentBasedDeduplication is in effect, messages with identical content sent within the deduplication interval are treated as duplicates and only one copy of the message is delivered.
        ///
        /// * If you send one message with ContentBasedDeduplication enabled, and then another message with a MessageDeduplicationId that is the same as the one generated for the first MessageDeduplicationId, the two messages are treated as duplicates and only one copy of the message is delivered.
        ///
        ///
        /// The MessageDeduplicationId is available to the consumer of the message (this can be useful for troubleshooting delivery issues). If a message is sent successfully but the acknowledgement is lost and the message is resent with the same MessageDeduplicationId after the deduplication interval, Amazon SNS can't detect duplicate messages. Amazon SNS continues to keep track of the message deduplication ID even after the message is received and deleted. The length of MessageDeduplicationId is 128 characters. MessageDeduplicationId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~).
        public var messageDeduplicationId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner (however, messages in different message groups might be processed out of order). To interleave multiple ordered streams within a single topic, use MessageGroupId values (for example, session data for multiple users). In this scenario, multiple consumers can process the topic, but the session data of each user is processed in a FIFO fashion. You must associate a non-empty MessageGroupId with a message. If you don't provide a MessageGroupId, the action fails. The length of MessageGroupId is 128 characters. MessageGroupId can contain alphanumeric characters (a-z, A-Z, 0-9) and punctuation (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~). MessageGroupId is required for FIFO topics. You can't use it for standard topics.
        public var messageGroupId: Swift.String?
        /// Set MessageStructure to json if you want to send a different message for each protocol. For example, using one publish action, you can send a short message to your SMS subscribers and a longer message to your email subscribers. If you set MessageStructure to json, the value of the Message parameter must:
        ///
        /// * be a syntactically valid JSON object; and
        ///
        /// * contain at least a top-level JSON key of "default" with a value that is a string.
        ///
        ///
        /// You can define other top-level keys that define the message you want to send to a specific transport protocol (e.g. http).
        public var messageStructure: Swift.String?
        /// The subject of the batch message.
        public var subject: Swift.String?

        public init(
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            messageAttributes: [Swift.String: SNSClientTypes.MessageAttributeValue]? = nil,
            messageDeduplicationId: Swift.String? = nil,
            messageGroupId: Swift.String? = nil,
            messageStructure: Swift.String? = nil,
            subject: Swift.String? = nil
        )
        {
            self.id = id
            self.message = message
            self.messageAttributes = messageAttributes
            self.messageDeduplicationId = messageDeduplicationId
            self.messageGroupId = messageGroupId
            self.messageStructure = messageStructure
            self.subject = subject
        }
    }
}

public struct PublishBatchInput: Swift.Sendable {
    /// A list of PublishBatch request entries to be sent to the SNS topic.
    /// This member is required.
    public var publishBatchRequestEntries: [SNSClientTypes.PublishBatchRequestEntry]?
    /// The Amazon resource name (ARN) of the topic you want to batch publish to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        publishBatchRequestEntries: [SNSClientTypes.PublishBatchRequestEntry]? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.publishBatchRequestEntries = publishBatchRequestEntries
        self.topicArn = topicArn
    }
}

extension SNSClientTypes {

    /// Gives a detailed description of failed messages in the batch.
    public struct BatchResultErrorEntry: Swift.Sendable {
        /// An error code representing why the action failed on this entry.
        /// This member is required.
        public var code: Swift.String?
        /// The Id of an entry in a batch request
        /// This member is required.
        public var id: Swift.String?
        /// A message explaining why the action failed on this entry.
        public var message: Swift.String?
        /// Specifies whether the error happened due to the caller of the batch API action.
        /// This member is required.
        public var senderFault: Swift.Bool

        public init(
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil,
            senderFault: Swift.Bool = false
        )
        {
            self.code = code
            self.id = id
            self.message = message
            self.senderFault = senderFault
        }
    }
}

extension SNSClientTypes {

    /// Encloses data related to a successful message in a batch request for topic.
    public struct PublishBatchResultEntry: Swift.Sendable {
        /// The Id of an entry in a batch request.
        public var id: Swift.String?
        /// An identifier for the message.
        public var messageId: Swift.String?
        /// This parameter applies only to FIFO (first-in-first-out) topics. The large, non-consecutive number that Amazon SNS assigns to each message. The length of SequenceNumber is 128 bits. SequenceNumber continues to increase for a particular MessageGroupId.
        public var sequenceNumber: Swift.String?

        public init(
            id: Swift.String? = nil,
            messageId: Swift.String? = nil,
            sequenceNumber: Swift.String? = nil
        )
        {
            self.id = id
            self.messageId = messageId
            self.sequenceNumber = sequenceNumber
        }
    }
}

public struct PublishBatchOutput: Swift.Sendable {
    /// A list of failed PublishBatch responses.
    public var failed: [SNSClientTypes.BatchResultErrorEntry]?
    /// A list of successful PublishBatch responses.
    public var successful: [SNSClientTypes.PublishBatchResultEntry]?

    public init(
        failed: [SNSClientTypes.BatchResultErrorEntry]? = nil,
        successful: [SNSClientTypes.PublishBatchResultEntry]? = nil
    )
    {
        self.failed = failed
        self.successful = successful
    }
}

public struct PutDataProtectionPolicyInput: Swift.Sendable {
    /// The JSON serialization of the topic's DataProtectionPolicy. The DataProtectionPolicy must be in JSON string format. Length Constraints: Maximum length of 30,720.
    /// This member is required.
    public var dataProtectionPolicy: Swift.String?
    /// The ARN of the topic whose DataProtectionPolicy you want to add or update. For more information about ARNs, see [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        dataProtectionPolicy: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.dataProtectionPolicy = dataProtectionPolicy
        self.resourceArn = resourceArn
    }
}

/// Input for RemovePermission action.
public struct RemovePermissionInput: Swift.Sendable {
    /// The unique label of the statement you want to remove.
    /// This member is required.
    public var label: Swift.String?
    /// The ARN of the topic whose access control policy you wish to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        label: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.label = label
        self.topicArn = topicArn
    }
}

/// Input for SetEndpointAttributes action.
public struct SetEndpointAttributesInput: Swift.Sendable {
    /// A map of the endpoint attributes. Attributes in this map include the following:
    ///
    /// * CustomUserData – arbitrary user data to associate with the endpoint. Amazon SNS does not use this data. The data must be in UTF-8 format and less than 2KB.
    ///
    /// * Enabled – flag that enables/disables delivery to the endpoint. Amazon SNS will set this to false when a notification service indicates to Amazon SNS that the endpoint is invalid. Users can set it back to true, typically after updating Token.
    ///
    /// * Token – device token, also referred to as a registration id, for an app and mobile device. This is returned from the notification service when an app and mobile device are registered with the notification service.
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?
    /// EndpointArn used for SetEndpointAttributes action.
    /// This member is required.
    public var endpointArn: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        endpointArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpointArn = endpointArn
    }
}

/// Input for SetPlatformApplicationAttributes action.
public struct SetPlatformApplicationAttributesInput: Swift.Sendable {
    /// A map of the platform application attributes. Attributes in this map include the following:
    ///
    /// * PlatformCredential – The credential received from the notification service.
    ///
    /// * For ADM, PlatformCredentialis client secret.
    ///
    /// * For Apple Services using certificate credentials, PlatformCredential is private key.
    ///
    /// * For Apple Services using token credentials, PlatformCredential is signing key.
    ///
    /// * For GCM (Firebase Cloud Messaging) using key credentials, there is no PlatformPrincipal. The PlatformCredential is API key.
    ///
    /// * For GCM (Firebase Cloud Messaging) using token credentials, there is no PlatformPrincipal. The PlatformCredential is a JSON formatted private key file. When using the Amazon Web Services CLI, the file must be in string format and special characters must be ignored. To format the file correctly, Amazon SNS recommends using the following command: SERVICE_JSON=`jq @json <<< cat service.json`.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * PlatformPrincipal – The principal received from the notification service.
    ///
    /// * For ADM, PlatformPrincipalis client id.
    ///
    /// * For Apple Services using certificate credentials, PlatformPrincipal is SSL certificate.
    ///
    /// * For Apple Services using token credentials, PlatformPrincipal is signing key ID.
    ///
    /// * For GCM (Firebase Cloud Messaging), there is no PlatformPrincipal.
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * EventEndpointCreated – Topic ARN to which EndpointCreated event notifications are sent.
    ///
    /// * EventEndpointDeleted – Topic ARN to which EndpointDeleted event notifications are sent.
    ///
    /// * EventEndpointUpdated – Topic ARN to which EndpointUpdate event notifications are sent.
    ///
    /// * EventDeliveryFailure – Topic ARN to which DeliveryFailure event notifications are sent upon Direct Publish delivery failure (permanent) to one of the application's endpoints.
    ///
    /// * SuccessFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * FailureFeedbackRoleArn – IAM role ARN used to give Amazon SNS write access to use CloudWatch Logs on your behalf.
    ///
    /// * SuccessFeedbackSampleRate – Sample rate percentage (0-100) of successfully delivered messages.
    ///
    ///
    /// The following attributes only apply to APNs token-based authentication:
    ///
    /// * ApplePlatformTeamID – The identifier that's assigned to your Apple developer account team.
    ///
    /// * ApplePlatformBundleID – The bundle identifier that's assigned to your iOS app.
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?
    /// PlatformApplicationArn for SetPlatformApplicationAttributes action.
    /// This member is required.
    public var platformApplicationArn: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        platformApplicationArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.platformApplicationArn = platformApplicationArn
    }
}

/// The input for the SetSMSAttributes action.
public struct SetSMSAttributesInput: Swift.Sendable {
    /// The default settings for sending SMS messages from your Amazon Web Services account. You can set values for the following attribute names: MonthlySpendLimit – The maximum amount in USD that you are willing to spend each month to send SMS messages. When Amazon SNS determines that sending an SMS message would incur a cost that exceeds this limit, it stops sending SMS messages within minutes. Amazon SNS stops sending SMS messages within minutes of the limit being crossed. During that interval, if you continue to send SMS messages, you will incur costs that exceed your limit. By default, the spend limit is set to the maximum allowed by Amazon SNS. If you want to raise the limit, submit an [SNS Limit Increase case](https://console.aws.amazon.com/support/home#/case/create?issueType=service-limit-increase&limitType=service-code-sns). For New limit value, enter your desired monthly spend limit. In the Use Case Description field, explain that you are requesting an SMS monthly spend limit increase. DeliveryStatusIAMRole – The ARN of the IAM role that allows Amazon SNS to write logs about SMS deliveries in CloudWatch Logs. For each SMS message that you send, Amazon SNS writes a log that includes the message price, the success or failure status, the reason for failure (if the message failed), the message dwell time, and other information. DeliveryStatusSuccessSamplingRate – The percentage of successful SMS deliveries for which Amazon SNS will write logs in CloudWatch Logs. The value can be an integer from 0 - 100. For example, to write logs only for failed deliveries, set this value to 0. To write logs for 10% of your successful deliveries, set it to 10. DefaultSenderID – A string, such as your business brand, that is displayed as the sender on the receiving device. Support for sender IDs varies by country. The sender ID can be 1 - 11 alphanumeric characters, and it must contain at least one letter. DefaultSMSType – The type of SMS message that you will send by default. You can assign the following values:
    ///
    /// * Promotional – (Default) Noncritical messages, such as marketing messages. Amazon SNS optimizes the message delivery to incur the lowest cost.
    ///
    /// * Transactional – Critical messages that support customer transactions, such as one-time passcodes for multi-factor authentication. Amazon SNS optimizes the message delivery to achieve the highest reliability.
    ///
    ///
    /// UsageReportS3Bucket – The name of the Amazon S3 bucket to receive daily SMS usage reports from Amazon SNS. Each day, Amazon SNS will deliver a usage report as a CSV file to the bucket. The report includes the following information for each SMS message that was successfully delivered by your Amazon Web Services account:
    ///
    /// * Time that the message was published (in UTC)
    ///
    /// * Message ID
    ///
    /// * Destination phone number
    ///
    /// * Message type
    ///
    /// * Delivery status
    ///
    /// * Message price (in USD)
    ///
    /// * Part number (a message is split into multiple parts if it is too long for a single message)
    ///
    /// * Total number of parts
    ///
    ///
    /// To receive the report, the bucket must have a policy that allows the Amazon SNS service principal to perform the s3:PutObject and s3:GetBucketLocation actions. For an example bucket policy and usage report, see [Monitoring SMS Activity](https://docs.aws.amazon.com/sns/latest/dg/sms_stats.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?

    public init(
        attributes: [Swift.String: Swift.String]? = nil
    )
    {
        self.attributes = attributes
    }
}

/// The response for the SetSMSAttributes action.
public struct SetSMSAttributesOutput: Swift.Sendable {

    public init() { }
}

/// Input for SetSubscriptionAttributes action.
public struct SetSubscriptionAttributesInput: Swift.Sendable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that this action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Firehose delivery stream subscriptions. For more information, see [Fanout to Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute in JSON format.
    public var attributeValue: Swift.String?
    /// The ARN of the subscription to modify.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        subscriptionArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.subscriptionArn = subscriptionArn
    }
}

/// Input for SetTopicAttributes action.
public struct SetTopicAttributesInput: Swift.Sendable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the SetTopicAttributes action uses:
    ///
    /// * ApplicationSuccessFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to a platform application endpoint.
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * DisplayName – The display name to use for a topic with SMS subscriptions.
    ///
    /// * Policy – The policy that defines who can access your topic. By default, only the topic owner can publish or subscribe to the topic.
    ///
    /// * TracingConfig – Tracing mode of an Amazon SNS topic. By default TracingConfig is set to PassThrough, and the topic passes through the tracing header it receives from an Amazon SNS publisher to its subscriptions. If set to Active, Amazon SNS will vend X-Ray segment data to topic owner account if the sampled flag in the tracing header is true. This is only supported on standard topics.
    ///
    /// * HTTP
    ///
    /// * HTTPSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    /// * HTTPSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    /// * HTTPFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an HTTP endpoint.
    ///
    ///
    ///
    ///
    /// * Amazon Kinesis Data Firehose
    ///
    /// * FirehoseSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    /// * FirehoseSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    /// * FirehoseFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Kinesis Data Firehose endpoint.
    ///
    ///
    ///
    ///
    /// * Lambda
    ///
    /// * LambdaSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    /// * LambdaSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    /// * LambdaFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Lambda endpoint.
    ///
    ///
    ///
    ///
    /// * Platform application endpoint
    ///
    /// * ApplicationSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    /// * ApplicationSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    /// * ApplicationFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon Web Services application endpoint.
    ///
    ///
    /// In addition to being able to configure topic attributes for message delivery status of notification messages sent to Amazon SNS application endpoints, you can also configure application attributes for the delivery status of push notification messages sent to push notification services. For example, For more information, see [Using Amazon SNS Application Attributes for Message Delivery Status](https://docs.aws.amazon.com/sns/latest/dg/sns-msg-status.html).
    ///
    /// * Amazon SQS
    ///
    /// * SQSSuccessFeedbackRoleArn – Indicates successful message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    /// * SQSSuccessFeedbackSampleRate – Indicates percentage of successful messages to sample for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    /// * SQSFailureFeedbackRoleArn – Indicates failed message delivery status for an Amazon SNS topic that is subscribed to an Amazon SQS endpoint.
    ///
    ///
    ///
    ///
    ///
    /// The SuccessFeedbackRoleArn and FailureFeedbackRoleArn attributes are used to give Amazon SNS write access to use CloudWatch Logs on your behalf. The SuccessFeedbackSampleRate attribute is for specifying the sample rate percentage (0-100) of successfully delivered messages. After you configure the FailureFeedbackRoleArn attribute, then all failed message deliveries generate CloudWatch Logs. The following attribute applies only to [server-side-encryption](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html):
    ///
    /// * KmsMasterKeyId – The ID of an Amazon Web Services managed customer master key (CMK) for Amazon SNS or a custom CMK. For more information, see [Key Terms](https://docs.aws.amazon.com/sns/latest/dg/sns-server-side-encryption.html#sse-key-terms). For more examples, see [KeyId](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters) in the Key Management Service API Reference.
    ///
    /// * SignatureVersion – The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. By default, SignatureVersion is set to 1.
    ///
    ///
    /// The following attribute applies only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ContentBasedDeduplication – Enables content-based deduplication for FIFO topics.
    ///
    /// * By default, ContentBasedDeduplication is set to false. If you create a FIFO topic and this attribute is false, you must specify a value for the MessageDeduplicationId parameter for the [Publish](https://docs.aws.amazon.com/sns/latest/api/API_Publish.html) action.
    ///
    /// * When you set ContentBasedDeduplication to true, Amazon SNS uses a SHA-256 hash to generate the MessageDeduplicationId using the body of the message (but not the attributes of the message). (Optional) To override the generated value, you can specify a value for the MessageDeduplicationId parameter for the Publish action.
    /// This member is required.
    public var attributeName: Swift.String?
    /// The new value for the attribute.
    public var attributeValue: Swift.String?
    /// The ARN of the topic to modify.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        topicArn: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.topicArn = topicArn
    }
}

/// Input for Subscribe action.
public struct SubscribeInput: Swift.Sendable {
    /// A map of attributes with their corresponding values. The following lists the names, descriptions, and values of the special request parameters that the Subscribe action uses:
    ///
    /// * DeliveryPolicy – The policy that defines how Amazon SNS retries failed deliveries to HTTP/S endpoints.
    ///
    /// * FilterPolicy – The simple JSON object that lets your subscriber receive only a subset of messages, rather than receiving every message published to the topic.
    ///
    /// * FilterPolicyScope – This attribute lets you choose the filtering scope by using one of the following string value types:
    ///
    /// * MessageAttributes (default) – The filter is applied on the message attributes.
    ///
    /// * MessageBody – The filter is applied on the message body.
    ///
    ///
    ///
    ///
    /// * RawMessageDelivery – When set to true, enables raw message delivery to Amazon SQS or HTTP/S endpoints. This eliminates the need for the endpoints to process JSON formatting, which is otherwise created for Amazon SNS metadata.
    ///
    /// * RedrivePolicy – When specified, sends undeliverable messages to the specified Amazon SQS dead-letter queue. Messages that can't be delivered due to client errors (for example, when the subscribed endpoint is unreachable) or server errors (for example, when the service that powers the subscribed endpoint becomes unavailable) are held in the dead-letter queue for further analysis or reprocessing.
    ///
    ///
    /// The following attribute applies only to Amazon Data Firehose delivery stream subscriptions:
    ///
    /// * SubscriptionRoleArn – The ARN of the IAM role that has the following:
    ///
    /// * Permission to write to the Firehose delivery stream
    ///
    /// * Amazon SNS listed as a trusted entity
    ///
    ///
    /// Specifying a valid ARN for this attribute is required for Firehose delivery stream subscriptions. For more information, see [Fanout to Firehose delivery streams](https://docs.aws.amazon.com/sns/latest/dg/sns-firehose-as-subscriber.html) in the Amazon SNS Developer Guide.
    ///
    ///
    /// The following attributes apply only to [FIFO topics](https://docs.aws.amazon.com/sns/latest/dg/sns-fifo-topics.html):
    ///
    /// * ReplayPolicy – Adds or updates an inline policy document for a subscription to replay messages stored in the specified Amazon SNS topic.
    ///
    /// * ReplayStatus – Retrieves the status of the subscription message replay, which can be one of the following:
    ///
    /// * Completed – The replay has successfully redelivered all messages, and is now delivering newly published messages. If an ending point was specified in the ReplayPolicy then the subscription will no longer receive newly published messages.
    ///
    /// * In progress – The replay is currently replaying the selected messages.
    ///
    /// * Failed – The replay was unable to complete.
    ///
    /// * Pending – The default state while the replay initiates.
    public var attributes: [Swift.String: Swift.String]?
    /// The endpoint that you want to receive notifications. Endpoints vary by protocol:
    ///
    /// * For the http protocol, the (public) endpoint is a URL beginning with http://.
    ///
    /// * For the https protocol, the (public) endpoint is a URL beginning with https://.
    ///
    /// * For the email protocol, the endpoint is an email address.
    ///
    /// * For the email-json protocol, the endpoint is an email address.
    ///
    /// * For the sms protocol, the endpoint is a phone number of an SMS-enabled device.
    ///
    /// * For the sqs protocol, the endpoint is the ARN of an Amazon SQS queue.
    ///
    /// * For the application protocol, the endpoint is the EndpointArn of a mobile app and device.
    ///
    /// * For the lambda protocol, the endpoint is the ARN of an Lambda function.
    ///
    /// * For the firehose protocol, the endpoint is the ARN of an Amazon Kinesis Data Firehose delivery stream.
    public var endpoint: Swift.String?
    /// The protocol that you want to use. Supported protocols include:
    ///
    /// * http – delivery of JSON-encoded message via HTTP POST
    ///
    /// * https – delivery of JSON-encoded message via HTTPS POST
    ///
    /// * email – delivery of message via SMTP
    ///
    /// * email-json – delivery of JSON-encoded message via SMTP
    ///
    /// * sms – delivery of message via SMS
    ///
    /// * sqs – delivery of JSON-encoded message to an Amazon SQS queue
    ///
    /// * application – delivery of JSON-encoded message to an EndpointArn for a mobile app and device
    ///
    /// * lambda – delivery of JSON-encoded message to an Lambda function
    ///
    /// * firehose – delivery of JSON-encoded message to an Amazon Kinesis Data Firehose delivery stream.
    /// This member is required.
    public var `protocol`: Swift.String?
    /// Sets whether the response from the Subscribe request includes the subscription ARN, even if the subscription is not yet confirmed. If you set this parameter to true, the response includes the ARN in all cases, even if the subscription is not yet confirmed. In addition to the ARN for confirmed subscriptions, the response also includes the pending subscription ARN value for subscriptions that aren't yet confirmed. A subscription becomes confirmed when the subscriber calls the ConfirmSubscription action with a confirmation token. The default value is false.
    public var returnSubscriptionArn: Swift.Bool?
    /// The ARN of the topic you want to subscribe to.
    /// This member is required.
    public var topicArn: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        endpoint: Swift.String? = nil,
        `protocol`: Swift.String? = nil,
        returnSubscriptionArn: Swift.Bool? = false,
        topicArn: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.endpoint = endpoint
        self.`protocol` = `protocol`
        self.returnSubscriptionArn = returnSubscriptionArn
        self.topicArn = topicArn
    }
}

/// Response for Subscribe action.
public struct SubscribeOutput: Swift.Sendable {
    /// The ARN of the subscription if it is confirmed, or the string "pending confirmation" if the subscription requires confirmation. However, if the API request parameter ReturnSubscriptionArn is true, then the value is always the subscription ARN, even if the subscription requires confirmation.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the topic to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to the specified topic. A tag consists of a required key and an optional value.
    /// This member is required.
    public var tags: [SNSClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [SNSClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Input for Unsubscribe action.
public struct UnsubscribeInput: Swift.Sendable {
    /// The ARN of the subscription to be deleted.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the topic from which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the specified topic.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Indicates that the one-time password (OTP) used for verification is invalid.
public struct VerificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The status of the verification error.
        /// This member is required.
        public internal(set) var status: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VerificationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.status = status
    }
}

public struct VerifySMSSandboxPhoneNumberInput: Swift.Sendable {
    /// The OTP sent to the destination number from the CreateSMSSandBoxPhoneNumber call.
    /// This member is required.
    public var oneTimePassword: Swift.String?
    /// The destination phone number to verify.
    /// This member is required.
    public var phoneNumber: Swift.String?

    public init(
        oneTimePassword: Swift.String? = nil,
        phoneNumber: Swift.String? = nil
    )
    {
        self.oneTimePassword = oneTimePassword
        self.phoneNumber = phoneNumber
    }
}

extension VerifySMSSandboxPhoneNumberInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VerifySMSSandboxPhoneNumberInput(oneTimePassword: \(Swift.String(describing: oneTimePassword)), phoneNumber: \"CONTENT_REDACTED\")"}
}

/// The destination phone number's verification status.
public struct VerifySMSSandboxPhoneNumberOutput: Swift.Sendable {

    public init() { }
}

extension AddPermissionInput {

    static func urlPathProvider(_ value: AddPermissionInput) -> Swift.String? {
        return "/"
    }
}

extension CheckIfPhoneNumberIsOptedOutInput {

    static func urlPathProvider(_ value: CheckIfPhoneNumberIsOptedOutInput) -> Swift.String? {
        return "/"
    }
}

extension ConfirmSubscriptionInput {

    static func urlPathProvider(_ value: ConfirmSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePlatformApplicationInput {

    static func urlPathProvider(_ value: CreatePlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePlatformEndpointInput {

    static func urlPathProvider(_ value: CreatePlatformEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: CreateSMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTopicInput {

    static func urlPathProvider(_ value: CreateTopicInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEndpointInput {

    static func urlPathProvider(_ value: DeleteEndpointInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePlatformApplicationInput {

    static func urlPathProvider(_ value: DeletePlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: DeleteSMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTopicInput {

    static func urlPathProvider(_ value: DeleteTopicInput) -> Swift.String? {
        return "/"
    }
}

extension GetDataProtectionPolicyInput {

    static func urlPathProvider(_ value: GetDataProtectionPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetEndpointAttributesInput {

    static func urlPathProvider(_ value: GetEndpointAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension GetPlatformApplicationAttributesInput {

    static func urlPathProvider(_ value: GetPlatformApplicationAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension GetSMSAttributesInput {

    static func urlPathProvider(_ value: GetSMSAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension GetSMSSandboxAccountStatusInput {

    static func urlPathProvider(_ value: GetSMSSandboxAccountStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetSubscriptionAttributesInput {

    static func urlPathProvider(_ value: GetSubscriptionAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension GetTopicAttributesInput {

    static func urlPathProvider(_ value: GetTopicAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension ListEndpointsByPlatformApplicationInput {

    static func urlPathProvider(_ value: ListEndpointsByPlatformApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension ListOriginationNumbersInput {

    static func urlPathProvider(_ value: ListOriginationNumbersInput) -> Swift.String? {
        return "/"
    }
}

extension ListPhoneNumbersOptedOutInput {

    static func urlPathProvider(_ value: ListPhoneNumbersOptedOutInput) -> Swift.String? {
        return "/"
    }
}

extension ListPlatformApplicationsInput {

    static func urlPathProvider(_ value: ListPlatformApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSMSSandboxPhoneNumbersInput {

    static func urlPathProvider(_ value: ListSMSSandboxPhoneNumbersInput) -> Swift.String? {
        return "/"
    }
}

extension ListSubscriptionsInput {

    static func urlPathProvider(_ value: ListSubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSubscriptionsByTopicInput {

    static func urlPathProvider(_ value: ListSubscriptionsByTopicInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTopicsInput {

    static func urlPathProvider(_ value: ListTopicsInput) -> Swift.String? {
        return "/"
    }
}

extension OptInPhoneNumberInput {

    static func urlPathProvider(_ value: OptInPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension PublishInput {

    static func urlPathProvider(_ value: PublishInput) -> Swift.String? {
        return "/"
    }
}

extension PublishBatchInput {

    static func urlPathProvider(_ value: PublishBatchInput) -> Swift.String? {
        return "/"
    }
}

extension PutDataProtectionPolicyInput {

    static func urlPathProvider(_ value: PutDataProtectionPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension RemovePermissionInput {

    static func urlPathProvider(_ value: RemovePermissionInput) -> Swift.String? {
        return "/"
    }
}

extension SetEndpointAttributesInput {

    static func urlPathProvider(_ value: SetEndpointAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension SetPlatformApplicationAttributesInput {

    static func urlPathProvider(_ value: SetPlatformApplicationAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension SetSMSAttributesInput {

    static func urlPathProvider(_ value: SetSMSAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension SetSubscriptionAttributesInput {

    static func urlPathProvider(_ value: SetSubscriptionAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension SetTopicAttributesInput {

    static func urlPathProvider(_ value: SetTopicAttributesInput) -> Swift.String? {
        return "/"
    }
}

extension SubscribeInput {

    static func urlPathProvider(_ value: SubscribeInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UnsubscribeInput {

    static func urlPathProvider(_ value: UnsubscribeInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension VerifySMSSandboxPhoneNumberInput {

    static func urlPathProvider(_ value: VerifySMSSandboxPhoneNumberInput) -> Swift.String? {
        return "/"
    }
}

extension AddPermissionInput {

    static func write(value: AddPermissionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AWSAccountId"].writeList(value.awsAccountId, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ActionName"].writeList(value.actionName, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Label"].write(value.label)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("AddPermission")
        try writer["Version"].write("2010-03-31")
    }
}

extension CheckIfPhoneNumberIsOptedOutInput {

    static func write(value: CheckIfPhoneNumberIsOptedOutInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["phoneNumber"].write(value.phoneNumber)
        try writer["Action"].write("CheckIfPhoneNumberIsOptedOut")
        try writer["Version"].write("2010-03-31")
    }
}

extension ConfirmSubscriptionInput {

    static func write(value: ConfirmSubscriptionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AuthenticateOnUnsubscribe"].write(value.authenticateOnUnsubscribe)
        try writer["Token"].write(value.token)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("ConfirmSubscription")
        try writer["Version"].write("2010-03-31")
    }
}

extension CreatePlatformApplicationInput {

    static func write(value: CreatePlatformApplicationInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Platform"].write(value.platform)
        try writer["Action"].write("CreatePlatformApplication")
        try writer["Version"].write("2010-03-31")
    }
}

extension CreatePlatformEndpointInput {

    static func write(value: CreatePlatformEndpointInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CustomUserData"].write(value.customUserData)
        try writer["PlatformApplicationArn"].write(value.platformApplicationArn)
        try writer["Token"].write(value.token)
        try writer["Action"].write("CreatePlatformEndpoint")
        try writer["Version"].write("2010-03-31")
    }
}

extension CreateSMSSandboxPhoneNumberInput {

    static func write(value: CreateSMSSandboxPhoneNumberInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["LanguageCode"].write(value.languageCode)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["Action"].write("CreateSMSSandboxPhoneNumber")
        try writer["Version"].write("2010-03-31")
    }
}

extension CreateTopicInput {

    static func write(value: CreateTopicInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["DataProtectionPolicy"].write(value.dataProtectionPolicy)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SNSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("CreateTopic")
        try writer["Version"].write("2010-03-31")
    }
}

extension DeleteEndpointInput {

    static func write(value: DeleteEndpointInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["Action"].write("DeleteEndpoint")
        try writer["Version"].write("2010-03-31")
    }
}

extension DeletePlatformApplicationInput {

    static func write(value: DeletePlatformApplicationInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PlatformApplicationArn"].write(value.platformApplicationArn)
        try writer["Action"].write("DeletePlatformApplication")
        try writer["Version"].write("2010-03-31")
    }
}

extension DeleteSMSSandboxPhoneNumberInput {

    static func write(value: DeleteSMSSandboxPhoneNumberInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["Action"].write("DeleteSMSSandboxPhoneNumber")
        try writer["Version"].write("2010-03-31")
    }
}

extension DeleteTopicInput {

    static func write(value: DeleteTopicInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("DeleteTopic")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetDataProtectionPolicyInput {

    static func write(value: GetDataProtectionPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Action"].write("GetDataProtectionPolicy")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetEndpointAttributesInput {

    static func write(value: GetEndpointAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["Action"].write("GetEndpointAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetPlatformApplicationAttributesInput {

    static func write(value: GetPlatformApplicationAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PlatformApplicationArn"].write(value.platformApplicationArn)
        try writer["Action"].write("GetPlatformApplicationAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetSMSAttributesInput {

    static func write(value: GetSMSAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeList(value.attributes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("GetSMSAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetSMSSandboxAccountStatusInput {

    static func write(value: GetSMSSandboxAccountStatusInput?, to writer: SmithyFormURL.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
        try writer["Action"].write("GetSMSSandboxAccountStatus")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetSubscriptionAttributesInput {

    static func write(value: GetSubscriptionAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionArn"].write(value.subscriptionArn)
        try writer["Action"].write("GetSubscriptionAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension GetTopicAttributesInput {

    static func write(value: GetTopicAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("GetTopicAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListEndpointsByPlatformApplicationInput {

    static func write(value: ListEndpointsByPlatformApplicationInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PlatformApplicationArn"].write(value.platformApplicationArn)
        try writer["Action"].write("ListEndpointsByPlatformApplication")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListOriginationNumbersInput {

    static func write(value: ListOriginationNumbersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Action"].write("ListOriginationNumbers")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListPhoneNumbersOptedOutInput {

    static func write(value: ListPhoneNumbersOptedOutInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
        try writer["Action"].write("ListPhoneNumbersOptedOut")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListPlatformApplicationsInput {

    static func write(value: ListPlatformApplicationsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["Action"].write("ListPlatformApplications")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListSMSSandboxPhoneNumbersInput {

    static func write(value: ListSMSSandboxPhoneNumbersInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Action"].write("ListSMSSandboxPhoneNumbers")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListSubscriptionsInput {

    static func write(value: ListSubscriptionsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["Action"].write("ListSubscriptions")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListSubscriptionsByTopicInput {

    static func write(value: ListSubscriptionsByTopicInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("ListSubscriptionsByTopic")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Action"].write("ListTagsForResource")
        try writer["Version"].write("2010-03-31")
    }
}

extension ListTopicsInput {

    static func write(value: ListTopicsInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["Action"].write("ListTopics")
        try writer["Version"].write("2010-03-31")
    }
}

extension OptInPhoneNumberInput {

    static func write(value: OptInPhoneNumberInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["phoneNumber"].write(value.phoneNumber)
        try writer["Action"].write("OptInPhoneNumber")
        try writer["Version"].write("2010-03-31")
    }
}

extension PublishInput {

    static func write(value: PublishInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Message"].write(value.message)
        try writer["MessageAttributes"].writeMap(value.messageAttributes, valueWritingClosure: SNSClientTypes.MessageAttributeValue.write(value:to:), keyNodeInfo: "Name", valueNodeInfo: "Value", isFlattened: false)
        try writer["MessageDeduplicationId"].write(value.messageDeduplicationId)
        try writer["MessageGroupId"].write(value.messageGroupId)
        try writer["MessageStructure"].write(value.messageStructure)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["Subject"].write(value.subject)
        try writer["TargetArn"].write(value.targetArn)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("Publish")
        try writer["Version"].write("2010-03-31")
    }
}

extension PublishBatchInput {

    static func write(value: PublishBatchInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["PublishBatchRequestEntries"].writeList(value.publishBatchRequestEntries, memberWritingClosure: SNSClientTypes.PublishBatchRequestEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("PublishBatch")
        try writer["Version"].write("2010-03-31")
    }
}

extension PutDataProtectionPolicyInput {

    static func write(value: PutDataProtectionPolicyInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["DataProtectionPolicy"].write(value.dataProtectionPolicy)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Action"].write("PutDataProtectionPolicy")
        try writer["Version"].write("2010-03-31")
    }
}

extension RemovePermissionInput {

    static func write(value: RemovePermissionInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Label"].write(value.label)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("RemovePermission")
        try writer["Version"].write("2010-03-31")
    }
}

extension SetEndpointAttributesInput {

    static func write(value: SetEndpointAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["EndpointArn"].write(value.endpointArn)
        try writer["Action"].write("SetEndpointAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension SetPlatformApplicationAttributesInput {

    static func write(value: SetPlatformApplicationAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["PlatformApplicationArn"].write(value.platformApplicationArn)
        try writer["Action"].write("SetPlatformApplicationAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension SetSMSAttributesInput {

    static func write(value: SetSMSAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Action"].write("SetSMSAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension SetSubscriptionAttributesInput {

    static func write(value: SetSubscriptionAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
        try writer["SubscriptionArn"].write(value.subscriptionArn)
        try writer["Action"].write("SetSubscriptionAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension SetTopicAttributesInput {

    static func write(value: SetTopicAttributesInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["AttributeName"].write(value.attributeName)
        try writer["AttributeValue"].write(value.attributeValue)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("SetTopicAttributes")
        try writer["Version"].write("2010-03-31")
    }
}

extension SubscribeInput {

    static func write(value: SubscribeInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Endpoint"].write(value.endpoint)
        try writer["Protocol"].write(value.`protocol`)
        try writer["ReturnSubscriptionArn"].write(value.returnSubscriptionArn)
        try writer["TopicArn"].write(value.topicArn)
        try writer["Action"].write("Subscribe")
        try writer["Version"].write("2010-03-31")
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SNSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("TagResource")
        try writer["Version"].write("2010-03-31")
    }
}

extension UnsubscribeInput {

    static func write(value: UnsubscribeInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionArn"].write(value.subscriptionArn)
        try writer["Action"].write("Unsubscribe")
        try writer["Version"].write("2010-03-31")
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Action"].write("UntagResource")
        try writer["Version"].write("2010-03-31")
    }
}

extension VerifySMSSandboxPhoneNumberInput {

    static func write(value: VerifySMSSandboxPhoneNumberInput?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["OneTimePassword"].write(value.oneTimePassword)
        try writer["PhoneNumber"].write(value.phoneNumber)
        try writer["Action"].write("VerifySMSSandboxPhoneNumber")
        try writer["Version"].write("2010-03-31")
    }
}

extension AddPermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddPermissionOutput {
        return AddPermissionOutput()
    }
}

extension CheckIfPhoneNumberIsOptedOutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CheckIfPhoneNumberIsOptedOutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CheckIfPhoneNumberIsOptedOutResult"]
        var value = CheckIfPhoneNumberIsOptedOutOutput()
        value.isOptedOut = try reader["isOptedOut"].readIfPresent() ?? false
        return value
    }
}

extension ConfirmSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ConfirmSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ConfirmSubscriptionResult"]
        var value = ConfirmSubscriptionOutput()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
        return value
    }
}

extension CreatePlatformApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePlatformApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreatePlatformApplicationResult"]
        var value = CreatePlatformApplicationOutput()
        value.platformApplicationArn = try reader["PlatformApplicationArn"].readIfPresent()
        return value
    }
}

extension CreatePlatformEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePlatformEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreatePlatformEndpointResult"]
        var value = CreatePlatformEndpointOutput()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        return value
    }
}

extension CreateSMSSandboxPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSMSSandboxPhoneNumberOutput {
        return CreateSMSSandboxPhoneNumberOutput()
    }
}

extension CreateTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["CreateTopicResult"]
        var value = CreateTopicOutput()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        return value
    }
}

extension DeleteEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEndpointOutput {
        return DeleteEndpointOutput()
    }
}

extension DeletePlatformApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlatformApplicationOutput {
        return DeletePlatformApplicationOutput()
    }
}

extension DeleteSMSSandboxPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSMSSandboxPhoneNumberOutput {
        return DeleteSMSSandboxPhoneNumberOutput()
    }
}

extension DeleteTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTopicOutput {
        return DeleteTopicOutput()
    }
}

extension GetDataProtectionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataProtectionPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetDataProtectionPolicyResult"]
        var value = GetDataProtectionPolicyOutput()
        value.dataProtectionPolicy = try reader["DataProtectionPolicy"].readIfPresent()
        return value
    }
}

extension GetEndpointAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEndpointAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetEndpointAttributesResult"]
        var value = GetEndpointAttributesOutput()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetPlatformApplicationAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlatformApplicationAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetPlatformApplicationAttributesResult"]
        var value = GetPlatformApplicationAttributesOutput()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSMSAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSMSAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetSMSAttributesResult"]
        var value = GetSMSAttributesOutput()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSMSSandboxAccountStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSMSSandboxAccountStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetSMSSandboxAccountStatusResult"]
        var value = GetSMSSandboxAccountStatusOutput()
        value.isInSandbox = try reader["IsInSandbox"].readIfPresent() ?? false
        return value
    }
}

extension GetSubscriptionAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetSubscriptionAttributesResult"]
        var value = GetSubscriptionAttributesOutput()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetTopicAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTopicAttributesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["GetTopicAttributesResult"]
        var value = GetTopicAttributesOutput()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListEndpointsByPlatformApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEndpointsByPlatformApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListEndpointsByPlatformApplicationResult"]
        var value = ListEndpointsByPlatformApplicationOutput()
        value.endpoints = try reader["Endpoints"].readListIfPresent(memberReadingClosure: SNSClientTypes.Endpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOriginationNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOriginationNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListOriginationNumbersResult"]
        var value = ListOriginationNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: SNSClientTypes.PhoneNumberInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPhoneNumbersOptedOutOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPhoneNumbersOptedOutOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPhoneNumbersOptedOutResult"]
        var value = ListPhoneNumbersOptedOutOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.phoneNumbers = try reader["phoneNumbers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPlatformApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlatformApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListPlatformApplicationsResult"]
        var value = ListPlatformApplicationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.platformApplications = try reader["PlatformApplications"].readListIfPresent(memberReadingClosure: SNSClientTypes.PlatformApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSMSSandboxPhoneNumbersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSMSSandboxPhoneNumbersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSMSSandboxPhoneNumbersResult"]
        var value = ListSMSSandboxPhoneNumbersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.phoneNumbers = try reader["PhoneNumbers"].readListIfPresent(memberReadingClosure: SNSClientTypes.SMSSandboxPhoneNumber.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSubscriptionsResult"]
        var value = ListSubscriptionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: SNSClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSubscriptionsByTopicOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionsByTopicOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListSubscriptionsByTopicResult"]
        var value = ListSubscriptionsByTopicOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: SNSClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListTagsForResourceResult"]
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SNSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTopicsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTopicsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["ListTopicsResult"]
        var value = ListTopicsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.topics = try reader["Topics"].readListIfPresent(memberReadingClosure: SNSClientTypes.Topic.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension OptInPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> OptInPhoneNumberOutput {
        return OptInPhoneNumberOutput()
    }
}

extension PublishOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["PublishResult"]
        var value = PublishOutput()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.sequenceNumber = try reader["SequenceNumber"].readIfPresent()
        return value
    }
}

extension PublishBatchOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PublishBatchOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["PublishBatchResult"]
        var value = PublishBatchOutput()
        value.failed = try reader["Failed"].readListIfPresent(memberReadingClosure: SNSClientTypes.BatchResultErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.successful = try reader["Successful"].readListIfPresent(memberReadingClosure: SNSClientTypes.PublishBatchResultEntry.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutDataProtectionPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDataProtectionPolicyOutput {
        return PutDataProtectionPolicyOutput()
    }
}

extension RemovePermissionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemovePermissionOutput {
        return RemovePermissionOutput()
    }
}

extension SetEndpointAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetEndpointAttributesOutput {
        return SetEndpointAttributesOutput()
    }
}

extension SetPlatformApplicationAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetPlatformApplicationAttributesOutput {
        return SetPlatformApplicationAttributesOutput()
    }
}

extension SetSMSAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetSMSAttributesOutput {
        return SetSMSAttributesOutput()
    }
}

extension SetSubscriptionAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetSubscriptionAttributesOutput {
        return SetSubscriptionAttributesOutput()
    }
}

extension SetTopicAttributesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SetTopicAttributesOutput {
        return SetTopicAttributesOutput()
    }
}

extension SubscribeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubscribeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let reader = responseReader["SubscribeResult"]
        var value = SubscribeOutput()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UnsubscribeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnsubscribeOutput {
        return UnsubscribeOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension VerifySMSSandboxPhoneNumberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> VerifySMSSandboxPhoneNumberOutput {
        return VerifySMSSandboxPhoneNumberOutput()
    }
}

enum AddPermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CheckIfPhoneNumberIsOptedOutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ConfirmSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "FilterPolicyLimitExceeded": return try FilterPolicyLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "ReplayLimitExceeded": return try ReplayLimitExceededException.makeError(baseError: baseError)
            case "SubscriptionLimitExceeded": return try SubscriptionLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePlatformApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePlatformEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSMSSandboxPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptedOut": return try OptedOutException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            case "UserError": return try UserErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConcurrentAccess": return try ConcurrentAccessException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "StaleTag": return try StaleTagException.makeError(baseError: baseError)
            case "TagLimitExceeded": return try TagLimitExceededException.makeError(baseError: baseError)
            case "TagPolicy": return try TagPolicyException.makeError(baseError: baseError)
            case "TopicLimitExceeded": return try TopicLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlatformApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSMSSandboxPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            case "UserError": return try UserErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConcurrentAccess": return try ConcurrentAccessException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidState": return try InvalidStateException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "StaleTag": return try StaleTagException.makeError(baseError: baseError)
            case "TagPolicy": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataProtectionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEndpointAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlatformApplicationAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSMSAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSMSSandboxAccountStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTopicAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEndpointsByPlatformApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOriginationNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPhoneNumbersOptedOutOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlatformApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSMSSandboxPhoneNumbersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionsByTopicOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConcurrentAccess": return try ConcurrentAccessException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagPolicy": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTopicsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum OptInPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "EndpointDisabled": return try EndpointDisabledException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ParameterValueInvalid": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "KMSAccessDenied": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabled": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidState": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFound": return try KMSNotFoundException.makeError(baseError: baseError)
            case "KMSOptInRequired": return try KMSOptInRequired.makeError(baseError: baseError)
            case "KMSThrottling": return try KMSThrottlingException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "PlatformApplicationDisabled": return try PlatformApplicationDisabledException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PublishBatchOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "BatchEntryIdsNotDistinct": return try BatchEntryIdsNotDistinctException.makeError(baseError: baseError)
            case "BatchRequestTooLong": return try BatchRequestTooLongException.makeError(baseError: baseError)
            case "EmptyBatchRequest": return try EmptyBatchRequestException.makeError(baseError: baseError)
            case "EndpointDisabled": return try EndpointDisabledException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidBatchEntryId": return try InvalidBatchEntryIdException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ParameterValueInvalid": return try InvalidParameterValueException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "KMSAccessDenied": return try KMSAccessDeniedException.makeError(baseError: baseError)
            case "KMSDisabled": return try KMSDisabledException.makeError(baseError: baseError)
            case "KMSInvalidState": return try KMSInvalidStateException.makeError(baseError: baseError)
            case "KMSNotFound": return try KMSNotFoundException.makeError(baseError: baseError)
            case "KMSOptInRequired": return try KMSOptInRequired.makeError(baseError: baseError)
            case "KMSThrottling": return try KMSThrottlingException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "PlatformApplicationDisabled": return try PlatformApplicationDisabledException.makeError(baseError: baseError)
            case "TooManyEntriesInBatchRequest": return try TooManyEntriesInBatchRequestException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDataProtectionPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemovePermissionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetEndpointAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetPlatformApplicationAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetSMSAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetSubscriptionAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "FilterPolicyLimitExceeded": return try FilterPolicyLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "ReplayLimitExceeded": return try ReplayLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SetTopicAttributesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubscribeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "FilterPolicyLimitExceeded": return try FilterPolicyLimitExceededException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            case "ReplayLimitExceeded": return try ReplayLimitExceededException.makeError(baseError: baseError)
            case "SubscriptionLimitExceeded": return try SubscriptionLimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConcurrentAccess": return try ConcurrentAccessException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "StaleTag": return try StaleTagException.makeError(baseError: baseError)
            case "TagLimitExceeded": return try TagLimitExceededException.makeError(baseError: baseError)
            case "TagPolicy": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnsubscribeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidSecurity": return try InvalidSecurityException.makeError(baseError: baseError)
            case "NotFound": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "ConcurrentAccess": return try ConcurrentAccessException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "StaleTag": return try StaleTagException.makeError(baseError: baseError)
            case "TagLimitExceeded": return try TagLimitExceededException.makeError(baseError: baseError)
            case "TagPolicy": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum VerifySMSSandboxPhoneNumberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyXML.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSQueryError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AuthorizationError": return try AuthorizationErrorException.makeError(baseError: baseError)
            case "InternalError": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFound": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "Throttled": return try ThrottledException.makeError(baseError: baseError)
            case "VerificationException": return try VerificationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AuthorizationErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> AuthorizationErrorException {
        let reader = baseError.errorBodyReader
        var value = AuthorizationErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InternalErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottledException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ThrottledException {
        let reader = baseError.errorBodyReader
        var value = ThrottledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FilterPolicyLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> FilterPolicyLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = FilterPolicyLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SubscriptionLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> SubscriptionLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = SubscriptionLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplayLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ReplayLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ReplayLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OptedOutException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> OptedOutException {
        let reader = baseError.errorBodyReader
        var value = OptedOutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UserErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> UserErrorException {
        let reader = baseError.errorBodyReader
        var value = UserErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidSecurityException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidSecurityException {
        let reader = baseError.errorBodyReader
        var value = InvalidSecurityException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StaleTagException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> StaleTagException {
        let reader = baseError.errorBodyReader
        var value = StaleTagException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TagPolicyException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TagLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = TagLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TopicLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TopicLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = TopicLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConcurrentAccessException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ConcurrentAccessException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentAccessException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidStateException {
        let reader = baseError.errorBodyReader
        var value = InvalidStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSInvalidStateException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSInvalidStateException {
        let reader = baseError.errorBodyReader
        var value = KMSInvalidStateException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSNotFoundException {
        let reader = baseError.errorBodyReader
        var value = KMSNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PlatformApplicationDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> PlatformApplicationDisabledException {
        let reader = baseError.errorBodyReader
        var value = PlatformApplicationDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSOptInRequired {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSOptInRequired {
        let reader = baseError.errorBodyReader
        var value = KMSOptInRequired()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterValueException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidParameterValueException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterValueException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EndpointDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> EndpointDisabledException {
        let reader = baseError.errorBodyReader
        var value = EndpointDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSAccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSAccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = KMSAccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSThrottlingException {
        let reader = baseError.errorBodyReader
        var value = KMSThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KMSDisabledException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> KMSDisabledException {
        let reader = baseError.errorBodyReader
        var value = KMSDisabledException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BatchRequestTooLongException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> BatchRequestTooLongException {
        let reader = baseError.errorBodyReader
        var value = BatchRequestTooLongException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidBatchEntryIdException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> InvalidBatchEntryIdException {
        let reader = baseError.errorBodyReader
        var value = InvalidBatchEntryIdException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyEntriesInBatchRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> TooManyEntriesInBatchRequestException {
        let reader = baseError.errorBodyReader
        var value = TooManyEntriesInBatchRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BatchEntryIdsNotDistinctException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> BatchEntryIdsNotDistinctException {
        let reader = baseError.errorBodyReader
        var value = BatchEntryIdsNotDistinctException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EmptyBatchRequestException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> EmptyBatchRequestException {
        let reader = baseError.errorBodyReader
        var value = EmptyBatchRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VerificationException {

    static func makeError(baseError: AWSClientRuntime.AWSQueryError) throws -> VerificationException {
        let reader = baseError.errorBodyReader
        var value = VerificationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.status = try reader["Status"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SNSClientTypes.Endpoint {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.Endpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.Endpoint()
        value.endpointArn = try reader["EndpointArn"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SNSClientTypes.PhoneNumberInformation {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.PhoneNumberInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.PhoneNumberInformation()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.iso2CountryCode = try reader["Iso2CountryCode"].readIfPresent()
        value.routeType = try reader["RouteType"].readIfPresent()
        value.numberCapabilities = try reader["NumberCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SNSClientTypes.NumberCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SNSClientTypes.PlatformApplication {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.PlatformApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.PlatformApplication()
        value.platformApplicationArn = try reader["PlatformApplicationArn"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SNSClientTypes.SMSSandboxPhoneNumber {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.SMSSandboxPhoneNumber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.SMSSandboxPhoneNumber()
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SNSClientTypes.Subscription {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.Subscription()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        return value
    }
}

extension SNSClientTypes.Tag {

    static func write(value: SNSClientTypes.Tag?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension SNSClientTypes.Topic {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.Topic {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.Topic()
        value.topicArn = try reader["TopicArn"].readIfPresent()
        return value
    }
}

extension SNSClientTypes.PublishBatchResultEntry {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.PublishBatchResultEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.PublishBatchResultEntry()
        value.id = try reader["Id"].readIfPresent()
        value.messageId = try reader["MessageId"].readIfPresent()
        value.sequenceNumber = try reader["SequenceNumber"].readIfPresent()
        return value
    }
}

extension SNSClientTypes.BatchResultErrorEntry {

    static func read(from reader: SmithyXML.Reader) throws -> SNSClientTypes.BatchResultErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SNSClientTypes.BatchResultErrorEntry()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent()
        value.senderFault = try reader["SenderFault"].readIfPresent() ?? false
        return value
    }
}

extension SNSClientTypes.MessageAttributeValue {

    static func write(value: SNSClientTypes.MessageAttributeValue?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["BinaryValue"].write(value.binaryValue)
        try writer["DataType"].write(value.dataType)
        try writer["StringValue"].write(value.stringValue)
    }
}

extension SNSClientTypes.PublishBatchRequestEntry {

    static func write(value: SNSClientTypes.PublishBatchRequestEntry?, to writer: SmithyFormURL.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Message"].write(value.message)
        try writer["MessageAttributes"].writeMap(value.messageAttributes, valueWritingClosure: SNSClientTypes.MessageAttributeValue.write(value:to:), keyNodeInfo: "Name", valueNodeInfo: "Value", isFlattened: false)
        try writer["MessageDeduplicationId"].write(value.messageDeduplicationId)
        try writer["MessageGroupId"].write(value.messageGroupId)
        try writer["MessageStructure"].write(value.messageStructure)
        try writer["Subject"].write(value.subject)
    }
}

public enum SNSClientTypes {}
