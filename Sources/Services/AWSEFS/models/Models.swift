// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessPointAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessPointAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.properties.accessPointId = output.accessPointId
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.accessPointId = nil
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the access point that you are trying to create already exists, with the creation token you provided in the request.
public struct AccessPointAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var accessPointId: Swift.String? = nil
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessPointAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        accessPointId: Swift.String? = nil,
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.accessPointId = accessPointId
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessPointAlreadyExistsBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let accessPointId: Swift.String?
}

extension AccessPointAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointId = "AccessPointId"
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
    }
}

extension EFSClientTypes.AccessPointDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = self.accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
        if let accessPointId = self.accessPointId {
            try encodeContainer.encode(accessPointId, forKey: .accessPointId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lifeCycleState = self.lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let posixUser = self.posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = self.rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EFSClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

extension EFSClientTypes {
    /// Provides a description of an EFS file system access point.
    public struct AccessPointDescription: Swift.Equatable {
        /// The unique Amazon Resource Name (ARN) associated with the access point.
        public var accessPointArn: Swift.String?
        /// The ID of the access point, assigned by Amazon EFS.
        public var accessPointId: Swift.String?
        /// The opaque string specified in the request to ensure idempotent creation.
        public var clientToken: Swift.String?
        /// The ID of the EFS file system that the access point applies to.
        public var fileSystemId: Swift.String?
        /// Identifies the lifecycle phase of the access point.
        public var lifeCycleState: EFSClientTypes.LifeCycleState?
        /// The name of the access point. This is the value of the Name tag.
        public var name: Swift.String?
        /// Identifies the Amazon Web Services account that owns the access point resource.
        public var ownerId: Swift.String?
        /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.
        public var posixUser: EFSClientTypes.PosixUser?
        /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
        public var rootDirectory: EFSClientTypes.RootDirectory?
        /// The tags associated with the access point, presented as an array of Tag objects.
        public var tags: [EFSClientTypes.Tag]?

        public init(
            accessPointArn: Swift.String? = nil,
            accessPointId: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
            name: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            posixUser: EFSClientTypes.PosixUser? = nil,
            rootDirectory: EFSClientTypes.RootDirectory? = nil,
            tags: [EFSClientTypes.Tag]? = nil
        )
        {
            self.accessPointArn = accessPointArn
            self.accessPointId = accessPointId
            self.clientToken = clientToken
            self.fileSystemId = fileSystemId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.ownerId = ownerId
            self.posixUser = posixUser
            self.rootDirectory = rootDirectory
            self.tags = tags
        }
    }

}

extension AccessPointLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessPointLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the Amazon Web Services account has already created the maximum number of access points allowed per file system. For more informaton, see [https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region](https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region).
public struct AccessPointLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessPointLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessPointLimitExceededBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension AccessPointLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessPointNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessPointNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the specified AccessPointId value doesn't exist in the requester's Amazon Web Services account.
public struct AccessPointNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessPointNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AccessPointNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension AccessPointNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AvailabilityZonesMismatch {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AvailabilityZonesMismatchBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the Availability Zone that was specified for a mount target is different from the Availability Zone that was specified for One Zone storage. For more information, see [Regional and One Zone storage redundancy](https://docs.aws.amazon.com/efs/latest/ug/availability-durability.html).
public struct AvailabilityZonesMismatch: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AvailabilityZonesMismatch" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct AvailabilityZonesMismatchBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension AvailabilityZonesMismatchBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes.BackupPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EFSClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension EFSClientTypes {
    /// The backup policy for the file system used to create automatic daily backups. If status has a value of ENABLED, the file system is being automatically backed up. For more information, see [Automatic backups](https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups).
    public struct BackupPolicy: Swift.Equatable {
        /// Describes the status of the file system's backup policy.
        ///
        /// * ENABLED - EFS is automatically backing up the file system.
        ///
        /// * ENABLING - EFS is turning on automatic backups for the file system.
        ///
        /// * DISABLED - Automatic back ups are turned off for the file system.
        ///
        /// * DISABLING - EFS is turning off automatic backups for the file system.
        /// This member is required.
        public var status: EFSClientTypes.Status?

        public init(
            status: EFSClientTypes.Status? = nil
        )
        {
            self.status = status
        }
    }

}

extension BadRequest {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the request is malformed or contains an error such as an invalid parameter value or a missing required parameter.
public struct BadRequest: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequest" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct BadRequestBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension BadRequestBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccessPointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let posixUser = self.posixUser {
            try encodeContainer.encode(posixUser, forKey: .posixUser)
        }
        if let rootDirectory = self.rootDirectory {
            try encodeContainer.encode(rootDirectory, forKey: .rootDirectory)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/access-points"
    }
}

public struct CreateAccessPointInput: Swift.Equatable {
    /// A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The ID of the EFS file system that the access point provides access to.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// The operating system user and group applied to all file system requests made using the access point.
    public var posixUser: EFSClientTypes.PosixUser?
    /// Specifies the directory on the Amazon EFS file system that the access point exposes as the root directory of your file system to NFS clients using the access point. The clients using the access point can only access the root directory and below. If the RootDirectory > Path specified does not exist, EFS creates it and applies the CreationInfo settings when a client connects to an access point. When specifying a RootDirectory, you must provide the Path, and the CreationInfo. Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail.
    public var rootDirectory: EFSClientTypes.RootDirectory?
    /// Creates tags associated with the access point. Each tag is a key-value pair, each key must be unique. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        posixUser: EFSClientTypes.PosixUser? = nil,
        rootDirectory: EFSClientTypes.RootDirectory? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let tags: [EFSClientTypes.Tag]?
    let fileSystemId: Swift.String?
    let posixUser: EFSClientTypes.PosixUser?
    let rootDirectory: EFSClientTypes.RootDirectory?
}

extension CreateAccessPointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EFSClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
    }
}

extension CreateAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPointOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPointArn = output.accessPointArn
            self.accessPointId = output.accessPointId
            self.clientToken = output.clientToken
            self.fileSystemId = output.fileSystemId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.ownerId = output.ownerId
            self.posixUser = output.posixUser
            self.rootDirectory = output.rootDirectory
            self.tags = output.tags
        } else {
            self.accessPointArn = nil
            self.accessPointId = nil
            self.clientToken = nil
            self.fileSystemId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.ownerId = nil
            self.posixUser = nil
            self.rootDirectory = nil
            self.tags = nil
        }
    }
}

/// Provides a description of an EFS file system access point.
public struct CreateAccessPointOutput: Swift.Equatable {
    /// The unique Amazon Resource Name (ARN) associated with the access point.
    public var accessPointArn: Swift.String?
    /// The ID of the access point, assigned by Amazon EFS.
    public var accessPointId: Swift.String?
    /// The opaque string specified in the request to ensure idempotent creation.
    public var clientToken: Swift.String?
    /// The ID of the EFS file system that the access point applies to.
    public var fileSystemId: Swift.String?
    /// Identifies the lifecycle phase of the access point.
    public var lifeCycleState: EFSClientTypes.LifeCycleState?
    /// The name of the access point. This is the value of the Name tag.
    public var name: Swift.String?
    /// Identifies the Amazon Web Services account that owns the access point resource.
    public var ownerId: Swift.String?
    /// The full POSIX identity, including the user ID, group ID, and secondary group IDs on the access point that is used for all file operations by NFS clients using the access point.
    public var posixUser: EFSClientTypes.PosixUser?
    /// The directory on the Amazon EFS file system that the access point exposes as the root directory to NFS clients using the access point.
    public var rootDirectory: EFSClientTypes.RootDirectory?
    /// The tags associated with the access point, presented as an array of Tag objects.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        accessPointArn: Swift.String? = nil,
        accessPointId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        posixUser: EFSClientTypes.PosixUser? = nil,
        rootDirectory: EFSClientTypes.RootDirectory? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.accessPointArn = accessPointArn
        self.accessPointId = accessPointId
        self.clientToken = clientToken
        self.fileSystemId = fileSystemId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.ownerId = ownerId
        self.posixUser = posixUser
        self.rootDirectory = rootDirectory
        self.tags = tags
    }
}

struct CreateAccessPointOutputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let name: Swift.String?
    let tags: [EFSClientTypes.Tag]?
    let accessPointId: Swift.String?
    let accessPointArn: Swift.String?
    let fileSystemId: Swift.String?
    let posixUser: EFSClientTypes.PosixUser?
    let rootDirectory: EFSClientTypes.RootDirectory?
    let ownerId: Swift.String?
    let lifeCycleState: EFSClientTypes.LifeCycleState?
}

extension CreateAccessPointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointArn = "AccessPointArn"
        case accessPointId = "AccessPointId"
        case clientToken = "ClientToken"
        case fileSystemId = "FileSystemId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case ownerId = "OwnerId"
        case posixUser = "PosixUser"
        case rootDirectory = "RootDirectory"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let accessPointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointId)
        accessPointId = accessPointIdDecoded
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let posixUserDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PosixUser.self, forKey: .posixUser)
        posixUser = posixUserDecoded
        let rootDirectoryDecoded = try containerValues.decodeIfPresent(EFSClientTypes.RootDirectory.self, forKey: .rootDirectory)
        rootDirectory = rootDirectoryDecoded
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
    }
}

enum CreateAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointAlreadyExists": return try await AccessPointAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccessPointLimitExceeded": return try await AccessPointLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFileSystemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneName = self.availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let backup = self.backup {
            try encodeContainer.encode(backup, forKey: .backup)
        }
        if let creationToken = self.creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let performanceMode = self.performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = self.provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

extension CreateFileSystemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/file-systems"
    }
}

public struct CreateFileSystemInput: Swift.Equatable {
    /// Used to create a file system that uses One Zone storage classes. It specifies the Amazon Web Services Availability Zone in which to create the file system. Use the format us-east-1a to specify the Availability Zone. For more information about One Zone storage classes, see [Using EFS storage classes](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the Amazon EFS User Guide. One Zone storage classes are not available in all Availability Zones in Amazon Web Services Regions where Amazon EFS is available.
    public var availabilityZoneName: Swift.String?
    /// Specifies whether automatic backups are enabled on the file system that you are creating. Set the value to true to enable automatic backups. If you are creating a file system that uses One Zone storage classes, automatic backups are enabled by default. For more information, see [Automatic backups](https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups) in the Amazon EFS User Guide. Default is false. However, if you specify an AvailabilityZoneName, the default is true. Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.
    public var backup: Swift.Bool?
    /// A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent creation.
    /// This member is required.
    public var creationToken: Swift.String?
    /// A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key). If you don't specify a KMS key, then the default KMS key for Amazon EFS, /aws/elasticfilesystem, is used to protect the encrypted file system.
    public var encrypted: Swift.Bool?
    /// The ID of the KMS key that you want to use to protect the encrypted file system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following formats:
    ///
    /// * Key ID - A unique identifier of the key, for example 1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * ARN - An Amazon Resource Name (ARN) for the key, for example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
    ///
    /// * Key alias - A previously created display name for a key, for example alias/projectKey1.
    ///
    /// * Key alias ARN - An ARN for a key alias, for example arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
    ///
    ///
    /// If you use KmsKeyId, you must set the [CreateFileSystemRequest$Encrypted] parameter to true. EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with Amazon EFS file systems.
    public var kmsKeyId: Swift.String?
    /// The performance mode of the file system. We recommend generalPurpose performance mode for most file systems. File systems using the maxIO performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created. The maxIO mode is not supported on file systems using One Zone storage classes. Default is generalPurpose.
    public var performanceMode: EFSClientTypes.PerformanceMode?
    /// The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ThroughputMode is set to provisioned. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact Amazon Web Services Support. For more information, see [Amazon EFS quotas that you can increase](https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits) in the Amazon EFS User Guide.
    public var provisionedThroughputInMibps: Swift.Double?
    /// Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a "Key":"Name","Value":"{value}" key-value pair. Each key must be unique. For more information, see [Tagging Amazon Web Services resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference Guide.
    public var tags: [EFSClientTypes.Tag]?
    /// Specifies the throughput mode for the file system. The mode can be bursting, provisioned, or elastic. If you set ThroughputMode to provisioned, you must also set a value for ProvisionedThroughputInMibps. After you create the file system, you can decrease your file system's throughput in Provisioned Throughput mode or change between the throughput modes, with certain time restrictions. For more information, see [Specifying throughput with provisioned mode](https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput) in the Amazon EFS User Guide. Default is bursting.
    public var throughputMode: EFSClientTypes.ThroughputMode?

    public init(
        availabilityZoneName: Swift.String? = nil,
        backup: Swift.Bool? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        kmsKeyId: Swift.String? = nil,
        performanceMode: EFSClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        tags: [EFSClientTypes.Tag]? = nil,
        throughputMode: EFSClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneName = availabilityZoneName
        self.backup = backup
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.kmsKeyId = kmsKeyId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemInputBody: Swift.Equatable {
    let creationToken: Swift.String?
    let performanceMode: EFSClientTypes.PerformanceMode?
    let encrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let throughputMode: EFSClientTypes.ThroughputMode?
    let provisionedThroughputInMibps: Swift.Double?
    let availabilityZoneName: Swift.String?
    let backup: Swift.Bool?
    let tags: [EFSClientTypes.Tag]?
}

extension CreateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case backup = "Backup"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case kmsKeyId = "KmsKeyId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let backupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .backup)
        backup = backupDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFileSystemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFileSystemOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// A description of the file system.
public struct CreateFileSystemOutput: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone in which the file system's One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID for the us-east-1 Amazon Web Services Region, and it has the same location in every Amazon Web Services account.
    public var availabilityZoneId: Swift.String?
    /// Describes the Amazon Web Services Availability Zone in which the file system is located, and is valid only for file systems using One Zone storage classes. For more information, see [Using EFS storage classes](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the Amazon EFS User Guide.
    public var availabilityZoneName: Swift.String?
    /// The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The opaque string specified in the request.
    /// This member is required.
    public var creationToken: Swift.String?
    /// A Boolean value that, if true, indicates that the file system is encrypted.
    public var encrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the EFS file system, in the format arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id . Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
    public var fileSystemArn: Swift.String?
    /// The ID of the file system, assigned by Amazon EFS.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// The ID of an KMS key used to protect the encrypted file system.
    public var kmsKeyId: Swift.String?
    /// The lifecycle phase of the file system.
    /// This member is required.
    public var lifeCycleState: EFSClientTypes.LifeCycleState?
    /// You can add tags to a file system, including a Name tag. For more information, see [CreateFileSystem]. If the file system has a Name tag, Amazon EFS returns the value in this field.
    public var name: Swift.String?
    /// The current number of mount targets that the file system has. For more information, see [CreateMountTarget].
    /// This member is required.
    public var numberOfMountTargets: Swift.Int
    /// The Amazon Web Services account that created the file system.
    /// This member is required.
    public var ownerId: Swift.String?
    /// The performance mode of the file system.
    /// This member is required.
    public var performanceMode: EFSClientTypes.PerformanceMode?
    /// The amount of provisioned throughput, measured in MiBps, for the file system. Valid for file systems using ThroughputMode set to provisioned.
    public var provisionedThroughputInMibps: Swift.Double?
    /// The latest known metered size (in bytes) of data stored in the file system, in its Value field, and the time at which that size was determined in its Timestamp field. The Timestamp value is the integer number of seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent the size of a consistent snapshot of the file system, but it is eventually consistent when there are no writes to the file system. That is, SizeInBytes represents actual size only if the file system is not modified for a period longer than a couple of hours. Otherwise, the value is not the exact size that the file system was at any point in time.
    /// This member is required.
    public var sizeInBytes: EFSClientTypes.FileSystemSize?
    /// The tags associated with the file system, presented as an array of Tag objects.
    /// This member is required.
    public var tags: [EFSClientTypes.Tag]?
    /// Displays the file system's throughput mode. For more information, see [Throughput modes](https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes) in the Amazon EFS User Guide.
    public var throughputMode: EFSClientTypes.ThroughputMode?

    public init(
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        fileSystemArn: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        numberOfMountTargets: Swift.Int = 0,
        ownerId: Swift.String? = nil,
        performanceMode: EFSClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        sizeInBytes: EFSClientTypes.FileSystemSize? = nil,
        tags: [EFSClientTypes.Tag]? = nil,
        throughputMode: EFSClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct CreateFileSystemOutputBody: Swift.Equatable {
    let ownerId: Swift.String?
    let creationToken: Swift.String?
    let fileSystemId: Swift.String?
    let fileSystemArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lifeCycleState: EFSClientTypes.LifeCycleState?
    let name: Swift.String?
    let numberOfMountTargets: Swift.Int
    let sizeInBytes: EFSClientTypes.FileSystemSize?
    let performanceMode: EFSClientTypes.PerformanceMode?
    let encrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let throughputMode: EFSClientTypes.ThroughputMode?
    let provisionedThroughputInMibps: Swift.Double?
    let availabilityZoneName: Swift.String?
    let availabilityZoneId: Swift.String?
    let tags: [EFSClientTypes.Tag]?
}

extension CreateFileSystemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMountTargets) ?? 0
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EFSClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateFileSystemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemAlreadyExists": return try await FileSystemAlreadyExists(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemLimitExceeded": return try await FileSystemLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientThroughputCapacity": return try await InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThroughputLimitExceeded": return try await ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedAvailabilityZone": return try await UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMountTargetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }
}

extension CreateMountTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/mount-targets"
    }
}

///
public struct CreateMountTargetInput: Swift.Equatable {
    /// The ID of the file system for which to create the mount target.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// Valid IPv4 address within the address range of the specified subnet.
    public var ipAddress: Swift.String?
    /// Up to five VPC security group IDs, of the form sg-xxxxxxxx. These must be for the same VPC as subnet specified.
    public var securityGroups: [Swift.String]?
    /// The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet that is associated with the file system's Availability Zone.
    /// This member is required.
    public var subnetId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil,
        subnetId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.securityGroups = securityGroups
        self.subnetId = subnetId
    }
}

struct CreateMountTargetInputBody: Swift.Equatable {
    let fileSystemId: Swift.String?
    let subnetId: Swift.String?
    let ipAddress: Swift.String?
    let securityGroups: [Swift.String]?
}

extension CreateMountTargetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case securityGroups = "SecurityGroups"
        case subnetId = "SubnetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension CreateMountTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMountTargetOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.fileSystemId = output.fileSystemId
            self.ipAddress = output.ipAddress
            self.lifeCycleState = output.lifeCycleState
            self.mountTargetId = output.mountTargetId
            self.networkInterfaceId = output.networkInterfaceId
            self.ownerId = output.ownerId
            self.subnetId = output.subnetId
            self.vpcId = output.vpcId
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.fileSystemId = nil
            self.ipAddress = nil
            self.lifeCycleState = nil
            self.mountTargetId = nil
            self.networkInterfaceId = nil
            self.ownerId = nil
            self.subnetId = nil
            self.vpcId = nil
        }
    }
}

/// Provides a description of a mount target.
public struct CreateMountTargetOutput: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone that the mount target resides in. For example, use1-az1 is an AZ ID for the us-east-1 Region and it has the same location in every Amazon Web Services account.
    public var availabilityZoneId: Swift.String?
    /// The name of the Availability Zone in which the mount target is located. Availability Zones are independently mapped to names for each Amazon Web Services account. For example, the Availability Zone us-east-1a for your Amazon Web Services account might not be the same location as us-east-1a for another Amazon Web Services account.
    public var availabilityZoneName: Swift.String?
    /// The ID of the file system for which the mount target is intended.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// Address at which the file system can be mounted by using the mount target.
    public var ipAddress: Swift.String?
    /// Lifecycle state of the mount target.
    /// This member is required.
    public var lifeCycleState: EFSClientTypes.LifeCycleState?
    /// System-assigned mount target ID.
    /// This member is required.
    public var mountTargetId: Swift.String?
    /// The ID of the network interface that Amazon EFS created when it created the mount target.
    public var networkInterfaceId: Swift.String?
    /// Amazon Web Services account ID that owns the resource.
    public var ownerId: Swift.String?
    /// The ID of the mount target's subnet.
    /// This member is required.
    public var subnetId: Swift.String?
    /// The virtual private cloud (VPC) ID that the mount target is configured in.
    public var vpcId: Swift.String?

    public init(
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
        mountTargetId: Swift.String? = nil,
        networkInterfaceId: Swift.String? = nil,
        ownerId: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        vpcId: Swift.String? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.fileSystemId = fileSystemId
        self.ipAddress = ipAddress
        self.lifeCycleState = lifeCycleState
        self.mountTargetId = mountTargetId
        self.networkInterfaceId = networkInterfaceId
        self.ownerId = ownerId
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

struct CreateMountTargetOutputBody: Swift.Equatable {
    let ownerId: Swift.String?
    let mountTargetId: Swift.String?
    let fileSystemId: Swift.String?
    let subnetId: Swift.String?
    let lifeCycleState: EFSClientTypes.LifeCycleState?
    let ipAddress: Swift.String?
    let networkInterfaceId: Swift.String?
    let availabilityZoneId: Swift.String?
    let availabilityZoneName: Swift.String?
    let vpcId: Swift.String?
}

extension CreateMountTargetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

enum CreateMountTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AvailabilityZonesMismatch": return try await AvailabilityZonesMismatch(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IpAddressInUse": return try await IpAddressInUse(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MountTargetConflict": return try await MountTargetConflict(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NetworkInterfaceLimitExceeded": return try await NetworkInterfaceLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoFreeAddressesInSubnet": return try await NoFreeAddressesInSubnet(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SecurityGroupLimitExceeded": return try await SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SecurityGroupNotFound": return try await SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SubnetNotFound": return try await SubnetNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedAvailabilityZone": return try await UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destinationtocreate0 in destinations {
                try destinationsContainer.encode(destinationtocreate0)
            }
        }
    }
}

extension CreateReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceFileSystemId = sourceFileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(sourceFileSystemId.urlPercentEncoding())/replication-configuration"
    }
}

public struct CreateReplicationConfigurationInput: Swift.Equatable {
    /// An array of destination configuration objects. Only one destination configuration object is supported.
    /// This member is required.
    public var destinations: [EFSClientTypes.DestinationToCreate]?
    /// Specifies the Amazon EFS file system that you want to replicate. This file system cannot already be a source or destination file system in another replication configuration.
    /// This member is required.
    public var sourceFileSystemId: Swift.String?

    public init(
        destinations: [EFSClientTypes.DestinationToCreate]? = nil,
        sourceFileSystemId: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.sourceFileSystemId = sourceFileSystemId
    }
}

struct CreateReplicationConfigurationInputBody: Swift.Equatable {
    let destinations: [EFSClientTypes.DestinationToCreate]?
}

extension CreateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "Destinations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([EFSClientTypes.DestinationToCreate?].self, forKey: .destinations)
        var destinationsDecoded0:[EFSClientTypes.DestinationToCreate]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [EFSClientTypes.DestinationToCreate]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension CreateReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destinations = output.destinations
            self.originalSourceFileSystemArn = output.originalSourceFileSystemArn
            self.sourceFileSystemArn = output.sourceFileSystemArn
            self.sourceFileSystemId = output.sourceFileSystemId
            self.sourceFileSystemRegion = output.sourceFileSystemRegion
        } else {
            self.creationTime = nil
            self.destinations = nil
            self.originalSourceFileSystemArn = nil
            self.sourceFileSystemArn = nil
            self.sourceFileSystemId = nil
            self.sourceFileSystemRegion = nil
        }
    }
}

/// Describes the replication configuration for a specific file system.
public struct CreateReplicationConfigurationOutput: Swift.Equatable {
    /// Describes when the replication configuration was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// An array of destination objects. Only one destination object is supported.
    /// This member is required.
    public var destinations: [EFSClientTypes.Destination]?
    /// The Amazon Resource Name (ARN) of the original source Amazon EFS file system in the replication configuration.
    /// This member is required.
    public var originalSourceFileSystemArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the current source file system in the replication configuration.
    /// This member is required.
    public var sourceFileSystemArn: Swift.String?
    /// The ID of the source Amazon EFS file system that is being replicated.
    /// This member is required.
    public var sourceFileSystemId: Swift.String?
    /// The Amazon Web Services Region in which the source Amazon EFS file system is located.
    /// This member is required.
    public var sourceFileSystemRegion: Swift.String?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        destinations: [EFSClientTypes.Destination]? = nil,
        originalSourceFileSystemArn: Swift.String? = nil,
        sourceFileSystemArn: Swift.String? = nil,
        sourceFileSystemId: Swift.String? = nil,
        sourceFileSystemRegion: Swift.String? = nil
    )
    {
        self.creationTime = creationTime
        self.destinations = destinations
        self.originalSourceFileSystemArn = originalSourceFileSystemArn
        self.sourceFileSystemArn = sourceFileSystemArn
        self.sourceFileSystemId = sourceFileSystemId
        self.sourceFileSystemRegion = sourceFileSystemRegion
    }
}

struct CreateReplicationConfigurationOutputBody: Swift.Equatable {
    let sourceFileSystemId: Swift.String?
    let sourceFileSystemRegion: Swift.String?
    let sourceFileSystemArn: Swift.String?
    let originalSourceFileSystemArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let destinations: [EFSClientTypes.Destination]?
}

extension CreateReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destinations = "Destinations"
        case originalSourceFileSystemArn = "OriginalSourceFileSystemArn"
        case sourceFileSystemArn = "SourceFileSystemArn"
        case sourceFileSystemId = "SourceFileSystemId"
        case sourceFileSystemRegion = "SourceFileSystemRegion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemId)
        sourceFileSystemId = sourceFileSystemIdDecoded
        let sourceFileSystemRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemRegion)
        sourceFileSystemRegion = sourceFileSystemRegionDecoded
        let sourceFileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemArn)
        sourceFileSystemArn = sourceFileSystemArnDecoded
        let originalSourceFileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalSourceFileSystemArn)
        originalSourceFileSystemArn = originalSourceFileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[EFSClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [EFSClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

enum CreateReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemLimitExceeded": return try await FileSystemLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientThroughputCapacity": return try await InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationNotFound": return try await ReplicationNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThroughputLimitExceeded": return try await ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedAvailabilityZone": return try await UnsupportedAvailabilityZone(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/create-tags/\(fileSystemId.urlPercentEncoding())"
    }
}

///
public struct CreateTagsInput: Swift.Equatable {
    /// The ID of the file system whose tags you want to modify (String). This operation modifies the tags only, not the file system.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// An array of Tag objects to add. Each Tag object is a key-value pair.
    /// This member is required.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        fileSystemId: Swift.String? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tags = tags
    }
}

struct CreateTagsInputBody: Swift.Equatable {
    let tags: [EFSClientTypes.Tag]?
}

extension CreateTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateTagsOutput: Swift.Equatable {

    public init() { }
}

enum CreateTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EFSClientTypes.CreationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ownerGid = "OwnerGid"
        case ownerUid = "OwnerUid"
        case permissions = "Permissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ownerGid = self.ownerGid {
            try encodeContainer.encode(ownerGid, forKey: .ownerGid)
        }
        if let ownerUid = self.ownerUid {
            try encodeContainer.encode(ownerUid, forKey: .ownerUid)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerUidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerUid)
        ownerUid = ownerUidDecoded
        let ownerGidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ownerGid)
        ownerGid = ownerGidDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension EFSClientTypes {
    /// Required if the RootDirectory > Path specified does not exist. Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory > Path. If the access point root directory does not exist, EFS creates it with these settings when a client connects to the access point. When specifying CreationInfo, you must include values for all properties. Amazon EFS creates a root directory only if you have provided the CreationInfo: OwnUid, OwnGID, and permissions for the directory. If you do not provide this information, Amazon EFS does not create the root directory. If the root directory does not exist, attempts to mount using the access point will fail. If you do not provide CreationInfo and the specified RootDirectory does not exist, attempts to mount the file system using the access point will fail.
    public struct CreationInfo: Swift.Equatable {
        /// Specifies the POSIX group ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        /// This member is required.
        public var ownerGid: Swift.Int?
        /// Specifies the POSIX user ID to apply to the RootDirectory. Accepts values from 0 to 2^32 (4294967295).
        /// This member is required.
        public var ownerUid: Swift.Int?
        /// Specifies the POSIX permissions to apply to the RootDirectory, in the format of an octal number representing the file's mode bits.
        /// This member is required.
        public var permissions: Swift.String?

        public init(
            ownerGid: Swift.Int? = nil,
            ownerUid: Swift.Int? = nil,
            permissions: Swift.String? = nil
        )
        {
            self.ownerGid = ownerGid
            self.ownerUid = ownerUid
            self.permissions = permissions
        }
    }

}

extension DeleteAccessPointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPointId = accessPointId else {
            return nil
        }
        return "/2015-02-01/access-points/\(accessPointId.urlPercentEncoding())"
    }
}

public struct DeleteAccessPointInput: Swift.Equatable {
    /// The ID of the access point that you want to delete.
    /// This member is required.
    public var accessPointId: Swift.String?

    public init(
        accessPointId: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
    }
}

struct DeleteAccessPointInputBody: Swift.Equatable {
}

extension DeleteAccessPointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPointOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFileSystemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())"
    }
}

///
public struct DeleteFileSystemInput: Swift.Equatable {
    /// The ID of the file system you want to delete.
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemInputBody: Swift.Equatable {
}

extension DeleteFileSystemInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFileSystemOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFileSystemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemInUse": return try await FileSystemInUse(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFileSystemPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/policy"
    }
}

public struct DeleteFileSystemPolicyInput: Swift.Equatable {
    /// Specifies the EFS file system for which to delete the FileSystemPolicy.
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DeleteFileSystemPolicyInputBody: Swift.Equatable {
}

extension DeleteFileSystemPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFileSystemPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFileSystemPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFileSystemPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMountTargetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mountTargetId = mountTargetId else {
            return nil
        }
        return "/2015-02-01/mount-targets/\(mountTargetId.urlPercentEncoding())"
    }
}

///
public struct DeleteMountTargetInput: Swift.Equatable {
    /// The ID of the mount target to delete (String).
    /// This member is required.
    public var mountTargetId: Swift.String?

    public init(
        mountTargetId: Swift.String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DeleteMountTargetInputBody: Swift.Equatable {
}

extension DeleteMountTargetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMountTargetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMountTargetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMountTargetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyTimeout": return try await DependencyTimeout(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MountTargetNotFound": return try await MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sourceFileSystemId = sourceFileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(sourceFileSystemId.urlPercentEncoding())/replication-configuration"
    }
}

public struct DeleteReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the source file system in the replication configuration.
    /// This member is required.
    public var sourceFileSystemId: Swift.String?

    public init(
        sourceFileSystemId: Swift.String? = nil
    )
    {
        self.sourceFileSystemId = sourceFileSystemId
    }
}

struct DeleteReplicationConfigurationInputBody: Swift.Equatable {
}

extension DeleteReplicationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReplicationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationNotFound": return try await ReplicationNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension DeleteTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/delete-tags/\(fileSystemId.urlPercentEncoding())"
    }
}

///
public struct DeleteTagsInput: Swift.Equatable {
    /// The ID of the file system whose tags you want to delete (String).
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// A list of tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        fileSystemId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.tagKeys = tagKeys
    }
}

struct DeleteTagsInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension DeleteTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension DeleteTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTagsOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DependencyTimeout {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyTimeoutBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service timed out trying to fulfill the request, and the client should try the call again.
public struct DependencyTimeout: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyTimeout" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct DependencyTimeoutBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension DependencyTimeoutBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DescribeAccessPointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let accessPointId = accessPointId {
                let accessPointIdQueryItem = ClientRuntime.URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: Swift.String(accessPointId).urlPercentEncoding())
                items.append(accessPointIdQueryItem)
            }
            if let fileSystemId = fileSystemId {
                let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
                items.append(fileSystemIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeAccessPointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/access-points"
    }
}

public struct DescribeAccessPointsInput: Swift.Equatable {
    /// (Optional) Specifies an EFS access point to describe in the response; mutually exclusive with FileSystemId.
    public var accessPointId: Swift.String?
    /// (Optional) If you provide a FileSystemId, EFS returns all access points for that file system; mutually exclusive with AccessPointId.
    public var fileSystemId: Swift.String?
    /// (Optional) When retrieving all access points for a file system, you can optionally specify the MaxItems parameter to limit the number of objects returned in a response. The default value is 100.
    public var maxResults: Swift.Int?
    /// NextToken is present if the response is paginated. You can use NextMarker in the subsequent request to fetch the next page of access point descriptions.
    public var nextToken: Swift.String?

    public init(
        accessPointId: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsInputBody: Swift.Equatable {
}

extension DescribeAccessPointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccessPointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPoints = output.accessPoints
            self.nextToken = output.nextToken
        } else {
            self.accessPoints = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAccessPointsOutput: Swift.Equatable {
    /// An array of access point descriptions.
    public var accessPoints: [EFSClientTypes.AccessPointDescription]?
    /// Present if there are more access points than returned in the response. You can use the NextMarker in the subsequent request to fetch the additional descriptions.
    public var nextToken: Swift.String?

    public init(
        accessPoints: [EFSClientTypes.AccessPointDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPoints = accessPoints
        self.nextToken = nextToken
    }
}

struct DescribeAccessPointsOutputBody: Swift.Equatable {
    let accessPoints: [EFSClientTypes.AccessPointDescription]?
    let nextToken: Swift.String?
}

extension DescribeAccessPointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints = "AccessPoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointsContainer = try containerValues.decodeIfPresent([EFSClientTypes.AccessPointDescription?].self, forKey: .accessPoints)
        var accessPointsDecoded0:[EFSClientTypes.AccessPointDescription]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [EFSClientTypes.AccessPointDescription]()
            for structure0 in accessPointsContainer {
                if let structure0 = structure0 {
                    accessPointsDecoded0?.append(structure0)
                }
            }
        }
        accessPoints = accessPointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccessPointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAccountPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/account-preferences"
    }
}

public struct DescribeAccountPreferencesInput: Swift.Equatable {
    /// (Optional) When retrieving account preferences, you can optionally specify the MaxItems parameter to limit the number of objects returned in a response. The default value is 100.
    public var maxResults: Swift.Int?
    /// (Optional) You can use NextToken in a subsequent request to fetch the next page of Amazon Web Services account preferences if the response payload was paginated.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAccountPreferencesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAccountPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAccountPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.nextToken = nil
            self.resourceIdPreference = nil
        }
    }
}

public struct DescribeAccountPreferencesOutput: Swift.Equatable {
    /// Present if there are more records than returned in the response. You can use the NextToken in the subsequent request to fetch the additional descriptions.
    public var nextToken: Swift.String?
    /// Describes the resource ID preference setting for the Amazon Web Services account associated with the user making the request, in the current Amazon Web Services Region.
    public var resourceIdPreference: EFSClientTypes.ResourceIdPreference?

    public init(
        nextToken: Swift.String? = nil,
        resourceIdPreference: EFSClientTypes.ResourceIdPreference? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdPreference = resourceIdPreference
    }
}

struct DescribeAccountPreferencesOutputBody: Swift.Equatable {
    let resourceIdPreference: EFSClientTypes.ResourceIdPreference?
    let nextToken: Swift.String?
}

extension DescribeAccountPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAccountPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBackupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/backup-policy"
    }
}

public struct DescribeBackupPolicyInput: Swift.Equatable {
    /// Specifies which EFS file system to retrieve the BackupPolicy for.
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeBackupPolicyInputBody: Swift.Equatable {
}

extension DescribeBackupPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBackupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBackupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct DescribeBackupPolicyOutput: Swift.Equatable {
    /// Describes the file system's backup policy, indicating whether automatic backups are turned on or off.
    public var backupPolicy: EFSClientTypes.BackupPolicy?

    public init(
        backupPolicy: EFSClientTypes.BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct DescribeBackupPolicyOutputBody: Swift.Equatable {
    let backupPolicy: EFSClientTypes.BackupPolicy?
}

extension DescribeBackupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EFSClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

enum DescribeBackupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFound": return try await PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFileSystemPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/policy"
    }
}

public struct DescribeFileSystemPolicyInput: Swift.Equatable {
    /// Specifies which EFS file system to retrieve the FileSystemPolicy for.
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeFileSystemPolicyInputBody: Swift.Equatable {
}

extension DescribeFileSystemPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFileSystemPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFileSystemPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct DescribeFileSystemPolicyOutput: Swift.Equatable {
    /// Specifies the EFS file system to which the FileSystemPolicy applies.
    public var fileSystemId: Swift.String?
    /// The JSON formatted FileSystemPolicy for the EFS file system.
    public var policy: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct DescribeFileSystemPolicyOutputBody: Swift.Equatable {
    let fileSystemId: Swift.String?
    let policy: Swift.String?
}

extension DescribeFileSystemPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DescribeFileSystemPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PolicyNotFound": return try await PolicyNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeFileSystemsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let creationToken = creationToken {
                let creationTokenQueryItem = ClientRuntime.URLQueryItem(name: "CreationToken".urlPercentEncoding(), value: Swift.String(creationToken).urlPercentEncoding())
                items.append(creationTokenQueryItem)
            }
            if let fileSystemId = fileSystemId {
                let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
                items.append(fileSystemIdQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeFileSystemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/file-systems"
    }
}

///
public struct DescribeFileSystemsInput: Swift.Equatable {
    /// (Optional) Restricts the list to the file system with this creation token (String). You specify a creation token when you create an Amazon EFS file system.
    public var creationToken: Swift.String?
    /// (Optional) ID of the file system whose description you want to retrieve (String).
    public var fileSystemId: Swift.String?
    /// (Optional) Opaque pagination token returned from a previous DescribeFileSystems operation (String). If present, specifies to continue the list from where the returning call had left off.
    public var marker: Swift.String?
    /// (Optional) Specifies the maximum number of file systems to return in the response (integer). This number is automatically set to 100. The response is paginated at 100 per page if you have more than 100 file systems.
    public var maxItems: Swift.Int?

    public init(
        creationToken: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.creationToken = creationToken
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeFileSystemsInputBody: Swift.Equatable {
}

extension DescribeFileSystemsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFileSystemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeFileSystemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.fileSystems = output.fileSystems
            self.marker = output.marker
            self.nextMarker = output.nextMarker
        } else {
            self.fileSystems = nil
            self.marker = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeFileSystemsOutput: Swift.Equatable {
    /// An array of file system descriptions.
    public var fileSystems: [EFSClientTypes.FileSystemDescription]?
    /// Present if provided by caller in the request (String).
    public var marker: Swift.String?
    /// Present if there are more file systems than returned in the response (String). You can use the NextMarker in the subsequent request to fetch the descriptions.
    public var nextMarker: Swift.String?

    public init(
        fileSystems: [EFSClientTypes.FileSystemDescription]? = nil,
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.fileSystems = fileSystems
        self.marker = marker
        self.nextMarker = nextMarker
    }
}

struct DescribeFileSystemsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let fileSystems: [EFSClientTypes.FileSystemDescription]?
    let nextMarker: Swift.String?
}

extension DescribeFileSystemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystems = "FileSystems"
        case marker = "Marker"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let fileSystemsContainer = try containerValues.decodeIfPresent([EFSClientTypes.FileSystemDescription?].self, forKey: .fileSystems)
        var fileSystemsDecoded0:[EFSClientTypes.FileSystemDescription]? = nil
        if let fileSystemsContainer = fileSystemsContainer {
            fileSystemsDecoded0 = [EFSClientTypes.FileSystemDescription]()
            for structure0 in fileSystemsContainer {
                if let structure0 = structure0 {
                    fileSystemsDecoded0?.append(structure0)
                }
            }
        }
        fileSystems = fileSystemsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum DescribeFileSystemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/lifecycle-configuration"
    }
}

public struct DescribeLifecycleConfigurationInput: Swift.Equatable {
    /// The ID of the file system whose LifecycleConfiguration object you want to retrieve (String).
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
    }
}

struct DescribeLifecycleConfigurationInputBody: Swift.Equatable {
}

extension DescribeLifecycleConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLifecycleConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct DescribeLifecycleConfigurationOutput: Swift.Equatable {
    /// An array of lifecycle management policies. EFS supports a maximum of one policy per file system.
    public var lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?

    public init(
        lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct DescribeLifecycleConfigurationOutputBody: Swift.Equatable {
    let lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?
}

extension DescribeLifecycleConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EFSClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EFSClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EFSClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

enum DescribeLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMountTargetSecurityGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mountTargetId = mountTargetId else {
            return nil
        }
        return "/2015-02-01/mount-targets/\(mountTargetId.urlPercentEncoding())/security-groups"
    }
}

///
public struct DescribeMountTargetSecurityGroupsInput: Swift.Equatable {
    /// The ID of the mount target whose security groups you want to retrieve.
    /// This member is required.
    public var mountTargetId: Swift.String?

    public init(
        mountTargetId: Swift.String? = nil
    )
    {
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetSecurityGroupsInputBody: Swift.Equatable {
}

extension DescribeMountTargetSecurityGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMountTargetSecurityGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMountTargetSecurityGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.securityGroups = output.securityGroups
        } else {
            self.securityGroups = nil
        }
    }
}

public struct DescribeMountTargetSecurityGroupsOutput: Swift.Equatable {
    /// An array of security groups.
    /// This member is required.
    public var securityGroups: [Swift.String]?

    public init(
        securityGroups: [Swift.String]? = nil
    )
    {
        self.securityGroups = securityGroups
    }
}

struct DescribeMountTargetSecurityGroupsOutputBody: Swift.Equatable {
    let securityGroups: [Swift.String]?
}

extension DescribeMountTargetSecurityGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

enum DescribeMountTargetSecurityGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectMountTargetState": return try await IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MountTargetNotFound": return try await MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMountTargetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let accessPointId = accessPointId {
                let accessPointIdQueryItem = ClientRuntime.URLQueryItem(name: "AccessPointId".urlPercentEncoding(), value: Swift.String(accessPointId).urlPercentEncoding())
                items.append(accessPointIdQueryItem)
            }
            if let fileSystemId = fileSystemId {
                let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
                items.append(fileSystemIdQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            if let mountTargetId = mountTargetId {
                let mountTargetIdQueryItem = ClientRuntime.URLQueryItem(name: "MountTargetId".urlPercentEncoding(), value: Swift.String(mountTargetId).urlPercentEncoding())
                items.append(mountTargetIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeMountTargetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/mount-targets"
    }
}

///
public struct DescribeMountTargetsInput: Swift.Equatable {
    /// (Optional) The ID of the access point whose mount targets that you want to list. It must be included in your request if a FileSystemId or MountTargetId is not included in your request. Accepts either an access point ID or ARN as input.
    public var accessPointId: Swift.String?
    /// (Optional) ID of the file system whose mount targets you want to list (String). It must be included in your request if an AccessPointId or MountTargetId is not included. Accepts either a file system ID or ARN as input.
    public var fileSystemId: Swift.String?
    /// (Optional) Opaque pagination token returned from a previous DescribeMountTargets operation (String). If present, it specifies to continue the list from where the previous returning call left off.
    public var marker: Swift.String?
    /// (Optional) Maximum number of mount targets to return in the response. Currently, this number is automatically set to 10, and other values are ignored. The response is paginated at 100 per page if you have more than 100 mount targets.
    public var maxItems: Swift.Int?
    /// (Optional) ID of the mount target that you want to have described (String). It must be included in your request if FileSystemId is not included. Accepts either a mount target ID or ARN as input.
    public var mountTargetId: Swift.String?

    public init(
        accessPointId: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        mountTargetId: Swift.String? = nil
    )
    {
        self.accessPointId = accessPointId
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
        self.mountTargetId = mountTargetId
    }
}

struct DescribeMountTargetsInputBody: Swift.Equatable {
}

extension DescribeMountTargetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeMountTargetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMountTargetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.mountTargets = output.mountTargets
            self.nextMarker = output.nextMarker
        } else {
            self.marker = nil
            self.mountTargets = nil
            self.nextMarker = nil
        }
    }
}

///
public struct DescribeMountTargetsOutput: Swift.Equatable {
    /// If the request included the Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// Returns the file system's mount targets as an array of MountTargetDescription objects.
    public var mountTargets: [EFSClientTypes.MountTargetDescription]?
    /// If a value is present, there are more mount targets to return. In a subsequent request, you can provide Marker in your request with this value to retrieve the next set of mount targets.
    public var nextMarker: Swift.String?

    public init(
        marker: Swift.String? = nil,
        mountTargets: [EFSClientTypes.MountTargetDescription]? = nil,
        nextMarker: Swift.String? = nil
    )
    {
        self.marker = marker
        self.mountTargets = mountTargets
        self.nextMarker = nextMarker
    }
}

struct DescribeMountTargetsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let mountTargets: [EFSClientTypes.MountTargetDescription]?
    let nextMarker: Swift.String?
}

extension DescribeMountTargetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case mountTargets = "MountTargets"
        case nextMarker = "NextMarker"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let mountTargetsContainer = try containerValues.decodeIfPresent([EFSClientTypes.MountTargetDescription?].self, forKey: .mountTargets)
        var mountTargetsDecoded0:[EFSClientTypes.MountTargetDescription]? = nil
        if let mountTargetsContainer = mountTargetsContainer {
            mountTargetsDecoded0 = [EFSClientTypes.MountTargetDescription]()
            for structure0 in mountTargetsContainer {
                if let structure0 = structure0 {
                    mountTargetsDecoded0?.append(structure0)
                }
            }
        }
        mountTargets = mountTargetsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum DescribeMountTargetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MountTargetNotFound": return try await MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeReplicationConfigurationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let fileSystemId = fileSystemId {
                let fileSystemIdQueryItem = ClientRuntime.URLQueryItem(name: "FileSystemId".urlPercentEncoding(), value: Swift.String(fileSystemId).urlPercentEncoding())
                items.append(fileSystemIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeReplicationConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/file-systems/replication-configurations"
    }
}

public struct DescribeReplicationConfigurationsInput: Swift.Equatable {
    /// You can retrieve the replication configuration for a specific file system by providing its file system ID.
    public var fileSystemId: Swift.String?
    /// (Optional) To limit the number of objects returned in a response, you can specify the MaxItems parameter. The default value is 100.
    public var maxResults: Swift.Int?
    /// NextToken is present if the response is paginated. You can use NextToken in a subsequent request to fetch the next page of output.
    public var nextToken: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationsInputBody: Swift.Equatable {
}

extension DescribeReplicationConfigurationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReplicationConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replications = output.replications
        } else {
            self.nextToken = nil
            self.replications = nil
        }
    }
}

public struct DescribeReplicationConfigurationsOutput: Swift.Equatable {
    /// You can use the NextToken from the previous response in a subsequent request to fetch the additional descriptions.
    public var nextToken: Swift.String?
    /// The collection of replication configurations that is returned.
    public var replications: [EFSClientTypes.ReplicationConfigurationDescription]?

    public init(
        nextToken: Swift.String? = nil,
        replications: [EFSClientTypes.ReplicationConfigurationDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.replications = replications
    }
}

struct DescribeReplicationConfigurationsOutputBody: Swift.Equatable {
    let replications: [EFSClientTypes.ReplicationConfigurationDescription]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case replications = "Replications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationsContainer = try containerValues.decodeIfPresent([EFSClientTypes.ReplicationConfigurationDescription?].self, forKey: .replications)
        var replicationsDecoded0:[EFSClientTypes.ReplicationConfigurationDescription]? = nil
        if let replicationsContainer = replicationsContainer {
            replicationsDecoded0 = [EFSClientTypes.ReplicationConfigurationDescription]()
            for structure0 in replicationsContainer {
                if let structure0 = structure0 {
                    replicationsDecoded0?.append(structure0)
                }
            }
        }
        replications = replicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeReplicationConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationNotFound": return try await ReplicationNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTagsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let marker = marker {
                let markerQueryItem = ClientRuntime.URLQueryItem(name: "Marker".urlPercentEncoding(), value: Swift.String(marker).urlPercentEncoding())
                items.append(markerQueryItem)
            }
            return items
        }
    }
}

extension DescribeTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/tags/\(fileSystemId.urlPercentEncoding())"
    }
}

///
public struct DescribeTagsInput: Swift.Equatable {
    /// The ID of the file system whose tag set you want to retrieve.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// (Optional) An opaque pagination token returned from a previous DescribeTags operation (String). If present, it specifies to continue the list from where the previous call left off.
    public var marker: Swift.String?
    /// (Optional) The maximum number of file system tags to return in the response. Currently, this number is automatically set to 100, and other values are ignored. The response is paginated at 100 per page if you have more than 100 tags.
    public var maxItems: Swift.Int?

    public init(
        fileSystemId: Swift.String? = nil,
        marker: Swift.String? = nil,
        maxItems: Swift.Int? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct DescribeTagsInputBody: Swift.Equatable {
}

extension DescribeTagsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.marker = output.marker
            self.nextMarker = output.nextMarker
            self.tags = output.tags
        } else {
            self.marker = nil
            self.nextMarker = nil
            self.tags = nil
        }
    }
}

///
public struct DescribeTagsOutput: Swift.Equatable {
    /// If the request included a Marker, the response returns that value in this field.
    public var marker: Swift.String?
    /// If a value is present, there are more tags to return. In a subsequent request, you can provide the value of NextMarker as the value of the Marker parameter in your next request to retrieve the next set of tags.
    public var nextMarker: Swift.String?
    /// Returns tags associated with the file system as an array of Tag objects.
    /// This member is required.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        marker: Swift.String? = nil,
        nextMarker: Swift.String? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.marker = marker
        self.nextMarker = nextMarker
        self.tags = tags
    }
}

struct DescribeTagsOutputBody: Swift.Equatable {
    let marker: Swift.String?
    let tags: [EFSClientTypes.Tag]?
    let nextMarker: Swift.String?
}

extension DescribeTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case marker = "Marker"
        case nextMarker = "NextMarker"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let markerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .marker)
        marker = markerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

enum DescribeTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EFSClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case lastReplicatedTimestamp = "LastReplicatedTimestamp"
        case region = "Region"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let lastReplicatedTimestamp = self.lastReplicatedTimestamp {
            try encodeContainer.encodeTimestamp(lastReplicatedTimestamp, format: .epochSeconds, forKey: .lastReplicatedTimestamp)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ReplicationStatus.self, forKey: .status)
        status = statusDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let lastReplicatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastReplicatedTimestamp)
        lastReplicatedTimestamp = lastReplicatedTimestampDecoded
    }
}

extension EFSClientTypes {
    /// Describes the destination file system in the replication configuration.
    public struct Destination: Swift.Equatable {
        /// The ID of the destination Amazon EFS file system.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The time when the most recent sync was successfully completed on the destination file system. Any changes to data on the source file system that occurred before this time have been successfully replicated to the destination file system. Any changes that occurred after this time might not be fully replicated.
        public var lastReplicatedTimestamp: ClientRuntime.Date?
        /// The Amazon Web Services Region in which the destination file system is located.
        /// This member is required.
        public var region: Swift.String?
        /// Describes the status of the destination Amazon EFS file system.
        ///
        /// * The Paused state occurs as a result of opting out of the source or destination Region after the replication configuration was created. To resume replication for the file system, you need to again opt in to the Amazon Web Services Region. For more information, see [Managing Amazon Web Services Regions](https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable) in the Amazon Web Services General Reference Guide.
        ///
        /// * The Error state occurs when either the source or the destination file system (or both) is in a failed state and is unrecoverable. For more information, see [Monitoring replication status](https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#restoring-backup-efsmonitoring-replication-status.html) in the Amazon EFS User Guide. You must delete the replication configuration, and then restore the most recent backup of the failed file system (either the source or the destination) to a new file system.
        /// This member is required.
        public var status: EFSClientTypes.ReplicationStatus?

        public init(
            fileSystemId: Swift.String? = nil,
            lastReplicatedTimestamp: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            status: EFSClientTypes.ReplicationStatus? = nil
        )
        {
            self.fileSystemId = fileSystemId
            self.lastReplicatedTimestamp = lastReplicatedTimestamp
            self.region = region
            self.status = status
        }
    }

}

extension EFSClientTypes.DestinationToCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneName = "AvailabilityZoneName"
        case kmsKeyId = "KmsKeyId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneName = self.availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension EFSClientTypes {
    /// Describes the destination file system to create in the replication configuration.
    public struct DestinationToCreate: Swift.Equatable {
        /// To create a file system that uses EFS One Zone storage, specify the name of the Availability Zone in which to create the destination file system.
        public var availabilityZoneName: Swift.String?
        /// Specifies the Key Management Service (KMS) key that you want to use to encrypt the destination file system. If you do not specify a KMS key, Amazon EFS uses your default KMS key for Amazon EFS, /aws/elasticfilesystem. This ID can be in one of the following formats:
        ///
        /// * Key ID - The unique identifier of the key, for example 1234abcd-12ab-34cd-56ef-1234567890ab.
        ///
        /// * ARN - The Amazon Resource Name (ARN) for the key, for example arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab.
        ///
        /// * Key alias - A previously created display name for a key, for example alias/projectKey1.
        ///
        /// * Key alias ARN - The ARN for a key alias, for example arn:aws:kms:us-west-2:444455556666:alias/projectKey1.
        public var kmsKeyId: Swift.String?
        /// To create a file system that uses Regional storage, specify the Amazon Web Services Region in which to create the destination file system.
        public var region: Swift.String?

        public init(
            availabilityZoneName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.availabilityZoneName = availabilityZoneName
            self.kmsKeyId = kmsKeyId
            self.region = region
        }
    }

}

extension FileSystemAlreadyExists {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileSystemAlreadyExistsBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.fileSystemId = output.fileSystemId
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.fileSystemId = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the file system you are trying to create already exists, with the creation token you provided.
public struct FileSystemAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// This member is required.
        public internal(set) var fileSystemId: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileSystemAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.fileSystemId = fileSystemId
        self.properties.message = message
    }
}

struct FileSystemAlreadyExistsBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let fileSystemId: Swift.String?
}

extension FileSystemAlreadyExistsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case fileSystemId = "FileSystemId"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
    }
}

extension EFSClientTypes.FileSystemDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = self.availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let creationToken = self.creationToken {
            try encodeContainer.encode(creationToken, forKey: .creationToken)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let fileSystemArn = self.fileSystemArn {
            try encodeContainer.encode(fileSystemArn, forKey: .fileSystemArn)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lifeCycleState = self.lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfMountTargets != 0 {
            try encodeContainer.encode(numberOfMountTargets, forKey: .numberOfMountTargets)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let performanceMode = self.performanceMode {
            try encodeContainer.encode(performanceMode.rawValue, forKey: .performanceMode)
        }
        if let provisionedThroughputInMibps = self.provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let sizeInBytes = self.sizeInBytes {
            try encodeContainer.encode(sizeInBytes, forKey: .sizeInBytes)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMountTargets) ?? 0
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EFSClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EFSClientTypes {
    /// A description of the file system.
    public struct FileSystemDescription: Swift.Equatable {
        /// The unique and consistent identifier of the Availability Zone in which the file system's One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID for the us-east-1 Amazon Web Services Region, and it has the same location in every Amazon Web Services account.
        public var availabilityZoneId: Swift.String?
        /// Describes the Amazon Web Services Availability Zone in which the file system is located, and is valid only for file systems using One Zone storage classes. For more information, see [Using EFS storage classes](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the Amazon EFS User Guide.
        public var availabilityZoneName: Swift.String?
        /// The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z).
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The opaque string specified in the request.
        /// This member is required.
        public var creationToken: Swift.String?
        /// A Boolean value that, if true, indicates that the file system is encrypted.
        public var encrypted: Swift.Bool?
        /// The Amazon Resource Name (ARN) for the EFS file system, in the format arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id . Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
        public var fileSystemArn: Swift.String?
        /// The ID of the file system, assigned by Amazon EFS.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// The ID of an KMS key used to protect the encrypted file system.
        public var kmsKeyId: Swift.String?
        /// The lifecycle phase of the file system.
        /// This member is required.
        public var lifeCycleState: EFSClientTypes.LifeCycleState?
        /// You can add tags to a file system, including a Name tag. For more information, see [CreateFileSystem]. If the file system has a Name tag, Amazon EFS returns the value in this field.
        public var name: Swift.String?
        /// The current number of mount targets that the file system has. For more information, see [CreateMountTarget].
        /// This member is required.
        public var numberOfMountTargets: Swift.Int
        /// The Amazon Web Services account that created the file system.
        /// This member is required.
        public var ownerId: Swift.String?
        /// The performance mode of the file system.
        /// This member is required.
        public var performanceMode: EFSClientTypes.PerformanceMode?
        /// The amount of provisioned throughput, measured in MiBps, for the file system. Valid for file systems using ThroughputMode set to provisioned.
        public var provisionedThroughputInMibps: Swift.Double?
        /// The latest known metered size (in bytes) of data stored in the file system, in its Value field, and the time at which that size was determined in its Timestamp field. The Timestamp value is the integer number of seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent the size of a consistent snapshot of the file system, but it is eventually consistent when there are no writes to the file system. That is, SizeInBytes represents actual size only if the file system is not modified for a period longer than a couple of hours. Otherwise, the value is not the exact size that the file system was at any point in time.
        /// This member is required.
        public var sizeInBytes: EFSClientTypes.FileSystemSize?
        /// The tags associated with the file system, presented as an array of Tag objects.
        /// This member is required.
        public var tags: [EFSClientTypes.Tag]?
        /// Displays the file system's throughput mode. For more information, see [Throughput modes](https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes) in the Amazon EFS User Guide.
        public var throughputMode: EFSClientTypes.ThroughputMode?

        public init(
            availabilityZoneId: Swift.String? = nil,
            availabilityZoneName: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            creationToken: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            fileSystemArn: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
            name: Swift.String? = nil,
            numberOfMountTargets: Swift.Int = 0,
            ownerId: Swift.String? = nil,
            performanceMode: EFSClientTypes.PerformanceMode? = nil,
            provisionedThroughputInMibps: Swift.Double? = nil,
            sizeInBytes: EFSClientTypes.FileSystemSize? = nil,
            tags: [EFSClientTypes.Tag]? = nil,
            throughputMode: EFSClientTypes.ThroughputMode? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.creationTime = creationTime
            self.creationToken = creationToken
            self.encrypted = encrypted
            self.fileSystemArn = fileSystemArn
            self.fileSystemId = fileSystemId
            self.kmsKeyId = kmsKeyId
            self.lifeCycleState = lifeCycleState
            self.name = name
            self.numberOfMountTargets = numberOfMountTargets
            self.ownerId = ownerId
            self.performanceMode = performanceMode
            self.provisionedThroughputInMibps = provisionedThroughputInMibps
            self.sizeInBytes = sizeInBytes
            self.tags = tags
            self.throughputMode = throughputMode
        }
    }

}

extension FileSystemInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileSystemInUseBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if a file system has mount targets.
public struct FileSystemInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileSystemInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct FileSystemInUseBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension FileSystemInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileSystemLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the Amazon Web Services account has already created the maximum number of file systems allowed per account.
public struct FileSystemLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileSystemLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct FileSystemLimitExceededBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension FileSystemLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FileSystemNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: FileSystemNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the specified FileSystemId value doesn't exist in the requester's Amazon Web Services account.
public struct FileSystemNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "FileSystemNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct FileSystemNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension FileSystemNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes.FileSystemSize: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case value = "Value"
        case valueInIA = "ValueInIA"
        case valueInStandard = "ValueInStandard"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let valueInIA = self.valueInIA {
            try encodeContainer.encode(valueInIA, forKey: .valueInIA)
        }
        if let valueInStandard = self.valueInStandard {
            try encodeContainer.encode(valueInStandard, forKey: .valueInStandard)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueInIADecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .valueInIA)
        valueInIA = valueInIADecoded
        let valueInStandardDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .valueInStandard)
        valueInStandard = valueInStandardDecoded
    }
}

extension EFSClientTypes {
    /// The latest known metered size (in bytes) of data stored in the file system, in its Value field, and the time at which that size was determined in its Timestamp field. The value doesn't represent the size of a consistent snapshot of the file system, but it is eventually consistent when there are no writes to the file system. That is, the value represents the actual size only if the file system is not modified for a period longer than a couple of hours. Otherwise, the value is not necessarily the exact size the file system was at any instant in time.
    public struct FileSystemSize: Swift.Equatable {
        /// The time at which the size of data, returned in the Value field, was determined. The value is the integer number of seconds since 1970-01-01T00:00:00Z.
        public var timestamp: ClientRuntime.Date?
        /// The latest known metered size (in bytes) of data stored in the file system.
        /// This member is required.
        public var value: Swift.Int
        /// The latest known metered size (in bytes) of data stored in the Infrequent Access storage class.
        public var valueInIA: Swift.Int?
        /// The latest known metered size (in bytes) of data stored in the Standard storage class.
        public var valueInStandard: Swift.Int?

        public init(
            timestamp: ClientRuntime.Date? = nil,
            value: Swift.Int = 0,
            valueInIA: Swift.Int? = nil,
            valueInStandard: Swift.Int? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
            self.valueInIA = valueInIA
            self.valueInStandard = valueInStandard
        }
    }

}

extension IncorrectFileSystemLifeCycleState {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncorrectFileSystemLifeCycleStateBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the file system's lifecycle state is not "available".
public struct IncorrectFileSystemLifeCycleState: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncorrectFileSystemLifeCycleState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct IncorrectFileSystemLifeCycleStateBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension IncorrectFileSystemLifeCycleStateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IncorrectMountTargetState {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IncorrectMountTargetStateBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the mount target is not in the correct state for the operation.
public struct IncorrectMountTargetState: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IncorrectMountTargetState" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct IncorrectMountTargetStateBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension IncorrectMountTargetStateBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientThroughputCapacity {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InsufficientThroughputCapacityBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if there's not enough capacity to provision additional throughput. This value might be returned when you try to create a file system in provisioned throughput mode, when you attempt to increase the provisioned throughput of an existing file system, or when you attempt to change an existing file system from Bursting Throughput to Provisioned Throughput mode. Try again later.
public struct InsufficientThroughputCapacity: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InsufficientThroughputCapacity" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InsufficientThroughputCapacityBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InsufficientThroughputCapacityBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if an error occurred on the server side.
public struct InternalServerError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InternalServerErrorBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPolicyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPolicyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the FileSystemPolicy is malformed or contains an error such as a parameter value that is not valid or a missing required parameter. Returned in the case of a policy lockout safety check error.
public struct InvalidPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPolicyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InvalidPolicyExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InvalidPolicyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IpAddressInUse {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: IpAddressInUseBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the request specified an IpAddress that is already in use in the subnet.
public struct IpAddressInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IpAddressInUse" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct IpAddressInUseBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension IpAddressInUseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case deleted
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .available,
                .creating,
                .deleted,
                .deleting,
                .error,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "available"
            case .creating: return "creating"
            case .deleted: return "deleted"
            case .deleting: return "deleting"
            case .error: return "error"
            case .updating: return "updating"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
        }
    }
}

extension EFSClientTypes.LifecyclePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transitionToIA = "TransitionToIA"
        case transitionToPrimaryStorageClass = "TransitionToPrimaryStorageClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitionToIA = self.transitionToIA {
            try encodeContainer.encode(transitionToIA.rawValue, forKey: .transitionToIA)
        }
        if let transitionToPrimaryStorageClass = self.transitionToPrimaryStorageClass {
            try encodeContainer.encode(transitionToPrimaryStorageClass.rawValue, forKey: .transitionToPrimaryStorageClass)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitionToIADecoded = try containerValues.decodeIfPresent(EFSClientTypes.TransitionToIARules.self, forKey: .transitionToIA)
        transitionToIA = transitionToIADecoded
        let transitionToPrimaryStorageClassDecoded = try containerValues.decodeIfPresent(EFSClientTypes.TransitionToPrimaryStorageClassRules.self, forKey: .transitionToPrimaryStorageClass)
        transitionToPrimaryStorageClass = transitionToPrimaryStorageClassDecoded
    }
}

extension EFSClientTypes {
    /// Describes a policy used by EFS lifecycle management and EFS Intelligent-Tiering that specifies when to transition files into and out of the file system's Infrequent Access (IA) storage class. For more information, see [EFS IntelligentTiering and EFS Lifecycle Management](https://docs.aws.amazon.com/efs/latest/ug/lifecycle-management-efs.html). When using the put-lifecycle-configuration CLI command or the PutLifecycleConfiguration API action, Amazon EFS requires that each LifecyclePolicy object have only a single transition. This means that in a request body, LifecyclePolicies must be structured as an array of LifecyclePolicy objects, one object for each transition, TransitionToIA, TransitionToPrimaryStorageClass. For more information, see the request examples in [PutLifecycleConfiguration].
    public struct LifecyclePolicy: Swift.Equatable {
        /// Describes the period of time that a file is not accessed, after which it transitions to IA storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        public var transitionToIA: EFSClientTypes.TransitionToIARules?
        /// Describes when to transition a file from IA storage to primary storage. Metadata operations such as listing the contents of a directory don't count as file access events.
        public var transitionToPrimaryStorageClass: EFSClientTypes.TransitionToPrimaryStorageClassRules?

        public init(
            transitionToIA: EFSClientTypes.TransitionToIARules? = nil,
            transitionToPrimaryStorageClass: EFSClientTypes.TransitionToPrimaryStorageClassRules? = nil
        )
        {
            self.transitionToIA = transitionToIA
            self.transitionToPrimaryStorageClass = transitionToPrimaryStorageClass
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/2015-02-01/resource-tags/\(resourceId.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// (Optional) Specifies the maximum number of tag objects to return in the response. The default value is 100.
    public var maxResults: Swift.Int?
    /// (Optional) You can use NextToken in a subsequent request to fetch the next page of access point descriptions if the response payload was paginated.
    public var nextToken: Swift.String?
    /// Specifies the EFS resource you want to retrieve tags for. You can retrieve tags for EFS file systems and access points using this API endpoint.
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// NextToken is present if the response payload is paginated. You can use NextToken in a subsequent request to fetch the next page of access point descriptions.
    public var nextToken: Swift.String?
    /// An array of the tags for the specified EFS resource.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [EFSClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ModifyMountTargetSecurityGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
    }
}

extension ModifyMountTargetSecurityGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let mountTargetId = mountTargetId else {
            return nil
        }
        return "/2015-02-01/mount-targets/\(mountTargetId.urlPercentEncoding())/security-groups"
    }
}

///
public struct ModifyMountTargetSecurityGroupsInput: Swift.Equatable {
    /// The ID of the mount target whose security groups you want to modify.
    /// This member is required.
    public var mountTargetId: Swift.String?
    /// An array of up to five VPC security group IDs.
    public var securityGroups: [Swift.String]?

    public init(
        mountTargetId: Swift.String? = nil,
        securityGroups: [Swift.String]? = nil
    )
    {
        self.mountTargetId = mountTargetId
        self.securityGroups = securityGroups
    }
}

struct ModifyMountTargetSecurityGroupsInputBody: Swift.Equatable {
    let securityGroups: [Swift.String]?
}

extension ModifyMountTargetSecurityGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension ModifyMountTargetSecurityGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ModifyMountTargetSecurityGroupsOutput: Swift.Equatable {

    public init() { }
}

enum ModifyMountTargetSecurityGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectMountTargetState": return try await IncorrectMountTargetState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MountTargetNotFound": return try await MountTargetNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SecurityGroupLimitExceeded": return try await SecurityGroupLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "SecurityGroupNotFound": return try await SecurityGroupNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MountTargetConflict {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MountTargetConflictBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the mount target would violate one of the specified restrictions based on the file system's existing mount targets.
public struct MountTargetConflict: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MountTargetConflict" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct MountTargetConflictBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension MountTargetConflictBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes.MountTargetDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case fileSystemId = "FileSystemId"
        case ipAddress = "IpAddress"
        case lifeCycleState = "LifeCycleState"
        case mountTargetId = "MountTargetId"
        case networkInterfaceId = "NetworkInterfaceId"
        case ownerId = "OwnerId"
        case subnetId = "SubnetId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZoneId = self.availabilityZoneId {
            try encodeContainer.encode(availabilityZoneId, forKey: .availabilityZoneId)
        }
        if let availabilityZoneName = self.availabilityZoneName {
            try encodeContainer.encode(availabilityZoneName, forKey: .availabilityZoneName)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let lifeCycleState = self.lifeCycleState {
            try encodeContainer.encode(lifeCycleState.rawValue, forKey: .lifeCycleState)
        }
        if let mountTargetId = self.mountTargetId {
            try encodeContainer.encode(mountTargetId, forKey: .mountTargetId)
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let ownerId = self.ownerId {
            try encodeContainer.encode(ownerId, forKey: .ownerId)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let mountTargetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountTargetId)
        mountTargetId = mountTargetIdDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension EFSClientTypes {
    /// Provides a description of a mount target.
    public struct MountTargetDescription: Swift.Equatable {
        /// The unique and consistent identifier of the Availability Zone that the mount target resides in. For example, use1-az1 is an AZ ID for the us-east-1 Region and it has the same location in every Amazon Web Services account.
        public var availabilityZoneId: Swift.String?
        /// The name of the Availability Zone in which the mount target is located. Availability Zones are independently mapped to names for each Amazon Web Services account. For example, the Availability Zone us-east-1a for your Amazon Web Services account might not be the same location as us-east-1a for another Amazon Web Services account.
        public var availabilityZoneName: Swift.String?
        /// The ID of the file system for which the mount target is intended.
        /// This member is required.
        public var fileSystemId: Swift.String?
        /// Address at which the file system can be mounted by using the mount target.
        public var ipAddress: Swift.String?
        /// Lifecycle state of the mount target.
        /// This member is required.
        public var lifeCycleState: EFSClientTypes.LifeCycleState?
        /// System-assigned mount target ID.
        /// This member is required.
        public var mountTargetId: Swift.String?
        /// The ID of the network interface that Amazon EFS created when it created the mount target.
        public var networkInterfaceId: Swift.String?
        /// Amazon Web Services account ID that owns the resource.
        public var ownerId: Swift.String?
        /// The ID of the mount target's subnet.
        /// This member is required.
        public var subnetId: Swift.String?
        /// The virtual private cloud (VPC) ID that the mount target is configured in.
        public var vpcId: Swift.String?

        public init(
            availabilityZoneId: Swift.String? = nil,
            availabilityZoneName: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
            mountTargetId: Swift.String? = nil,
            networkInterfaceId: Swift.String? = nil,
            ownerId: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.availabilityZoneId = availabilityZoneId
            self.availabilityZoneName = availabilityZoneName
            self.fileSystemId = fileSystemId
            self.ipAddress = ipAddress
            self.lifeCycleState = lifeCycleState
            self.mountTargetId = mountTargetId
            self.networkInterfaceId = networkInterfaceId
            self.ownerId = ownerId
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension MountTargetNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MountTargetNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if there is no mount target with the specified ID found in the caller's Amazon Web Services account.
public struct MountTargetNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MountTargetNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct MountTargetNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension MountTargetNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkInterfaceLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NetworkInterfaceLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The calling account has reached the limit for elastic network interfaces for the specific Amazon Web Services Region. Either delete some network interfaces or request that the account quota be raised. For more information, see [Amazon VPC Quotas](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Appendix_Limits.html) in the Amazon VPC User Guide (see the Network interfaces per Region entry in the Network interfaces table).
public struct NetworkInterfaceLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NetworkInterfaceLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct NetworkInterfaceLimitExceededBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension NetworkInterfaceLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoFreeAddressesInSubnet {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoFreeAddressesInSubnetBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if IpAddress was not specified in the request and there are no free IP addresses in the subnet.
public struct NoFreeAddressesInSubnet: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoFreeAddressesInSubnet" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct NoFreeAddressesInSubnetBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension NoFreeAddressesInSubnetBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum PerformanceMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generalPurpose
        case maxIo
        case sdkUnknown(Swift.String)

        public static var allCases: [PerformanceMode] {
            return [
                .generalPurpose,
                .maxIo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generalPurpose: return "generalPurpose"
            case .maxIo: return "maxIO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PerformanceMode(rawValue: rawValue) ?? PerformanceMode.sdkUnknown(rawValue)
        }
    }
}

extension PolicyNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PolicyNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the default file system policy is in effect for the EFS file system specified.
public struct PolicyNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PolicyNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct PolicyNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension PolicyNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes.PosixUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for gid0 in secondaryGids {
                try secondaryGidsContainer.encode(gid0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Swift.Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Swift.Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension EFSClientTypes {
    /// The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point.
    public struct PosixUser: Swift.Equatable {
        /// The POSIX group ID used for all file system operations using this access point.
        /// This member is required.
        public var gid: Swift.Int?
        /// Secondary POSIX group IDs used for all file system operations using this access point.
        public var secondaryGids: [Swift.Int]?
        /// The POSIX user ID used for all file system operations using this access point.
        /// This member is required.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            secondaryGids: [Swift.Int]? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.secondaryGids = secondaryGids
            self.uid = uid
        }
    }

}

extension PutAccountPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = self.resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
    }
}

extension PutAccountPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2015-02-01/account-preferences"
    }
}

public struct PutAccountPreferencesInput: Swift.Equatable {
    /// Specifies the EFS resource ID preference to set for the user's Amazon Web Services account, in the current Amazon Web Services Region, either LONG_ID (17 characters), or SHORT_ID (8 characters). Starting in October, 2021, you will receive an error when setting the account preference to SHORT_ID. Contact Amazon Web Services support if you receive an error and must use short IDs for file system and mount target resources.
    /// This member is required.
    public var resourceIdType: EFSClientTypes.ResourceIdType?

    public init(
        resourceIdType: EFSClientTypes.ResourceIdType? = nil
    )
    {
        self.resourceIdType = resourceIdType
    }
}

struct PutAccountPreferencesInputBody: Swift.Equatable {
    let resourceIdType: EFSClientTypes.ResourceIdType?
}

extension PutAccountPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
    }
}

extension PutAccountPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAccountPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceIdPreference = output.resourceIdPreference
        } else {
            self.resourceIdPreference = nil
        }
    }
}

public struct PutAccountPreferencesOutput: Swift.Equatable {
    /// Describes the resource type and its ID preference for the user's Amazon Web Services account, in the current Amazon Web Services Region.
    public var resourceIdPreference: EFSClientTypes.ResourceIdPreference?

    public init(
        resourceIdPreference: EFSClientTypes.ResourceIdPreference? = nil
    )
    {
        self.resourceIdPreference = resourceIdPreference
    }
}

struct PutAccountPreferencesOutputBody: Swift.Equatable {
    let resourceIdPreference: EFSClientTypes.ResourceIdPreference?
}

extension PutAccountPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdPreference = "ResourceIdPreference"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdPreferenceDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ResourceIdPreference.self, forKey: .resourceIdPreference)
        resourceIdPreference = resourceIdPreferenceDecoded
    }
}

enum PutAccountPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutBackupPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupPolicy = self.backupPolicy {
            try encodeContainer.encode(backupPolicy, forKey: .backupPolicy)
        }
    }
}

extension PutBackupPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/backup-policy"
    }
}

public struct PutBackupPolicyInput: Swift.Equatable {
    /// The backup policy included in the PutBackupPolicy request.
    /// This member is required.
    public var backupPolicy: EFSClientTypes.BackupPolicy?
    /// Specifies which EFS file system to update the backup policy for.
    /// This member is required.
    public var fileSystemId: Swift.String?

    public init(
        backupPolicy: EFSClientTypes.BackupPolicy? = nil,
        fileSystemId: Swift.String? = nil
    )
    {
        self.backupPolicy = backupPolicy
        self.fileSystemId = fileSystemId
    }
}

struct PutBackupPolicyInputBody: Swift.Equatable {
    let backupPolicy: EFSClientTypes.BackupPolicy?
}

extension PutBackupPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EFSClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

extension PutBackupPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutBackupPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.backupPolicy = output.backupPolicy
        } else {
            self.backupPolicy = nil
        }
    }
}

public struct PutBackupPolicyOutput: Swift.Equatable {
    /// Describes the file system's backup policy, indicating whether automatic backups are turned on or off.
    public var backupPolicy: EFSClientTypes.BackupPolicy?

    public init(
        backupPolicy: EFSClientTypes.BackupPolicy? = nil
    )
    {
        self.backupPolicy = backupPolicy
    }
}

struct PutBackupPolicyOutputBody: Swift.Equatable {
    let backupPolicy: EFSClientTypes.BackupPolicy?
}

extension PutBackupPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupPolicy = "BackupPolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupPolicyDecoded = try containerValues.decodeIfPresent(EFSClientTypes.BackupPolicy.self, forKey: .backupPolicy)
        backupPolicy = backupPolicyDecoded
    }
}

enum PutBackupPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutFileSystemPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bypassPolicyLockoutSafetyCheck = self.bypassPolicyLockoutSafetyCheck {
            try encodeContainer.encode(bypassPolicyLockoutSafetyCheck, forKey: .bypassPolicyLockoutSafetyCheck)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutFileSystemPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/policy"
    }
}

public struct PutFileSystemPolicyInput: Swift.Equatable {
    /// (Optional) A boolean that specifies whether or not to bypass the FileSystemPolicy lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future PutFileSystemPolicy requests on this file system. Set BypassPolicyLockoutSafetyCheck to True only when you intend to prevent the IAM principal that is making the request from making subsequent PutFileSystemPolicy requests on this file system. The default value is False.
    public var bypassPolicyLockoutSafetyCheck: Swift.Bool?
    /// The ID of the EFS file system that you want to create or update the FileSystemPolicy for.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// The FileSystemPolicy that you're creating. Accepts a JSON formatted policy definition. EFS file system policies have a 20,000 character limit. To find out more about the elements that make up a file system policy, see [EFS Resource-based Policies](https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies).
    /// This member is required.
    public var policy: Swift.String?

    public init(
        bypassPolicyLockoutSafetyCheck: Swift.Bool? = nil,
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheck
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyInputBody: Swift.Equatable {
    let policy: Swift.String?
    let bypassPolicyLockoutSafetyCheck: Swift.Bool?
}

extension PutFileSystemPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bypassPolicyLockoutSafetyCheck = "BypassPolicyLockoutSafetyCheck"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
        let bypassPolicyLockoutSafetyCheckDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .bypassPolicyLockoutSafetyCheck)
        bypassPolicyLockoutSafetyCheck = bypassPolicyLockoutSafetyCheckDecoded
    }
}

extension PutFileSystemPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutFileSystemPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.fileSystemId = output.fileSystemId
            self.policy = output.policy
        } else {
            self.fileSystemId = nil
            self.policy = nil
        }
    }
}

public struct PutFileSystemPolicyOutput: Swift.Equatable {
    /// Specifies the EFS file system to which the FileSystemPolicy applies.
    public var fileSystemId: Swift.String?
    /// The JSON formatted FileSystemPolicy for the EFS file system.
    public var policy: Swift.String?

    public init(
        fileSystemId: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.policy = policy
    }
}

struct PutFileSystemPolicyOutputBody: Swift.Equatable {
    let fileSystemId: Swift.String?
    let policy: Swift.String?
}

extension PutFileSystemPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemId = "FileSystemId"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutFileSystemPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPolicyException": return try await InvalidPolicyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLifecycleConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicies = lifecyclePolicies {
            var lifecyclePoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifecyclePolicies)
            for lifecyclepolicy0 in lifecyclePolicies {
                try lifecyclePoliciesContainer.encode(lifecyclepolicy0)
            }
        }
    }
}

extension PutLifecycleConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())/lifecycle-configuration"
    }
}

public struct PutLifecycleConfigurationInput: Swift.Equatable {
    /// The ID of the file system for which you are creating the LifecycleConfiguration object (String).
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// An array of LifecyclePolicy objects that define the file system's LifecycleConfiguration object. A LifecycleConfiguration object informs EFS lifecycle management and EFS Intelligent-Tiering of the following:
    ///
    /// * When to move files in the file system from primary storage to the IA storage class.
    ///
    /// * When to move files that are in IA storage to primary storage.
    ///
    ///
    /// When using the put-lifecycle-configuration CLI command or the PutLifecycleConfiguration API action, Amazon EFS requires that each LifecyclePolicy object have only a single transition. This means that in a request body, LifecyclePolicies must be structured as an array of LifecyclePolicy objects, one object for each transition, TransitionToIA, TransitionToPrimaryStorageClass. See the example requests in the following section for more information.
    /// This member is required.
    public var lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?

    public init(
        fileSystemId: Swift.String? = nil,
        lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationInputBody: Swift.Equatable {
    let lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?
}

extension PutLifecycleConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EFSClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EFSClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EFSClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

extension PutLifecycleConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutLifecycleConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicies = output.lifecyclePolicies
        } else {
            self.lifecyclePolicies = nil
        }
    }
}

public struct PutLifecycleConfigurationOutput: Swift.Equatable {
    /// An array of lifecycle management policies. EFS supports a maximum of one policy per file system.
    public var lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?

    public init(
        lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]? = nil
    )
    {
        self.lifecyclePolicies = lifecyclePolicies
    }
}

struct PutLifecycleConfigurationOutputBody: Swift.Equatable {
    let lifecyclePolicies: [EFSClientTypes.LifecyclePolicy]?
}

extension PutLifecycleConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicies = "LifecyclePolicies"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecyclePoliciesContainer = try containerValues.decodeIfPresent([EFSClientTypes.LifecyclePolicy?].self, forKey: .lifecyclePolicies)
        var lifecyclePoliciesDecoded0:[EFSClientTypes.LifecyclePolicy]? = nil
        if let lifecyclePoliciesContainer = lifecyclePoliciesContainer {
            lifecyclePoliciesDecoded0 = [EFSClientTypes.LifecyclePolicy]()
            for structure0 in lifecyclePoliciesContainer {
                if let structure0 = structure0 {
                    lifecyclePoliciesDecoded0?.append(structure0)
                }
            }
        }
        lifecyclePolicies = lifecyclePoliciesDecoded0
    }
}

enum PutLifecycleConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EFSClientTypes.ReplicationConfigurationDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case destinations = "Destinations"
        case originalSourceFileSystemArn = "OriginalSourceFileSystemArn"
        case sourceFileSystemArn = "SourceFileSystemArn"
        case sourceFileSystemId = "SourceFileSystemId"
        case sourceFileSystemRegion = "SourceFileSystemRegion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for destination0 in destinations {
                try destinationsContainer.encode(destination0)
            }
        }
        if let originalSourceFileSystemArn = self.originalSourceFileSystemArn {
            try encodeContainer.encode(originalSourceFileSystemArn, forKey: .originalSourceFileSystemArn)
        }
        if let sourceFileSystemArn = self.sourceFileSystemArn {
            try encodeContainer.encode(sourceFileSystemArn, forKey: .sourceFileSystemArn)
        }
        if let sourceFileSystemId = self.sourceFileSystemId {
            try encodeContainer.encode(sourceFileSystemId, forKey: .sourceFileSystemId)
        }
        if let sourceFileSystemRegion = self.sourceFileSystemRegion {
            try encodeContainer.encode(sourceFileSystemRegion, forKey: .sourceFileSystemRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemId)
        sourceFileSystemId = sourceFileSystemIdDecoded
        let sourceFileSystemRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemRegion)
        sourceFileSystemRegion = sourceFileSystemRegionDecoded
        let sourceFileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFileSystemArn)
        sourceFileSystemArn = sourceFileSystemArnDecoded
        let originalSourceFileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originalSourceFileSystemArn)
        originalSourceFileSystemArn = originalSourceFileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let destinationsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[EFSClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [EFSClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension EFSClientTypes {
    /// Describes the replication configuration for a specific file system.
    public struct ReplicationConfigurationDescription: Swift.Equatable {
        /// Describes when the replication configuration was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// An array of destination objects. Only one destination object is supported.
        /// This member is required.
        public var destinations: [EFSClientTypes.Destination]?
        /// The Amazon Resource Name (ARN) of the original source Amazon EFS file system in the replication configuration.
        /// This member is required.
        public var originalSourceFileSystemArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the current source file system in the replication configuration.
        /// This member is required.
        public var sourceFileSystemArn: Swift.String?
        /// The ID of the source Amazon EFS file system that is being replicated.
        /// This member is required.
        public var sourceFileSystemId: Swift.String?
        /// The Amazon Web Services Region in which the source Amazon EFS file system is located.
        /// This member is required.
        public var sourceFileSystemRegion: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            destinations: [EFSClientTypes.Destination]? = nil,
            originalSourceFileSystemArn: Swift.String? = nil,
            sourceFileSystemArn: Swift.String? = nil,
            sourceFileSystemId: Swift.String? = nil,
            sourceFileSystemRegion: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.destinations = destinations
            self.originalSourceFileSystemArn = originalSourceFileSystemArn
            self.sourceFileSystemArn = sourceFileSystemArn
            self.sourceFileSystemId = sourceFileSystemId
            self.sourceFileSystemRegion = sourceFileSystemRegion
        }
    }

}

extension ReplicationNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicationNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the specified file system does not have a replication configuration.
public struct ReplicationNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// ReplicationNotFound
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ReplicationNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ReplicationNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case enabled
        case enabling
        case error
        case paused
        case pausing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .deleting,
                .enabled,
                .enabling,
                .error,
                .paused,
                .pausing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case .error: return "ERROR"
            case .paused: return "PAUSED"
            case .pausing: return "PAUSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension EFSClientTypes {
    /// An EFS resource, for example a file system or a mount target.
    public enum Resource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case filesystem
        case mounttarget
        case sdkUnknown(Swift.String)

        public static var allCases: [Resource] {
            return [
                .filesystem,
                .mounttarget,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .filesystem: return "FILE_SYSTEM"
            case .mounttarget: return "MOUNT_TARGET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Resource(rawValue: rawValue) ?? Resource.sdkUnknown(rawValue)
        }
    }
}

extension EFSClientTypes.ResourceIdPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceIdType = "ResourceIdType"
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceIdType = self.resourceIdType {
            try encodeContainer.encode(resourceIdType.rawValue, forKey: .resourceIdType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdTypeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ResourceIdType.self, forKey: .resourceIdType)
        resourceIdType = resourceIdTypeDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([EFSClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[EFSClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [EFSClientTypes.Resource]()
            for enum0 in resourcesContainer {
                if let enum0 = enum0 {
                    resourcesDecoded0?.append(enum0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension EFSClientTypes {
    /// Describes the resource type and its ID preference for the user's Amazon Web Services account, in the current Amazon Web Services Region.
    public struct ResourceIdPreference: Swift.Equatable {
        /// Identifies the EFS resource ID preference, either LONG_ID (17 characters) or SHORT_ID (8 characters).
        public var resourceIdType: EFSClientTypes.ResourceIdType?
        /// Identifies the Amazon EFS resources to which the ID preference setting applies, FILE_SYSTEM and MOUNT_TARGET.
        public var resources: [EFSClientTypes.Resource]?

        public init(
            resourceIdType: EFSClientTypes.ResourceIdType? = nil,
            resources: [EFSClientTypes.Resource]? = nil
        )
        {
            self.resourceIdType = resourceIdType
            self.resources = resources
        }
    }

}

extension EFSClientTypes {
    /// A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.
    public enum ResourceIdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case longid
        case shortid
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceIdType] {
            return [
                .longid,
                .shortid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .longid: return "LONG_ID"
            case .shortid: return "SHORT_ID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceIdType(rawValue: rawValue) ?? ResourceIdType.sdkUnknown(rawValue)
        }
    }
}

extension EFSClientTypes.RootDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationInfo = "CreationInfo"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationInfo = self.creationInfo {
            try encodeContainer.encode(creationInfo, forKey: .creationInfo)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let creationInfoDecoded = try containerValues.decodeIfPresent(EFSClientTypes.CreationInfo.self, forKey: .creationInfo)
        creationInfo = creationInfoDecoded
    }
}

extension EFSClientTypes {
    /// Specifies the directory on the Amazon EFS file system that the access point provides access to. The access point exposes the specified file system path as the root directory of your file system to applications using the access point. NFS clients using the access point can only access data in the access point's RootDirectory and it's subdirectories.
    public struct RootDirectory: Swift.Equatable {
        /// (Optional) Specifies the POSIX IDs and permissions to apply to the access point's RootDirectory. If the RootDirectory > Path specified does not exist, EFS creates the root directory using the CreationInfo settings when a client connects to an access point. When specifying the CreationInfo, you must provide values for all properties. If you do not provide CreationInfo and the specified RootDirectory > Path does not exist, attempts to mount the file system using the access point will fail.
        public var creationInfo: EFSClientTypes.CreationInfo?
        /// Specifies the path on the EFS file system to expose as the root directory to NFS clients using the access point to access the EFS file system. A path can have up to four subdirectories. If the specified path does not exist, you are required to provide the CreationInfo.
        public var path: Swift.String?

        public init(
            creationInfo: EFSClientTypes.CreationInfo? = nil,
            path: Swift.String? = nil
        )
        {
            self.creationInfo = creationInfo
            self.path = path
        }
    }

}

extension SecurityGroupLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SecurityGroupLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the size of SecurityGroups specified in the request is greater than five.
public struct SecurityGroupLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SecurityGroupLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct SecurityGroupLimitExceededBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension SecurityGroupLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SecurityGroupNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SecurityGroupNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if one of the specified security groups doesn't exist in the subnet's virtual private cloud (VPC).
public struct SecurityGroupNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SecurityGroupNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct SecurityGroupNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension SecurityGroupNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case disabling
        case enabled
        case enabling
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .disabled,
                .disabling,
                .enabled,
                .enabling,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabled: return "ENABLED"
            case .enabling: return "ENABLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension SubnetNotFound {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SubnetNotFoundBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if there is no subnet with ID SubnetId provided in the request.
public struct SubnetNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "SubnetNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct SubnetNotFoundBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension SubnetNotFoundBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EFSClientTypes {
    /// A tag is a key-value pair. Allowed characters are letters, white space, and numbers that can be represented in UTF-8, and the following characters: + - = . _ : /.
    public struct Tag: Swift.Equatable {
        /// The tag key (String). The key can't start with aws:.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/2015-02-01/resource-tags/\(resourceId.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ID specifying the EFS resource that you want to create a tag for.
    /// This member is required.
    public var resourceId: Swift.String?
    /// An array of Tag objects to add. Each Tag object is a key-value pair.
    /// This member is required.
    public var tags: [EFSClientTypes.Tag]?

    public init(
        resourceId: Swift.String? = nil,
        tags: [EFSClientTypes.Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [EFSClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned when the CreateAccessPoint API action is called too quickly and the number of Access Points on the file system is nearing the [limit of 120](https://docs.aws.amazon.com/efs/latest/ug/limits.html#limits-efs-resources-per-account-per-region).
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ThroughputLimitExceeded {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThroughputLimitExceededBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the throughput mode or amount of provisioned throughput can't be changed because the throughput limit of 1024 MiB/s has been reached.
public struct ThroughputLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThroughputLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ThroughputLimitExceededBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ThroughputLimitExceededBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum ThroughputMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bursting
        case elastic
        case provisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ThroughputMode] {
            return [
                .bursting,
                .elastic,
                .provisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bursting: return "bursting"
            case .elastic: return "elastic"
            case .provisioned: return "provisioned"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThroughputMode(rawValue: rawValue) ?? ThroughputMode.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequests {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if you dont wait at least 24 hours before either changing the throughput mode, or decreasing the Provisioned Throughput value.
public struct TooManyRequests: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequests" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct TooManyRequestsBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSClientTypes {
    public enum TransitionToIARules: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case after14Days
        case after1Day
        case after30Days
        case after60Days
        case after7Days
        case after90Days
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionToIARules] {
            return [
                .after14Days,
                .after1Day,
                .after30Days,
                .after60Days,
                .after7Days,
                .after90Days,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .after14Days: return "AFTER_14_DAYS"
            case .after1Day: return "AFTER_1_DAY"
            case .after30Days: return "AFTER_30_DAYS"
            case .after60Days: return "AFTER_60_DAYS"
            case .after7Days: return "AFTER_7_DAYS"
            case .after90Days: return "AFTER_90_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionToIARules(rawValue: rawValue) ?? TransitionToIARules.sdkUnknown(rawValue)
        }
    }
}

extension EFSClientTypes {
    public enum TransitionToPrimaryStorageClassRules: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case after1Access
        case sdkUnknown(Swift.String)

        public static var allCases: [TransitionToPrimaryStorageClassRules] {
            return [
                .after1Access,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .after1Access: return "AFTER_1_ACCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransitionToPrimaryStorageClassRules(rawValue: rawValue) ?? TransitionToPrimaryStorageClassRules.sdkUnknown(rawValue)
        }
    }
}

extension UnsupportedAvailabilityZone {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedAvailabilityZoneBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the requested Amazon EFS functionality is not available in the specified Availability Zone.
public struct UnsupportedAvailabilityZone: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedAvailabilityZone" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct UnsupportedAvailabilityZoneBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension UnsupportedAvailabilityZoneBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceId = resourceId else {
            return nil
        }
        return "/2015-02-01/resource-tags/\(resourceId.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies the EFS resource that you want to remove tags from.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The keys of the key-value tag pairs that you want to remove from the specified EFS resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceId: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessPointNotFound": return try await AccessPointNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFileSystemInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedThroughputInMibps = self.provisionedThroughputInMibps {
            try encodeContainer.encode(provisionedThroughputInMibps, forKey: .provisionedThroughputInMibps)
        }
        if let throughputMode = self.throughputMode {
            try encodeContainer.encode(throughputMode.rawValue, forKey: .throughputMode)
        }
    }
}

extension UpdateFileSystemInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let fileSystemId = fileSystemId else {
            return nil
        }
        return "/2015-02-01/file-systems/\(fileSystemId.urlPercentEncoding())"
    }
}

public struct UpdateFileSystemInput: Swift.Equatable {
    /// The ID of the file system that you want to update.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// (Optional) The throughput, measured in mebibytes per second (MiBps), that you want to provision for a file system that you're creating. Required if ThroughputMode is set to provisioned. Valid values are 1-3414 MiBps, with the upper limit depending on Region. To increase this limit, contact Amazon Web Services Support. For more information, see [Amazon EFS quotas that you can increase](https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits) in the Amazon EFS User Guide.
    public var provisionedThroughputInMibps: Swift.Double?
    /// (Optional) Updates the file system's throughput mode. If you're not updating your throughput mode, you don't need to provide this value in your request. If you are changing the ThroughputMode to provisioned, you must also set a value for ProvisionedThroughputInMibps.
    public var throughputMode: EFSClientTypes.ThroughputMode?

    public init(
        fileSystemId: Swift.String? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        throughputMode: EFSClientTypes.ThroughputMode? = nil
    )
    {
        self.fileSystemId = fileSystemId
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemInputBody: Swift.Equatable {
    let throughputMode: EFSClientTypes.ThroughputMode?
    let provisionedThroughputInMibps: Swift.Double?
}

extension UpdateFileSystemInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case throughputMode = "ThroughputMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let throughputModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
    }
}

extension UpdateFileSystemOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFileSystemOutputBody = try responseDecoder.decode(responseBody: data)
            self.availabilityZoneId = output.availabilityZoneId
            self.availabilityZoneName = output.availabilityZoneName
            self.creationTime = output.creationTime
            self.creationToken = output.creationToken
            self.encrypted = output.encrypted
            self.fileSystemArn = output.fileSystemArn
            self.fileSystemId = output.fileSystemId
            self.kmsKeyId = output.kmsKeyId
            self.lifeCycleState = output.lifeCycleState
            self.name = output.name
            self.numberOfMountTargets = output.numberOfMountTargets
            self.ownerId = output.ownerId
            self.performanceMode = output.performanceMode
            self.provisionedThroughputInMibps = output.provisionedThroughputInMibps
            self.sizeInBytes = output.sizeInBytes
            self.tags = output.tags
            self.throughputMode = output.throughputMode
        } else {
            self.availabilityZoneId = nil
            self.availabilityZoneName = nil
            self.creationTime = nil
            self.creationToken = nil
            self.encrypted = nil
            self.fileSystemArn = nil
            self.fileSystemId = nil
            self.kmsKeyId = nil
            self.lifeCycleState = nil
            self.name = nil
            self.numberOfMountTargets = 0
            self.ownerId = nil
            self.performanceMode = nil
            self.provisionedThroughputInMibps = nil
            self.sizeInBytes = nil
            self.tags = nil
            self.throughputMode = nil
        }
    }
}

/// A description of the file system.
public struct UpdateFileSystemOutput: Swift.Equatable {
    /// The unique and consistent identifier of the Availability Zone in which the file system's One Zone storage classes exist. For example, use1-az1 is an Availability Zone ID for the us-east-1 Amazon Web Services Region, and it has the same location in every Amazon Web Services account.
    public var availabilityZoneId: Swift.String?
    /// Describes the Amazon Web Services Availability Zone in which the file system is located, and is valid only for file systems using One Zone storage classes. For more information, see [Using EFS storage classes](https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html) in the Amazon EFS User Guide.
    public var availabilityZoneName: Swift.String?
    /// The time that the file system was created, in seconds (since 1970-01-01T00:00:00Z).
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The opaque string specified in the request.
    /// This member is required.
    public var creationToken: Swift.String?
    /// A Boolean value that, if true, indicates that the file system is encrypted.
    public var encrypted: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the EFS file system, in the format arn:aws:elasticfilesystem:region:account-id:file-system/file-system-id . Example with sample data: arn:aws:elasticfilesystem:us-west-2:1111333322228888:file-system/fs-01234567
    public var fileSystemArn: Swift.String?
    /// The ID of the file system, assigned by Amazon EFS.
    /// This member is required.
    public var fileSystemId: Swift.String?
    /// The ID of an KMS key used to protect the encrypted file system.
    public var kmsKeyId: Swift.String?
    /// The lifecycle phase of the file system.
    /// This member is required.
    public var lifeCycleState: EFSClientTypes.LifeCycleState?
    /// You can add tags to a file system, including a Name tag. For more information, see [CreateFileSystem]. If the file system has a Name tag, Amazon EFS returns the value in this field.
    public var name: Swift.String?
    /// The current number of mount targets that the file system has. For more information, see [CreateMountTarget].
    /// This member is required.
    public var numberOfMountTargets: Swift.Int
    /// The Amazon Web Services account that created the file system.
    /// This member is required.
    public var ownerId: Swift.String?
    /// The performance mode of the file system.
    /// This member is required.
    public var performanceMode: EFSClientTypes.PerformanceMode?
    /// The amount of provisioned throughput, measured in MiBps, for the file system. Valid for file systems using ThroughputMode set to provisioned.
    public var provisionedThroughputInMibps: Swift.Double?
    /// The latest known metered size (in bytes) of data stored in the file system, in its Value field, and the time at which that size was determined in its Timestamp field. The Timestamp value is the integer number of seconds since 1970-01-01T00:00:00Z. The SizeInBytes value doesn't represent the size of a consistent snapshot of the file system, but it is eventually consistent when there are no writes to the file system. That is, SizeInBytes represents actual size only if the file system is not modified for a period longer than a couple of hours. Otherwise, the value is not the exact size that the file system was at any point in time.
    /// This member is required.
    public var sizeInBytes: EFSClientTypes.FileSystemSize?
    /// The tags associated with the file system, presented as an array of Tag objects.
    /// This member is required.
    public var tags: [EFSClientTypes.Tag]?
    /// Displays the file system's throughput mode. For more information, see [Throughput modes](https://docs.aws.amazon.com/efs/latest/ug/performance.html#throughput-modes) in the Amazon EFS User Guide.
    public var throughputMode: EFSClientTypes.ThroughputMode?

    public init(
        availabilityZoneId: Swift.String? = nil,
        availabilityZoneName: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        creationToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        fileSystemArn: Swift.String? = nil,
        fileSystemId: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        lifeCycleState: EFSClientTypes.LifeCycleState? = nil,
        name: Swift.String? = nil,
        numberOfMountTargets: Swift.Int = 0,
        ownerId: Swift.String? = nil,
        performanceMode: EFSClientTypes.PerformanceMode? = nil,
        provisionedThroughputInMibps: Swift.Double? = nil,
        sizeInBytes: EFSClientTypes.FileSystemSize? = nil,
        tags: [EFSClientTypes.Tag]? = nil,
        throughputMode: EFSClientTypes.ThroughputMode? = nil
    )
    {
        self.availabilityZoneId = availabilityZoneId
        self.availabilityZoneName = availabilityZoneName
        self.creationTime = creationTime
        self.creationToken = creationToken
        self.encrypted = encrypted
        self.fileSystemArn = fileSystemArn
        self.fileSystemId = fileSystemId
        self.kmsKeyId = kmsKeyId
        self.lifeCycleState = lifeCycleState
        self.name = name
        self.numberOfMountTargets = numberOfMountTargets
        self.ownerId = ownerId
        self.performanceMode = performanceMode
        self.provisionedThroughputInMibps = provisionedThroughputInMibps
        self.sizeInBytes = sizeInBytes
        self.tags = tags
        self.throughputMode = throughputMode
    }
}

struct UpdateFileSystemOutputBody: Swift.Equatable {
    let ownerId: Swift.String?
    let creationToken: Swift.String?
    let fileSystemId: Swift.String?
    let fileSystemArn: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lifeCycleState: EFSClientTypes.LifeCycleState?
    let name: Swift.String?
    let numberOfMountTargets: Swift.Int
    let sizeInBytes: EFSClientTypes.FileSystemSize?
    let performanceMode: EFSClientTypes.PerformanceMode?
    let encrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
    let throughputMode: EFSClientTypes.ThroughputMode?
    let provisionedThroughputInMibps: Swift.Double?
    let availabilityZoneName: Swift.String?
    let availabilityZoneId: Swift.String?
    let tags: [EFSClientTypes.Tag]?
}

extension UpdateFileSystemOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZoneId = "AvailabilityZoneId"
        case availabilityZoneName = "AvailabilityZoneName"
        case creationTime = "CreationTime"
        case creationToken = "CreationToken"
        case encrypted = "Encrypted"
        case fileSystemArn = "FileSystemArn"
        case fileSystemId = "FileSystemId"
        case kmsKeyId = "KmsKeyId"
        case lifeCycleState = "LifeCycleState"
        case name = "Name"
        case numberOfMountTargets = "NumberOfMountTargets"
        case ownerId = "OwnerId"
        case performanceMode = "PerformanceMode"
        case provisionedThroughputInMibps = "ProvisionedThroughputInMibps"
        case sizeInBytes = "SizeInBytes"
        case tags = "Tags"
        case throughputMode = "ThroughputMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerId)
        ownerId = ownerIdDecoded
        let creationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationToken)
        creationToken = creationTokenDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let fileSystemArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemArn)
        fileSystemArn = fileSystemArnDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lifeCycleStateDecoded = try containerValues.decodeIfPresent(EFSClientTypes.LifeCycleState.self, forKey: .lifeCycleState)
        lifeCycleState = lifeCycleStateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let numberOfMountTargetsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfMountTargets) ?? 0
        numberOfMountTargets = numberOfMountTargetsDecoded
        let sizeInBytesDecoded = try containerValues.decodeIfPresent(EFSClientTypes.FileSystemSize.self, forKey: .sizeInBytes)
        sizeInBytes = sizeInBytesDecoded
        let performanceModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.PerformanceMode.self, forKey: .performanceMode)
        performanceMode = performanceModeDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let throughputModeDecoded = try containerValues.decodeIfPresent(EFSClientTypes.ThroughputMode.self, forKey: .throughputMode)
        throughputMode = throughputModeDecoded
        let provisionedThroughputInMibpsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .provisionedThroughputInMibps)
        provisionedThroughputInMibps = provisionedThroughputInMibpsDecoded
        let availabilityZoneNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneName)
        availabilityZoneName = availabilityZoneNameDecoded
        let availabilityZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZoneId)
        availabilityZoneId = availabilityZoneIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EFSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EFSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EFSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateFileSystemOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequest": return try await BadRequest(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "FileSystemNotFound": return try await FileSystemNotFound(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "IncorrectFileSystemLifeCycleState": return try await IncorrectFileSystemLifeCycleState(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InsufficientThroughputCapacity": return try await InsufficientThroughputCapacity(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerError": return try await InternalServerError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThroughputLimitExceeded": return try await ThroughputLimitExceeded(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequests": return try await TooManyRequests(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Returned if the Backup service is not available in the Amazon Web Services Region in which the request was made.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code is a string that uniquely identifies an error condition. It is meant to be read and understood by programs that detect and handle errors by type.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The error message contains a generic description of the error condition in English. It is intended for a human audience. Simple programs display the message directly to the end user if they encounter an error condition they don't know how or don't care to handle. Sophisticated programs with more exhaustive error handling and proper internationalization are more likely to ignore the error message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
