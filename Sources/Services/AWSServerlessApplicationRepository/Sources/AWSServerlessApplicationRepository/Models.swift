//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox


public struct DeleteApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct UnshareApplicationOutput: Swift.Sendable {

    public init() { }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// A nested application summary.
    public struct ApplicationDependencySummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the nested application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The semantic version of the nested application.
        /// This member is required.
        public var semanticVersion: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            semanticVersion: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Policy statement applied to the application.
    public struct ApplicationPolicyStatement: Swift.Sendable {
        /// For the list of actions supported for this operation, see [Application Permissions](https://docs.aws.amazon.com/serverlessrepo/latest/devguide/access-control-resource-based.html#application-permissions).
        /// This member is required.
        public var actions: [Swift.String]?
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM [aws:PrincipalOrgID](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#principal-org-id) global condition key.
        public var principalOrgIDs: [Swift.String]?
        /// An array of AWS account IDs, or * to make the application public.
        /// This member is required.
        public var principals: [Swift.String]?
        /// A unique ID for the statement.
        public var statementId: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            principalOrgIDs: [Swift.String]? = nil,
            principals: [Swift.String]? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Summary of details about the application.
    public struct ApplicationSummary: Swift.Sendable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        /// This member is required.
        public var author: Swift.String?
        /// The date and time this resource was created.
        public var creationTime: Swift.String?
        /// The description of the application.Minimum length=1. Maximum length=256
        /// This member is required.
        public var description: Swift.String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public var homePageUrl: Swift.String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public var labels: [Swift.String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        /// This member is required.
        public var name: Swift.String?
        /// A valid identifier from [https://spdx.org/licenses/](https://spdx.org/licenses/).
        public var spdxLicenseId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            description: Swift.String? = nil,
            homePageUrl: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            name: Swift.String? = nil,
            spdxLicenseId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Values that must be specified in order to deploy some applications.
    public enum Capability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capabilityAutoExpand
        case capabilityIam
        case capabilityNamedIam
        case capabilityResourcePolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .capabilityAutoExpand,
                .capabilityIam,
                .capabilityNamedIam,
                .capabilityResourcePolicy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capabilityAutoExpand: return "CAPABILITY_AUTO_EXPAND"
            case .capabilityIam: return "CAPABILITY_IAM"
            case .capabilityNamedIam: return "CAPABILITY_NAMED_IAM"
            case .capabilityResourcePolicy: return "CAPABILITY_RESOURCE_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Parameters supported by the application.
    public struct ParameterDefinition: Swift.Sendable {
        /// A regular expression that represents the patterns to allow for String types.
        public var allowedPattern: Swift.String?
        /// An array containing the list of values allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display the following customized error message: Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public var constraintDescription: Swift.String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created. If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public var defaultValue: Swift.String?
        /// A string of up to 4,000 characters that describes the parameter.
        public var description: Swift.String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public var maxLength: Swift.Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public var maxValue: Swift.Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public var minLength: Swift.Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public var minValue: Swift.Int?
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the value to true, the parameter value is masked with asterisks (*****).
        public var noEcho: Swift.Bool?
        /// A list of AWS SAM resources that use this parameter.
        /// This member is required.
        public var referencedByResources: [Swift.String]?
        /// The type of the parameter.Valid values: String | Number | List<Number> | CommaDelimitedList String: A literal string.For example, users can specify "MyUserName". Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888". List<Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"]. CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas. Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public var type: Swift.String?

        public init(
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxLength: Swift.Int? = nil,
            maxValue: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            noEcho: Swift.Bool? = nil,
            referencedByResources: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Parameter value of the application.
    public struct ParameterValue: Swift.Sendable {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        /// This member is required.
        public var name: Swift.String?
        /// The input value associated with the parameter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// This property corresponds to the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
    public struct RollbackTrigger: Swift.Sendable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
        /// This member is required.
        public var arn: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
        /// This member is required.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// This property corresponds to the AWS CloudFormation [Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
    public struct Tag: Swift.Sendable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
        /// This member is required.
        public var key: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [ Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// An application version summary.
    public struct VersionSummary: Swift.Sendable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// The semantic version of the application: [https://semver.org/](https://semver.org/)
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }
    }
}

/// One of the parameters in the request is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 400
        public internal(set) var errorCode: Swift.String? = nil
        /// One of the parameters in the request is invalid.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The resource already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 409
        public internal(set) var errorCode: Swift.String? = nil
        /// The resource already exists.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The client is not authenticated.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 403
        public internal(set) var errorCode: Swift.String? = nil
        /// The client is not authenticated.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The AWS Serverless Application Repository service encountered an internal error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 500
        public internal(set) var errorCode: Swift.String? = nil
        /// The AWS Serverless Application Repository service encountered an internal error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

/// The client is sending more than the allowed number of requests per unit of time.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 429
        public internal(set) var errorCode: Swift.String? = nil
        /// The client is sending more than the allowed number of requests per unit of time.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct CreateApplicationInput: Swift.Sendable {
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    /// This member is required.
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    /// This member is required.
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A local text file that contains the license of the app that matches the spdxLicenseID value of your application. The file has the format file://<path>/<filename>.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseBody: Swift.String?
    /// A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseUrl: Swift.String?
    /// The name of the application that you want to publish.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    /// This member is required.
    public var name: Swift.String?
    /// A local text readme file in Markdown language that contains a more detailed description of the application and how it works. The file has the format file://<path>/<filename>.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeBody: Swift.String?
    /// A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeUrl: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A valid identifier from [https://spdx.org/licenses/](https://spdx.org/licenses/).
    public var spdxLicenseId: Swift.String?
    /// The local raw packaged AWS SAM template file of your application. The file has the format file://<path>/<filename>.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateBody: Swift.String?
    /// A link to the S3 object containing the packaged AWS SAM template of your application.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateUrl: Swift.String?

    public init(
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        licenseBody: Swift.String? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.licenseBody = licenseBody
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.spdxLicenseId = spdxLicenseId
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// Application version details.
    public struct Version: Swift.Sendable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// An array of parameter types supported by the application.
        /// This member is required.
        public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS::TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        /// This member is required.
        public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        /// This member is required.
        public var resourcesSupported: Swift.Bool?
        /// The semantic version of the application: [https://semver.org/](https://semver.org/)
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public var sourceCodeArchiveUrl: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?
        /// A link to the packaged AWS SAM template of your application.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
            requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
            resourcesSupported: Swift.Bool? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeArchiveUrl: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil,
            templateUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }
    }
}

public struct CreateApplicationOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

public struct CreateApplicationVersionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the new version.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// The raw packaged AWS SAM template of your application.
    public var templateBody: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

public struct CreateApplicationVersionOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// An array of parameter types supported by the application.
    public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
    /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS::TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
    public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
    /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
    public var resourcesSupported: Swift.Bool?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
        requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
        resourcesSupported: Swift.Bool? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.parameterDefinitions = parameterDefinitions
        self.requiredCapabilities = requiredCapabilities
        self.resourcesSupported = resourcesSupported
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateUrl = templateUrl
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    /// This property corresponds to the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
    public struct RollbackConfiguration: Swift.Sendable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
        public var monitoringTimeInMinutes: Swift.Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
        public var rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]?

        public init(
            monitoringTimeInMinutes: Swift.Int? = nil,
            rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]? = nil
        )
        {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }
    }
}

public struct CreateCloudFormationChangeSetInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS:TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
    public var capabilities: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var changeSetName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var clientToken: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var description: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var notificationArns: [Swift.String]?
    /// A list of parameter values for the parameters of the application.
    public var parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var resourceTypes: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    /// This member is required.
    public var stackName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var tags: [ServerlessApplicationRepositoryClientTypes.Tag]?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        changeSetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]? = nil,
        resourceTypes: [Swift.String]? = nil,
        rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration? = nil,
        semanticVersion: Swift.String? = nil,
        stackName: Swift.String? = nil,
        tags: [ServerlessApplicationRepositoryClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.capabilities = capabilities
        self.changeSetName = changeSetName
        self.clientToken = clientToken
        self.description = description
        self.notificationArns = notificationArns
        self.parameterOverrides = parameterOverrides
        self.resourceTypes = resourceTypes
        self.rollbackConfiguration = rollbackConfiguration
        self.semanticVersion = semanticVersion
        self.stackName = stackName
        self.tags = tags
        self.templateId = templateId
    }
}

public struct CreateCloudFormationChangeSetOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the change set.Length constraints: Minimum length of 1.Pattern: ARN:[-a-zA-Z0-9:/]*
    public var changeSetId: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// The unique ID of the stack.
    public var stackId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.changeSetId = changeSetId
        self.semanticVersion = semanticVersion
        self.stackId = stackId
    }
}

/// The resource (for example, an access policy statement) specified in the request doesn't exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 404
        public internal(set) var errorCode: Swift.String? = nil
        /// The resource (for example, an access policy statement) specified in the request doesn't exist.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

public struct CreateCloudFormationTemplateInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

extension ServerlessApplicationRepositoryClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case expired
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .expired,
                .preparing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCloudFormationTemplateOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

public struct DeleteApplicationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApplicationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

public struct GetApplicationOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

public struct GetApplicationPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

public struct GetApplicationPolicyOutput: Swift.Sendable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

public struct GetCloudFormationTemplateInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.templateId = templateId
    }
}

public struct GetCloudFormationTemplateOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

public struct ListApplicationDependenciesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
        self.semanticVersion = semanticVersion
    }
}

public struct ListApplicationDependenciesOutput: Swift.Sendable {
    /// An array of application summaries nested in the application.
    public var dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

public struct ListApplicationsInput: Swift.Sendable {
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput: Swift.Sendable {
    /// An array of application summaries.
    public var applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct ListApplicationVersionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

public struct ListApplicationVersionsOutput: Swift.Sendable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// An array of version summaries for the application.
    public var versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct PutApplicationPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// An array of policy statements applied to the application.
    /// This member is required.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        applicationId: Swift.String? = nil,
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.applicationId = applicationId
        self.statements = statements
    }
}

public struct PutApplicationPolicyOutput: Swift.Sendable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

public struct UnshareApplicationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The AWS Organization ID to unshare the application from.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.organizationId = organizationId
    }
}

public struct UpdateApplicationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A text readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeBody: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
    }
}

public struct UpdateApplicationOutput: Swift.Sendable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateApplicationVersionInput {

    static func urlPathProvider(_ value: CreateApplicationVersionInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let semanticVersion = value.semanticVersion else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions/\(semanticVersion.urlPercentEncoding())"
    }
}

extension CreateCloudFormationChangeSetInput {

    static func urlPathProvider(_ value: CreateCloudFormationChangeSetInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/changesets"
    }
}

extension CreateCloudFormationTemplateInput {

    static func urlPathProvider(_ value: CreateCloudFormationTemplateInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/templates"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension GetApplicationInput {

    static func queryItemProvider(_ value: GetApplicationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let semanticVersion = value.semanticVersion {
            let semanticVersionQueryItem = Smithy.URIQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            items.append(semanticVersionQueryItem)
        }
        return items
    }
}

extension GetApplicationPolicyInput {

    static func urlPathProvider(_ value: GetApplicationPolicyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/policy"
    }
}

extension GetCloudFormationTemplateInput {

    static func urlPathProvider(_ value: GetCloudFormationTemplateInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        guard let templateId = value.templateId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

extension ListApplicationDependenciesInput {

    static func urlPathProvider(_ value: ListApplicationDependenciesInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dependencies"
    }
}

extension ListApplicationDependenciesInput {

    static func queryItemProvider(_ value: ListApplicationDependenciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        if let semanticVersion = value.semanticVersion {
            let semanticVersionQueryItem = Smithy.URIQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
            items.append(semanticVersionQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension ListApplicationVersionsInput {

    static func urlPathProvider(_ value: ListApplicationVersionsInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions"
    }
}

extension ListApplicationVersionsInput {

    static func queryItemProvider(_ value: ListApplicationVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxItems = value.maxItems {
            let maxItemsQueryItem = Smithy.URIQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
            items.append(maxItemsQueryItem)
        }
        return items
    }
}

extension PutApplicationPolicyInput {

    static func urlPathProvider(_ value: PutApplicationPolicyInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/policy"
    }
}

extension UnshareApplicationInput {

    static func urlPathProvider(_ value: UnshareApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/unshare"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let applicationId = value.applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["author"].write(value.author)
        try writer["description"].write(value.description)
        try writer["homePageUrl"].write(value.homePageUrl)
        try writer["labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["licenseBody"].write(value.licenseBody)
        try writer["licenseUrl"].write(value.licenseUrl)
        try writer["name"].write(value.name)
        try writer["readmeBody"].write(value.readmeBody)
        try writer["readmeUrl"].write(value.readmeUrl)
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["sourceCodeArchiveUrl"].write(value.sourceCodeArchiveUrl)
        try writer["sourceCodeUrl"].write(value.sourceCodeUrl)
        try writer["spdxLicenseId"].write(value.spdxLicenseId)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateUrl"].write(value.templateUrl)
    }
}

extension CreateApplicationVersionInput {

    static func write(value: CreateApplicationVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sourceCodeArchiveUrl"].write(value.sourceCodeArchiveUrl)
        try writer["sourceCodeUrl"].write(value.sourceCodeUrl)
        try writer["templateBody"].write(value.templateBody)
        try writer["templateUrl"].write(value.templateUrl)
    }
}

extension CreateCloudFormationChangeSetInput {

    static func write(value: CreateCloudFormationChangeSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["changeSetName"].write(value.changeSetName)
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["notificationArns"].writeList(value.notificationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["parameterOverrides"].writeList(value.parameterOverrides, memberWritingClosure: ServerlessApplicationRepositoryClientTypes.ParameterValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rollbackConfiguration"].write(value.rollbackConfiguration, with: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration.write(value:to:))
        try writer["semanticVersion"].write(value.semanticVersion)
        try writer["stackName"].write(value.stackName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: ServerlessApplicationRepositoryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["templateId"].write(value.templateId)
    }
}

extension CreateCloudFormationTemplateInput {

    static func write(value: CreateCloudFormationTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["semanticVersion"].write(value.semanticVersion)
    }
}

extension PutApplicationPolicyInput {

    static func write(value: PutApplicationPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["statements"].writeList(value.statements, memberWritingClosure: ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UnshareApplicationInput {

    static func write(value: UnshareApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["organizationId"].write(value.organizationId)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["author"].write(value.author)
        try writer["description"].write(value.description)
        try writer["homePageUrl"].write(value.homePageUrl)
        try writer["labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["readmeBody"].write(value.readmeBody)
        try writer["readmeUrl"].write(value.readmeUrl)
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.homePageUrl = try reader["homePageUrl"].readIfPresent()
        value.isVerifiedAuthor = try reader["isVerifiedAuthor"].readIfPresent()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseUrl = try reader["licenseUrl"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.readmeUrl = try reader["readmeUrl"].readIfPresent()
        value.spdxLicenseId = try reader["spdxLicenseId"].readIfPresent()
        value.verifiedAuthorUrl = try reader["verifiedAuthorUrl"].readIfPresent()
        value.version = try reader["version"].readIfPresent(with: ServerlessApplicationRepositoryClientTypes.Version.read(from:))
        return value
    }
}

extension CreateApplicationVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationVersionOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.parameterDefinitions = try reader["parameterDefinitions"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ParameterDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ServerlessApplicationRepositoryClientTypes.Capability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourcesSupported = try reader["resourcesSupported"].readIfPresent()
        value.semanticVersion = try reader["semanticVersion"].readIfPresent()
        value.sourceCodeArchiveUrl = try reader["sourceCodeArchiveUrl"].readIfPresent()
        value.sourceCodeUrl = try reader["sourceCodeUrl"].readIfPresent()
        value.templateUrl = try reader["templateUrl"].readIfPresent()
        return value
    }
}

extension CreateCloudFormationChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudFormationChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudFormationChangeSetOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.changeSetId = try reader["changeSetId"].readIfPresent()
        value.semanticVersion = try reader["semanticVersion"].readIfPresent()
        value.stackId = try reader["stackId"].readIfPresent()
        return value
    }
}

extension CreateCloudFormationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCloudFormationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCloudFormationTemplateOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.expirationTime = try reader["expirationTime"].readIfPresent()
        value.semanticVersion = try reader["semanticVersion"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.templateId = try reader["templateId"].readIfPresent()
        value.templateUrl = try reader["templateUrl"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.homePageUrl = try reader["homePageUrl"].readIfPresent()
        value.isVerifiedAuthor = try reader["isVerifiedAuthor"].readIfPresent()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseUrl = try reader["licenseUrl"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.readmeUrl = try reader["readmeUrl"].readIfPresent()
        value.spdxLicenseId = try reader["spdxLicenseId"].readIfPresent()
        value.verifiedAuthorUrl = try reader["verifiedAuthorUrl"].readIfPresent()
        value.version = try reader["version"].readIfPresent(with: ServerlessApplicationRepositoryClientTypes.Version.read(from:))
        return value
    }
}

extension GetApplicationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationPolicyOutput()
        value.statements = try reader["statements"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCloudFormationTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCloudFormationTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCloudFormationTemplateOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.expirationTime = try reader["expirationTime"].readIfPresent()
        value.semanticVersion = try reader["semanticVersion"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.templateId = try reader["templateId"].readIfPresent()
        value.templateUrl = try reader["templateUrl"].readIfPresent()
        return value
    }
}

extension ListApplicationDependenciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationDependenciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationDependenciesOutput()
        value.dependencies = try reader["dependencies"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["applications"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationVersionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.versions = try reader["versions"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.VersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutApplicationPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutApplicationPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutApplicationPolicyOutput()
        value.statements = try reader["statements"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UnshareApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnshareApplicationOutput {
        return UnshareApplicationOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationId = try reader["applicationId"].readIfPresent()
        value.author = try reader["author"].readIfPresent()
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.homePageUrl = try reader["homePageUrl"].readIfPresent()
        value.isVerifiedAuthor = try reader["isVerifiedAuthor"].readIfPresent()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.licenseUrl = try reader["licenseUrl"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.readmeUrl = try reader["readmeUrl"].readIfPresent()
        value.spdxLicenseId = try reader["spdxLicenseId"].readIfPresent()
        value.verifiedAuthorUrl = try reader["verifiedAuthorUrl"].readIfPresent()
        value.version = try reader["version"].readIfPresent(with: ServerlessApplicationRepositoryClientTypes.Version.read(from:))
        return value
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudFormationChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCloudFormationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCloudFormationTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationDependenciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutApplicationPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnshareApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.Version {

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.Version {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.Version()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readIfPresent() ?? ""
        value.parameterDefinitions = try reader["parameterDefinitions"].readListIfPresent(memberReadingClosure: ServerlessApplicationRepositoryClientTypes.ParameterDefinition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.requiredCapabilities = try reader["requiredCapabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<ServerlessApplicationRepositoryClientTypes.Capability>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.resourcesSupported = try reader["resourcesSupported"].readIfPresent() ?? false
        value.semanticVersion = try reader["semanticVersion"].readIfPresent() ?? ""
        value.sourceCodeArchiveUrl = try reader["sourceCodeArchiveUrl"].readIfPresent()
        value.sourceCodeUrl = try reader["sourceCodeUrl"].readIfPresent()
        value.templateUrl = try reader["templateUrl"].readIfPresent() ?? ""
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.ParameterDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.ParameterDefinition()
        value.allowedPattern = try reader["allowedPattern"].readIfPresent()
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.constraintDescription = try reader["constraintDescription"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.maxLength = try reader["maxLength"].readIfPresent()
        value.maxValue = try reader["maxValue"].readIfPresent()
        value.minLength = try reader["minLength"].readIfPresent()
        value.minValue = try reader["minValue"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.noEcho = try reader["noEcho"].readIfPresent()
        value.referencedByResources = try reader["referencedByResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement {

    static func write(value: ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actions"].writeList(value.actions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principalOrgIDs"].writeList(value.principalOrgIDs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["principals"].writeList(value.principals, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["statementId"].write(value.statementId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.principalOrgIDs = try reader["principalOrgIDs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.principals = try reader["principals"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.statementId = try reader["statementId"].readIfPresent()
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.semanticVersion = try reader["semanticVersion"].readIfPresent() ?? ""
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.ApplicationSummary()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.author = try reader["author"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent() ?? ""
        value.homePageUrl = try reader["homePageUrl"].readIfPresent()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.spdxLicenseId = try reader["spdxLicenseId"].readIfPresent()
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.VersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServerlessApplicationRepositoryClientTypes.VersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServerlessApplicationRepositoryClientTypes.VersionSummary()
        value.applicationId = try reader["applicationId"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readIfPresent() ?? ""
        value.semanticVersion = try reader["semanticVersion"].readIfPresent() ?? ""
        value.sourceCodeUrl = try reader["sourceCodeUrl"].readIfPresent()
        return value
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterValue {

    static func write(value: ServerlessApplicationRepositoryClientTypes.ParameterValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackConfiguration {

    static func write(value: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["monitoringTimeInMinutes"].write(value.monitoringTimeInMinutes)
        try writer["rollbackTriggers"].writeList(value.rollbackTriggers, memberWritingClosure: ServerlessApplicationRepositoryClientTypes.RollbackTrigger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackTrigger {

    static func write(value: ServerlessApplicationRepositoryClientTypes.RollbackTrigger?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["type"].write(value.type)
    }
}

extension ServerlessApplicationRepositoryClientTypes.Tag {

    static func write(value: ServerlessApplicationRepositoryClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }
}

public enum ServerlessApplicationRepositoryClientTypes {}
