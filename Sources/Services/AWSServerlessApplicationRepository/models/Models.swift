// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// A nested application summary.
    public struct ApplicationDependencySummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the nested application.
        /// This member is required.
        public var applicationId: Swift.String?
        /// The semantic version of the nested application.
        /// This member is required.
        public var semanticVersion: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            semanticVersion: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.semanticVersion = semanticVersion
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "actions"
        case principalOrgIDs = "principalOrgIDs"
        case principals = "principals"
        case statementId = "statementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for __string0 in actions {
                try actionsContainer.encode(__string0)
            }
        }
        if let principalOrgIDs = principalOrgIDs {
            var principalOrgIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principalOrgIDs)
            for __string0 in principalOrgIDs {
                try principalOrgIDsContainer.encode(__string0)
            }
        }
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for __string0 in principals {
                try principalsContainer.encode(__string0)
            }
        }
        if let statementId = self.statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let principalOrgIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principalOrgIDs)
        var principalOrgIDsDecoded0:[Swift.String]? = nil
        if let principalOrgIDsContainer = principalOrgIDsContainer {
            principalOrgIDsDecoded0 = [Swift.String]()
            for string0 in principalOrgIDsContainer {
                if let string0 = string0 {
                    principalOrgIDsDecoded0?.append(string0)
                }
            }
        }
        principalOrgIDs = principalOrgIDsDecoded0
        let principalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .principals)
        var principalsDecoded0:[Swift.String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [Swift.String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let statementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statementId)
        statementId = statementIdDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Policy statement applied to the application.
    public struct ApplicationPolicyStatement: Swift.Equatable {
        /// For the list of actions supported for this operation, see [Application Permissions](https://docs.aws.amazon.com/serverlessrepo/latest/devguide/access-control-resource-based.html#application-permissions).
        /// This member is required.
        public var actions: [Swift.String]?
        /// An array of PrinciplalOrgIDs, which corresponds to AWS IAM [aws:PrincipalOrgID](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#principal-org-id) global condition key.
        public var principalOrgIDs: [Swift.String]?
        /// An array of AWS account IDs, or * to make the application public.
        /// This member is required.
        public var principals: [Swift.String]?
        /// A unique ID for the statement.
        public var statementId: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            principalOrgIDs: [Swift.String]? = nil,
            principals: [Swift.String]? = nil,
            statementId: Swift.String? = nil
        )
        {
            self.actions = actions
            self.principalOrgIDs = principalOrgIDs
            self.principals = principals
            self.statementId = statementId
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ApplicationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case name = "name"
        case spdxLicenseId = "spdxLicenseId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = self.homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __string0 in labels {
                try labelsContainer.encode(__string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let spdxLicenseId = self.spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Summary of details about the application.
    public struct ApplicationSummary: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
        /// This member is required.
        public var author: Swift.String?
        /// The date and time this resource was created.
        public var creationTime: Swift.String?
        /// The description of the application.Minimum length=1. Maximum length=256
        /// This member is required.
        public var description: Swift.String?
        /// A URL with more information about the application, for example the location of your GitHub repository for the application.
        public var homePageUrl: Swift.String?
        /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
        public var labels: [Swift.String]?
        /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
        /// This member is required.
        public var name: Swift.String?
        /// A valid identifier from [https://spdx.org/licenses/](https://spdx.org/licenses/).
        public var spdxLicenseId: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            author: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            description: Swift.String? = nil,
            homePageUrl: Swift.String? = nil,
            labels: [Swift.String]? = nil,
            name: Swift.String? = nil,
            spdxLicenseId: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.author = author
            self.creationTime = creationTime
            self.description = description
            self.homePageUrl = homePageUrl
            self.labels = labels
            self.name = name
            self.spdxLicenseId = spdxLicenseId
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the parameters in the request is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 400
        public internal(set) var errorCode: Swift.String? = nil
        /// One of the parameters in the request is invalid.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Values that must be specified in order to deploy some applications.
    public enum Capability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case capabilityAutoExpand
        case capabilityIam
        case capabilityNamedIam
        case capabilityResourcePolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [Capability] {
            return [
                .capabilityAutoExpand,
                .capabilityIam,
                .capabilityNamedIam,
                .capabilityResourcePolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .capabilityAutoExpand: return "CAPABILITY_AUTO_EXPAND"
            case .capabilityIam: return "CAPABILITY_IAM"
            case .capabilityNamedIam: return "CAPABILITY_NAMED_IAM"
            case .capabilityResourcePolicy: return "CAPABILITY_RESOURCE_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Capability(rawValue: rawValue) ?? Capability.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 409
        public internal(set) var errorCode: Swift.String? = nil
        /// The resource already exists.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = self.homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __string0 in labels {
                try labelsContainer.encode(__string0)
            }
        }
        if let licenseBody = self.licenseBody {
            try encodeContainer.encode(licenseBody, forKey: .licenseBody)
        }
        if let licenseUrl = self.licenseUrl {
            try encodeContainer.encode(licenseUrl, forKey: .licenseUrl)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let readmeBody = self.readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = self.readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = self.sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = self.sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let spdxLicenseId = self.spdxLicenseId {
            try encodeContainer.encode(spdxLicenseId, forKey: .spdxLicenseId)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = self.templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    /// This member is required.
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    /// This member is required.
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A local text file that contains the license of the app that matches the spdxLicenseID value of your application. The file has the format file://<path>/<filename>.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseBody: Swift.String?
    /// A link to the S3 object that contains the license of the app that matches the spdxLicenseID value of your application.Maximum size 5 MBYou can specify only one of licenseBody and licenseUrl; otherwise, an error results.
    public var licenseUrl: Swift.String?
    /// The name of the application that you want to publish.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    /// This member is required.
    public var name: Swift.String?
    /// A local text readme file in Markdown language that contains a more detailed description of the application and how it works. The file has the format file://<path>/<filename>.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeBody: Swift.String?
    /// A link to the S3 object in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MBYou can specify only one of readmeBody and readmeUrl; otherwise, an error results.
    public var readmeUrl: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A valid identifier from [https://spdx.org/licenses/](https://spdx.org/licenses/).
    public var spdxLicenseId: Swift.String?
    /// The local raw packaged AWS SAM template file of your application. The file has the format file://<path>/<filename>.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateBody: Swift.String?
    /// A link to the S3 object containing the packaged AWS SAM template of your application.You can specify only one of templateBody and templateUrl; otherwise an error results.
    public var templateUrl: Swift.String?

    public init(
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        licenseBody: Swift.String? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.licenseBody = licenseBody
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.spdxLicenseId = spdxLicenseId
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let author: Swift.String?
    let description: Swift.String?
    let homePageUrl: Swift.String?
    let labels: [Swift.String]?
    let licenseBody: Swift.String?
    let licenseUrl: Swift.String?
    let name: Swift.String?
    let readmeBody: Swift.String?
    let readmeUrl: Swift.String?
    let semanticVersion: Swift.String?
    let sourceCodeArchiveUrl: Swift.String?
    let sourceCodeUrl: Swift.String?
    let spdxLicenseId: Swift.String?
    let templateBody: Swift.String?
    let templateUrl: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case licenseBody = "licenseBody"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseBody)
        licenseBody = licenseBodyDecoded
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let author: Swift.String?
    let creationTime: Swift.String?
    let description: Swift.String?
    let homePageUrl: Swift.String?
    let isVerifiedAuthor: Swift.Bool?
    let labels: [Swift.String]?
    let licenseUrl: Swift.String?
    let name: Swift.String?
    let readmeUrl: Swift.String?
    let spdxLicenseId: Swift.String?
    let verifiedAuthorUrl: Swift.String?
    let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApplicationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceCodeArchiveUrl = self.sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = self.sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateBody = self.templateBody {
            try encodeContainer.encode(templateBody, forKey: .templateBody)
        }
        if let templateUrl = self.templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }
}

extension CreateApplicationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let semanticVersion = semanticVersion else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions/\(semanticVersion.urlPercentEncoding())"
    }
}

public struct CreateApplicationVersionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the new version.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// The raw packaged AWS SAM template of your application.
    public var templateBody: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateBody: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateBody = templateBody
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionInputBody: Swift.Equatable {
    let sourceCodeArchiveUrl: Swift.String?
    let sourceCodeUrl: Swift.String?
    let templateBody: Swift.String?
    let templateUrl: Swift.String?
}

extension CreateApplicationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateBody = "templateBody"
        case templateUrl = "templateUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateBody)
        templateBody = templateBodyDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension CreateApplicationVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.parameterDefinitions = output.parameterDefinitions
            self.requiredCapabilities = output.requiredCapabilities
            self.resourcesSupported = output.resourcesSupported
            self.semanticVersion = output.semanticVersion
            self.sourceCodeArchiveUrl = output.sourceCodeArchiveUrl
            self.sourceCodeUrl = output.sourceCodeUrl
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.parameterDefinitions = nil
            self.requiredCapabilities = nil
            self.resourcesSupported = nil
            self.semanticVersion = nil
            self.sourceCodeArchiveUrl = nil
            self.sourceCodeUrl = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateApplicationVersionOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// An array of parameter types supported by the application.
    public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
    /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS::TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
    public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
    /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
    public var resourcesSupported: Swift.Bool?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
    public var sourceCodeArchiveUrl: Swift.String?
    /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
    public var sourceCodeUrl: Swift.String?
    /// A link to the packaged AWS SAM template of your application.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
        requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
        resourcesSupported: Swift.Bool? = nil,
        semanticVersion: Swift.String? = nil,
        sourceCodeArchiveUrl: Swift.String? = nil,
        sourceCodeUrl: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.parameterDefinitions = parameterDefinitions
        self.requiredCapabilities = requiredCapabilities
        self.resourcesSupported = resourcesSupported
        self.semanticVersion = semanticVersion
        self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
        self.sourceCodeUrl = sourceCodeUrl
        self.templateUrl = templateUrl
    }
}

struct CreateApplicationVersionOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let creationTime: Swift.String?
    let parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
    let requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
    let resourcesSupported: Swift.Bool?
    let semanticVersion: Swift.String?
    let sourceCodeArchiveUrl: Swift.String?
    let sourceCodeUrl: Swift.String?
    let templateUrl: Swift.String?
}

extension CreateApplicationVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[ServerlessApplicationRepositoryClientTypes.Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [ServerlessApplicationRepositoryClientTypes.Capability]()
            for enum0 in requiredCapabilitiesContainer {
                if let enum0 = enum0 {
                    requiredCapabilitiesDecoded0?.append(enum0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

enum CreateApplicationVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCloudFormationChangeSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for __string0 in capabilities {
                try capabilitiesContainer.encode(__string0)
            }
        }
        if let changeSetName = self.changeSetName {
            try encodeContainer.encode(changeSetName, forKey: .changeSetName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for __string0 in notificationArns {
                try notificationArnsContainer.encode(__string0)
            }
        }
        if let parameterOverrides = parameterOverrides {
            var parameterOverridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterOverrides)
            for parametervalue0 in parameterOverrides {
                try parameterOverridesContainer.encode(parametervalue0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for __string0 in resourceTypes {
                try resourceTypesContainer.encode(__string0)
            }
        }
        if let rollbackConfiguration = self.rollbackConfiguration {
            try encodeContainer.encode(rollbackConfiguration, forKey: .rollbackConfiguration)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let templateId = self.templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }
}

extension CreateCloudFormationChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/changesets"
    }
}

public struct CreateCloudFormationChangeSetInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS:TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
    public var capabilities: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var changeSetName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var clientToken: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var description: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var notificationArns: [Swift.String]?
    /// A list of parameter values for the parameters of the application.
    public var parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var resourceTypes: [Swift.String]?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    /// This member is required.
    public var stackName: Swift.String?
    /// This property corresponds to the parameter of the same name for the AWS CloudFormation [CreateChangeSet](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/CreateChangeSet) API.
    public var tags: [ServerlessApplicationRepositoryClientTypes.Tag]?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        changeSetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]? = nil,
        resourceTypes: [Swift.String]? = nil,
        rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration? = nil,
        semanticVersion: Swift.String? = nil,
        stackName: Swift.String? = nil,
        tags: [ServerlessApplicationRepositoryClientTypes.Tag]? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.capabilities = capabilities
        self.changeSetName = changeSetName
        self.clientToken = clientToken
        self.description = description
        self.notificationArns = notificationArns
        self.parameterOverrides = parameterOverrides
        self.resourceTypes = resourceTypes
        self.rollbackConfiguration = rollbackConfiguration
        self.semanticVersion = semanticVersion
        self.stackName = stackName
        self.tags = tags
        self.templateId = templateId
    }
}

struct CreateCloudFormationChangeSetInputBody: Swift.Equatable {
    let capabilities: [Swift.String]?
    let changeSetName: Swift.String?
    let clientToken: Swift.String?
    let description: Swift.String?
    let notificationArns: [Swift.String]?
    let parameterOverrides: [ServerlessApplicationRepositoryClientTypes.ParameterValue]?
    let resourceTypes: [Swift.String]?
    let rollbackConfiguration: ServerlessApplicationRepositoryClientTypes.RollbackConfiguration?
    let semanticVersion: Swift.String?
    let stackName: Swift.String?
    let tags: [ServerlessApplicationRepositoryClientTypes.Tag]?
    let templateId: Swift.String?
}

extension CreateCloudFormationChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities = "capabilities"
        case changeSetName = "changeSetName"
        case clientToken = "clientToken"
        case description = "description"
        case notificationArns = "notificationArns"
        case parameterOverrides = "parameterOverrides"
        case resourceTypes = "resourceTypes"
        case rollbackConfiguration = "rollbackConfiguration"
        case semanticVersion = "semanticVersion"
        case stackName = "stackName"
        case tags = "tags"
        case templateId = "templateId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let changeSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetName)
        changeSetName = changeSetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let parameterOverridesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterValue?].self, forKey: .parameterOverrides)
        var parameterOverridesDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterValue]? = nil
        if let parameterOverridesContainer = parameterOverridesContainer {
            parameterOverridesDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterValue]()
            for structure0 in parameterOverridesContainer {
                if let structure0 = structure0 {
                    parameterOverridesDecoded0?.append(structure0)
                }
            }
        }
        parameterOverrides = parameterOverridesDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[Swift.String]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [Swift.String]()
            for string0 in resourceTypesContainer {
                if let string0 = string0 {
                    resourceTypesDecoded0?.append(string0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let rollbackConfigurationDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.RollbackConfiguration.self, forKey: .rollbackConfiguration)
        rollbackConfiguration = rollbackConfigurationDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServerlessApplicationRepositoryClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServerlessApplicationRepositoryClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension CreateCloudFormationChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCloudFormationChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.changeSetId = output.changeSetId
            self.semanticVersion = output.semanticVersion
            self.stackId = output.stackId
        } else {
            self.applicationId = nil
            self.changeSetId = nil
            self.semanticVersion = nil
            self.stackId = nil
        }
    }
}

public struct CreateCloudFormationChangeSetOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the change set.Length constraints: Minimum length of 1.Pattern: ARN:[-a-zA-Z0-9:/]*
    public var changeSetId: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// The unique ID of the stack.
    public var stackId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        changeSetId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        stackId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.changeSetId = changeSetId
        self.semanticVersion = semanticVersion
        self.stackId = stackId
    }
}

struct CreateCloudFormationChangeSetOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let changeSetId: Swift.String?
    let semanticVersion: Swift.String?
    let stackId: Swift.String?
}

extension CreateCloudFormationChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case changeSetId = "changeSetId"
        case semanticVersion = "semanticVersion"
        case stackId = "stackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let changeSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeSetId)
        changeSetId = changeSetIdDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

enum CreateCloudFormationChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCloudFormationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
    }
}

extension CreateCloudFormationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/templates"
    }
}

public struct CreateCloudFormationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct CreateCloudFormationTemplateInputBody: Swift.Equatable {
    let semanticVersion: Swift.String?
}

extension CreateCloudFormationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case semanticVersion = "semanticVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
    }
}

extension CreateCloudFormationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCloudFormationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct CreateCloudFormationTemplateOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct CreateCloudFormationTemplateOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let creationTime: Swift.String?
    let expirationTime: Swift.String?
    let semanticVersion: Swift.String?
    let status: ServerlessApplicationRepositoryClientTypes.Status?
    let templateId: Swift.String?
    let templateUrl: Swift.String?
}

extension CreateCloudFormationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

enum CreateCloudFormationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is not authenticated.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 403
        public internal(set) var errorCode: Swift.String? = nil
        /// The client is not authenticated.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApplicationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let semanticVersion = semanticVersion {
                let semanticVersionQueryItem = ClientRuntime.URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
                items.append(semanticVersionQueryItem)
            }
            return items
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.semanticVersion = semanticVersion
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct GetApplicationOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct GetApplicationOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let author: Swift.String?
    let creationTime: Swift.String?
    let description: Swift.String?
    let homePageUrl: Swift.String?
    let isVerifiedAuthor: Swift.Bool?
    let labels: [Swift.String]?
    let licenseUrl: Swift.String?
    let name: Swift.String?
    let readmeUrl: Swift.String?
    let spdxLicenseId: Swift.String?
    let verifiedAuthorUrl: Swift.String?
    let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension GetApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/policy"
    }
}

public struct GetApplicationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationPolicyInputBody: Swift.Equatable {
}

extension GetApplicationPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct GetApplicationPolicyOutput: Swift.Equatable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct GetApplicationPolicyOutputBody: Swift.Equatable {
    let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension GetApplicationPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

enum GetApplicationPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCloudFormationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let templateId = templateId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/templates/\(templateId.urlPercentEncoding())"
    }
}

public struct GetCloudFormationTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    /// This member is required.
    public var templateId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        templateId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.templateId = templateId
    }
}

struct GetCloudFormationTemplateInputBody: Swift.Equatable {
}

extension GetCloudFormationTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCloudFormationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCloudFormationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.semanticVersion = output.semanticVersion
            self.status = output.status
            self.templateId = output.templateId
            self.templateUrl = output.templateUrl
        } else {
            self.applicationId = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.semanticVersion = nil
            self.status = nil
            self.templateId = nil
            self.templateUrl = nil
        }
    }
}

public struct GetCloudFormationTemplateOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The date and time this template expires. Templates expire 1 hour after creation.
    public var expirationTime: Swift.String?
    /// The semantic version of the application: [https://semver.org/](https://semver.org/)
    public var semanticVersion: Swift.String?
    /// Status of the template creation workflow.Possible values: PREPARING | ACTIVE | EXPIRED
    public var status: ServerlessApplicationRepositoryClientTypes.Status?
    /// The UUID returned by CreateCloudFormationTemplate.Pattern: [0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}
    public var templateId: Swift.String?
    /// A link to the template that can be used to deploy the application using AWS CloudFormation.
    public var templateUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        expirationTime: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        status: ServerlessApplicationRepositoryClientTypes.Status? = nil,
        templateId: Swift.String? = nil,
        templateUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.semanticVersion = semanticVersion
        self.status = status
        self.templateId = templateId
        self.templateUrl = templateUrl
    }
}

struct GetCloudFormationTemplateOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let creationTime: Swift.String?
    let expirationTime: Swift.String?
    let semanticVersion: Swift.String?
    let status: ServerlessApplicationRepositoryClientTypes.Status?
    let templateId: Swift.String?
    let templateUrl: Swift.String?
}

extension GetCloudFormationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case expirationTime = "expirationTime"
        case semanticVersion = "semanticVersion"
        case status = "status"
        case templateId = "templateId"
        case templateUrl = "templateUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateId)
        templateId = templateIdDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

enum GetCloudFormationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The AWS Serverless Application Repository service encountered an internal error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 500
        public internal(set) var errorCode: Swift.String? = nil
        /// The AWS Serverless Application Repository service encountered an internal error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationDependenciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            if let semanticVersion = semanticVersion {
                let semanticVersionQueryItem = ClientRuntime.URLQueryItem(name: "semanticVersion".urlPercentEncoding(), value: Swift.String(semanticVersion).urlPercentEncoding())
                items.append(semanticVersionQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationDependenciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/dependencies"
    }
}

public struct ListApplicationDependenciesInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?
    /// The semantic version of the application to get.
    public var semanticVersion: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        semanticVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
        self.semanticVersion = semanticVersion
    }
}

struct ListApplicationDependenciesInputBody: Swift.Equatable {
}

extension ListApplicationDependenciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationDependenciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationDependenciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.nextToken = output.nextToken
        } else {
            self.dependencies = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationDependenciesOutput: Swift.Equatable {
    /// An array of application summaries nested in the application.
    public var dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.nextToken = nextToken
    }
}

struct ListApplicationDependenciesOutputBody: Swift.Equatable {
    let dependencies: [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]?
    let nextToken: Swift.String?
}

extension ListApplicationDependenciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies = "dependencies"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dependenciesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary?].self, forKey: .dependencies)
        var dependenciesDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationDependencySummary]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationDependenciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/versions"
    }
}

public struct ListApplicationVersionsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationVersionsInputBody: Swift.Equatable {
}

extension ListApplicationVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListApplicationVersionsOutput: Swift.Equatable {
    /// The token to request the next page of results.
    public var nextToken: Swift.String?
    /// An array of version summaries for the application.
    public var versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListApplicationVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [ServerlessApplicationRepositoryClientTypes.VersionSummary]?
}

extension ListApplicationVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case versions = "versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.VersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[ServerlessApplicationRepositoryClientTypes.VersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.VersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListApplicationVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxItems = maxItems {
                let maxItemsQueryItem = ClientRuntime.URLQueryItem(name: "maxItems".urlPercentEncoding(), value: Swift.String(maxItems).urlPercentEncoding())
                items.append(maxItemsQueryItem)
            }
            return items
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The total number of items to return.
    public var maxItems: Swift.Int?
    /// A token to specify where to start paginating.
    public var nextToken: Swift.String?

    public init(
        maxItems: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxItems = maxItems
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// An array of application summaries.
    public var applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]?
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "applications"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationSummary?].self, forKey: .applications)
        var applicationsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationSummary]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationSummary]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource (for example, an access policy statement) specified in the request doesn't exist.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 404
        public internal(set) var errorCode: Swift.String? = nil
        /// The resource (for example, an access policy statement) specified in the request doesn't exist.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes.ParameterDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "allowedPattern"
        case allowedValues = "allowedValues"
        case constraintDescription = "constraintDescription"
        case defaultValue = "defaultValue"
        case description = "description"
        case maxLength = "maxLength"
        case maxValue = "maxValue"
        case minLength = "minLength"
        case minValue = "minValue"
        case name = "name"
        case noEcho = "noEcho"
        case referencedByResources = "referencedByResources"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = self.allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for __string0 in allowedValues {
                try allowedValuesContainer.encode(__string0)
            }
        }
        if let constraintDescription = self.constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let maxLength = self.maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let maxValue = self.maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minLength = self.minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let minValue = self.minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let noEcho = self.noEcho {
            try encodeContainer.encode(noEcho, forKey: .noEcho)
        }
        if let referencedByResources = referencedByResources {
            var referencedByResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referencedByResources)
            for __string0 in referencedByResources {
                try referencedByResourcesContainer.encode(__string0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLength)
        minLength = minLengthDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let noEchoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let referencedByResourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referencedByResources)
        var referencedByResourcesDecoded0:[Swift.String]? = nil
        if let referencedByResourcesContainer = referencedByResourcesContainer {
            referencedByResourcesDecoded0 = [Swift.String]()
            for string0 in referencedByResourcesContainer {
                if let string0 = string0 {
                    referencedByResourcesDecoded0?.append(string0)
                }
            }
        }
        referencedByResources = referencedByResourcesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Parameters supported by the application.
    public struct ParameterDefinition: Swift.Equatable {
        /// A regular expression that represents the patterns to allow for String types.
        public var allowedPattern: Swift.String?
        /// An array containing the list of values allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value: Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+ By adding a constraint description, such as "must contain only uppercase and lowercase letters and numbers," you can display the following customized error message: Malformed input-Parameter MyParameter must contain only uppercase and lowercase letters and numbers.
        public var constraintDescription: Swift.String?
        /// A value of the appropriate type for the template to use if no value is specified when a stack is created. If you define constraints for the parameter, you must specify a value that adheres to those constraints.
        public var defaultValue: Swift.String?
        /// A string of up to 4,000 characters that describes the parameter.
        public var description: Swift.String?
        /// An integer value that determines the largest number of characters that you want to allow for String types.
        public var maxLength: Swift.Int?
        /// A numeric value that determines the largest numeric value that you want to allow for Number types.
        public var maxValue: Swift.Int?
        /// An integer value that determines the smallest number of characters that you want to allow for String types.
        public var minLength: Swift.Int?
        /// A numeric value that determines the smallest numeric value that you want to allow for Number types.
        public var minValue: Swift.Int?
        /// The name of the parameter.
        /// This member is required.
        public var name: Swift.String?
        /// Whether to mask the parameter value whenever anyone makes a call that describes the stack. If you set the value to true, the parameter value is masked with asterisks (*****).
        public var noEcho: Swift.Bool?
        /// A list of AWS SAM resources that use this parameter.
        /// This member is required.
        public var referencedByResources: [Swift.String]?
        /// The type of the parameter.Valid values: String | Number | List<Number> | CommaDelimitedList String: A literal string.For example, users can specify "MyUserName". Number: An integer or float. AWS CloudFormation validates the parameter value as a number. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a string.For example, users might specify "8888". List<Number>: An array of integers or floats that are separated by commas. AWS CloudFormation validates the parameter value as numbers. However, when you use the parameter elsewhere in your template (for example, by using the Ref intrinsic function), the parameter value becomes a list of strings.For example, users might specify "80,20", and then Ref results in ["80","20"]. CommaDelimitedList: An array of literal strings that are separated by commas. The total number of strings should be one more than the total number of commas. Also, each member string is space-trimmed.For example, users might specify "test,dev,prod", and then Ref results in ["test","dev","prod"].
        public var type: Swift.String?

        public init(
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            maxLength: Swift.Int? = nil,
            maxValue: Swift.Int? = nil,
            minLength: Swift.Int? = nil,
            minValue: Swift.Int? = nil,
            name: Swift.String? = nil,
            noEcho: Swift.Bool? = nil,
            referencedByResources: [Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.defaultValue = defaultValue
            self.description = description
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
            self.name = name
            self.noEcho = noEcho
            self.referencedByResources = referencedByResources
            self.type = type
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.ParameterValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Parameter value of the application.
    public struct ParameterValue: Swift.Equatable {
        /// The key associated with the parameter. If you don't specify a key and value for a particular parameter, AWS CloudFormation uses the default value that is specified in your template.
        /// This member is required.
        public var name: Swift.String?
        /// The input value associated with the parameter.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension PutApplicationPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statements = statements {
            var statementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statements)
            for applicationpolicystatement0 in statements {
                try statementsContainer.encode(applicationpolicystatement0)
            }
        }
    }
}

extension PutApplicationPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/policy"
    }
}

public struct PutApplicationPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// An array of policy statements applied to the application.
    /// This member is required.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        applicationId: Swift.String? = nil,
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.applicationId = applicationId
        self.statements = statements
    }
}

struct PutApplicationPolicyInputBody: Swift.Equatable {
    let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension PutApplicationPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

extension PutApplicationPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutApplicationPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.statements = output.statements
        } else {
            self.statements = nil
        }
    }
}

public struct PutApplicationPolicyOutput: Swift.Equatable {
    /// An array of policy statements applied to the application.
    public var statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?

    public init(
        statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
    )
    {
        self.statements = statements
    }
}

struct PutApplicationPolicyOutputBody: Swift.Equatable {
    let statements: [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]?
}

extension PutApplicationPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statements = "statements"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement?].self, forKey: .statements)
        var statementsDecoded0:[ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]? = nil
        if let statementsContainer = statementsContainer {
            statementsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ApplicationPolicyStatement]()
            for structure0 in statementsContainer {
                if let structure0 = structure0 {
                    statementsDecoded0?.append(structure0)
                }
            }
        }
        statements = statementsDecoded0
    }
}

enum PutApplicationPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes.RollbackConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitoringTimeInMinutes = "monitoringTimeInMinutes"
        case rollbackTriggers = "rollbackTriggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitoringTimeInMinutes = self.monitoringTimeInMinutes {
            try encodeContainer.encode(monitoringTimeInMinutes, forKey: .monitoringTimeInMinutes)
        }
        if let rollbackTriggers = rollbackTriggers {
            var rollbackTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rollbackTriggers)
            for rollbacktrigger0 in rollbackTriggers {
                try rollbackTriggersContainer.encode(rollbacktrigger0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoringTimeInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .monitoringTimeInMinutes)
        monitoringTimeInMinutes = monitoringTimeInMinutesDecoded
        let rollbackTriggersContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.RollbackTrigger?].self, forKey: .rollbackTriggers)
        var rollbackTriggersDecoded0:[ServerlessApplicationRepositoryClientTypes.RollbackTrigger]? = nil
        if let rollbackTriggersContainer = rollbackTriggersContainer {
            rollbackTriggersDecoded0 = [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]()
            for structure0 in rollbackTriggersContainer {
                if let structure0 = structure0 {
                    rollbackTriggersDecoded0?.append(structure0)
                }
            }
        }
        rollbackTriggers = rollbackTriggersDecoded0
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
    public struct RollbackConfiguration: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
        public var monitoringTimeInMinutes: Swift.Int?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackConfiguration](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackConfiguration) Data Type.
        public var rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]?

        public init(
            monitoringTimeInMinutes: Swift.Int? = nil,
            rollbackTriggers: [ServerlessApplicationRepositoryClientTypes.RollbackTrigger]? = nil
        )
        {
            self.monitoringTimeInMinutes = monitoringTimeInMinutes
            self.rollbackTriggers = rollbackTriggers
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.RollbackTrigger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
    public struct RollbackTrigger: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
        /// This member is required.
        public var arn: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [RollbackTrigger](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/RollbackTrigger) Data Type.
        /// This member is required.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .expired,
                .preparing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// This property corresponds to the AWS CloudFormation [Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
    public struct Tag: Swift.Equatable {
        /// This property corresponds to the content of the same name for the AWS CloudFormation [Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
        /// This member is required.
        public var key: Swift.String?
        /// This property corresponds to the content of the same name for the AWS CloudFormation [ Tag](https://docs.aws.amazon.com/goto/WebAPI/cloudformation-2010-05-15/Tag) Data Type.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is sending more than the allowed number of requests per unit of time.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 429
        public internal(set) var errorCode: Swift.String? = nil
        /// The client is sending more than the allowed number of requests per unit of time.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "errorCode"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnshareApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "organizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = self.organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

extension UnshareApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/unshare"
    }
}

public struct UnshareApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The AWS Organization ID to unshare the application from.
    /// This member is required.
    public var organizationId: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.organizationId = organizationId
    }
}

struct UnshareApplicationInputBody: Swift.Equatable {
    let organizationId: Swift.String?
}

extension UnshareApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "organizationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension UnshareApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnshareApplicationOutput: Swift.Equatable {

    public init() { }
}

enum UnshareApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let homePageUrl = self.homePageUrl {
            try encodeContainer.encode(homePageUrl, forKey: .homePageUrl)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for __string0 in labels {
                try labelsContainer.encode(__string0)
            }
        }
        if let readmeBody = self.readmeBody {
            try encodeContainer.encode(readmeBody, forKey: .readmeBody)
        }
        if let readmeUrl = self.readmeUrl {
            try encodeContainer.encode(readmeUrl, forKey: .readmeUrl)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the application.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A text readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeBody: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        readmeBody: Swift.String? = nil,
        readmeUrl: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.description = description
        self.homePageUrl = homePageUrl
        self.labels = labels
        self.readmeBody = readmeBody
        self.readmeUrl = readmeUrl
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let author: Swift.String?
    let description: Swift.String?
    let homePageUrl: Swift.String?
    let labels: [Swift.String]?
    let readmeBody: Swift.String?
    let readmeUrl: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case author = "author"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case labels = "labels"
        case readmeBody = "readmeBody"
        case readmeUrl = "readmeUrl"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let readmeBodyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeBody)
        readmeBody = readmeBodyDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.author = output.author
            self.creationTime = output.creationTime
            self.description = output.description
            self.homePageUrl = output.homePageUrl
            self.isVerifiedAuthor = output.isVerifiedAuthor
            self.labels = output.labels
            self.licenseUrl = output.licenseUrl
            self.name = output.name
            self.readmeUrl = output.readmeUrl
            self.spdxLicenseId = output.spdxLicenseId
            self.verifiedAuthorUrl = output.verifiedAuthorUrl
            self.version = output.version
        } else {
            self.applicationId = nil
            self.author = nil
            self.creationTime = nil
            self.description = nil
            self.homePageUrl = nil
            self.isVerifiedAuthor = nil
            self.labels = nil
            self.licenseUrl = nil
            self.name = nil
            self.readmeUrl = nil
            self.spdxLicenseId = nil
            self.verifiedAuthorUrl = nil
            self.version = nil
        }
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {
    /// The application Amazon Resource Name (ARN).
    public var applicationId: Swift.String?
    /// The name of the author publishing the app.Minimum length=1. Maximum length=127.Pattern "^[a-z0-9](([a-z0-9]|-(?!-))*[a-z0-9])?$";
    public var author: Swift.String?
    /// The date and time this resource was created.
    public var creationTime: Swift.String?
    /// The description of the application.Minimum length=1. Maximum length=256
    public var description: Swift.String?
    /// A URL with more information about the application, for example the location of your GitHub repository for the application.
    public var homePageUrl: Swift.String?
    /// Whether the author of this application has been verified. This means means that AWS has made a good faith review, as a reasonable and prudent service provider, of the information provided by the requester and has confirmed that the requester's identity is as claimed.
    public var isVerifiedAuthor: Swift.Bool?
    /// Labels to improve discovery of apps in search results.Minimum length=1. Maximum length=127. Maximum number of labels: 10Pattern: "^[a-zA-Z0-9+\\-_:\\/@]+$";
    public var labels: [Swift.String]?
    /// A link to a license file of the app that matches the spdxLicenseID value of your application.Maximum size 5 MB
    public var licenseUrl: Swift.String?
    /// The name of the application.Minimum length=1. Maximum length=140Pattern: "[a-zA-Z0-9\\-]+";
    public var name: Swift.String?
    /// A link to the readme file in Markdown language that contains a more detailed description of the application and how it works.Maximum size 5 MB
    public var readmeUrl: Swift.String?
    /// A valid identifier from https://spdx.org/licenses/.
    public var spdxLicenseId: Swift.String?
    /// The URL to the public profile of a verified author. This URL is submitted by the author.
    public var verifiedAuthorUrl: Swift.String?
    /// Version information about the application.
    public var version: ServerlessApplicationRepositoryClientTypes.Version?

    public init(
        applicationId: Swift.String? = nil,
        author: Swift.String? = nil,
        creationTime: Swift.String? = nil,
        description: Swift.String? = nil,
        homePageUrl: Swift.String? = nil,
        isVerifiedAuthor: Swift.Bool? = nil,
        labels: [Swift.String]? = nil,
        licenseUrl: Swift.String? = nil,
        name: Swift.String? = nil,
        readmeUrl: Swift.String? = nil,
        spdxLicenseId: Swift.String? = nil,
        verifiedAuthorUrl: Swift.String? = nil,
        version: ServerlessApplicationRepositoryClientTypes.Version? = nil
    )
    {
        self.applicationId = applicationId
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.homePageUrl = homePageUrl
        self.isVerifiedAuthor = isVerifiedAuthor
        self.labels = labels
        self.licenseUrl = licenseUrl
        self.name = name
        self.readmeUrl = readmeUrl
        self.spdxLicenseId = spdxLicenseId
        self.verifiedAuthorUrl = verifiedAuthorUrl
        self.version = version
    }
}

struct UpdateApplicationOutputBody: Swift.Equatable {
    let applicationId: Swift.String?
    let author: Swift.String?
    let creationTime: Swift.String?
    let description: Swift.String?
    let homePageUrl: Swift.String?
    let isVerifiedAuthor: Swift.Bool?
    let labels: [Swift.String]?
    let licenseUrl: Swift.String?
    let name: Swift.String?
    let readmeUrl: Swift.String?
    let spdxLicenseId: Swift.String?
    let verifiedAuthorUrl: Swift.String?
    let version: ServerlessApplicationRepositoryClientTypes.Version?
}

extension UpdateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case author = "author"
        case creationTime = "creationTime"
        case description = "description"
        case homePageUrl = "homePageUrl"
        case isVerifiedAuthor = "isVerifiedAuthor"
        case labels = "labels"
        case licenseUrl = "licenseUrl"
        case name = "name"
        case readmeUrl = "readmeUrl"
        case spdxLicenseId = "spdxLicenseId"
        case verifiedAuthorUrl = "verifiedAuthorUrl"
        case version = "version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let homePageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePageUrl)
        homePageUrl = homePageUrlDecoded
        let isVerifiedAuthorDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isVerifiedAuthor)
        isVerifiedAuthor = isVerifiedAuthorDecoded
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let licenseUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseUrl)
        licenseUrl = licenseUrlDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let readmeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readmeUrl)
        readmeUrl = readmeUrlDecoded
        let spdxLicenseIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spdxLicenseId)
        spdxLicenseId = spdxLicenseIdDecoded
        let verifiedAuthorUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verifiedAuthorUrl)
        verifiedAuthorUrl = verifiedAuthorUrlDecoded
        let versionDecoded = try containerValues.decodeIfPresent(ServerlessApplicationRepositoryClientTypes.Version.self, forKey: .version)
        version = versionDecoded
    }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServerlessApplicationRepositoryClientTypes.Version: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case parameterDefinitions = "parameterDefinitions"
        case requiredCapabilities = "requiredCapabilities"
        case resourcesSupported = "resourcesSupported"
        case semanticVersion = "semanticVersion"
        case sourceCodeArchiveUrl = "sourceCodeArchiveUrl"
        case sourceCodeUrl = "sourceCodeUrl"
        case templateUrl = "templateUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let parameterDefinitions = parameterDefinitions {
            var parameterDefinitionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterDefinitions)
            for parameterdefinition0 in parameterDefinitions {
                try parameterDefinitionsContainer.encode(parameterdefinition0)
            }
        }
        if let requiredCapabilities = requiredCapabilities {
            var requiredCapabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .requiredCapabilities)
            for capability0 in requiredCapabilities {
                try requiredCapabilitiesContainer.encode(capability0.rawValue)
            }
        }
        if let resourcesSupported = self.resourcesSupported {
            try encodeContainer.encode(resourcesSupported, forKey: .resourcesSupported)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeArchiveUrl = self.sourceCodeArchiveUrl {
            try encodeContainer.encode(sourceCodeArchiveUrl, forKey: .sourceCodeArchiveUrl)
        }
        if let sourceCodeUrl = self.sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
        if let templateUrl = self.templateUrl {
            try encodeContainer.encode(templateUrl, forKey: .templateUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let parameterDefinitionsContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.ParameterDefinition?].self, forKey: .parameterDefinitions)
        var parameterDefinitionsDecoded0:[ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil
        if let parameterDefinitionsContainer = parameterDefinitionsContainer {
            parameterDefinitionsDecoded0 = [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]()
            for structure0 in parameterDefinitionsContainer {
                if let structure0 = structure0 {
                    parameterDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        parameterDefinitions = parameterDefinitionsDecoded0
        let requiredCapabilitiesContainer = try containerValues.decodeIfPresent([ServerlessApplicationRepositoryClientTypes.Capability?].self, forKey: .requiredCapabilities)
        var requiredCapabilitiesDecoded0:[ServerlessApplicationRepositoryClientTypes.Capability]? = nil
        if let requiredCapabilitiesContainer = requiredCapabilitiesContainer {
            requiredCapabilitiesDecoded0 = [ServerlessApplicationRepositoryClientTypes.Capability]()
            for enum0 in requiredCapabilitiesContainer {
                if let enum0 = enum0 {
                    requiredCapabilitiesDecoded0?.append(enum0)
                }
            }
        }
        requiredCapabilities = requiredCapabilitiesDecoded0
        let resourcesSupportedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .resourcesSupported)
        resourcesSupported = resourcesSupportedDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeArchiveUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeArchiveUrl)
        sourceCodeArchiveUrl = sourceCodeArchiveUrlDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
        let templateUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .templateUrl)
        templateUrl = templateUrlDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// Application version details.
    public struct Version: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// An array of parameter types supported by the application.
        /// This member is required.
        public var parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]?
        /// A list of values that you must specify before you can deploy certain applications. Some applications might include resources that can affect permissions in your AWS account, for example, by creating new AWS Identity and Access Management (IAM) users. For those applications, you must explicitly acknowledge their capabilities by specifying this parameter.The only valid values are CAPABILITY_IAM, CAPABILITY_NAMED_IAM, CAPABILITY_RESOURCE_POLICY, and CAPABILITY_AUTO_EXPAND.The following resources require you to specify CAPABILITY_IAM or CAPABILITY_NAMED_IAM: [AWS::IAM::Group](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iam-group.html), [AWS::IAM::InstanceProfile](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html), [AWS::IAM::Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), and [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html). If the application contains IAM resources, you can specify either CAPABILITY_IAM or CAPABILITY_NAMED_IAM. If the application contains IAM resources with custom names, you must specify CAPABILITY_NAMED_IAM.The following resources require you to specify CAPABILITY_RESOURCE_POLICY: [AWS::Lambda::Permission](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html), [AWS::IAM:Policy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-policy.html), [AWS::ApplicationAutoScaling::ScalingPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-applicationautoscaling-scalingpolicy.html), [AWS::S3::BucketPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-policy.html), [AWS::SQS::QueuePolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sqs-policy.html), and [AWS::SNS::TopicPolicy](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sns-policy.html).Applications that contain one or more nested applications require you to specify CAPABILITY_AUTO_EXPAND.If your application template contains any of the above resources, we recommend that you review all permissions associated with the application before deploying. If you don't specify this parameter for an application that requires capabilities, the call will fail.
        /// This member is required.
        public var requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]?
        /// Whether all of the AWS resources contained in this application are supported in the region in which it is being retrieved.
        /// This member is required.
        public var resourcesSupported: Swift.Bool?
        /// The semantic version of the application: [https://semver.org/](https://semver.org/)
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to the S3 object that contains the ZIP archive of the source code for this version of your application.Maximum size 50 MB
        public var sourceCodeArchiveUrl: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?
        /// A link to the packaged AWS SAM template of your application.
        /// This member is required.
        public var templateUrl: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            parameterDefinitions: [ServerlessApplicationRepositoryClientTypes.ParameterDefinition]? = nil,
            requiredCapabilities: [ServerlessApplicationRepositoryClientTypes.Capability]? = nil,
            resourcesSupported: Swift.Bool? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeArchiveUrl: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil,
            templateUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.parameterDefinitions = parameterDefinitions
            self.requiredCapabilities = requiredCapabilities
            self.resourcesSupported = resourcesSupported
            self.semanticVersion = semanticVersion
            self.sourceCodeArchiveUrl = sourceCodeArchiveUrl
            self.sourceCodeUrl = sourceCodeUrl
            self.templateUrl = templateUrl
        }
    }

}

extension ServerlessApplicationRepositoryClientTypes.VersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "applicationId"
        case creationTime = "creationTime"
        case semanticVersion = "semanticVersion"
        case sourceCodeUrl = "sourceCodeUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = self.applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encode(creationTime, forKey: .creationTime)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let sourceCodeUrl = self.sourceCodeUrl {
            try encodeContainer.encode(sourceCodeUrl, forKey: .sourceCodeUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let sourceCodeUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeUrl)
        sourceCodeUrl = sourceCodeUrlDecoded
    }
}

extension ServerlessApplicationRepositoryClientTypes {
    /// An application version summary.
    public struct VersionSummary: Swift.Equatable {
        /// The application Amazon Resource Name (ARN).
        /// This member is required.
        public var applicationId: Swift.String?
        /// The date and time this resource was created.
        /// This member is required.
        public var creationTime: Swift.String?
        /// The semantic version of the application: [https://semver.org/](https://semver.org/)
        /// This member is required.
        public var semanticVersion: Swift.String?
        /// A link to a public repository for the source code of your application, for example the URL of a specific GitHub commit.
        public var sourceCodeUrl: Swift.String?

        public init(
            applicationId: Swift.String? = nil,
            creationTime: Swift.String? = nil,
            semanticVersion: Swift.String? = nil,
            sourceCodeUrl: Swift.String? = nil
        )
        {
            self.applicationId = applicationId
            self.creationTime = creationTime
            self.semanticVersion = semanticVersion
            self.sourceCodeUrl = sourceCodeUrl
        }
    }

}
