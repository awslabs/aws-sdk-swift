//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have sufficient permissions to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDenied" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was throttled because of quota limits.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource is not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct BatchGetServiceLevelObjectiveBudgetReportInput {
    /// An array containing the IDs of the service level objectives that you want to include in the report.
    /// This member is required.
    public var sloIds: [Swift.String]?
    /// The date and time that you want the report to be for. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
    /// This member is required.
    public var timestamp: Foundation.Date?

    public init(
        sloIds: [Swift.String]? = nil,
        timestamp: Foundation.Date? = nil
    )
    {
        self.sloIds = sloIds
        self.timestamp = timestamp
    }
}

extension ApplicationSignalsClientTypes {
    /// A structure containing information about one error that occurred during a [BatchGetServiceLevelObjectiveBudgetReport](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_BatchGetServiceLevelObjectiveBudgetReport.html) operation.
    public struct ServiceLevelObjectiveBudgetReportError {
        /// The ARN of the SLO that this error is related to.
        /// This member is required.
        public var arn: Swift.String?
        /// The error code for this error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message for this error.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The name of the SLO that this error is related to.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.name = name
        }
    }

}

extension ApplicationSignalsClientTypes {

    public enum ServiceLevelObjectiveBudgetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case breached
        case insufficientData
        case ok
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceLevelObjectiveBudgetStatus] {
            return [
                .breached,
                .insufficientData,
                .ok,
                .warning
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .breached: return "BREACHED"
            case .insufficientData: return "INSUFFICIENT_DATA"
            case .ok: return "OK"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {

    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case periodBased
        case requestBased
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .periodBased,
                .requestBased
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .periodBased: return "PeriodBased"
            case .requestBased: return "RequestBased"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {

    public enum DurationUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case minute
        case month
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnit] {
            return [
                .day,
                .hour,
                .minute,
                .month
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case .month: return "MONTH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {
    /// If the interval for this service level objective is a calendar interval, this structure contains the interval specifications.
    public struct CalendarInterval {
        /// Specifies the duration of each calendar interval. For example, if Duration is 1 and DurationUnit is MONTH, each interval is one month, aligned with the calendar.
        /// This member is required.
        public var duration: Swift.Int?
        /// Specifies the calendar interval unit.
        /// This member is required.
        public var durationUnit: ApplicationSignalsClientTypes.DurationUnit?
        /// The date and time when you want the first interval to start. Be sure to choose a time that configures the intervals the way that you want. For example, if you want weekly intervals starting on Mondays at 6 a.m., be sure to specify a start time that is a Monday at 6 a.m. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 As soon as one calendar interval ends, another automatically begins.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            duration: Swift.Int? = nil,
            durationUnit: ApplicationSignalsClientTypes.DurationUnit? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.duration = duration
            self.durationUnit = durationUnit
            self.startTime = startTime
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// If the interval for this SLO is a rolling interval, this structure contains the interval specifications.
    public struct RollingInterval {
        /// Specifies the duration of each rolling interval. For example, if Duration is 7 and DurationUnit is DAY, each rolling interval is seven days.
        /// This member is required.
        public var duration: Swift.Int?
        /// Specifies the rolling interval unit.
        /// This member is required.
        public var durationUnit: ApplicationSignalsClientTypes.DurationUnit?

        public init(
            duration: Swift.Int? = nil,
            durationUnit: ApplicationSignalsClientTypes.DurationUnit? = nil
        )
        {
            self.duration = duration
            self.durationUnit = durationUnit
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// The time period used to evaluate the SLO. It can be either a calendar interval or rolling interval.
    public enum Interval {
        /// If the interval is a rolling interval, this structure contains the interval specifications.
        case rollinginterval(ApplicationSignalsClientTypes.RollingInterval)
        /// If the interval is a calendar interval, this structure contains the interval specifications.
        case calendarinterval(ApplicationSignalsClientTypes.CalendarInterval)
        case sdkUnknown(Swift.String)
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.
    public struct Goal {
        /// The threshold that determines if the goal is being met. If this is a period-based SLO, the attainment goal is the percentage of good periods that meet the threshold requirements to the total periods within the interval. For example, an attainment goal of 99.9% means that within your interval, you are targeting 99.9% of the periods to be in healthy state. If this is a request-based SLO, the attainment goal is the percentage of requests that must be successful to meet the attainment goal. If you omit this parameter, 99 is used to represent 99% as the attainment goal.
        public var attainmentGoal: Swift.Double?
        /// The time period used to evaluate the SLO. It can be either a calendar interval or rolling interval. If you omit this parameter, a rolling interval of 7 days is used.
        public var interval: ApplicationSignalsClientTypes.Interval?
        /// The percentage of remaining budget over total budget that you want to get warnings for. If you omit this parameter, the default of 50.0 is used.
        public var warningThreshold: Swift.Double?

        public init(
            attainmentGoal: Swift.Double? = nil,
            interval: ApplicationSignalsClientTypes.Interval? = nil,
            warningThreshold: Swift.Double? = nil
        )
        {
            self.attainmentGoal = attainmentGoal
            self.interval = interval
            self.warningThreshold = warningThreshold
        }
    }

}

extension ApplicationSignalsClientTypes {

    public enum ServiceLevelIndicatorComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greaterThan
        case greaterThanOrEqualTo
        case lessThan
        case lessThanOrEqualTo
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceLevelIndicatorComparisonOperator] {
            return [
                .greaterThan,
                .greaterThanOrEqualTo,
                .lessThan,
                .lessThanOrEqualTo
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greaterThan: return "GreaterThan"
            case .greaterThanOrEqualTo: return "GreaterThanOrEqualTo"
            case .lessThan: return "LessThan"
            case .lessThanOrEqualTo: return "LessThanOrEqualTo"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {

    public enum ServiceLevelIndicatorMetricType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case availability
        case latency
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceLevelIndicatorMetricType] {
            return [
                .availability,
                .latency
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .availability: return "AVAILABILITY"
            case .latency: return "LATENCY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {
    /// A dimension is a name/value pair that is part of the identity of a metric. Because dimensions are part of the unique identifier for a metric, whenever you add a unique name/value pair to one of your metrics, you are creating a new variation of that metric. For example, many Amazon EC2 metrics publish InstanceId as a dimension name, and the actual instance ID as the value for that dimension. You can assign up to 30 dimensions to a metric.
    public struct Dimension {
        /// The name of the dimension. Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:). ASCII control characters are not supported as part of dimension names.
        /// This member is required.
        public var name: Swift.String?
        /// The value of the dimension. Dimension values must contain only ASCII characters and must include at least one non-whitespace character. ASCII control characters are not supported as part of dimension values.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure defines the metric used for a service level indicator, including the metric name, namespace, and dimensions
    public struct Metric {
        /// An array of one or more dimensions to use to define the metric that you want to use. For more information, see [Dimensions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension).
        public var dimensions: [ApplicationSignalsClientTypes.Dimension]?
        /// The name of the metric to use.
        public var metricName: Swift.String?
        /// The namespace of the metric. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        public var namespace: Swift.String?

        public init(
            dimensions: [ApplicationSignalsClientTypes.Dimension]? = nil,
            metricName: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metricName = metricName
            self.namespace = namespace
        }
    }

}

extension ApplicationSignalsClientTypes {

    public enum StandardUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bitsSecond
        case bytes
        case bytesSecond
        case count
        case countSecond
        case gigabits
        case gigabitsSecond
        case gigabytes
        case gigabytesSecond
        case kilobits
        case kilobitsSecond
        case kilobytes
        case kilobytesSecond
        case megabits
        case megabitsSecond
        case megabytes
        case megabytesSecond
        case microseconds
        case milliseconds
        case `none`
        case percent
        case seconds
        case terabits
        case terabitsSecond
        case terabytes
        case terabytesSecond
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardUnit] {
            return [
                .bits,
                .bitsSecond,
                .bytes,
                .bytesSecond,
                .count,
                .countSecond,
                .gigabits,
                .gigabitsSecond,
                .gigabytes,
                .gigabytesSecond,
                .kilobits,
                .kilobitsSecond,
                .kilobytes,
                .kilobytesSecond,
                .megabits,
                .megabitsSecond,
                .megabytes,
                .megabytesSecond,
                .microseconds,
                .milliseconds,
                .none,
                .percent,
                .seconds,
                .terabits,
                .terabitsSecond,
                .terabytes,
                .terabytesSecond
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "Bits"
            case .bitsSecond: return "Bits/Second"
            case .bytes: return "Bytes"
            case .bytesSecond: return "Bytes/Second"
            case .count: return "Count"
            case .countSecond: return "Count/Second"
            case .gigabits: return "Gigabits"
            case .gigabitsSecond: return "Gigabits/Second"
            case .gigabytes: return "Gigabytes"
            case .gigabytesSecond: return "Gigabytes/Second"
            case .kilobits: return "Kilobits"
            case .kilobitsSecond: return "Kilobits/Second"
            case .kilobytes: return "Kilobytes"
            case .kilobytesSecond: return "Kilobytes/Second"
            case .megabits: return "Megabits"
            case .megabitsSecond: return "Megabits/Second"
            case .megabytes: return "Megabytes"
            case .megabytesSecond: return "Megabytes/Second"
            case .microseconds: return "Microseconds"
            case .milliseconds: return "Milliseconds"
            case .none: return "None"
            case .percent: return "Percent"
            case .seconds: return "Seconds"
            case .terabits: return "Terabits"
            case .terabitsSecond: return "Terabits/Second"
            case .terabytes: return "Terabytes"
            case .terabytesSecond: return "Terabytes/Second"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure defines the metric to be used as the service level indicator, along with the statistics, period, and unit.
    public struct MetricStat {
        /// The metric to use as the service level indicator, including the metric name, namespace, and dimensions.
        /// This member is required.
        public var metric: ApplicationSignalsClientTypes.Metric?
        /// The granularity, in seconds, to be used for the metric. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a PutMetricData call that includes a StorageResolution of 1 second.
        /// This member is required.
        public var period: Swift.Int?
        /// The statistic to use for comparison to the threshold. It can be any CloudWatch statistic or extended statistic. For more information about statistics, see [CloudWatch statistics definitions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
        /// This member is required.
        public var stat: Swift.String?
        /// If you omit Unit then all data that was collected with any unit is returned, along with the corresponding units that were specified when the data was reported to CloudWatch. If you specify a unit, the operation returns only data that was collected with that unit specified. If you specify a unit that does not match the data collected, the results of the operation are null. CloudWatch does not perform unit conversions.
        public var unit: ApplicationSignalsClientTypes.StandardUnit?

        public init(
            metric: ApplicationSignalsClientTypes.Metric? = nil,
            period: Swift.Int? = nil,
            stat: Swift.String? = nil,
            unit: ApplicationSignalsClientTypes.StandardUnit? = nil
        )
        {
            self.metric = metric
            self.period = period
            self.stat = stat
            self.unit = unit
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// Use this structure to define a metric or metric math expression that you want to use as for a service level objective. Each MetricDataQuery in the MetricDataQueries array specifies either a metric to retrieve, or a metric math expression to be performed on retrieved metrics. A single MetricDataQueries array can include as many as 20 MetricDataQuery structures in the array. The 20 structures can include as many as 10 structures that contain a MetricStat parameter to retrieve a metric, and as many as 10 structures that contain the Expression parameter to perform a math expression. Of those Expression structures, exactly one must have true as the value for ReturnData. The result of this expression used for the SLO. For more information about metric math expressions, see [CloudWatchUse metric math](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html). Within each MetricDataQuery object, you must specify either Expression or MetricStat but not both.
    public struct MetricDataQuery {
        /// The ID of the account where this metric is located. If you are performing this operation in a monitoring account, use this to specify which source account to retrieve this metric from.
        public var accountId: Swift.String?
        /// This field can contain a metric math expression to be performed on the other metrics that you are retrieving within this MetricDataQueries structure. A math expression can use the Id of the other metrics or queries to refer to those metrics, and can also use the Id of other expressions to use the result of those expressions. For more information about metric math expressions, see [Metric Math Syntax and Functions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html#metric-math-syntax) in the Amazon CloudWatch User Guide. Within each MetricDataQuery object, you must specify either Expression or MetricStat but not both.
        public var expression: Swift.String?
        /// A short name used to tie this object to the results in the response. This Id must be unique within a MetricDataQueries array. If you are performing math expressions on this set of data, this name represents that data and can serve as a variable in the metric math expression. The valid characters are letters, numbers, and underscore. The first character must be a lowercase letter.
        /// This member is required.
        public var id: Swift.String?
        /// A human-readable label for this metric or expression. This is especially useful if this is an expression, so that you know what the value represents. If the metric or expression is shown in a CloudWatch dashboard widget, the label is shown. If Label is omitted, CloudWatch generates a default. You can put dynamic expressions into a label, so that it is more descriptive. For more information, see [Using Dynamic Labels](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/graph-dynamic-labels.html).
        public var label: Swift.String?
        /// A metric to be used directly for the SLO, or to be used in the math expression that will be used for the SLO. Within one MetricDataQuery object, you must specify either Expression or MetricStat but not both.
        public var metricStat: ApplicationSignalsClientTypes.MetricStat?
        /// The granularity, in seconds, of the returned data points for this metric. For metrics with regular resolution, a period can be as short as one minute (60 seconds) and must be a multiple of 60. For high-resolution metrics that are collected at intervals of less than one minute, the period can be 1, 5, 10, 30, 60, or any multiple of 60. High-resolution metrics are those metrics stored by a PutMetricData call that includes a StorageResolution of 1 second. If the StartTime parameter specifies a time stamp that is greater than 3 hours ago, you must specify the period as follows or no data points in that time range is returned:
        ///
        /// * Start time between 3 hours and 15 days ago - Use a multiple of 60 seconds (1 minute).
        ///
        /// * Start time between 15 and 63 days ago - Use a multiple of 300 seconds (5 minutes).
        ///
        /// * Start time greater than 63 days ago - Use a multiple of 3600 seconds (1 hour).
        public var period: Swift.Int?
        /// Use this only if you are using a metric math expression for the SLO. Specify true for ReturnData for only the one expression result to use as the alarm. For all other metrics and expressions in the same CreateServiceLevelObjective operation, specify ReturnData as false.
        public var returnData: Swift.Bool?

        public init(
            accountId: Swift.String? = nil,
            expression: Swift.String? = nil,
            id: Swift.String? = nil,
            label: Swift.String? = nil,
            metricStat: ApplicationSignalsClientTypes.MetricStat? = nil,
            period: Swift.Int? = nil,
            returnData: Swift.Bool? = nil
        )
        {
            self.accountId = accountId
            self.expression = expression
            self.id = id
            self.label = label
            self.metricStat = metricStat
            self.period = period
            self.returnData = returnData
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure defines the metric that is used as the "good request" or "bad request" value for a request-based SLO. This value observed for the metric defined in TotalRequestCountMetric is divided by the number found for MonitoredRequestCountMetric to determine the percentage of successful requests that this SLO tracks.
    public enum MonitoredRequestCountMetricDataQueries {
        /// If you want to count "good requests" to determine the percentage of successful requests for this request-based SLO, specify the metric to use as "good requests" in this structure.
        case goodcountmetric([ApplicationSignalsClientTypes.MetricDataQuery])
        /// If you want to count "bad requests" to determine the percentage of successful requests for this request-based SLO, specify the metric to use as "bad requests" in this structure.
        case badcountmetric([ApplicationSignalsClientTypes.MetricDataQuery])
        case sdkUnknown(Swift.String)
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains the information about the metric that is used for a request-based SLO.
    public struct RequestBasedServiceLevelIndicatorMetric {
        /// This is a string-to-string map that contains information about the type of object that this SLO is related to. It can include the following fields.
        ///
        /// * Type designates the type of object that this SLO is related to.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// If the SLO monitors either the LATENCY or AVAILABILITY metric that Application Signals collects, this field displays which of those metrics is used.
        public var metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType?
        /// This structure defines the metric that is used as the "good request" or "bad request" value for a request-based SLO. This value observed for the metric defined in TotalRequestCountMetric is divided by the number found for MonitoredRequestCountMetric to determine the percentage of successful requests that this SLO tracks.
        /// This member is required.
        public var monitoredRequestCountMetric: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries?
        /// If the SLO monitors a specific operation of the service, this field displays that operation name.
        public var operationName: Swift.String?
        /// This structure defines the metric that is used as the "total requests" number for a request-based SLO. The number observed for this metric is divided by the number of "good requests" or "bad requests" that is observed for the metric defined in MonitoredRequestCountMetric.
        /// This member is required.
        public var totalRequestCountMetric: [ApplicationSignalsClientTypes.MetricDataQuery]?

        public init(
            keyAttributes: [Swift.String: Swift.String]? = nil,
            metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType? = nil,
            monitoredRequestCountMetric: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries? = nil,
            operationName: Swift.String? = nil,
            totalRequestCountMetric: [ApplicationSignalsClientTypes.MetricDataQuery]? = nil
        )
        {
            self.keyAttributes = keyAttributes
            self.metricType = metricType
            self.monitoredRequestCountMetric = monitoredRequestCountMetric
            self.operationName = operationName
            self.totalRequestCountMetric = totalRequestCountMetric
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about the performance metric that a request-based SLO monitors.
    public struct RequestBasedServiceLevelIndicator {
        /// The arithmetic operation used when comparing the specified metric to the threshold.
        public var comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator?
        /// This value is the threshold that the observed metric values of the SLI metric are compared to.
        public var metricThreshold: Swift.Double?
        /// A structure that contains information about the metric that the SLO monitors.
        /// This member is required.
        public var requestBasedSliMetric: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric?

        public init(
            comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator? = nil,
            metricThreshold: Swift.Double? = nil,
            requestBasedSliMetric: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.requestBasedSliMetric = requestBasedSliMetric
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains the information about the metric that is used for a period-based SLO.
    public struct ServiceLevelIndicatorMetric {
        /// This is a string-to-string map that contains information about the type of object that this SLO is related to. It can include the following fields.
        ///
        /// * Type designates the type of object that this SLO is related to.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// If this SLO monitors a CloudWatch metric or the result of a CloudWatch metric math expression, this structure includes the information about that metric or expression.
        /// This member is required.
        public var metricDataQueries: [ApplicationSignalsClientTypes.MetricDataQuery]?
        /// If the SLO monitors either the LATENCY or AVAILABILITY metric that Application Signals collects, this field displays which of those metrics is used.
        public var metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType?
        /// If the SLO monitors a specific operation of the service, this field displays that operation name.
        public var operationName: Swift.String?

        public init(
            keyAttributes: [Swift.String: Swift.String]? = nil,
            metricDataQueries: [ApplicationSignalsClientTypes.MetricDataQuery]? = nil,
            metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType? = nil,
            operationName: Swift.String? = nil
        )
        {
            self.keyAttributes = keyAttributes
            self.metricDataQueries = metricDataQueries
            self.metricType = metricType
            self.operationName = operationName
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about the performance metric that a period-based SLO monitors.
    public struct ServiceLevelIndicator {
        /// The arithmetic operation used when comparing the specified metric to the threshold.
        /// This member is required.
        public var comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator?
        /// The value that the SLI metric is compared to.
        /// This member is required.
        public var metricThreshold: Swift.Double?
        /// A structure that contains information about the metric that the SLO monitors.
        /// This member is required.
        public var sliMetric: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric?

        public init(
            comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator? = nil,
            metricThreshold: Swift.Double? = nil,
            sliMetric: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.sliMetric = sliMetric
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// A structure containing an SLO budget report that you have requested.
    public struct ServiceLevelObjectiveBudgetReport {
        /// The ARN of the SLO that this report is for.
        /// This member is required.
        public var arn: Swift.String?
        /// A number between 0 and 100 that represents the success percentage of your application compared to the goal set by the SLO. If this is a period-based SLO, the number is the percentage of time periods that the service has attained the SLO's attainment goal, as of the time of the request. If this is a request-based SLO, the number is the number of successful requests divided by the number of total requests, multiplied by 100, during the time range that you specified in your request.
        public var attainment: Swift.Double?
        /// This field is displayed only for request-based SLOs. It displays the number of failed requests that can be tolerated before any more successful requests occur, and still have the application meet its SLO goal. This number can go up and down between different reports, based on both how many successful requests and how many failed requests occur in that time.
        public var budgetRequestsRemaining: Swift.Int?
        /// The budget amount remaining before the SLO status becomes BREACHING, at the time specified in the Timestemp parameter of the request. If this value is negative, then the SLO is already in BREACHING status. This field is included only if the SLO is a period-based SLO.
        public var budgetSecondsRemaining: Swift.Int?
        /// The status of this SLO, as it relates to the error budget for the entire time interval.
        ///
        /// * OK means that the SLO had remaining budget above the warning threshold, as of the time that you specified in TimeStamp.
        ///
        /// * WARNING means that the SLO's remaining budget was below the warning threshold, as of the time that you specified in TimeStamp.
        ///
        /// * BREACHED means that the SLO's budget was exhausted, as of the time that you specified in TimeStamp.
        ///
        /// * INSUFFICIENT_DATA means that the specified start and end times were before the SLO was created, or that attainment data is missing.
        /// This member is required.
        public var budgetStatus: ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetStatus?
        /// Displays whether this budget report is for a period-based SLO or a request-based SLO.
        public var evaluationType: ApplicationSignalsClientTypes.EvaluationType?
        /// This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.
        public var goal: ApplicationSignalsClientTypes.Goal?
        /// The name of the SLO that this report is for.
        /// This member is required.
        public var name: Swift.String?
        /// This structure contains information about the performance metric that a request-based SLO monitors.
        public var requestBasedSli: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator?
        /// A structure that contains information about the performance metric that this SLO monitors.
        public var sli: ApplicationSignalsClientTypes.ServiceLevelIndicator?
        /// This field is displayed only for request-based SLOs. It displays the total number of failed requests that can be tolerated during the time range between the start of the interval and the time stamp supplied in the budget report request. It is based on the total number of requests that occurred, and the percentage specified in the attainment goal. If the number of failed requests matches this number or is higher, then this SLO is currently breaching. This number can go up and down between reports with different time stamps, based on both how many total requests occur.
        public var totalBudgetRequests: Swift.Int?
        /// The total number of seconds in the error budget for the interval. This field is included only if the SLO is a period-based SLO.
        public var totalBudgetSeconds: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            attainment: Swift.Double? = nil,
            budgetRequestsRemaining: Swift.Int? = nil,
            budgetSecondsRemaining: Swift.Int? = nil,
            budgetStatus: ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetStatus? = nil,
            evaluationType: ApplicationSignalsClientTypes.EvaluationType? = nil,
            goal: ApplicationSignalsClientTypes.Goal? = nil,
            name: Swift.String? = nil,
            requestBasedSli: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator? = nil,
            sli: ApplicationSignalsClientTypes.ServiceLevelIndicator? = nil,
            totalBudgetRequests: Swift.Int? = nil,
            totalBudgetSeconds: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.attainment = attainment
            self.budgetRequestsRemaining = budgetRequestsRemaining
            self.budgetSecondsRemaining = budgetSecondsRemaining
            self.budgetStatus = budgetStatus
            self.evaluationType = evaluationType
            self.goal = goal
            self.name = name
            self.requestBasedSli = requestBasedSli
            self.sli = sli
            self.totalBudgetRequests = totalBudgetRequests
            self.totalBudgetSeconds = totalBudgetSeconds
        }
    }

}

public struct BatchGetServiceLevelObjectiveBudgetReportOutput {
    /// An array of structures, where each structure includes an error indicating that one of the requests in the array was not valid.
    /// This member is required.
    public var errors: [ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError]?
    /// An array of structures, where each structure is one budget report.
    /// This member is required.
    public var reports: [ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport]?
    /// The date and time that the report is for. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
    /// This member is required.
    public var timestamp: Foundation.Date?

    public init(
        errors: [ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError]? = nil,
        reports: [ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport]? = nil,
        timestamp: Foundation.Date? = nil
    )
    {
        self.errors = errors
        self.reports = reports
        self.timestamp = timestamp
    }
}

public struct GetServiceInput {
    /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
    ///
    /// * Type designates the type of object this is.
    ///
    /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
    ///
    /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Environment specifies the location where this object is hosted, or what it belongs to.
    /// This member is required.
    public var keyAttributes: [Swift.String: Swift.String]?
    /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        keyAttributes: [Swift.String: Swift.String]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.keyAttributes = keyAttributes
        self.startTime = startTime
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about one CloudWatch metric associated with this entity discovered by Application Signals.
    public struct MetricReference {
        /// An array of one or more dimensions that further define the metric. For more information, see [CloudWatchDimensions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Dimension).
        public var dimensions: [ApplicationSignalsClientTypes.Dimension]?
        /// The name of the metric.
        /// This member is required.
        public var metricName: Swift.String?
        /// Used to display the appropriate statistics in the CloudWatch console.
        /// This member is required.
        public var metricType: Swift.String?
        /// The namespace of the metric. For more information, see [CloudWatchNamespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        /// This member is required.
        public var namespace: Swift.String?

        public init(
            dimensions: [ApplicationSignalsClientTypes.Dimension]? = nil,
            metricName: Swift.String? = nil,
            metricType: Swift.String? = nil,
            namespace: Swift.String? = nil
        )
        {
            self.dimensions = dimensions
            self.metricName = metricName
            self.metricType = metricType
            self.namespace = namespace
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about one of your services that was discovered by Application Signals.
    public struct Service {
        /// This structure contains one or more string-to-string maps that help identify this service. It can include platform attributes, application attributes, and telemetry attributes. Platform attributes contain information the service's platform.
        ///
        /// * PlatformType defines the hosted-in platform.
        ///
        /// * EKS.Cluster is the name of the Amazon EKS cluster.
        ///
        /// * K8s.Cluster is the name of the self-hosted Kubernetes cluster.
        ///
        /// * K8s.Namespace is the name of the Kubernetes namespace in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Workload is the name of the Kubernetes workload in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Node is the name of the Kubernetes node in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Pod is the name of the Kubernetes pod in either Amazon EKS or Kubernetes clusters.
        ///
        /// * EC2.AutoScalingGroup is the name of the Amazon EC2 Auto Scaling group.
        ///
        /// * EC2.InstanceId is the ID of the Amazon EC2 instance.
        ///
        /// * Host is the name of the host, for all platform types.
        ///
        ///
        /// Application attributes contain information about the application.
        ///
        /// * AWS.Application is the application's name in Amazon Web Services Service Catalog AppRegistry.
        ///
        /// * AWS.Application.ARN is the application's ARN in Amazon Web Services Service Catalog AppRegistry.
        ///
        ///
        /// Telemetry attributes contain telemetry information.
        ///
        /// * Telemetry.SDK is the fingerprint of the OpenTelemetry SDK version for instrumented services.
        ///
        /// * Telemetry.Agent is the fingerprint of the agent used to collect and send telemetry data.
        ///
        /// * Telemetry.Source Specifies the point of application where the telemetry was collected or specifies what was used for the source of telemetry data.
        public var attributeMaps: [[Swift.String: Swift.String]]?
        /// This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        /// This member is required.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// An array of string-to-string maps that each contain information about one log group associated with this service. Each string-to-string map includes the following fields:
        ///
        /// * "Type": "AWS::Resource"
        ///
        /// * "ResourceType": "AWS::Logs::LogGroup"
        ///
        /// * "Identifier": "name-of-log-group"
        public var logGroupReferences: [[Swift.String: Swift.String]]?
        /// An array of structures that each contain information about one metric associated with this service.
        /// This member is required.
        public var metricReferences: [ApplicationSignalsClientTypes.MetricReference]?

        public init(
            attributeMaps: [[Swift.String: Swift.String]]? = nil,
            keyAttributes: [Swift.String: Swift.String]? = nil,
            logGroupReferences: [[Swift.String: Swift.String]]? = nil,
            metricReferences: [ApplicationSignalsClientTypes.MetricReference]? = nil
        )
        {
            self.attributeMaps = attributeMaps
            self.keyAttributes = keyAttributes
            self.logGroupReferences = logGroupReferences
            self.metricReferences = metricReferences
        }
    }

}

public struct GetServiceOutput {
    /// The end time of the data included in the response. In a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057. This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// An array of string-to-string maps that each contain information about one log group associated with this service. Each string-to-string map includes the following fields:
    ///
    /// * "Type": "AWS::Resource"
    ///
    /// * "ResourceType": "AWS::Logs::LogGroup"
    ///
    /// * "Identifier": "name-of-log-group"
    public var logGroupReferences: [[Swift.String: Swift.String]]?
    /// A structure containing information about the service.
    /// This member is required.
    public var service: ApplicationSignalsClientTypes.Service?
    /// The start time of the data included in the response. In a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057. This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        logGroupReferences: [[Swift.String: Swift.String]]? = nil,
        service: ApplicationSignalsClientTypes.Service? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.logGroupReferences = logGroupReferences
        self.service = service
        self.startTime = startTime
    }
}

public struct ListServiceDependenciesInput {
    /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested end time will be rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
    ///
    /// * Type designates the type of object this is.
    ///
    /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
    ///
    /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Environment specifies the location where this object is hosted, or what it belongs to.
    /// This member is required.
    public var keyAttributes: [Swift.String: Swift.String]?
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of service dependencies.
    public var nextToken: Swift.String?
    /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        keyAttributes: [Swift.String: Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.keyAttributes = keyAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about one dependency of this service.
    public struct ServiceDependency {
        /// This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        /// This member is required.
        public var dependencyKeyAttributes: [Swift.String: Swift.String]?
        /// The name of the called operation in the dependency.
        /// This member is required.
        public var dependencyOperationName: Swift.String?
        /// An array of structures that each contain information about one metric associated with this service dependency that was discovered by Application Signals.
        /// This member is required.
        public var metricReferences: [ApplicationSignalsClientTypes.MetricReference]?
        /// The name of the operation in this service that calls the dependency.
        /// This member is required.
        public var operationName: Swift.String?

        public init(
            dependencyKeyAttributes: [Swift.String: Swift.String]? = nil,
            dependencyOperationName: Swift.String? = nil,
            metricReferences: [ApplicationSignalsClientTypes.MetricReference]? = nil,
            operationName: Swift.String? = nil
        )
        {
            self.dependencyKeyAttributes = dependencyKeyAttributes
            self.dependencyOperationName = dependencyOperationName
            self.metricReferences = metricReferences
            self.operationName = operationName
        }
    }

}

public struct ListServiceDependenciesOutput {
    /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Include this value in your next use of this API to get next set of service dependencies.
    public var nextToken: Swift.String?
    /// An array, where each object in the array contains information about one of the dependencies of this service.
    /// This member is required.
    public var serviceDependencies: [ApplicationSignalsClientTypes.ServiceDependency]?
    /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        serviceDependencies: [ApplicationSignalsClientTypes.ServiceDependency]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.serviceDependencies = serviceDependencies
        self.startTime = startTime
    }
}

public struct ListServiceDependentsInput {
    /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
    ///
    /// * Type designates the type of object this is.
    ///
    /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
    ///
    /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Environment specifies the location where this object is hosted, or what it belongs to.
    /// This member is required.
    public var keyAttributes: [Swift.String: Swift.String]?
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of service dependents.
    public var nextToken: Swift.String?
    /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        keyAttributes: [Swift.String: Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.keyAttributes = keyAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about a service dependent that was discovered by Application Signals. A dependent is an entity that invoked the specified service during the provided time range. Dependents include other services, CloudWatch Synthetics canaries, and clients that are instrumented with CloudWatch RUM app monitors.
    public struct ServiceDependent {
        /// This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        /// This member is required.
        public var dependentKeyAttributes: [Swift.String: Swift.String]?
        /// If the dependent invoker was a service that invoked it from an operation, the name of that dependent operation is displayed here.
        public var dependentOperationName: Swift.String?
        /// An array of structures that each contain information about one metric associated with this service dependent that was discovered by Application Signals.
        /// This member is required.
        public var metricReferences: [ApplicationSignalsClientTypes.MetricReference]?
        /// If the invoked entity is an operation on an entity, the name of that dependent operation is displayed here.
        public var operationName: Swift.String?

        public init(
            dependentKeyAttributes: [Swift.String: Swift.String]? = nil,
            dependentOperationName: Swift.String? = nil,
            metricReferences: [ApplicationSignalsClientTypes.MetricReference]? = nil,
            operationName: Swift.String? = nil
        )
        {
            self.dependentKeyAttributes = dependentKeyAttributes
            self.dependentOperationName = dependentOperationName
            self.metricReferences = metricReferences
            self.operationName = operationName
        }
    }

}

public struct ListServiceDependentsOutput {
    /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Include this value in your next use of this API to get next set of service dependents.
    public var nextToken: Swift.String?
    /// An array, where each object in the array contains information about one of the dependents of this service.
    /// This member is required.
    public var serviceDependents: [ApplicationSignalsClientTypes.ServiceDependent]?
    /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        serviceDependents: [ApplicationSignalsClientTypes.ServiceDependent]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.serviceDependents = serviceDependents
        self.startTime = startTime
    }
}

public struct ListServiceOperationsInput {
    /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested end time will be rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Use this field to specify which service you want to retrieve information for. You must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
    ///
    /// * Type designates the type of object this is.
    ///
    /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
    ///
    /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Environment specifies the location where this object is hosted, or what it belongs to.
    /// This member is required.
    public var keyAttributes: [Swift.String: Swift.String]?
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of service operations.
    public var nextToken: Swift.String?
    /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        keyAttributes: [Swift.String: Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.keyAttributes = keyAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about an operation discovered by Application Signals. An operation is a specific function performed by a service that was discovered by Application Signals, and is often an API that is called by an upstream dependent.
    public struct ServiceOperation {
        /// An array of structures that each contain information about one metric associated with this service operation that was discovered by Application Signals.
        /// This member is required.
        public var metricReferences: [ApplicationSignalsClientTypes.MetricReference]?
        /// The name of the operation, discovered by Application Signals.
        /// This member is required.
        public var name: Swift.String?

        public init(
            metricReferences: [ApplicationSignalsClientTypes.MetricReference]? = nil,
            name: Swift.String? = nil
        )
        {
            self.metricReferences = metricReferences
            self.name = name
        }
    }

}

public struct ListServiceOperationsOutput {
    /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Include this value in your next use of this API to get next set of service operations.
    public var nextToken: Swift.String?
    /// An array of structures that each contain information about one operation of this service.
    /// This member is required.
    public var serviceOperations: [ApplicationSignalsClientTypes.ServiceOperation]?
    /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        serviceOperations: [ApplicationSignalsClientTypes.ServiceOperation]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.serviceOperations = serviceOperations
        self.startTime = startTime
    }
}

public struct ListServicesInput {
    /// The end of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of services.
    public var nextToken: Swift.String?
    /// The start of the time period to retrieve information about. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 Your requested start time will be rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ApplicationSignalsClientTypes {
    /// This structure contains information about one of your services that was discovered by Application Signals
    public struct ServiceSummary {
        /// This structure contains one or more string-to-string maps that help identify this service. It can include platform attributes, application attributes, and telemetry attributes. Platform attributes contain information the service's platform.
        ///
        /// * PlatformType defines the hosted-in platform.
        ///
        /// * EKS.Cluster is the name of the Amazon EKS cluster.
        ///
        /// * K8s.Cluster is the name of the self-hosted Kubernetes cluster.
        ///
        /// * K8s.Namespace is the name of the Kubernetes namespace in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Workload is the name of the Kubernetes workload in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Node is the name of the Kubernetes node in either Amazon EKS or Kubernetes clusters.
        ///
        /// * K8s.Pod is the name of the Kubernetes pod in either Amazon EKS or Kubernetes clusters.
        ///
        /// * EC2.AutoScalingGroup is the name of the Amazon EC2 Auto Scaling group.
        ///
        /// * EC2.InstanceId is the ID of the Amazon EC2 instance.
        ///
        /// * Host is the name of the host, for all platform types.
        ///
        ///
        /// Application attributes contain information about the application.
        ///
        /// * AWS.Application is the application's name in Amazon Web Services Service Catalog AppRegistry.
        ///
        /// * AWS.Application.ARN is the application's ARN in Amazon Web Services Service Catalog AppRegistry.
        ///
        ///
        /// Telemetry attributes contain telemetry information.
        ///
        /// * Telemetry.SDK is the fingerprint of the OpenTelemetry SDK version for instrumented services.
        ///
        /// * Telemetry.Agent is the fingerprint of the agent used to collect and send telemetry data.
        ///
        /// * Telemetry.Source Specifies the point of application where the telemetry was collected or specifies what was used for the source of telemetry data.
        public var attributeMaps: [[Swift.String: Swift.String]]?
        /// This is a string-to-string map that help identify the objects discovered by Application Signals. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        /// This member is required.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// An array of structures that each contain information about one metric associated with this service.
        /// This member is required.
        public var metricReferences: [ApplicationSignalsClientTypes.MetricReference]?

        public init(
            attributeMaps: [[Swift.String: Swift.String]]? = nil,
            keyAttributes: [Swift.String: Swift.String]? = nil,
            metricReferences: [ApplicationSignalsClientTypes.MetricReference]? = nil
        )
        {
            self.attributeMaps = attributeMaps
            self.keyAttributes = keyAttributes
            self.metricReferences = metricReferences
        }
    }

}

public struct ListServicesOutput {
    /// The end of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// Include this value in your next use of this API to get next set of services.
    public var nextToken: Swift.String?
    /// An array of structures, where each structure contains some information about a service. To get complete information about a service, use [GetService](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_GetService.html).
    /// This member is required.
    public var serviceSummaries: [ApplicationSignalsClientTypes.ServiceSummary]?
    /// The start of the time period that the returned information applies to. When used in a raw HTTP Query API, it is formatted as be epoch time in seconds. For example: 1698778057 This displays the time that Application Signals used for the request. It might not match your request exactly, because it was rounded to the nearest hour.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        serviceSummaries: [ApplicationSignalsClientTypes.ServiceSummary]? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.serviceSummaries = serviceSummaries
        self.startTime = startTime
    }
}

/// Resource not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Can't find the resource id.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type is not valid.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to view tags for. The ARN format of an Application Signals SLO is arn:aws:cloudwatch:Region:account-id:slo:slo-name  For more information about ARN format, see [ Resource Types Defined by Amazon CloudWatch](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ApplicationSignalsClientTypes {
    /// A key-value pair associated with a resource. Tags can help you organize and categorize your resources.
    public struct Tag {
        /// A string that you can use to assign a value. The combination of tag keys and values can help you organize and categorize your resources.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the specified tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct ListTagsForResourceOutput {
    /// The list of tag keys and values associated with the resource you specified.
    public var tags: [ApplicationSignalsClientTypes.Tag]?

    public init(
        tags: [ApplicationSignalsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

/// This operation attempted to create a resource that already exists.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ApplicationSignalsClientTypes {
    /// Use this structure to specify the information for the metric that a period-based SLO will monitor.
    public struct RequestBasedServiceLevelIndicatorMetricConfig {
        /// If this SLO is related to a metric collected by Application Signals, you must use this field to specify which service the SLO metric is related to. To do so, you must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// If the SLO is to monitor either the LATENCY or AVAILABILITY metric that Application Signals collects, use this field to specify which of those metrics is used.
        public var metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType?
        /// Use this structure to define the metric that you want to use as the "good request" or "bad request" value for a request-based SLO. This value observed for the metric defined in TotalRequestCountMetric will be divided by the number found for MonitoredRequestCountMetric to determine the percentage of successful requests that this SLO tracks.
        public var monitoredRequestCountMetric: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries?
        /// If the SLO is to monitor a specific operation of the service, use this field to specify the name of that operation.
        public var operationName: Swift.String?
        /// Use this structure to define the metric that you want to use as the "total requests" number for a request-based SLO. This result will be divided by the "good request" or "bad request" value defined in MonitoredRequestCountMetric.
        public var totalRequestCountMetric: [ApplicationSignalsClientTypes.MetricDataQuery]?

        public init(
            keyAttributes: [Swift.String: Swift.String]? = nil,
            metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType? = nil,
            monitoredRequestCountMetric: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries? = nil,
            operationName: Swift.String? = nil,
            totalRequestCountMetric: [ApplicationSignalsClientTypes.MetricDataQuery]? = nil
        )
        {
            self.keyAttributes = keyAttributes
            self.metricType = metricType
            self.monitoredRequestCountMetric = monitoredRequestCountMetric
            self.operationName = operationName
            self.totalRequestCountMetric = totalRequestCountMetric
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure specifies the information about the service and the performance metric that a request-based SLO is to monitor.
    public struct RequestBasedServiceLevelIndicatorConfig {
        /// The arithmetic operation to use when comparing the specified metric to the threshold. This parameter is required if this SLO is tracking the Latency metric.
        public var comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator?
        /// The value that the SLI metric is compared to. This parameter is required if this SLO is tracking the Latency metric.
        public var metricThreshold: Swift.Double?
        /// Use this structure to specify the metric to be used for the SLO.
        /// This member is required.
        public var requestBasedSliMetricConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetricConfig?

        public init(
            comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator? = nil,
            metricThreshold: Swift.Double? = nil,
            requestBasedSliMetricConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetricConfig? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.requestBasedSliMetricConfig = requestBasedSliMetricConfig
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// Use this structure to specify the information for the metric that a period-based SLO will monitor.
    public struct ServiceLevelIndicatorMetricConfig {
        /// If this SLO is related to a metric collected by Application Signals, you must use this field to specify which service the SLO metric is related to. To do so, you must specify at least the Type, Name, and Environment attributes. This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this is.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// If this SLO monitors a CloudWatch metric or the result of a CloudWatch metric math expression, use this structure to specify that metric or expression.
        public var metricDataQueries: [ApplicationSignalsClientTypes.MetricDataQuery]?
        /// If the SLO is to monitor either the LATENCY or AVAILABILITY metric that Application Signals collects, use this field to specify which of those metrics is used.
        public var metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType?
        /// If the SLO is to monitor a specific operation of the service, use this field to specify the name of that operation.
        public var operationName: Swift.String?
        /// The number of seconds to use as the period for SLO evaluation. Your application's performance is compared to the SLI during each period. For each period, the application is determined to have either achieved or not achieved the necessary performance.
        public var periodSeconds: Swift.Int?
        /// The statistic to use for comparison to the threshold. It can be any CloudWatch statistic or extended statistic. For more information about statistics, see [CloudWatch statistics definitions](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Statistics-definitions.html).
        public var statistic: Swift.String?

        public init(
            keyAttributes: [Swift.String: Swift.String]? = nil,
            metricDataQueries: [ApplicationSignalsClientTypes.MetricDataQuery]? = nil,
            metricType: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricType? = nil,
            operationName: Swift.String? = nil,
            periodSeconds: Swift.Int? = nil,
            statistic: Swift.String? = nil
        )
        {
            self.keyAttributes = keyAttributes
            self.metricDataQueries = metricDataQueries
            self.metricType = metricType
            self.operationName = operationName
            self.periodSeconds = periodSeconds
            self.statistic = statistic
        }
    }

}

extension ApplicationSignalsClientTypes {
    /// This structure specifies the information about the service and the performance metric that a period-based SLO is to monitor.
    public struct ServiceLevelIndicatorConfig {
        /// The arithmetic operation to use when comparing the specified metric to the threshold.
        /// This member is required.
        public var comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator?
        /// This parameter is used only when a request-based SLO tracks the Latency metric. Specify the threshold value that the observed Latency metric values are to be compared to.
        /// This member is required.
        public var metricThreshold: Swift.Double?
        /// Use this structure to specify the metric to be used for the SLO.
        /// This member is required.
        public var sliMetricConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricConfig?

        public init(
            comparisonOperator: ApplicationSignalsClientTypes.ServiceLevelIndicatorComparisonOperator? = nil,
            metricThreshold: Swift.Double? = nil,
            sliMetricConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricConfig? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.metricThreshold = metricThreshold
            self.sliMetricConfig = sliMetricConfig
        }
    }

}

public struct CreateServiceLevelObjectiveInput {
    /// An optional description for this SLO.
    public var description: Swift.String?
    /// This structure contains the attributes that determine the goal of the SLO.
    public var goal: ApplicationSignalsClientTypes.Goal?
    /// A name for this SLO.
    /// This member is required.
    public var name: Swift.String?
    /// If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
    public var requestBasedSliConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig?
    /// If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both RequestBasedSliConfig and SliConfig in the same operation.
    public var sliConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig?
    /// A list of key-value pairs to associate with the SLO. You can associate as many as 50 tags with an SLO. To be able to associate tags with the SLO when you create the SLO, you must have the cloudwatch:TagResource permission. Tags can help you organize and categorize your resources. You can also use them to scope user permissions by granting a user permission to access or change only resources with certain tag values.
    public var tags: [ApplicationSignalsClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        goal: ApplicationSignalsClientTypes.Goal? = nil,
        name: Swift.String? = nil,
        requestBasedSliConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig? = nil,
        sliConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig? = nil,
        tags: [ApplicationSignalsClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.goal = goal
        self.name = name
        self.requestBasedSliConfig = requestBasedSliConfig
        self.sliConfig = sliConfig
        self.tags = tags
    }
}

extension ApplicationSignalsClientTypes {
    /// A structure containing information about one service level objective (SLO) that has been created in Application Signals. Creating SLOs can help you ensure your services are performing to the level that you expect. SLOs help you set and track a specific target level for the reliability and availability of your applications and services. Each SLO uses a service level indicator (SLI), which is a key performance metric, to calculate how much underperformance can be tolerated before the goal that you set for the SLO is not achieved.
    public struct ServiceLevelObjective {
        /// The ARN of this SLO.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that this SLO was created. When used in a raw HTTP Query API, it is formatted as yyyy-MM-dd'T'HH:mm:ss. For example, 2019-07-01T23:59:59.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description that you created for this SLO.
        public var description: Swift.String?
        /// Displays whether this is a period-based SLO or a request-based SLO.
        public var evaluationType: ApplicationSignalsClientTypes.EvaluationType?
        /// This structure contains the attributes that determine the goal of an SLO. This includes the time period for evaluation and the attainment threshold.
        /// This member is required.
        public var goal: ApplicationSignalsClientTypes.Goal?
        /// The time that this SLO was most recently updated. When used in a raw HTTP Query API, it is formatted as yyyy-MM-dd'T'HH:mm:ss. For example, 2019-07-01T23:59:59.
        /// This member is required.
        public var lastUpdatedTime: Foundation.Date?
        /// The name of this SLO.
        /// This member is required.
        public var name: Swift.String?
        /// A structure containing information about the performance metric that this SLO monitors, if this is a request-based SLO.
        public var requestBasedSli: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator?
        /// A structure containing information about the performance metric that this SLO monitors, if this is a period-based SLO.
        public var sli: ApplicationSignalsClientTypes.ServiceLevelIndicator?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            evaluationType: ApplicationSignalsClientTypes.EvaluationType? = nil,
            goal: ApplicationSignalsClientTypes.Goal? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            requestBasedSli: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator? = nil,
            sli: ApplicationSignalsClientTypes.ServiceLevelIndicator? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.evaluationType = evaluationType
            self.goal = goal
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.requestBasedSli = requestBasedSli
            self.sli = sli
        }
    }

}

public struct CreateServiceLevelObjectiveOutput {
    /// A structure that contains information about the SLO that you just created.
    /// This member is required.
    public var slo: ApplicationSignalsClientTypes.ServiceLevelObjective?

    public init(
        slo: ApplicationSignalsClientTypes.ServiceLevelObjective? = nil
    )
    {
        self.slo = slo
    }
}

public struct DeleteServiceLevelObjectiveInput {
    /// The ARN or name of the service level objective to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteServiceLevelObjectiveOutput {

    public init() { }
}

public struct GetServiceLevelObjectiveInput {
    /// The ARN or name of the SLO that you want to retrieve information about. You can find the ARNs of SLOs by using the [ListServiceLevelObjectives](https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_ListServiceLevelObjectives.html) operation.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetServiceLevelObjectiveOutput {
    /// A structure containing the information about the SLO.
    /// This member is required.
    public var slo: ApplicationSignalsClientTypes.ServiceLevelObjective?

    public init(
        slo: ApplicationSignalsClientTypes.ServiceLevelObjective? = nil
    )
    {
        self.slo = slo
    }
}

public struct ListServiceLevelObjectivesInput {
    /// You can use this optional field to specify which services you want to retrieve SLO information for. This is a string-to-string map. It can include the following fields.
    ///
    /// * Type designates the type of object this is.
    ///
    /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
    ///
    /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
    ///
    /// * Environment specifies the location where this object is hosted, or what it belongs to.
    public var keyAttributes: [Swift.String: Swift.String]?
    /// The maximum number of results to return in one operation. If you omit this parameter, the default of 50 is used.
    public var maxResults: Swift.Int?
    /// Include this value, if it was returned by the previous operation, to get the next set of service level objectives.
    public var nextToken: Swift.String?
    /// The name of the operation that this SLO is associated with.
    public var operationName: Swift.String?

    public init(
        keyAttributes: [Swift.String: Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        operationName: Swift.String? = nil
    )
    {
        self.keyAttributes = keyAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operationName = operationName
    }
}

extension ApplicationSignalsClientTypes {
    /// A structure that contains information about one service level objective (SLO) created in Application Signals.
    public struct ServiceLevelObjectiveSummary {
        /// The ARN of this service level objective.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time that this service level objective was created. It is expressed as the number of milliseconds since Jan 1, 1970 00:00:00 UTC.
        public var createdTime: Foundation.Date?
        /// This is a string-to-string map. It can include the following fields.
        ///
        /// * Type designates the type of object this service level objective is for.
        ///
        /// * ResourceType specifies the type of the resource. This field is used only when the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Name specifies the name of the object. This is used only if the value of the Type field is Service, RemoteService, or AWS::Service.
        ///
        /// * Identifier identifies the resource objects of this resource. This is used only if the value of the Type field is Resource or AWS::Resource.
        ///
        /// * Environment specifies the location where this object is hosted, or what it belongs to.
        public var keyAttributes: [Swift.String: Swift.String]?
        /// The name of the service level objective.
        /// This member is required.
        public var name: Swift.String?
        /// If this service level objective is specific to a single operation, this field displays the name of that operation.
        public var operationName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            keyAttributes: [Swift.String: Swift.String]? = nil,
            name: Swift.String? = nil,
            operationName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.keyAttributes = keyAttributes
            self.name = name
            self.operationName = operationName
        }
    }

}

public struct ListServiceLevelObjectivesOutput {
    /// Include this value in your next use of this API to get next set of service level objectives.
    public var nextToken: Swift.String?
    /// An array of structures, where each structure contains information about one SLO.
    public var sloSummaries: [ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sloSummaries: [ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sloSummaries = sloSummaries
    }
}

public struct UpdateServiceLevelObjectiveInput {
    /// An optional description for the SLO.
    public var description: Swift.String?
    /// A structure that contains the attributes that determine the goal of the SLO. This includes the time period for evaluation and the attainment threshold.
    public var goal: ApplicationSignalsClientTypes.Goal?
    /// The Amazon Resource Name (ARN) or name of the service level objective that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// If this SLO is a request-based SLO, this structure defines the information about what performance metric this SLO will monitor. You can't specify both SliConfig and RequestBasedSliConfig in the same operation.
    public var requestBasedSliConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig?
    /// If this SLO is a period-based SLO, this structure defines the information about what performance metric this SLO will monitor.
    public var sliConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig?

    public init(
        description: Swift.String? = nil,
        goal: ApplicationSignalsClientTypes.Goal? = nil,
        id: Swift.String? = nil,
        requestBasedSliConfig: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig? = nil,
        sliConfig: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig? = nil
    )
    {
        self.description = description
        self.goal = goal
        self.id = id
        self.requestBasedSliConfig = requestBasedSliConfig
        self.sliConfig = sliConfig
    }
}

public struct UpdateServiceLevelObjectiveOutput {
    /// A structure that contains information about the SLO that you just updated.
    /// This member is required.
    public var slo: ApplicationSignalsClientTypes.ServiceLevelObjective?

    public init(
        slo: ApplicationSignalsClientTypes.ServiceLevelObjective? = nil
    )
    {
        self.slo = slo
    }
}

public struct StartDiscoveryInput {

    public init() { }
}

public struct StartDiscoveryOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to set tags for. The ARN format of an Application Signals SLO is arn:aws:cloudwatch:Region:account-id:slo:slo-name  For more information about ARN format, see [ Resource Types Defined by Amazon CloudWatch](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of key-value pairs to associate with the alarm.
    /// This member is required.
    public var tags: [ApplicationSignalsClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ApplicationSignalsClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the CloudWatch resource that you want to delete tags from. The ARN format of an Application Signals SLO is arn:aws:cloudwatch:Region:account-id:slo:slo-name  For more information about ARN format, see [ Resource Types Defined by Amazon CloudWatch](https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazoncloudwatch.html#amazoncloudwatch-resources-for-iam-policies) in the Amazon Web Services General Reference.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension BatchGetServiceLevelObjectiveBudgetReportInput {

    static func urlPathProvider(_ value: BatchGetServiceLevelObjectiveBudgetReportInput) -> Swift.String? {
        return "/budget-report"
    }
}

extension CreateServiceLevelObjectiveInput {

    static func urlPathProvider(_ value: CreateServiceLevelObjectiveInput) -> Swift.String? {
        return "/slo"
    }
}

extension DeleteServiceLevelObjectiveInput {

    static func urlPathProvider(_ value: DeleteServiceLevelObjectiveInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/slo/\(id.urlPercentEncoding())"
    }
}

extension GetServiceInput {

    static func urlPathProvider(_ value: GetServiceInput) -> Swift.String? {
        return "/service"
    }
}

extension GetServiceInput {

    static func queryItemProvider(_ value: GetServiceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        return items
    }
}

extension GetServiceLevelObjectiveInput {

    static func urlPathProvider(_ value: GetServiceLevelObjectiveInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/slo/\(id.urlPercentEncoding())"
    }
}

extension ListServiceDependenciesInput {

    static func urlPathProvider(_ value: ListServiceDependenciesInput) -> Swift.String? {
        return "/service-dependencies"
    }
}

extension ListServiceDependenciesInput {

    static func queryItemProvider(_ value: ListServiceDependenciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        return items
    }
}

extension ListServiceDependentsInput {

    static func urlPathProvider(_ value: ListServiceDependentsInput) -> Swift.String? {
        return "/service-dependents"
    }
}

extension ListServiceDependentsInput {

    static func queryItemProvider(_ value: ListServiceDependentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        return items
    }
}

extension ListServiceLevelObjectivesInput {

    static func urlPathProvider(_ value: ListServiceLevelObjectivesInput) -> Swift.String? {
        return "/slos"
    }
}

extension ListServiceLevelObjectivesInput {

    static func queryItemProvider(_ value: ListServiceLevelObjectivesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let operationName = value.operationName {
            let operationNameQueryItem = Smithy.URIQueryItem(name: "OperationName".urlPercentEncoding(), value: Swift.String(operationName).urlPercentEncoding())
            items.append(operationNameQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListServiceOperationsInput {

    static func urlPathProvider(_ value: ListServiceOperationsInput) -> Swift.String? {
        return "/service-operations"
    }
}

extension ListServiceOperationsInput {

    static func queryItemProvider(_ value: ListServiceOperationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        return items
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/services"
    }
}

extension ListServicesInput {

    static func queryItemProvider(_ value: ListServicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endTime = value.endTime else {
            let message = "Creating a URL Query Item failed. endTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeQueryItem = Smithy.URIQueryItem(name: "EndTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endTime)).urlPercentEncoding())
        items.append(endTimeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startTime = value.startTime else {
            let message = "Creating a URL Query Item failed. startTime is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeQueryItem = Smithy.URIQueryItem(name: "StartTime".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startTime)).urlPercentEncoding())
        items.append(startTimeQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "ResourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension StartDiscoveryInput {

    static func urlPathProvider(_ value: StartDiscoveryInput) -> Swift.String? {
        return "/start-discovery"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tag-resource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untag-resource"
    }
}

extension UpdateServiceLevelObjectiveInput {

    static func urlPathProvider(_ value: UpdateServiceLevelObjectiveInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/slo/\(id.urlPercentEncoding())"
    }
}

extension BatchGetServiceLevelObjectiveBudgetReportInput {

    static func write(value: BatchGetServiceLevelObjectiveBudgetReportInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SloIds"].writeList(value.sloIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension CreateServiceLevelObjectiveInput {

    static func write(value: CreateServiceLevelObjectiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Goal"].write(value.goal, with: ApplicationSignalsClientTypes.Goal.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["RequestBasedSliConfig"].write(value.requestBasedSliConfig, with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig.write(value:to:))
        try writer["SliConfig"].write(value.sliConfig, with: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ApplicationSignalsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetServiceInput {

    static func write(value: GetServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListServiceDependenciesInput {

    static func write(value: ListServiceDependenciesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListServiceDependentsInput {

    static func write(value: ListServiceDependentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListServiceLevelObjectivesInput {

    static func write(value: ListServiceLevelObjectivesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ListServiceOperationsInput {

    static func write(value: ListServiceOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ApplicationSignalsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateServiceLevelObjectiveInput {

    static func write(value: UpdateServiceLevelObjectiveInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Goal"].write(value.goal, with: ApplicationSignalsClientTypes.Goal.write(value:to:))
        try writer["RequestBasedSliConfig"].write(value.requestBasedSliConfig, with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig.write(value:to:))
        try writer["SliConfig"].write(value.sliConfig, with: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig.write(value:to:))
    }
}

extension BatchGetServiceLevelObjectiveBudgetReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetServiceLevelObjectiveBudgetReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetServiceLevelObjectiveBudgetReportOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.reports = try reader["Reports"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateServiceLevelObjectiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceLevelObjectiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceLevelObjectiveOutput()
        value.slo = try reader["Slo"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelObjective.read(from:))
        return value
    }
}

extension DeleteServiceLevelObjectiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceLevelObjectiveOutput {
        return DeleteServiceLevelObjectiveOutput()
    }
}

extension GetServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.logGroupReferences = try reader["LogGroupReferences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.service = try reader["Service"].readIfPresent(with: ApplicationSignalsClientTypes.Service.read(from:))
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetServiceLevelObjectiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceLevelObjectiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceLevelObjectiveOutput()
        value.slo = try reader["Slo"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelObjective.read(from:))
        return value
    }
}

extension ListServiceDependenciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceDependenciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceDependenciesOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceDependencies = try reader["ServiceDependencies"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceDependency.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ListServiceDependentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceDependentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceDependentsOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceDependents = try reader["ServiceDependents"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceDependent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ListServiceLevelObjectivesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceLevelObjectivesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceLevelObjectivesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.sloSummaries = try reader["SloSummaries"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServiceOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServiceOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServiceOperationsOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceOperations = try reader["ServiceOperations"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceOperation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.serviceSummaries = try reader["ServiceSummaries"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension StartDiscoveryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartDiscoveryOutput {
        return StartDiscoveryOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateServiceLevelObjectiveOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceLevelObjectiveOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceLevelObjectiveOutput()
        value.slo = try reader["Slo"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelObjective.read(from:))
        return value
    }
}

enum BatchGetServiceLevelObjectiveBudgetReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceLevelObjectiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceLevelObjectiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceLevelObjectiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceDependenciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceDependentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceLevelObjectivesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServiceOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartDiscoveryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDenied": return try AccessDeniedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceLevelObjectiveOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationError": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReport()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.evaluationType = try reader["EvaluationType"].readIfPresent()
        value.budgetStatus = try reader["BudgetStatus"].readIfPresent() ?? .sdkUnknown("")
        value.attainment = try reader["Attainment"].readIfPresent()
        value.totalBudgetSeconds = try reader["TotalBudgetSeconds"].readIfPresent()
        value.budgetSecondsRemaining = try reader["BudgetSecondsRemaining"].readIfPresent()
        value.totalBudgetRequests = try reader["TotalBudgetRequests"].readIfPresent()
        value.budgetRequestsRemaining = try reader["BudgetRequestsRemaining"].readIfPresent()
        value.sli = try reader["Sli"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelIndicator.read(from:))
        value.requestBasedSli = try reader["RequestBasedSli"].readIfPresent(with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator.read(from:))
        value.goal = try reader["Goal"].readIfPresent(with: ApplicationSignalsClientTypes.Goal.read(from:))
        return value
    }
}

extension ApplicationSignalsClientTypes.Goal {

    static func write(value: ApplicationSignalsClientTypes.Goal?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttainmentGoal"].write(value.attainmentGoal)
        try writer["Interval"].write(value.interval, with: ApplicationSignalsClientTypes.Interval.write(value:to:))
        try writer["WarningThreshold"].write(value.warningThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Goal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.Goal()
        value.interval = try reader["Interval"].readIfPresent(with: ApplicationSignalsClientTypes.Interval.read(from:))
        value.attainmentGoal = try reader["AttainmentGoal"].readIfPresent()
        value.warningThreshold = try reader["WarningThreshold"].readIfPresent()
        return value
    }
}

extension ApplicationSignalsClientTypes.Interval {

    static func write(value: ApplicationSignalsClientTypes.Interval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .calendarinterval(calendarinterval):
                try writer["CalendarInterval"].write(calendarinterval, with: ApplicationSignalsClientTypes.CalendarInterval.write(value:to:))
            case let .rollinginterval(rollinginterval):
                try writer["RollingInterval"].write(rollinginterval, with: ApplicationSignalsClientTypes.RollingInterval.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Interval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "RollingInterval":
                return .rollinginterval(try reader["RollingInterval"].read(with: ApplicationSignalsClientTypes.RollingInterval.read(from:)))
            case "CalendarInterval":
                return .calendarinterval(try reader["CalendarInterval"].read(with: ApplicationSignalsClientTypes.CalendarInterval.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ApplicationSignalsClientTypes.CalendarInterval {

    static func write(value: ApplicationSignalsClientTypes.CalendarInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["DurationUnit"].write(value.durationUnit)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.CalendarInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.CalendarInterval()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.durationUnit = try reader["DurationUnit"].readIfPresent() ?? .sdkUnknown("")
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationSignalsClientTypes.RollingInterval {

    static func write(value: ApplicationSignalsClientTypes.RollingInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Duration"].write(value.duration)
        try writer["DurationUnit"].write(value.durationUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.RollingInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.RollingInterval()
        value.durationUnit = try reader["DurationUnit"].readIfPresent() ?? .sdkUnknown("")
        value.duration = try reader["Duration"].readIfPresent() ?? 0
        return value
    }
}

extension ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator()
        value.requestBasedSliMetric = try reader["RequestBasedSliMetric"].readIfPresent(with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric.read(from:))
        value.metricThreshold = try reader["MetricThreshold"].readIfPresent()
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent()
        return value
    }
}

extension ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetric()
        value.keyAttributes = try reader["KeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["OperationName"].readIfPresent()
        value.metricType = try reader["MetricType"].readIfPresent()
        value.totalRequestCountMetric = try reader["TotalRequestCountMetric"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricDataQuery.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.monitoredRequestCountMetric = try reader["MonitoredRequestCountMetric"].readIfPresent(with: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries.read(from:))
        return value
    }
}

extension ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries {

    static func write(value: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .badcountmetric(badcountmetric):
                try writer["BadCountMetric"].writeList(badcountmetric, memberWritingClosure: ApplicationSignalsClientTypes.MetricDataQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .goodcountmetric(goodcountmetric):
                try writer["GoodCountMetric"].writeList(goodcountmetric, memberWritingClosure: ApplicationSignalsClientTypes.MetricDataQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "GoodCountMetric":
                return .goodcountmetric(try reader["GoodCountMetric"].readList(memberReadingClosure: ApplicationSignalsClientTypes.MetricDataQuery.read(from:), memberNodeInfo: "member", isFlattened: false))
            case "BadCountMetric":
                return .badcountmetric(try reader["BadCountMetric"].readList(memberReadingClosure: ApplicationSignalsClientTypes.MetricDataQuery.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ApplicationSignalsClientTypes.MetricDataQuery {

    static func write(value: ApplicationSignalsClientTypes.MetricDataQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Expression"].write(value.expression)
        try writer["Id"].write(value.id)
        try writer["Label"].write(value.label)
        try writer["MetricStat"].write(value.metricStat, with: ApplicationSignalsClientTypes.MetricStat.write(value:to:))
        try writer["Period"].write(value.period)
        try writer["ReturnData"].write(value.returnData)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.MetricDataQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.MetricDataQuery()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.metricStat = try reader["MetricStat"].readIfPresent(with: ApplicationSignalsClientTypes.MetricStat.read(from:))
        value.expression = try reader["Expression"].readIfPresent()
        value.label = try reader["Label"].readIfPresent()
        value.returnData = try reader["ReturnData"].readIfPresent()
        value.period = try reader["Period"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension ApplicationSignalsClientTypes.MetricStat {

    static func write(value: ApplicationSignalsClientTypes.MetricStat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Metric"].write(value.metric, with: ApplicationSignalsClientTypes.Metric.write(value:to:))
        try writer["Period"].write(value.period)
        try writer["Stat"].write(value.stat)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.MetricStat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.MetricStat()
        value.metric = try reader["Metric"].readIfPresent(with: ApplicationSignalsClientTypes.Metric.read(from:))
        value.period = try reader["Period"].readIfPresent() ?? 0
        value.stat = try reader["Stat"].readIfPresent() ?? ""
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension ApplicationSignalsClientTypes.Metric {

    static func write(value: ApplicationSignalsClientTypes.Metric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Dimensions"].writeList(value.dimensions, memberWritingClosure: ApplicationSignalsClientTypes.Dimension.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricName"].write(value.metricName)
        try writer["Namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Metric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.Metric()
        value.namespace = try reader["Namespace"].readIfPresent()
        value.metricName = try reader["MetricName"].readIfPresent()
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.Dimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApplicationSignalsClientTypes.Dimension {

    static func write(value: ApplicationSignalsClientTypes.Dimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Dimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.Dimension()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelIndicator {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelIndicator {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelIndicator()
        value.sliMetric = try reader["SliMetric"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric.read(from:))
        value.metricThreshold = try reader["MetricThreshold"].readIfPresent() ?? 0.0
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelIndicatorMetric()
        value.keyAttributes = try reader["KeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["OperationName"].readIfPresent()
        value.metricType = try reader["MetricType"].readIfPresent()
        value.metricDataQueries = try reader["MetricDataQueries"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricDataQuery.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelObjectiveBudgetReportError()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.errorCode = try reader["ErrorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["ErrorMessage"].readIfPresent() ?? ""
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelObjective {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelObjective {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelObjective()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sli = try reader["Sli"].readIfPresent(with: ApplicationSignalsClientTypes.ServiceLevelIndicator.read(from:))
        value.requestBasedSli = try reader["RequestBasedSli"].readIfPresent(with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicator.read(from:))
        value.evaluationType = try reader["EvaluationType"].readIfPresent()
        value.goal = try reader["Goal"].readIfPresent(with: ApplicationSignalsClientTypes.Goal.read(from:))
        return value
    }
}

extension ApplicationSignalsClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.Service()
        value.keyAttributes = try reader["KeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.attributeMaps = try reader["AttributeMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.metricReferences = try reader["MetricReferences"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.logGroupReferences = try reader["LogGroupReferences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ApplicationSignalsClientTypes.MetricReference {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.MetricReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.MetricReference()
        value.namespace = try reader["Namespace"].readIfPresent() ?? ""
        value.metricType = try reader["MetricType"].readIfPresent() ?? ""
        value.dimensions = try reader["Dimensions"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.Dimension.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.metricName = try reader["MetricName"].readIfPresent() ?? ""
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceDependency {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceDependency {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceDependency()
        value.operationName = try reader["OperationName"].readIfPresent() ?? ""
        value.dependencyKeyAttributes = try reader["DependencyKeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.dependencyOperationName = try reader["DependencyOperationName"].readIfPresent() ?? ""
        value.metricReferences = try reader["MetricReferences"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceDependent {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceDependent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceDependent()
        value.operationName = try reader["OperationName"].readIfPresent()
        value.dependentKeyAttributes = try reader["DependentKeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.dependentOperationName = try reader["DependentOperationName"].readIfPresent()
        value.metricReferences = try reader["MetricReferences"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceLevelObjectiveSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.keyAttributes = try reader["KeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.operationName = try reader["OperationName"].readIfPresent()
        value.createdTime = try reader["CreatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceOperation {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceOperation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceOperation()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.metricReferences = try reader["MetricReferences"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.ServiceSummary()
        value.keyAttributes = try reader["KeyAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.attributeMaps = try reader["AttributeMaps"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.metricReferences = try reader["MetricReferences"].readListIfPresent(memberReadingClosure: ApplicationSignalsClientTypes.MetricReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ApplicationSignalsClientTypes.Tag {

    static func write(value: ApplicationSignalsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ApplicationSignalsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ApplicationSignalsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig {

    static func write(value: ApplicationSignalsClientTypes.ServiceLevelIndicatorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["MetricThreshold"].write(value.metricThreshold)
        try writer["SliMetricConfig"].write(value.sliMetricConfig, with: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricConfig.write(value:to:))
    }
}

extension ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricConfig {

    static func write(value: ApplicationSignalsClientTypes.ServiceLevelIndicatorMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MetricDataQueries"].writeList(value.metricDataQueries, memberWritingClosure: ApplicationSignalsClientTypes.MetricDataQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MetricType"].write(value.metricType)
        try writer["OperationName"].write(value.operationName)
        try writer["PeriodSeconds"].write(value.periodSeconds)
        try writer["Statistic"].write(value.statistic)
    }
}

extension ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig {

    static func write(value: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["MetricThreshold"].write(value.metricThreshold)
        try writer["RequestBasedSliMetricConfig"].write(value.requestBasedSliMetricConfig, with: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetricConfig.write(value:to:))
    }
}

extension ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetricConfig {

    static func write(value: ApplicationSignalsClientTypes.RequestBasedServiceLevelIndicatorMetricConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KeyAttributes"].writeMap(value.keyAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["MetricType"].write(value.metricType)
        try writer["MonitoredRequestCountMetric"].write(value.monitoredRequestCountMetric, with: ApplicationSignalsClientTypes.MonitoredRequestCountMetricDataQueries.write(value:to:))
        try writer["OperationName"].write(value.operationName)
        try writer["TotalRequestCountMetric"].writeList(value.totalRequestCountMetric, memberWritingClosure: ApplicationSignalsClientTypes.MetricDataQuery.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ApplicationSignalsClientTypes {}
