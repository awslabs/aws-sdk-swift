//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension CostExplorerClientTypes {

    public enum AccountScope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linked
        case payer
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountScope] {
            return [
                .linked,
                .payer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linked: return "LINKED"
            case .payer: return "PAYER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Quantifies the anomaly. The higher score means that it's more anomalous.
    public struct AnomalyScore: Swift.Sendable {
        /// The last observed score.
        /// This member is required.
        public var currentScore: Swift.Double
        /// The maximum score that's observed during the AnomalyDateInterval.
        /// This member is required.
        public var maxScore: Swift.Double

        public init(
            currentScore: Swift.Double = 0.0,
            maxScore: Swift.Double = 0.0
        )
        {
            self.currentScore = currentScore
            self.maxScore = maxScore
        }
    }
}

extension CostExplorerClientTypes {

    public enum AnomalyFeedbackType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case plannedActivity
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyFeedbackType] {
            return [
                .no,
                .plannedActivity,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .plannedActivity: return "PLANNED_ACTIVITY"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The dollar value of the anomaly.
    public struct Impact: Swift.Sendable {
        /// The maximum dollar value that's observed for an anomaly.
        /// This member is required.
        public var maxImpact: Swift.Double
        /// The cumulative dollar amount that was actually spent during the anomaly.
        public var totalActualSpend: Swift.Double?
        /// The cumulative dollar amount that was expected to be spent during the anomaly. It is calculated using advanced machine learning models to determine the typical spending pattern based on historical data for a customer.
        public var totalExpectedSpend: Swift.Double?
        /// The cumulative dollar difference between the total actual spend and total expected spend. It is calculated as TotalActualSpend - TotalExpectedSpend.
        public var totalImpact: Swift.Double
        /// The cumulative percentage difference between the total actual spend and total expected spend. It is calculated as (TotalImpact / TotalExpectedSpend) * 100. When TotalExpectedSpend is zero, this field is omitted. Expected spend can be zero in situations such as when you start to use a service for the first time.
        public var totalImpactPercentage: Swift.Double?

        public init(
            maxImpact: Swift.Double = 0.0,
            totalActualSpend: Swift.Double? = nil,
            totalExpectedSpend: Swift.Double? = nil,
            totalImpact: Swift.Double = 0.0,
            totalImpactPercentage: Swift.Double? = nil
        )
        {
            self.maxImpact = maxImpact
            self.totalActualSpend = totalActualSpend
            self.totalExpectedSpend = totalExpectedSpend
            self.totalImpact = totalImpact
            self.totalImpactPercentage = totalImpactPercentage
        }
    }
}

extension CostExplorerClientTypes {

    /// The combination of Amazon Web Servicesservice, linked account, linked account name, Region, and usage type where a cost anomaly is observed. The linked account name will only be available when the account name can be identified.
    public struct RootCause: Swift.Sendable {
        /// The member account value that's associated with the cost anomaly.
        public var linkedAccount: Swift.String?
        /// The member account name value that's associated with the cost anomaly.
        public var linkedAccountName: Swift.String?
        /// The Amazon Web Services Region that's associated with the cost anomaly.
        public var region: Swift.String?
        /// The Amazon Web Servicesservice name that's associated with the cost anomaly.
        public var service: Swift.String?
        /// The UsageType value that's associated with the cost anomaly.
        public var usageType: Swift.String?

        public init(
            linkedAccount: Swift.String? = nil,
            linkedAccountName: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.linkedAccount = linkedAccount
            self.linkedAccountName = linkedAccountName
            self.region = region
            self.service = service
            self.usageType = usageType
        }
    }
}

extension CostExplorerClientTypes {

    /// An unusual cost pattern. This consists of the detailed metadata and the current status of the anomaly object.
    public struct Anomaly: Swift.Sendable {
        /// The last day the anomaly is detected.
        public var anomalyEndDate: Swift.String?
        /// The unique identifier for the anomaly.
        /// This member is required.
        public var anomalyId: Swift.String?
        /// The latest and maximum score for the anomaly.
        /// This member is required.
        public var anomalyScore: CostExplorerClientTypes.AnomalyScore?
        /// The first day the anomaly is detected.
        public var anomalyStartDate: Swift.String?
        /// The dimension for the anomaly (for example, an Amazon Web Servicesservice in a service monitor).
        public var dimensionValue: Swift.String?
        /// The feedback value.
        public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
        /// The dollar impact for the anomaly.
        /// This member is required.
        public var impact: CostExplorerClientTypes.Impact?
        /// The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The list of identified root causes for the anomaly.
        public var rootCauses: [CostExplorerClientTypes.RootCause]?

        public init(
            anomalyEndDate: Swift.String? = nil,
            anomalyId: Swift.String? = nil,
            anomalyScore: CostExplorerClientTypes.AnomalyScore? = nil,
            anomalyStartDate: Swift.String? = nil,
            dimensionValue: Swift.String? = nil,
            feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
            impact: CostExplorerClientTypes.Impact? = nil,
            monitorArn: Swift.String? = nil,
            rootCauses: [CostExplorerClientTypes.RootCause]? = nil
        )
        {
            self.anomalyEndDate = anomalyEndDate
            self.anomalyId = anomalyId
            self.anomalyScore = anomalyScore
            self.anomalyStartDate = anomalyStartDate
            self.dimensionValue = dimensionValue
            self.feedback = feedback
            self.impact = impact
            self.monitorArn = monitorArn
            self.rootCauses = rootCauses
        }
    }
}

extension CostExplorerClientTypes {

    /// The time period for an anomaly.
    public struct AnomalyDateInterval: Swift.Sendable {
        /// The last date an anomaly was observed.
        public var endDate: Swift.String?
        /// The first date an anomaly was observed.
        /// This member is required.
        public var startDate: Swift.String?

        public init(
            endDate: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.startDate = startDate
        }
    }
}

extension CostExplorerClientTypes {

    public enum MonitorDimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorDimension] {
            return [
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absent
        case caseInsensitive
        case caseSensitive
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .absent,
                .caseInsensitive,
                .caseSensitive,
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .caseInsensitive: return "CASE_INSENSITIVE"
            case .caseSensitive: return "CASE_SENSITIVE"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The Cost Categories values used for filtering the costs. If Values and Key are not specified, the ABSENTMatchOption is applied to all Cost Categories. That is, it filters on resources that aren't mapped to any Cost Categories. If Values is provided and Key isn't specified, the ABSENTMatchOption is applied to the Cost Categories Key only. That is, it filters on resources without the given Cost Categories key.
    public struct CostCategoryValues: Swift.Sendable {
        /// The unique name of the Cost Category.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the Cost Category.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension CostExplorerClientTypes {

    public enum Dimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agreementEndDateTimeAfter
        case agreementEndDateTimeBefore
        case anomalyTotalImpactAbsolute
        case anomalyTotalImpactPercentage
        case az
        case billingEntity
        case cacheEngine
        case databaseEngine
        case deploymentOption
        case instanceType
        case instanceTypeFamily
        case invoicingEntity
        case legalEntityName
        case linkedAccount
        case linkedAccountName
        case operatingSystem
        case operation
        case paymentOption
        case platform
        case purchaseType
        case recordType
        case region
        case reservationId
        case resourceId
        case rightsizingType
        case savingsPlansType
        case savingsPlanArn
        case scope
        case service
        case serviceCode
        case subscriptionId
        case tenancy
        case usageType
        case usageTypeGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .agreementEndDateTimeAfter,
                .agreementEndDateTimeBefore,
                .anomalyTotalImpactAbsolute,
                .anomalyTotalImpactPercentage,
                .az,
                .billingEntity,
                .cacheEngine,
                .databaseEngine,
                .deploymentOption,
                .instanceType,
                .instanceTypeFamily,
                .invoicingEntity,
                .legalEntityName,
                .linkedAccount,
                .linkedAccountName,
                .operatingSystem,
                .operation,
                .paymentOption,
                .platform,
                .purchaseType,
                .recordType,
                .region,
                .reservationId,
                .resourceId,
                .rightsizingType,
                .savingsPlansType,
                .savingsPlanArn,
                .scope,
                .service,
                .serviceCode,
                .subscriptionId,
                .tenancy,
                .usageType,
                .usageTypeGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agreementEndDateTimeAfter: return "AGREEMENT_END_DATE_TIME_AFTER"
            case .agreementEndDateTimeBefore: return "AGREEMENT_END_DATE_TIME_BEFORE"
            case .anomalyTotalImpactAbsolute: return "ANOMALY_TOTAL_IMPACT_ABSOLUTE"
            case .anomalyTotalImpactPercentage: return "ANOMALY_TOTAL_IMPACT_PERCENTAGE"
            case .az: return "AZ"
            case .billingEntity: return "BILLING_ENTITY"
            case .cacheEngine: return "CACHE_ENGINE"
            case .databaseEngine: return "DATABASE_ENGINE"
            case .deploymentOption: return "DEPLOYMENT_OPTION"
            case .instanceType: return "INSTANCE_TYPE"
            case .instanceTypeFamily: return "INSTANCE_TYPE_FAMILY"
            case .invoicingEntity: return "INVOICING_ENTITY"
            case .legalEntityName: return "LEGAL_ENTITY_NAME"
            case .linkedAccount: return "LINKED_ACCOUNT"
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .operation: return "OPERATION"
            case .paymentOption: return "PAYMENT_OPTION"
            case .platform: return "PLATFORM"
            case .purchaseType: return "PURCHASE_TYPE"
            case .recordType: return "RECORD_TYPE"
            case .region: return "REGION"
            case .reservationId: return "RESERVATION_ID"
            case .resourceId: return "RESOURCE_ID"
            case .rightsizingType: return "RIGHTSIZING_TYPE"
            case .savingsPlansType: return "SAVINGS_PLANS_TYPE"
            case .savingsPlanArn: return "SAVINGS_PLAN_ARN"
            case .scope: return "SCOPE"
            case .service: return "SERVICE"
            case .serviceCode: return "SERVICE_CODE"
            case .subscriptionId: return "SUBSCRIPTION_ID"
            case .tenancy: return "TENANCY"
            case .usageType: return "USAGE_TYPE"
            case .usageTypeGroup: return "USAGE_TYPE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The metadata that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValues: Swift.Sendable {
        /// The names of the metadata types that you can use to filter and group your results. For example, AZ returns a list of Availability Zones. Not all dimensions are supported in each API. Refer to the documentation for each specific API to see what is supported. LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html). ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE can only be used in [AnomalySubscriptions](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html).
        public var key: CostExplorerClientTypes.Dimension?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category and Anomaly Subscriptions. Refer to the documentation for each specific API to see what is supported. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The metadata values that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
        public var values: [Swift.String]?

        public init(
            key: CostExplorerClientTypes.Dimension? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension CostExplorerClientTypes {

    /// The values that are available for a tag. If Values and Key aren't specified, the ABSENTMatchOption is applied to all tags. That is, it's filtered on resources with no tags. If Key is provided and Values isn't specified, the ABSENTMatchOption is applied to the tag Key only. That is, it's filtered on resources without the given tag key.
    public struct TagValues: Swift.Sendable {
        /// The key for the tag.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the tag.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension CostExplorerClientTypes {

    public enum MonitorType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case dimensional
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorType] {
            return [
                .custom,
                .dimensional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .dimensional: return "DIMENSIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum AnomalySubscriptionFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case immediate
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySubscriptionFrequency] {
            return [
                .daily,
                .immediate,
                .weekly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .immediate: return "IMMEDIATE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum SubscriberStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confirmed
        case declined
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberStatus] {
            return [
                .confirmed,
                .declined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "CONFIRMED"
            case .declined: return "DECLINED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum SubscriberType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberType] {
            return [
                .email,
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The recipient of AnomalySubscription notifications.
    public struct Subscriber: Swift.Sendable {
        /// The email address or SNS Amazon Resource Name (ARN). This depends on the Type.
        public var address: Swift.String?
        /// Indicates if the subscriber accepts the notifications.
        public var status: CostExplorerClientTypes.SubscriberStatus?
        /// The notification delivery channel.
        public var type: CostExplorerClientTypes.SubscriberType?

        public init(
            address: Swift.String? = nil,
            status: CostExplorerClientTypes.SubscriberStatus? = nil,
            type: CostExplorerClientTypes.SubscriberType? = nil
        )
        {
            self.address = address
            self.status = status
            self.type = type
        }
    }
}

extension CostExplorerClientTypes {

    public enum ApproximationDimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resource
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [ApproximationDimension] {
            return [
                .resource,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resource: return "RESOURCE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You made too many calls in a short period of time. Try again later.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CostExplorerClientTypes {

    /// The tag structure that contains a tag key and value. Tagging is supported only for the following Cost Explorer resource types: [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html), [AnomalySubscription](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html), [CostCategory](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html).
    public struct ResourceTag: Swift.Sendable {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAnomalyMonitorOutput: Swift.Sendable {
    /// The unique identifier of your newly created cost anomaly detection monitor.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

/// The cost anomaly monitor does not exist for the account.
public struct UnknownMonitorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownMonitorException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateAnomalySubscriptionOutput: Swift.Sendable {
    /// The unique identifier of your newly created cost anomaly subscription.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

/// You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CostExplorerClientTypes {

    public enum CostCategoryInheritedValueDimensionName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linkedAccountName
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryInheritedValueDimensionName] {
            return [
                .linkedAccountName,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// When you create or update a cost category, you can define the CostCategoryRule rule type as INHERITED_VALUE. This rule type adds the flexibility to define a rule that dynamically inherits the cost category value from the dimension value that's defined by CostCategoryInheritedValueDimension. For example, suppose that you want to dynamically group costs that are based on the value of a specific tag key. First, choose an inherited value rule type, and then choose the tag dimension and specify the tag key to use.
    public struct CostCategoryInheritedValueDimension: Swift.Sendable {
        /// The key to extract cost category values.
        public var dimensionKey: Swift.String?
        /// The name of the dimension that's used to group costs. If you specify LINKED_ACCOUNT_NAME, the cost category value is based on account name. If you specify TAG, the cost category value is based on the value of the specified tag key.
        public var dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName?

        public init(
            dimensionKey: Swift.String? = nil,
            dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName? = nil
        )
        {
            self.dimensionKey = dimensionKey
            self.dimensionName = dimensionName
        }
    }
}

extension CostExplorerClientTypes {

    public enum CostCategoryRuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inheritedValue
        case regular
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleType] {
            return [
                .inheritedValue,
                .regular
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inheritedValue: return "INHERITED_VALUE"
            case .regular: return "REGULAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The rule schema version in this particular Cost Category.
    public enum CostCategoryRuleVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costcategoryexpressionv1
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleVersion] {
            return [
                .costcategoryexpressionv1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costcategoryexpressionv1: return "CostCategoryExpression.v1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum CostCategorySplitChargeMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case even
        case fixed
        case proportional
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeMethod] {
            return [
                .even,
                .fixed,
                .proportional
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .even: return "EVEN"
            case .fixed: return "FIXED"
            case .proportional: return "PROPORTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum CostCategorySplitChargeRuleParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allocationPercentages
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeRuleParameterType] {
            return [
                .allocationPercentages
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allocationPercentages: return "ALLOCATION_PERCENTAGES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The parameters for a split charge method.
    public struct CostCategorySplitChargeRuleParameter: Swift.Sendable {
        /// The parameter type.
        /// This member is required.
        public var type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType?
        /// The parameter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }
}

extension CostExplorerClientTypes {

    /// Use the split charge rule to split the cost of one Cost Category value across several other target values.
    public struct CostCategorySplitChargeRule: Swift.Sendable {
        /// The method that's used to define how to split your source costs across your targets. Proportional - Allocates charges across your targets based on the proportional weighted cost of each target. Fixed - Allocates charges across your targets based on your defined allocation percentage. >Even - Allocates costs evenly across all targets.
        /// This member is required.
        public var method: CostExplorerClientTypes.CostCategorySplitChargeMethod?
        /// The parameters for a split charge method. This is only required for the FIXED method.
        public var parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]?
        /// The Cost Category value that you want to split. That value can't be used as a source or a target in other split charge rules. To indicate uncategorized costs, you can use an empty string as the source.
        /// This member is required.
        public var source: Swift.String?
        /// The Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        /// This member is required.
        public var targets: [Swift.String]?

        public init(
            method: CostExplorerClientTypes.CostCategorySplitChargeMethod? = nil,
            parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]? = nil,
            source: Swift.String? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.method = method
            self.parameters = parameters
            self.source = source
            self.targets = targets
        }
    }
}

public struct CreateCostCategoryDefinitionOutput: Swift.Sendable {
    /// The unique identifier for your newly created Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
    public var effectiveStart: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

public struct DeleteAnomalyMonitorInput: Swift.Sendable {
    /// The unique identifier of the cost anomaly monitor that you want to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

public struct DeleteAnomalyMonitorOutput: Swift.Sendable {

    public init() { }
}

/// The cost anomaly subscription does not exist for the account.
public struct UnknownSubscriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownSubscriptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteAnomalySubscriptionInput: Swift.Sendable {
    /// The unique identifier of the cost anomaly subscription that you want to delete.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

public struct DeleteAnomalySubscriptionOutput: Swift.Sendable {

    public init() { }
}

/// The specified ARN in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct DeleteCostCategoryDefinitionInput: Swift.Sendable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
    }
}

public struct DeleteCostCategoryDefinitionOutput: Swift.Sendable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The effective end date of the Cost Category as a result of deleting it. No costs after this date is categorized by the deleted Cost Category.
    public var effectiveEnd: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveEnd: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveEnd = effectiveEnd
    }
}

public struct DescribeCostCategoryDefinitionInput: Swift.Sendable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveOn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveOn = effectiveOn
    }
}

extension CostExplorerClientTypes {

    public enum CostCategoryStatusComponent: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costExplorer
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatusComponent] {
            return [
                .costExplorer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costExplorer: return "COST_EXPLORER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum CostCategoryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applied
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatus] {
            return [
                .applied,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The list of processing statuses for Cost Management products for a specific cost category.
    public struct CostCategoryProcessingStatus: Swift.Sendable {
        /// The Cost Management product name of the applied status.
        public var component: CostExplorerClientTypes.CostCategoryStatusComponent?
        /// The process status for a specific cost category.
        public var status: CostExplorerClientTypes.CostCategoryStatus?

        public init(
            component: CostExplorerClientTypes.CostCategoryStatusComponent? = nil,
            status: CostExplorerClientTypes.CostCategoryStatus? = nil
        )
        {
            self.component = component
            self.status = status
        }
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CostExplorerClientTypes {

    public enum NumericOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case between
        case equal
        case greaterThan
        case greaterThanOrEqual
        case lessThan
        case lessThanOrEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericOperator] {
            return [
                .between,
                .equal,
                .greaterThan,
                .greaterThanOrEqual,
                .lessThan,
                .lessThanOrEqual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Filters cost anomalies based on the total impact.
    public struct TotalImpactFilter: Swift.Sendable {
        /// The upper bound dollar value that's used in the filter.
        public var endValue: Swift.Double
        /// The comparing value that's used in the filter.
        /// This member is required.
        public var numericOperator: CostExplorerClientTypes.NumericOperator?
        /// The lower bound dollar value that's used in the filter.
        /// This member is required.
        public var startValue: Swift.Double

        public init(
            endValue: Swift.Double = 0.0,
            numericOperator: CostExplorerClientTypes.NumericOperator? = nil,
            startValue: Swift.Double = 0.0
        )
        {
            self.endValue = endValue
            self.numericOperator = numericOperator
            self.startValue = startValue
        }
    }
}

public struct GetAnomaliesInput: Swift.Sendable {
    /// Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an AnomalyEndDate in the specified time range.
    /// This member is required.
    public var dateInterval: CostExplorerClientTypes.AnomalyDateInterval?
    /// Filters anomaly results by the feedback field on the anomaly object.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN).
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies GREATER_THAN 200.00 to retrieve anomalies, with an estimated dollar impact greater than 200.
    public var totalImpact: CostExplorerClientTypes.TotalImpactFilter?

    public init(
        dateInterval: CostExplorerClientTypes.AnomalyDateInterval? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        totalImpact: CostExplorerClientTypes.TotalImpactFilter? = nil
    )
    {
        self.dateInterval = dateInterval
        self.feedback = feedback
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.totalImpact = totalImpact
    }
}

public struct GetAnomaliesOutput: Swift.Sendable {
    /// A list of cost anomalies.
    /// This member is required.
    public var anomalies: [CostExplorerClientTypes.Anomaly]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalies: [CostExplorerClientTypes.Anomaly]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalies = anomalies
        self.nextPageToken = nextPageToken
    }
}

public struct GetAnomalyMonitorsInput: Swift.Sendable {
    /// The number of entries that a paginated response contains.
    public var maxResults: Swift.Int?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        monitorArnList: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArnList = monitorArnList
        self.nextPageToken = nextPageToken
    }
}

public struct GetAnomalySubscriptionsInput: Swift.Sendable {
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Cost anomaly monitor ARNs.
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// A list of cost anomaly subscription ARNs.
    public var subscriptionArnList: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        subscriptionArnList: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.subscriptionArnList = subscriptionArnList
    }
}

/// The requested data is unavailable.
public struct DataUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CostExplorerClientTypes {

    public enum Granularity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [Granularity] {
            return [
                .daily,
                .hourly,
                .monthly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetApproximateUsageRecordsInput: Swift.Sendable {
    /// The service to evaluate for the usage records. You can choose resource-level data at daily granularity, or hourly granularity with or without resource-level data.
    /// This member is required.
    public var approximationDimension: CostExplorerClientTypes.ApproximationDimension?
    /// How granular you want the data to be. You can enable data at hourly or daily granularity.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// The service metadata for the service or services you want to query. If not specified, all elements are returned.
    public var services: [Swift.String]?

    public init(
        approximationDimension: CostExplorerClientTypes.ApproximationDimension? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        services: [Swift.String]? = nil
    )
    {
        self.approximationDimension = approximationDimension
        self.granularity = granularity
        self.services = services
    }
}

extension CostExplorerClientTypes {

    /// The time period of the request.
    public struct DateInterval: Swift.Sendable {
        /// The end of the time period. The end date is exclusive. For example, if end is 2017-05-01, Amazon Web Services retrieves cost and usage data from the start date up to, but not including, 2017-05-01.
        /// This member is required.
        public var end: Swift.String?
        /// The beginning of the time period. The start date is inclusive. For example, if start is 2017-01-01, Amazon Web Services retrieves cost and usage data starting at 2017-01-01 up to the end date. The start date must be equal to or no later than the current date to avoid a validation error.
        /// This member is required.
        public var start: Swift.String?

        public init(
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }
}

public struct GetApproximateUsageRecordsOutput: Swift.Sendable {
    /// The lookback period that's used for the estimation.
    public var lookbackPeriod: CostExplorerClientTypes.DateInterval?
    /// The service metadata for the service or services in the response.
    public var services: [Swift.String: Swift.Int]?
    /// The total number of usage records for all services in the services list.
    public var totalRecords: Swift.Int

    public init(
        lookbackPeriod: CostExplorerClientTypes.DateInterval? = nil,
        services: [Swift.String: Swift.Int]? = nil,
        totalRecords: Swift.Int = 0
    )
    {
        self.lookbackPeriod = lookbackPeriod
        self.services = services
        self.totalRecords = totalRecords
    }
}

/// The requested report expired. Update the date interval and try again.
public struct BillExpirationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillExpirationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request parameters changed between pages. Try again with the old parameters or without a pagination token.
public struct RequestChangedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestChangedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CostExplorerClientTypes {

    public enum GroupDefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costCategory
        case dimension
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupDefinitionType] {
            return [
                .costCategory,
                .dimension,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costCategory: return "COST_CATEGORY"
            case .dimension: return "DIMENSION"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Represents a group when you specify a group by criteria or in the response to a query with a specific grouping.
    public struct GroupDefinition: Swift.Sendable {
        /// The string that represents a key for a specified group.
        public var key: Swift.String?
        /// The string that represents the type of group.
        public var type: CostExplorerClientTypes.GroupDefinitionType?

        public init(
            key: Swift.String? = nil,
            type: CostExplorerClientTypes.GroupDefinitionType? = nil
        )
        {
            self.key = key
            self.type = type
        }
    }
}

extension CostExplorerClientTypes {

    /// The metadata of a specific type that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValuesWithAttributes: Swift.Sendable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String: Swift.String]?
        /// The value of a dimension with a specific attribute.
        public var value: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.value = value
        }
    }
}

extension CostExplorerClientTypes {

    /// The aggregated value for a metric.
    public struct MetricValue: Swift.Sendable {
        /// The actual number that represents the metric.
        public var amount: Swift.String?
        /// The unit that the metric is given in.
        public var unit: Swift.String?

        public init(
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }
}

extension CostExplorerClientTypes {

    /// One level of grouped data in the results.
    public struct Group: Swift.Sendable {
        /// The keys that are included in this group.
        public var keys: [Swift.String]?
        /// The metrics that are included in this group.
        public var metrics: [Swift.String: CostExplorerClientTypes.MetricValue]?

        public init(
            keys: [Swift.String]? = nil,
            metrics: [Swift.String: CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.keys = keys
            self.metrics = metrics
        }
    }
}

extension CostExplorerClientTypes {

    /// The result that's associated with a time period.
    public struct ResultByTime: Swift.Sendable {
        /// Determines whether the result is estimated.
        public var estimated: Swift.Bool
        /// The groups that this time period includes.
        public var groups: [CostExplorerClientTypes.Group]?
        /// The time period that the result covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total amount of cost or usage accrued during the time period.
        public var total: [Swift.String: CostExplorerClientTypes.MetricValue]?

        public init(
            estimated: Swift.Bool = false,
            groups: [CostExplorerClientTypes.Group]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: [Swift.String: CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.estimated = estimated
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }
}

public struct GetCostAndUsageOutput: Swift.Sendable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that's covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init(
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

public struct GetCostAndUsageWithResourcesOutput: Swift.Sendable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that's covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init(
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

extension CostExplorerClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The details for how to sort the data.
    public struct SortDefinition: Swift.Sendable {
        /// The key that's used to sort the data.
        /// This member is required.
        public var key: Swift.String?
        /// The order that's used to sort the data.
        public var sortOrder: CostExplorerClientTypes.SortOrder?

        public init(
            key: Swift.String? = nil,
            sortOrder: CostExplorerClientTypes.SortOrder? = nil
        )
        {
            self.key = key
            self.sortOrder = sortOrder
        }
    }
}

public struct GetCostCategoriesOutput: Swift.Sendable {
    /// The names of the Cost Categories.
    public var costCategoryNames: [Swift.String]?
    /// The Cost Category values. If the CostCategoryName key isn't specified in the request, the CostCategoryValues fields aren't returned.
    public var costCategoryValues: [Swift.String]?
    /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.
    public var nextPageToken: Swift.String?
    /// The number of objects that are returned.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of objects.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        costCategoryNames: [Swift.String]? = nil,
        costCategoryValues: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.costCategoryNames = costCategoryNames
        self.costCategoryValues = costCategoryValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

extension CostExplorerClientTypes {

    public enum Metric: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amortizedCost
        case blendedCost
        case netAmortizedCost
        case netUnblendedCost
        case normalizedUsageAmount
        case unblendedCost
        case usageQuantity
        case sdkUnknown(Swift.String)

        public static var allCases: [Metric] {
            return [
                .amortizedCost,
                .blendedCost,
                .netAmortizedCost,
                .netUnblendedCost,
                .normalizedUsageAmount,
                .unblendedCost,
                .usageQuantity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amortizedCost: return "AMORTIZED_COST"
            case .blendedCost: return "BLENDED_COST"
            case .netAmortizedCost: return "NET_AMORTIZED_COST"
            case .netUnblendedCost: return "NET_UNBLENDED_COST"
            case .normalizedUsageAmount: return "NORMALIZED_USAGE_AMOUNT"
            case .unblendedCost: return "UNBLENDED_COST"
            case .usageQuantity: return "USAGE_QUANTITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The forecast that's created for your query.
    public struct ForecastResult: Swift.Sendable {
        /// The mean value of the forecast.
        public var meanValue: Swift.String?
        /// The lower limit for the prediction interval.
        public var predictionIntervalLowerBound: Swift.String?
        /// The upper limit for the prediction interval.
        public var predictionIntervalUpperBound: Swift.String?
        /// The period of time that the forecast covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init(
            meanValue: Swift.String? = nil,
            predictionIntervalLowerBound: Swift.String? = nil,
            predictionIntervalUpperBound: Swift.String? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.meanValue = meanValue
            self.predictionIntervalLowerBound = predictionIntervalLowerBound
            self.predictionIntervalUpperBound = predictionIntervalUpperBound
            self.timePeriod = timePeriod
        }
    }
}

public struct GetCostForecastOutput: Swift.Sendable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you are forecasted to spend over the forecast period, in USD.
    public var total: CostExplorerClientTypes.MetricValue?

    public init(
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

extension CostExplorerClientTypes {

    public enum Context: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costAndUsage
        case reservations
        case savingsPlans
        case sdkUnknown(Swift.String)

        public static var allCases: [Context] {
            return [
                .costAndUsage,
                .reservations,
                .savingsPlans
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costAndUsage: return "COST_AND_USAGE"
            case .reservations: return "RESERVATIONS"
            case .savingsPlans: return "SAVINGS_PLANS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetDimensionValuesOutput: Swift.Sendable {
    /// The filters that you used to filter your request. Some dimensions are available only for a specific context. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service. You can opt-in by enabling Hourly and Resource Level Data in Cost Management Console preferences.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan
    /// This member is required.
    public var dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of results that Amazon Web Services returned at one time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of search results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.dimensionValues = dimensionValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

extension CostExplorerClientTypes {

    /// How much it costs to run an instance.
    public struct CoverageCost: Swift.Sendable {
        /// How much an On-Demand Instance costs.
        public var onDemandCost: Swift.String?

        public init(
            onDemandCost: Swift.String? = nil
        )
        {
            self.onDemandCost = onDemandCost
        }
    }
}

extension CostExplorerClientTypes {

    /// How long a running instance either used a reservation or was On-Demand.
    public struct CoverageHours: Swift.Sendable {
        /// The percentage of instance hours that a reservation covered.
        public var coverageHoursPercentage: Swift.String?
        /// The number of instance running hours that On-Demand Instances covered.
        public var onDemandHours: Swift.String?
        /// The number of instance running hours that reservations covered.
        public var reservedHours: Swift.String?
        /// The total instance usage, in hours.
        public var totalRunningHours: Swift.String?

        public init(
            coverageHoursPercentage: Swift.String? = nil,
            onDemandHours: Swift.String? = nil,
            reservedHours: Swift.String? = nil,
            totalRunningHours: Swift.String? = nil
        )
        {
            self.coverageHoursPercentage = coverageHoursPercentage
            self.onDemandHours = onDemandHours
            self.reservedHours = reservedHours
            self.totalRunningHours = totalRunningHours
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of instance usage, in normalized units. You can use normalized units to see your EC2 usage for multiple sizes of instances in a uniform way. For example, suppose that you run an xlarge instance and a 2xlarge instance. If you run both instances for the same amount of time, the 2xlarge instance uses twice as much of your reservation as the xlarge instance, even though both instances show only one instance-hour. When you use normalized units instead of instance-hours, the xlarge instance used 8 normalized units, and the 2xlarge instance used 16 normalized units. For more information, see [Modifying Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html) in the Amazon Elastic Compute Cloud User Guide for Linux Instances.
    public struct CoverageNormalizedUnits: Swift.Sendable {
        /// The percentage of your used instance normalized units that a reservation covers.
        public var coverageNormalizedUnitsPercentage: Swift.String?
        /// The number of normalized units that are covered by On-Demand Instances instead of a reservation.
        public var onDemandNormalizedUnits: Swift.String?
        /// The number of normalized units that a reservation covers.
        public var reservedNormalizedUnits: Swift.String?
        /// The total number of normalized units that you used.
        public var totalRunningNormalizedUnits: Swift.String?

        public init(
            coverageNormalizedUnitsPercentage: Swift.String? = nil,
            onDemandNormalizedUnits: Swift.String? = nil,
            reservedNormalizedUnits: Swift.String? = nil,
            totalRunningNormalizedUnits: Swift.String? = nil
        )
        {
            self.coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage
            self.onDemandNormalizedUnits = onDemandNormalizedUnits
            self.reservedNormalizedUnits = reservedNormalizedUnits
            self.totalRunningNormalizedUnits = totalRunningNormalizedUnits
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of instance usage that a reservation covered.
    public struct Coverage: Swift.Sendable {
        /// The amount of cost that the reservation covered.
        public var coverageCost: CostExplorerClientTypes.CoverageCost?
        /// The amount of instance usage that the reservation covered, in hours.
        public var coverageHours: CostExplorerClientTypes.CoverageHours?
        /// The amount of instance usage that the reservation covered, in normalized units.
        public var coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits?

        public init(
            coverageCost: CostExplorerClientTypes.CoverageCost? = nil,
            coverageHours: CostExplorerClientTypes.CoverageHours? = nil,
            coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits? = nil
        )
        {
            self.coverageCost = coverageCost
            self.coverageHours = coverageHours
            self.coverageNormalizedUnits = coverageNormalizedUnits
        }
    }
}

extension CostExplorerClientTypes {

    /// A group of reservations that share a set of attributes.
    public struct ReservationCoverageGroup: Swift.Sendable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String: Swift.String]?
        /// How much instance usage this group of reservations covered.
        public var coverage: CostExplorerClientTypes.Coverage?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            coverage: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
        }
    }
}

extension CostExplorerClientTypes {

    /// Reservation coverage for a specified period, in hours.
    public struct CoverageByTime: Swift.Sendable {
        /// The groups of instances that the reservation covered.
        public var groups: [CostExplorerClientTypes.ReservationCoverageGroup]?
        /// The period that this coverage was used over.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total reservation coverage, in hours.
        public var total: CostExplorerClientTypes.Coverage?

        public init(
            groups: [CostExplorerClientTypes.ReservationCoverageGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }
}

public struct GetReservationCoverageOutput: Swift.Sendable {
    /// The amount of time that your reservations covered.
    /// This member is required.
    public var coveragesByTime: [CostExplorerClientTypes.CoverageByTime]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of instance usage that a reservation covered.
    public var total: CostExplorerClientTypes.Coverage?

    public init(
        coveragesByTime: [CostExplorerClientTypes.CoverageByTime]? = nil,
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.Coverage? = nil
    )
    {
        self.coveragesByTime = coveragesByTime
        self.nextPageToken = nextPageToken
        self.total = total
    }
}

extension CostExplorerClientTypes {

    public enum LookbackPeriodInDays: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sevenDays
        case sixtyDays
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [LookbackPeriodInDays] {
            return [
                .sevenDays,
                .sixtyDays,
                .thirtyDays
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sevenDays: return "SEVEN_DAYS"
            case .sixtyDays: return "SIXTY_DAYS"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum PaymentOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allUpfront
        case heavyUtilization
        case lightUtilization
        case mediumUtilization
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .heavyUtilization,
                .lightUtilization,
                .mediumUtilization,
                .noUpfront,
                .partialUpfront
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .heavyUtilization: return "HEAVY_UTILIZATION"
            case .lightUtilization: return "LIGHT_UTILIZATION"
            case .mediumUtilization: return "MEDIUM_UTILIZATION"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum OfferingClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case convertible
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingClass] {
            return [
                .convertible,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .convertible: return "CONVERTIBLE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
    public struct EC2Specification: Swift.Sendable {
        /// Indicates whether you want a recommendation for standard or convertible reservations.
        public var offeringClass: CostExplorerClientTypes.OfferingClass?

        public init(
            offeringClass: CostExplorerClientTypes.OfferingClass? = nil
        )
        {
            self.offeringClass = offeringClass
        }
    }
}

extension CostExplorerClientTypes {

    /// Hardware specifications for the service that you want recommendations for.
    public struct ServiceSpecification: Swift.Sendable {
        /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
        public var ec2Specification: CostExplorerClientTypes.EC2Specification?

        public init(
            ec2Specification: CostExplorerClientTypes.EC2Specification? = nil
        )
        {
            self.ec2Specification = ec2Specification
        }
    }
}

extension CostExplorerClientTypes {

    public enum TermInYears: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneYear
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [TermInYears] {
            return [
                .oneYear,
                .threeYears
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Information about a recommendation, such as the timestamp for when Amazon Web Services made a specific recommendation.
    public struct ReservationPurchaseRecommendationMetadata: Swift.Sendable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp for when Amazon Web Services made the recommendation.
        public var generationTimestamp: Swift.String?
        /// The ID for the recommendation.
        public var recommendationId: Swift.String?

        public init(
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the Amazon EC2 reservations that Amazon Web Services recommends that you purchase.
    public struct EC2InstanceDetails: Swift.Sendable {
        /// The Availability Zone of the recommended reservation.
        public var availabilityZone: Swift.String?
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool
        /// Determines whether the recommended reservation is dedicated or shared.
        public var tenancy: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false,
            tenancy: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentGeneration = currentGeneration
            self.family = family
            self.instanceType = instanceType
            self.platform = platform
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the Amazon ElastiCache reservations that Amazon Web Services recommends that you purchase.
    public struct ElastiCacheInstanceDetails: Swift.Sendable {
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The description of the recommended reservation.
        public var productDescription: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.productDescription = productDescription
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the Amazon OpenSearch Service reservations that Amazon Web Services recommends that you purchase.
    public struct ESInstanceDetails: Swift.Sendable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The class of instance that Amazon Web Services recommends.
        public var instanceClass: Swift.String?
        /// The size of instance that Amazon Web Services recommends.
        public var instanceSize: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            instanceClass: Swift.String? = nil,
            instanceSize: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.instanceClass = instanceClass
            self.instanceSize = instanceSize
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the MemoryDB reservations that Amazon Web Services recommends that you purchase.
    public struct MemoryDBInstanceDetails: Swift.Sendable {
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The node type of the recommended reservation.
        public var nodeType: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the Amazon RDS reservations that Amazon Web Services recommends that you purchase.
    public struct RDSInstanceDetails: Swift.Sendable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The database edition that the recommended reservation supports.
        public var databaseEdition: Swift.String?
        /// The database engine that the recommended reservation supports.
        public var databaseEngine: Swift.String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public var deploymentOption: Swift.String?
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The license model that the recommended reservation supports.
        public var licenseModel: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            databaseEdition: Swift.String? = nil,
            databaseEngine: Swift.String? = nil,
            deploymentOption: Swift.String? = nil,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.family = family
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the Amazon Redshift reservations that Amazon Web Services recommends that you purchase.
    public struct RedshiftInstanceDetails: Swift.Sendable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the reservations that Amazon Web Services recommends that you purchase.
    public struct InstanceDetails: Swift.Sendable {
        /// The Amazon EC2 reservations that Amazon Web Services recommends that you purchase.
        public var ec2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails?
        /// The ElastiCache reservations that Amazon Web Services recommends that you purchase.
        public var elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails?
        /// The Amazon OpenSearch Service reservations that Amazon Web Services recommends that you purchase.
        public var esInstanceDetails: CostExplorerClientTypes.ESInstanceDetails?
        /// The MemoryDB reservations that Amazon Web Services recommends that you purchase.
        public var memoryDBInstanceDetails: CostExplorerClientTypes.MemoryDBInstanceDetails?
        /// The Amazon RDS reservations that Amazon Web Services recommends that you purchase.
        public var rdsInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails?
        /// The Amazon Redshift reservations that Amazon Web Services recommends that you purchase.
        public var redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails?

        public init(
            ec2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails? = nil,
            elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails? = nil,
            esInstanceDetails: CostExplorerClientTypes.ESInstanceDetails? = nil,
            memoryDBInstanceDetails: CostExplorerClientTypes.MemoryDBInstanceDetails? = nil,
            rdsInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails? = nil,
            redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails? = nil
        )
        {
            self.ec2InstanceDetails = ec2InstanceDetails
            self.elastiCacheInstanceDetails = elastiCacheInstanceDetails
            self.esInstanceDetails = esInstanceDetails
            self.memoryDBInstanceDetails = memoryDBInstanceDetails
            self.rdsInstanceDetails = rdsInstanceDetails
            self.redshiftInstanceDetails = redshiftInstanceDetails
        }
    }
}

extension CostExplorerClientTypes {

    /// The DynamoDB reservations that Amazon Web Services recommends that you purchase.
    public struct DynamoDBCapacityDetails: Swift.Sendable {
        /// The capacity unit of the recommended reservation.
        public var capacityUnits: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?

        public init(
            capacityUnits: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.capacityUnits = capacityUnits
            self.region = region
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about the reservations that Amazon Web Services recommends that you purchase.
    public struct ReservedCapacityDetails: Swift.Sendable {
        /// The DynamoDB reservations that Amazon Web Services recommends that you purchase.
        public var dynamoDBCapacityDetails: CostExplorerClientTypes.DynamoDBCapacityDetails?

        public init(
            dynamoDBCapacityDetails: CostExplorerClientTypes.DynamoDBCapacityDetails? = nil
        )
        {
            self.dynamoDBCapacityDetails = dynamoDBCapacityDetails
        }
    }
}

extension CostExplorerClientTypes {

    /// Details about your recommended reservation purchase.
    public struct ReservationPurchaseRecommendationDetail: Swift.Sendable {
        /// The account that this Reserved Instance (RI) recommendation is for.
        public var accountId: Swift.String?
        /// The average number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNormalizedUnitsUsedPerHour: Swift.String?
        /// The average number of provisioned capacity units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNumberOfCapacityUnitsUsedPerHour: Swift.String?
        /// The average number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNumberOfInstancesUsedPerHour: Swift.String?
        /// The average utilization of your recommendations. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageUtilization: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the costs for this recommendation.
        public var currencyCode: Swift.String?
        /// How long Amazon Web Services estimates that it takes for this recommendation to start saving you money, in months.
        public var estimatedBreakEvenInMonths: Swift.String?
        /// How much Amazon Web Services estimates that you spend on On-Demand Instances in a month.
        public var estimatedMonthlyOnDemandCost: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month, as a percentage of your overall costs.
        public var estimatedMonthlySavingsPercentage: Swift.String?
        /// How much Amazon Web Services estimates that you might spend for all usage during the specified historical period if you had a reservation.
        public var estimatedReservationCostForLookbackPeriod: Swift.String?
        /// Details about the reservations that Amazon Web Services recommends that you purchase.
        public var instanceDetails: CostExplorerClientTypes.InstanceDetails?
        /// The maximum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNormalizedUnitsUsedPerHour: Swift.String?
        /// The maximum number of provisioned capacity units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNumberOfCapacityUnitsUsedPerHour: Swift.String?
        /// The maximum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNumberOfInstancesUsedPerHour: Swift.String?
        /// The minimum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNormalizedUnitsUsedPerHour: Swift.String?
        /// The minimum number of provisioned capacity units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNumberOfCapacityUnitsUsedPerHour: Swift.String?
        /// The minimum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNumberOfInstancesUsedPerHour: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var recommendedNormalizedUnitsToPurchase: Swift.String?
        /// The number of reserved capacity units that Amazon Web Services recommends that you purchase.
        public var recommendedNumberOfCapacityUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var recommendedNumberOfInstancesToPurchase: Swift.String?
        /// How much purchasing this recommendation costs you on a monthly basis.
        public var recurringStandardMonthlyCost: Swift.String?
        /// Details about the reservations that Amazon Web Services recommends that you purchase.
        public var reservedCapacityDetails: CostExplorerClientTypes.ReservedCapacityDetails?
        /// How much purchasing this recommendation costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            averageNormalizedUnitsUsedPerHour: Swift.String? = nil,
            averageNumberOfCapacityUnitsUsedPerHour: Swift.String? = nil,
            averageNumberOfInstancesUsedPerHour: Swift.String? = nil,
            averageUtilization: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            estimatedBreakEvenInMonths: Swift.String? = nil,
            estimatedMonthlyOnDemandCost: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedMonthlySavingsPercentage: Swift.String? = nil,
            estimatedReservationCostForLookbackPeriod: Swift.String? = nil,
            instanceDetails: CostExplorerClientTypes.InstanceDetails? = nil,
            maximumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            maximumNumberOfCapacityUnitsUsedPerHour: Swift.String? = nil,
            maximumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            minimumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            minimumNumberOfCapacityUnitsUsedPerHour: Swift.String? = nil,
            minimumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            recommendedNormalizedUnitsToPurchase: Swift.String? = nil,
            recommendedNumberOfCapacityUnitsToPurchase: Swift.String? = nil,
            recommendedNumberOfInstancesToPurchase: Swift.String? = nil,
            recurringStandardMonthlyCost: Swift.String? = nil,
            reservedCapacityDetails: CostExplorerClientTypes.ReservedCapacityDetails? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour
            self.averageNumberOfCapacityUnitsUsedPerHour = averageNumberOfCapacityUnitsUsedPerHour
            self.averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour
            self.averageUtilization = averageUtilization
            self.currencyCode = currencyCode
            self.estimatedBreakEvenInMonths = estimatedBreakEvenInMonths
            self.estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage
            self.estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod
            self.instanceDetails = instanceDetails
            self.maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour
            self.maximumNumberOfCapacityUnitsUsedPerHour = maximumNumberOfCapacityUnitsUsedPerHour
            self.maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour
            self.minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour
            self.minimumNumberOfCapacityUnitsUsedPerHour = minimumNumberOfCapacityUnitsUsedPerHour
            self.minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour
            self.recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase
            self.recommendedNumberOfCapacityUnitsToPurchase = recommendedNumberOfCapacityUnitsToPurchase
            self.recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase
            self.recurringStandardMonthlyCost = recurringStandardMonthlyCost
            self.reservedCapacityDetails = reservedCapacityDetails
            self.upfrontCost = upfrontCost
        }
    }
}

extension CostExplorerClientTypes {

    /// A summary about this recommendation, such as the currency code, the amount that Amazon Web Services estimates that you could save, and the total amount of reservation to purchase.
    public struct ReservationPurchaseRecommendationSummary: Swift.Sendable {
        /// The currency code used for this recommendation.
        public var currencyCode: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month.
        public var totalEstimatedMonthlySavingsAmount: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month, as a percentage of your costs.
        public var totalEstimatedMonthlySavingsPercentage: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            totalEstimatedMonthlySavingsAmount: Swift.String? = nil,
            totalEstimatedMonthlySavingsPercentage: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount
            self.totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage
        }
    }
}

extension CostExplorerClientTypes {

    /// A specific reservation that Amazon Web Services recommends for purchase.
    public struct ReservationPurchaseRecommendation: Swift.Sendable {
        /// The account scope that Amazon Web Services recommends that you purchase this instance for. For example, you can purchase this reservation for an entire organization in Amazon Web Services Organizations.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option for the reservation (for example, AllUpfront or NoUpfront).
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details about the recommended purchases.
        public var recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]?
        /// A summary about the recommended purchase.
        public var recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary?
        /// Hardware specifications for the service that you want recommendations for.
        public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
        /// The term of the reservation that you want recommendations for, in years.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init(
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]? = nil,
            recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary? = nil,
            serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.recommendationDetails = recommendationDetails
            self.recommendationSummary = recommendationSummary
            self.serviceSpecification = serviceSpecification
            self.termInYears = termInYears
        }
    }
}

public struct GetReservationPurchaseRecommendationOutput: Swift.Sendable {
    /// Information about this specific recommendation call, such as the time stamp for when Cost Explorer generated this recommendation.
    public var metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata?
    /// The pagination token for the next set of retrievable results.
    public var nextPageToken: Swift.String?
    /// Recommendations for reservations to purchase.
    public var recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]?

    public init(
        metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.recommendations = recommendations
    }
}

extension CostExplorerClientTypes {

    /// The aggregated numbers for your reservation usage.
    public struct ReservationAggregates: Swift.Sendable {
        /// The monthly cost of your reservation. It's amortized over the reservation period.
        public var amortizedRecurringFee: Swift.String?
        /// The upfront cost of your reservation. It's amortized over the reservation period.
        public var amortizedUpfrontFee: Swift.String?
        /// How much you saved due to purchasing and utilizing reservation. Amazon Web Services calculates this by subtracting TotalAmortizedFee from OnDemandCostOfRIHoursUsed.
        public var netRISavings: Swift.String?
        /// How much your reservation costs if charged On-Demand rates.
        public var onDemandCostOfRIHoursUsed: Swift.String?
        /// How many reservation hours that you purchased.
        public var purchasedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you purchased. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var purchasedUnits: Swift.String?
        /// The realized savings because of purchasing and using a reservation.
        public var realizedSavings: Swift.String?
        /// The cost of unused hours for your reservation.
        public var riCostForUnusedHours: Swift.String?
        /// The total number of reservation hours that you used.
        public var totalActualHours: Swift.String?
        /// The total number of Amazon EC2 reservation hours that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var totalActualUnits: Swift.String?
        /// The total cost of your reservation. It's amortized over the reservation period.
        public var totalAmortizedFee: Swift.String?
        /// How much you might save if you use your entire reservation.
        public var totalPotentialRISavings: Swift.String?
        /// The unrealized savings because of purchasing and using a reservation.
        public var unrealizedSavings: Swift.String?
        /// The number of reservation hours that you didn't use.
        public var unusedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you didn't use. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var unusedUnits: Swift.String?
        /// The percentage of reservation time that you used.
        public var utilizationPercentage: Swift.String?
        /// The percentage of Amazon EC2 reservation time that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var utilizationPercentageInUnits: Swift.String?

        public init(
            amortizedRecurringFee: Swift.String? = nil,
            amortizedUpfrontFee: Swift.String? = nil,
            netRISavings: Swift.String? = nil,
            onDemandCostOfRIHoursUsed: Swift.String? = nil,
            purchasedHours: Swift.String? = nil,
            purchasedUnits: Swift.String? = nil,
            realizedSavings: Swift.String? = nil,
            riCostForUnusedHours: Swift.String? = nil,
            totalActualHours: Swift.String? = nil,
            totalActualUnits: Swift.String? = nil,
            totalAmortizedFee: Swift.String? = nil,
            totalPotentialRISavings: Swift.String? = nil,
            unrealizedSavings: Swift.String? = nil,
            unusedHours: Swift.String? = nil,
            unusedUnits: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil,
            utilizationPercentageInUnits: Swift.String? = nil
        )
        {
            self.amortizedRecurringFee = amortizedRecurringFee
            self.amortizedUpfrontFee = amortizedUpfrontFee
            self.netRISavings = netRISavings
            self.onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed
            self.purchasedHours = purchasedHours
            self.purchasedUnits = purchasedUnits
            self.realizedSavings = realizedSavings
            self.riCostForUnusedHours = riCostForUnusedHours
            self.totalActualHours = totalActualHours
            self.totalActualUnits = totalActualUnits
            self.totalAmortizedFee = totalAmortizedFee
            self.totalPotentialRISavings = totalPotentialRISavings
            self.unrealizedSavings = unrealizedSavings
            self.unusedHours = unusedHours
            self.unusedUnits = unusedUnits
            self.utilizationPercentage = utilizationPercentage
            self.utilizationPercentageInUnits = utilizationPercentageInUnits
        }
    }
}

extension CostExplorerClientTypes {

    /// A group of reservations that share a set of attributes.
    public struct ReservationUtilizationGroup: Swift.Sendable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String: Swift.String]?
        /// The key for a specific reservation attribute.
        public var key: Swift.String?
        /// How much you used this group of reservations.
        public var utilization: CostExplorerClientTypes.ReservationAggregates?
        /// The value of a specific reservation attribute.
        public var value: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            key: Swift.String? = nil,
            utilization: CostExplorerClientTypes.ReservationAggregates? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.key = key
            self.utilization = utilization
            self.value = value
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of utilization, in hours.
    public struct UtilizationByTime: Swift.Sendable {
        /// The groups that this utilization result uses.
        public var groups: [CostExplorerClientTypes.ReservationUtilizationGroup]?
        /// The period of time that this utilization was used for.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total number of reservation hours that were used.
        public var total: CostExplorerClientTypes.ReservationAggregates?

        public init(
            groups: [CostExplorerClientTypes.ReservationUtilizationGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.ReservationAggregates? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }
}

public struct GetReservationUtilizationOutput: Swift.Sendable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of time that you used your Reserved Instances (RIs).
    public var total: CostExplorerClientTypes.ReservationAggregates?
    /// The amount of time that you used your Reserved Instances (RIs).
    /// This member is required.
    public var utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]?

    public init(
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.ReservationAggregates? = nil,
        utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.total = total
        self.utilizationsByTime = utilizationsByTime
    }
}

extension CostExplorerClientTypes {

    public enum RecommendationTarget: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case crossInstanceFamily
        case sameInstanceFamily
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTarget] {
            return [
                .crossInstanceFamily,
                .sameInstanceFamily
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .crossInstanceFamily: return "CROSS_INSTANCE_FAMILY"
            case .sameInstanceFamily: return "SAME_INSTANCE_FAMILY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// You can use RightsizingRecommendationConfiguration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or Reserved Instance (RI) benefits, or neither.
    public struct RightsizingRecommendationConfiguration: Swift.Sendable {
        /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is TRUE.
        /// This member is required.
        public var benefitsConsidered: Swift.Bool
        /// The option to see recommendations within the same instance family or recommendations for instances across other families. The default value is SAME_INSTANCE_FAMILY.
        /// This member is required.
        public var recommendationTarget: CostExplorerClientTypes.RecommendationTarget?

        public init(
            benefitsConsidered: Swift.Bool = false,
            recommendationTarget: CostExplorerClientTypes.RecommendationTarget? = nil
        )
        {
            self.benefitsConsidered = benefitsConsidered
            self.recommendationTarget = recommendationTarget
        }
    }
}

extension CostExplorerClientTypes {

    /// Metadata for a recommendation set.
    public struct RightsizingRecommendationMetadata: Swift.Sendable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp for when Amazon Web Services made the recommendation.
        public var generationTimestamp: Swift.String?
        /// The number of days of previous usage that Amazon Web Services considers when making the recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The ID for the recommendation.
        public var recommendationId: Swift.String?

        public init(
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.recommendationId = recommendationId
        }
    }
}

extension CostExplorerClientTypes {

    /// Details on the Amazon EC2 Resource.
    public struct EC2ResourceDetails: Swift.Sendable {
        /// The hourly public On-Demand rate for the instance type.
        public var hourlyOnDemandRate: Swift.String?
        /// The type of Amazon Web Services instance.
        public var instanceType: Swift.String?
        /// The memory capacity of the Amazon Web Services instance.
        public var memory: Swift.String?
        /// The network performance capacity of the Amazon Web Services instance.
        public var networkPerformance: Swift.String?
        /// The platform of the Amazon Web Services instance. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the instance.
        public var region: Swift.String?
        /// The SKU of the product.
        public var sku: Swift.String?
        /// The disk storage of the Amazon Web Services instance. This doesn't include EBS storage.
        public var storage: Swift.String?
        /// The number of VCPU cores in the Amazon Web Services instance type.
        public var vcpu: Swift.String?

        public init(
            hourlyOnDemandRate: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            memory: Swift.String? = nil,
            networkPerformance: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sku: Swift.String? = nil,
            storage: Swift.String? = nil,
            vcpu: Swift.String? = nil
        )
        {
            self.hourlyOnDemandRate = hourlyOnDemandRate
            self.instanceType = instanceType
            self.memory = memory
            self.networkPerformance = networkPerformance
            self.platform = platform
            self.region = region
            self.sku = sku
            self.storage = storage
            self.vcpu = vcpu
        }
    }
}

extension CostExplorerClientTypes {

    /// Details for the resource.
    public struct ResourceDetails: Swift.Sendable {
        /// Details for the Amazon EC2 resource.
        public var ec2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails?

        public init(
            ec2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails? = nil
        )
        {
            self.ec2ResourceDetails = ec2ResourceDetails
        }
    }
}

extension CostExplorerClientTypes {

    /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
    public struct DiskResourceUtilization: Swift.Sendable {
        /// The maximum read throughput operations per second.
        public var diskReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var diskReadOpsPerSecond: Swift.String?
        /// The maximum write throughput operations per second.
        public var diskWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var diskWriteOpsPerSecond: Swift.String?

        public init(
            diskReadBytesPerSecond: Swift.String? = nil,
            diskReadOpsPerSecond: Swift.String? = nil,
            diskWriteBytesPerSecond: Swift.String? = nil,
            diskWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.diskReadBytesPerSecond = diskReadBytesPerSecond
            self.diskReadOpsPerSecond = diskReadOpsPerSecond
            self.diskWriteBytesPerSecond = diskWriteBytesPerSecond
            self.diskWriteOpsPerSecond = diskWriteOpsPerSecond
        }
    }
}

extension CostExplorerClientTypes {

    /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
    public struct EBSResourceUtilization: Swift.Sendable {
        /// The maximum size of read operations per second
        public var ebsReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var ebsReadOpsPerSecond: Swift.String?
        /// The maximum size of write operations per second.
        public var ebsWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var ebsWriteOpsPerSecond: Swift.String?

        public init(
            ebsReadBytesPerSecond: Swift.String? = nil,
            ebsReadOpsPerSecond: Swift.String? = nil,
            ebsWriteBytesPerSecond: Swift.String? = nil,
            ebsWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.ebsReadBytesPerSecond = ebsReadBytesPerSecond
            self.ebsReadOpsPerSecond = ebsReadOpsPerSecond
            self.ebsWriteBytesPerSecond = ebsWriteBytesPerSecond
            self.ebsWriteOpsPerSecond = ebsWriteOpsPerSecond
        }
    }
}

extension CostExplorerClientTypes {

    /// The network field that contains a list of network metrics that are associated with the current instance.
    public struct NetworkResourceUtilization: Swift.Sendable {
        /// The network inbound throughput utilization measured in Bytes per second (Bps).
        public var networkInBytesPerSecond: Swift.String?
        /// The network outbound throughput utilization measured in Bytes per second (Bps).
        public var networkOutBytesPerSecond: Swift.String?
        /// The network inbound packets that are measured in packets per second.
        public var networkPacketsInPerSecond: Swift.String?
        /// The network outbound packets that are measured in packets per second.
        public var networkPacketsOutPerSecond: Swift.String?

        public init(
            networkInBytesPerSecond: Swift.String? = nil,
            networkOutBytesPerSecond: Swift.String? = nil,
            networkPacketsInPerSecond: Swift.String? = nil,
            networkPacketsOutPerSecond: Swift.String? = nil
        )
        {
            self.networkInBytesPerSecond = networkInBytesPerSecond
            self.networkOutBytesPerSecond = networkOutBytesPerSecond
            self.networkPacketsInPerSecond = networkPacketsInPerSecond
            self.networkPacketsOutPerSecond = networkPacketsOutPerSecond
        }
    }
}

extension CostExplorerClientTypes {

    /// Utilization metrics for the instance.
    public struct EC2ResourceUtilization: Swift.Sendable {
        /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
        public var diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization?
        /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
        public var ebsResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization?
        /// The maximum observed or expected CPU utilization of the instance.
        public var maxCpuUtilizationPercentage: Swift.String?
        /// The maximum observed or expected memory utilization of the instance.
        public var maxMemoryUtilizationPercentage: Swift.String?
        /// The maximum observed or expected storage utilization of the instance. This doesn't include EBS storage.
        public var maxStorageUtilizationPercentage: Swift.String?
        /// The network field that contains a list of network metrics that are associated with the current instance.
        public var networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization?

        public init(
            diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization? = nil,
            ebsResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization? = nil,
            maxCpuUtilizationPercentage: Swift.String? = nil,
            maxMemoryUtilizationPercentage: Swift.String? = nil,
            maxStorageUtilizationPercentage: Swift.String? = nil,
            networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization? = nil
        )
        {
            self.diskResourceUtilization = diskResourceUtilization
            self.ebsResourceUtilization = ebsResourceUtilization
            self.maxCpuUtilizationPercentage = maxCpuUtilizationPercentage
            self.maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage
            self.maxStorageUtilizationPercentage = maxStorageUtilizationPercentage
            self.networkResourceUtilization = networkResourceUtilization
        }
    }
}

extension CostExplorerClientTypes {

    /// Resource utilization of current resource.
    public struct ResourceUtilization: Swift.Sendable {
        /// The utilization of current Amazon EC2 instance.
        public var ec2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization?

        public init(
            ec2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization? = nil
        )
        {
            self.ec2ResourceUtilization = ec2ResourceUtilization
        }
    }
}

extension CostExplorerClientTypes {

    /// Context about the current instance.
    public struct CurrentInstance: Swift.Sendable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The name that you given an instance. This field shows as blank if you haven't given the instance a name.
        public var instanceName: Swift.String?
        /// The current On-Demand cost of operating this instance on a monthly basis.
        public var monthlyCost: Swift.String?
        /// The number of hours during the lookback period that's billed at On-Demand rates.
        public var onDemandHoursInLookbackPeriod: Swift.String?
        /// The number of hours during the lookback period that's covered by reservations.
        public var reservationCoveredHoursInLookbackPeriod: Swift.String?
        /// Details about the resource and utilization.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?
        /// Resource ID of the current instance.
        public var resourceId: Swift.String?
        /// Utilization information of the current instance during the lookback period.
        public var resourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// The number of hours during the lookback period that's covered by Savings Plans.
        public var savingsPlansCoveredHoursInLookbackPeriod: Swift.String?
        /// Cost allocation resource tags that are applied to the instance.
        public var tags: [CostExplorerClientTypes.TagValues]?
        /// The total number of hours that the instance ran during the lookback period.
        public var totalRunningHoursInLookbackPeriod: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            monthlyCost: Swift.String? = nil,
            onDemandHoursInLookbackPeriod: Swift.String? = nil,
            reservationCoveredHoursInLookbackPeriod: Swift.String? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil,
            resourceId: Swift.String? = nil,
            resourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            savingsPlansCoveredHoursInLookbackPeriod: Swift.String? = nil,
            tags: [CostExplorerClientTypes.TagValues]? = nil,
            totalRunningHoursInLookbackPeriod: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.instanceName = instanceName
            self.monthlyCost = monthlyCost
            self.onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod
            self.reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.resourceUtilization = resourceUtilization
            self.savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod
            self.tags = tags
            self.totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod
        }
    }
}

extension CostExplorerClientTypes {

    public enum FindingReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cpuOverProvisioned
        case cpuUnderProvisioned
        case diskIopsOverProvisioned
        case diskIopsUnderProvisioned
        case diskThroughputOverProvisioned
        case diskThroughputUnderProvisioned
        case ebsIopsOverProvisioned
        case ebsIopsUnderProvisioned
        case ebsThroughputOverProvisioned
        case ebsThroughputUnderProvisioned
        case memoryOverProvisioned
        case memoryUnderProvisioned
        case networkBandwidthOverProvisioned
        case networkBandwidthUnderProvisioned
        case networkPpsOverProvisioned
        case networkPpsUnderProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingReasonCode] {
            return [
                .cpuOverProvisioned,
                .cpuUnderProvisioned,
                .diskIopsOverProvisioned,
                .diskIopsUnderProvisioned,
                .diskThroughputOverProvisioned,
                .diskThroughputUnderProvisioned,
                .ebsIopsOverProvisioned,
                .ebsIopsUnderProvisioned,
                .ebsThroughputOverProvisioned,
                .ebsThroughputUnderProvisioned,
                .memoryOverProvisioned,
                .memoryUnderProvisioned,
                .networkBandwidthOverProvisioned,
                .networkBandwidthUnderProvisioned,
                .networkPpsOverProvisioned,
                .networkPpsUnderProvisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cpuOverProvisioned: return "CPU_OVER_PROVISIONED"
            case .cpuUnderProvisioned: return "CPU_UNDER_PROVISIONED"
            case .diskIopsOverProvisioned: return "DISK_IOPS_OVER_PROVISIONED"
            case .diskIopsUnderProvisioned: return "DISK_IOPS_UNDER_PROVISIONED"
            case .diskThroughputOverProvisioned: return "DISK_THROUGHPUT_OVER_PROVISIONED"
            case .diskThroughputUnderProvisioned: return "DISK_THROUGHPUT_UNDER_PROVISIONED"
            case .ebsIopsOverProvisioned: return "EBS_IOPS_OVER_PROVISIONED"
            case .ebsIopsUnderProvisioned: return "EBS_IOPS_UNDER_PROVISIONED"
            case .ebsThroughputOverProvisioned: return "EBS_THROUGHPUT_OVER_PROVISIONED"
            case .ebsThroughputUnderProvisioned: return "EBS_THROUGHPUT_UNDER_PROVISIONED"
            case .memoryOverProvisioned: return "MEMORY_OVER_PROVISIONED"
            case .memoryUnderProvisioned: return "MEMORY_UNDER_PROVISIONED"
            case .networkBandwidthOverProvisioned: return "NETWORK_BANDWIDTH_OVER_PROVISIONED"
            case .networkBandwidthUnderProvisioned: return "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
            case .networkPpsOverProvisioned: return "NETWORK_PPS_OVER_PROVISIONED"
            case .networkPpsUnderProvisioned: return "NETWORK_PPS_UNDER_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum PlatformDifference: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hypervisor
        case instanceStoreAvailability
        case networkInterface
        case storageInterface
        case virtualizationType
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformDifference] {
            return [
                .hypervisor,
                .instanceStoreAvailability,
                .networkInterface,
                .storageInterface,
                .virtualizationType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hypervisor: return "HYPERVISOR"
            case .instanceStoreAvailability: return "INSTANCE_STORE_AVAILABILITY"
            case .networkInterface: return "NETWORK_INTERFACE"
            case .storageInterface: return "STORAGE_INTERFACE"
            case .virtualizationType: return "VIRTUALIZATION_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Details on recommended instance.
    public struct TargetInstance: Swift.Sendable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// Determines whether this recommendation is the defaulted Amazon Web Services recommendation.
        public var defaultTargetInstance: Swift.Bool
        /// The expected cost to operate this instance type on a monthly basis.
        public var estimatedMonthlyCost: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?
        /// The expected utilization metrics for target instance type.
        public var expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// Explains the actions that you might need to take to successfully migrate your workloads from the current instance type to the recommended instance type.
        public var platformDifferences: [CostExplorerClientTypes.PlatformDifference]?
        /// Details on the target instance type.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?

        public init(
            currencyCode: Swift.String? = nil,
            defaultTargetInstance: Swift.Bool = false,
            estimatedMonthlyCost: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil,
            expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            platformDifferences: [CostExplorerClientTypes.PlatformDifference]? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil
        )
        {
            self.currencyCode = currencyCode
            self.defaultTargetInstance = defaultTargetInstance
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.expectedResourceUtilization = expectedResourceUtilization
            self.platformDifferences = platformDifferences
            self.resourceDetails = resourceDetails
        }
    }
}

extension CostExplorerClientTypes {

    /// Details for the modification recommendation.
    public struct ModifyRecommendationDetail: Swift.Sendable {
        /// Determines whether this instance type is the Amazon Web Services default recommendation.
        public var targetInstances: [CostExplorerClientTypes.TargetInstance]?

        public init(
            targetInstances: [CostExplorerClientTypes.TargetInstance]? = nil
        )
        {
            self.targetInstances = targetInstances
        }
    }
}

extension CostExplorerClientTypes {

    public enum RightsizingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case modify
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [RightsizingType] {
            return [
                .modify,
                .terminate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// Details on termination recommendation.
    public struct TerminateRecommendationDetail: Swift.Sendable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }
    }
}

extension CostExplorerClientTypes {

    /// Recommendations to rightsize resources.
    public struct RightsizingRecommendation: Swift.Sendable {
        /// The account that this recommendation is for.
        public var accountId: Swift.String?
        /// Context regarding the current instance.
        public var currentInstance: CostExplorerClientTypes.CurrentInstance?
        /// The list of possible reasons why the recommendation is generated, such as under- or over-utilization of specific metrics (for example, CPU, Memory, Network).
        public var findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]?
        /// The details for the modification recommendations.
        public var modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail?
        /// A recommendation to either terminate or modify the resource.
        public var rightsizingType: CostExplorerClientTypes.RightsizingType?
        /// The details for termination recommendations.
        public var terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail?

        public init(
            accountId: Swift.String? = nil,
            currentInstance: CostExplorerClientTypes.CurrentInstance? = nil,
            findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]? = nil,
            modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail? = nil,
            rightsizingType: CostExplorerClientTypes.RightsizingType? = nil,
            terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail? = nil
        )
        {
            self.accountId = accountId
            self.currentInstance = currentInstance
            self.findingReasonCodes = findingReasonCodes
            self.modifyRecommendationDetail = modifyRecommendationDetail
            self.rightsizingType = rightsizingType
            self.terminateRecommendationDetail = terminateRecommendationDetail
        }
    }
}

extension CostExplorerClientTypes {

    /// The summary of rightsizing recommendations
    public struct RightsizingRecommendationSummary: Swift.Sendable {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public var estimatedTotalMonthlySavingsAmount: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the savings.
        public var savingsCurrencyCode: Swift.String?
        /// The savings percentage based on the recommended modifications. It's relative to the total On-Demand costs that are associated with these instances.
        public var savingsPercentage: Swift.String?
        /// The total number of instance recommendations.
        public var totalRecommendationCount: Swift.String?

        public init(
            estimatedTotalMonthlySavingsAmount: Swift.String? = nil,
            savingsCurrencyCode: Swift.String? = nil,
            savingsPercentage: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount
            self.savingsCurrencyCode = savingsCurrencyCode
            self.savingsPercentage = savingsPercentage
            self.totalRecommendationCount = totalRecommendationCount
        }
    }
}

public struct GetRightsizingRecommendationOutput: Swift.Sendable {
    /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Information regarding this specific recommendation set.
    public var metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?
    /// Recommendations to rightsize resources.
    public var rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]?
    /// Summary of this recommendation set.
    public var summary: CostExplorerClientTypes.RightsizingRecommendationSummary?

    public init(
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]? = nil,
        summary: CostExplorerClientTypes.RightsizingRecommendationSummary? = nil
    )
    {
        self.configuration = configuration
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.rightsizingRecommendations = rightsizingRecommendations
        self.summary = summary
    }
}

public struct GetSavingsPlanPurchaseRecommendationDetailsInput: Swift.Sendable {
    /// The ID that is associated with the Savings Plan recommendation.
    /// This member is required.
    public var recommendationDetailId: Swift.String?

    public init(
        recommendationDetailId: Swift.String? = nil
    )
    {
        self.recommendationDetailId = recommendationDetailId
    }
}

extension CostExplorerClientTypes {

    /// Contains the hourly metrics for the given recommendation over the lookback period.
    public struct RecommendationDetailHourlyMetrics: Swift.Sendable {
        /// The current amount of Savings Plans eligible usage that the Savings Plan covered.
        public var currentCoverage: Swift.String?
        /// The estimated coverage amount based on the recommended Savings Plan.
        public var estimatedCoverage: Swift.String?
        /// The estimated utilization for the recommended Savings Plan.
        public var estimatedNewCommitmentUtilization: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plan, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var startTime: Swift.String?

        public init(
            currentCoverage: Swift.String? = nil,
            estimatedCoverage: Swift.String? = nil,
            estimatedNewCommitmentUtilization: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.currentCoverage = currentCoverage
            self.estimatedCoverage = estimatedCoverage
            self.estimatedNewCommitmentUtilization = estimatedNewCommitmentUtilization
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.startTime = startTime
        }
    }
}

extension CostExplorerClientTypes {

    public enum SupportedSavingsPlansType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case computeSp
        case ec2InstanceSp
        case sagemakerSp
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedSavingsPlansType] {
            return [
                .computeSp,
                .ec2InstanceSp,
                .sagemakerSp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .computeSp: return "COMPUTE_SP"
            case .ec2InstanceSp: return "EC2_INSTANCE_SP"
            case .sagemakerSp: return "SAGEMAKER_SP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The details and metrics for the given recommendation.
    public struct RecommendationDetailData: Swift.Sendable {
        /// The AccountID that the recommendation is generated for.
        public var accountId: Swift.String?
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// The currency code that Amazon Web Services used to generate the recommendation and present potential savings.
        public var currencyCode: Swift.String?
        /// The average value of hourly coverage over the lookback period.
        public var currentAverageCoverage: Swift.String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentAverageHourlyOnDemandSpend: Swift.String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMaximumHourlyOnDemandSpend: Swift.String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMinimumHourlyOnDemandSpend: Swift.String?
        /// The estimated coverage of the recommended Savings Plan.
        public var estimatedAverageCoverage: Swift.String?
        /// The estimated utilization of the recommended Savings Plan.
        public var estimatedAverageUtilization: Swift.String?
        /// The estimated monthly savings amount based on the recommended Savings Plan.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plan, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment, based on your usage of the selected time period and the Savings Plan you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plan that you purchased. This is calculated as estimatedSavingsAmount/estimatedSPCost*100.
        public var estimatedROI: Swift.String?
        /// The cost of the recommended Savings Plan over the length of the lookback period.
        public var estimatedSPCost: Swift.String?
        /// The estimated savings amount that's based on the recommended Savings Plan over the length of the lookback period.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public var estimatedSavingsPercentage: Swift.String?
        /// The existing hourly commitment for the Savings Plan type.
        public var existingHourlyCommitment: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var generationTimestamp: Swift.String?
        /// The recommended hourly commitment level for the Savings Plan type and the configuration that's based on the usage during the lookback period.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// The instance family of the recommended Savings Plan.
        public var instanceFamily: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var latestUsageTimestamp: Swift.String?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The related hourly cost, coverage, and utilization metrics over the lookback period.
        public var metricsOverLookbackPeriod: [CostExplorerClientTypes.RecommendationDetailHourlyMetrics]?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public var offeringId: Swift.String?
        /// The payment option for the commitment (for example, All Upfront or No Upfront).
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// The region the recommendation is generated for.
        public var region: Swift.String?
        /// The requested Savings Plan recommendation type.
        public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
        /// The term of the commitment in years.
        public var termInYears: CostExplorerClientTypes.TermInYears?
        /// The upfront cost of the recommended Savings Plan, based on the selected payment option.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            currencyCode: Swift.String? = nil,
            currentAverageCoverage: Swift.String? = nil,
            currentAverageHourlyOnDemandSpend: Swift.String? = nil,
            currentMaximumHourlyOnDemandSpend: Swift.String? = nil,
            currentMinimumHourlyOnDemandSpend: Swift.String? = nil,
            estimatedAverageCoverage: Swift.String? = nil,
            estimatedAverageUtilization: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSPCost: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            existingHourlyCommitment: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            latestUsageTimestamp: Swift.String? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            metricsOverLookbackPeriod: [CostExplorerClientTypes.RecommendationDetailHourlyMetrics]? = nil,
            offeringId: Swift.String? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            region: Swift.String? = nil,
            savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountScope = accountScope
            self.currencyCode = currencyCode
            self.currentAverageCoverage = currentAverageCoverage
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageCoverage = estimatedAverageCoverage
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSPCost = estimatedSPCost
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.existingHourlyCommitment = existingHourlyCommitment
            self.generationTimestamp = generationTimestamp
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.instanceFamily = instanceFamily
            self.latestUsageTimestamp = latestUsageTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.metricsOverLookbackPeriod = metricsOverLookbackPeriod
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.region = region
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
            self.upfrontCost = upfrontCost
        }
    }
}

public struct GetSavingsPlanPurchaseRecommendationDetailsOutput: Swift.Sendable {
    /// Contains detailed information about a specific Savings Plan recommendation.
    public var recommendationDetailData: CostExplorerClientTypes.RecommendationDetailData?
    /// The ID that is associated with the Savings Plan recommendation.
    public var recommendationDetailId: Swift.String?

    public init(
        recommendationDetailData: CostExplorerClientTypes.RecommendationDetailData? = nil,
        recommendationDetailId: Swift.String? = nil
    )
    {
        self.recommendationDetailData = recommendationDetailData
        self.recommendationDetailId = recommendationDetailId
    }
}

extension CostExplorerClientTypes {

    /// Specific coverage percentage, On-Demand costs, and spend covered by Savings Plans, and total Savings Plans costs for an account.
    public struct SavingsPlansCoverageData: Swift.Sendable {
        /// The percentage of your existing Savings Plans covered usage, divided by all of your eligible Savings Plans usage in an account (or set of accounts).
        public var coveragePercentage: Swift.String?
        /// The cost of your Amazon Web Services usage at the public On-Demand rate.
        public var onDemandCost: Swift.String?
        /// The amount of your Amazon Web Services usage that's covered by a Savings Plans.
        public var spendCoveredBySavingsPlans: Swift.String?
        /// The total cost of your Amazon Web Services usage, regardless of your purchase option.
        public var totalCost: Swift.String?

        public init(
            coveragePercentage: Swift.String? = nil,
            onDemandCost: Swift.String? = nil,
            spendCoveredBySavingsPlans: Swift.String? = nil,
            totalCost: Swift.String? = nil
        )
        {
            self.coveragePercentage = coveragePercentage
            self.onDemandCost = onDemandCost
            self.spendCoveredBySavingsPlans = spendCoveredBySavingsPlans
            self.totalCost = totalCost
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of Savings Plans eligible usage that's covered by Savings Plans. All calculations consider the On-Demand equivalent of your Savings Plans usage.
    public struct SavingsPlansCoverage: Swift.Sendable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String: Swift.String]?
        /// The amount of Savings Plans eligible usage that the Savings Plans covered.
        public var coverage: CostExplorerClientTypes.SavingsPlansCoverageData?
        /// The time period of the request.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            coverage: CostExplorerClientTypes.SavingsPlansCoverageData? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
            self.timePeriod = timePeriod
        }
    }
}

public struct GetSavingsPlansCoverageOutput: Swift.Sendable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The amount of spend that your Savings Plans covered.
    /// This member is required.
    public var savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]?

    public init(
        nextToken: Swift.String? = nil,
        savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansCoverages = savingsPlansCoverages
    }
}

extension CostExplorerClientTypes {

    /// Metadata about your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationMetadata: Swift.Sendable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp that shows when the recommendations were generated.
        public var generationTimestamp: Swift.String?
        /// The unique identifier for the recommendation set.
        public var recommendationId: Swift.String?

        public init(
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }
}

extension CostExplorerClientTypes {

    /// The attribute details on a specific Savings Plan.
    public struct SavingsPlansDetails: Swift.Sendable {
        /// A group of instance types that Savings Plans applies to.
        public var instanceFamily: Swift.String?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public var offeringId: Swift.String?
        /// A collection of Amazon Web Services resources in a geographic area. Each Amazon Web Services Region is isolated and independent of the other Regions.
        public var region: Swift.String?

        public init(
            instanceFamily: Swift.String? = nil,
            offeringId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.instanceFamily = instanceFamily
            self.offeringId = offeringId
            self.region = region
        }
    }
}

extension CostExplorerClientTypes {

    /// Details for your recommended Savings Plans.
    public struct SavingsPlansPurchaseRecommendationDetail: Swift.Sendable {
        /// The AccountID the recommendation is generated for.
        public var accountId: Swift.String?
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentAverageHourlyOnDemandSpend: Swift.String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMaximumHourlyOnDemandSpend: Swift.String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMinimumHourlyOnDemandSpend: Swift.String?
        /// The estimated utilization of the recommended Savings Plans.
        public var estimatedAverageUtilization: Swift.String?
        /// The estimated monthly savings amount based on the recommended Savings Plans.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans that you purchased. This is calculated as estimatedSavingsAmount/ estimatedSPCost*100.
        public var estimatedROI: Swift.String?
        /// The cost of the recommended Savings Plans over the length of the lookback period.
        public var estimatedSPCost: Swift.String?
        /// The estimated savings amount that's based on the recommended Savings Plans over the length of the lookback period.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public var estimatedSavingsPercentage: Swift.String?
        /// The recommended hourly commitment level for the Savings Plans type and the configuration that's based on the usage during the lookback period.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// Contains detailed information about a specific Savings Plan recommendation.
        public var recommendationDetailId: Swift.String?
        /// Details for your recommended Savings Plans.
        public var savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails?
        /// The upfront cost of the recommended Savings Plans, based on the selected payment option.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            currentAverageHourlyOnDemandSpend: Swift.String? = nil,
            currentMaximumHourlyOnDemandSpend: Swift.String? = nil,
            currentMinimumHourlyOnDemandSpend: Swift.String? = nil,
            estimatedAverageUtilization: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSPCost: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            recommendationDetailId: Swift.String? = nil,
            savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.currencyCode = currencyCode
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSPCost = estimatedSPCost
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.recommendationDetailId = recommendationDetailId
            self.savingsPlansDetails = savingsPlansDetails
            self.upfrontCost = upfrontCost
        }
    }
}

extension CostExplorerClientTypes {

    /// Summary metrics for your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationSummary: Swift.Sendable {
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The current total on demand spend of the applicable usage types over the lookback period.
        public var currentOnDemandSpend: Swift.String?
        /// The recommended Savings Plans cost on a daily (24 hourly) basis.
        public var dailyCommitmentToPurchase: Swift.String?
        /// The estimated monthly savings amount that's based on the recommended Savings Plans purchase.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment. It's based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans and estimated savings.
        public var estimatedROI: Swift.String?
        /// The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as estimatedSavingsAmount/ CurrentOnDemandSpend*100.
        public var estimatedSavingsPercentage: Swift.String?
        /// The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.
        public var estimatedTotalCost: Swift.String?
        /// The recommended hourly commitment that's based on the recommendation parameters.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// The aggregate number of Savings Plans recommendations that exist for your account.
        public var totalRecommendationCount: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            currentOnDemandSpend: Swift.String? = nil,
            dailyCommitmentToPurchase: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            estimatedTotalCost: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.currentOnDemandSpend = currentOnDemandSpend
            self.dailyCommitmentToPurchase = dailyCommitmentToPurchase
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.estimatedTotalCost = estimatedTotalCost
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.totalRecommendationCount = totalRecommendationCount
        }
    }
}

extension CostExplorerClientTypes {

    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public struct SavingsPlansPurchaseRecommendation: Swift.Sendable {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations that include the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// The lookback period in days that's used to generate the recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option that's used to generate the recommendation.
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details for the Savings Plans that we recommend that you purchase to cover existing Savings Plans eligible workloads.
        public var savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]?
        /// Summary metrics for your Savings Plans Recommendations.
        public var savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary?
        /// The requested Savings Plans recommendation type.
        public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
        /// The Savings Plans recommendation term in years. It's used to generate the recommendation.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init(
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]? = nil,
            savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary? = nil,
            savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails
            self.savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
        }
    }
}

public struct GetSavingsPlansPurchaseRecommendationOutput: Swift.Sendable {
    /// Information that regards this specific recommendation set.
    public var metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public var savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation?

    public init(
        metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendation
    }
}

extension CostExplorerClientTypes {

    /// The amortized amount of Savings Plans purchased in a specific account during a specific time interval.
    public struct SavingsPlansAmortizedCommitment: Swift.Sendable {
        /// The amortized amount of your Savings Plans commitment that was purchased with either a Partial or a NoUpfront.
        public var amortizedRecurringCommitment: Swift.String?
        /// The amortized amount of your Savings Plans commitment that was purchased with an Upfront or PartialUpfront Savings Plans.
        public var amortizedUpfrontCommitment: Swift.String?
        /// The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method.
        public var totalAmortizedCommitment: Swift.String?

        public init(
            amortizedRecurringCommitment: Swift.String? = nil,
            amortizedUpfrontCommitment: Swift.String? = nil,
            totalAmortizedCommitment: Swift.String? = nil
        )
        {
            self.amortizedRecurringCommitment = amortizedRecurringCommitment
            self.amortizedUpfrontCommitment = amortizedUpfrontCommitment
            self.totalAmortizedCommitment = totalAmortizedCommitment
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of savings that you're accumulating, against the public On-Demand rate of the usage accrued in an account.
    public struct SavingsPlansSavings: Swift.Sendable {
        /// The savings amount that you're accumulating for the usage that's covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.
        public var netSavings: Swift.String?
        /// How much the amount that the usage would have cost if it was accrued at the On-Demand rate.
        public var onDemandCostEquivalent: Swift.String?

        public init(
            netSavings: Swift.String? = nil,
            onDemandCostEquivalent: Swift.String? = nil
        )
        {
            self.netSavings = netSavings
            self.onDemandCostEquivalent = onDemandCostEquivalent
        }
    }
}

extension CostExplorerClientTypes {

    /// The measurement of how well you're using your existing Savings Plans.
    public struct SavingsPlansUtilization: Swift.Sendable {
        /// The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).
        public var totalCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that wasn't consumed from Savings Plans eligible usage in a specific period.
        public var unusedCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.
        public var usedCommitment: Swift.String?
        /// The amount of UsedCommitment divided by the TotalCommitment for your Savings Plans.
        public var utilizationPercentage: Swift.String?

        public init(
            totalCommitment: Swift.String? = nil,
            unusedCommitment: Swift.String? = nil,
            usedCommitment: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil
        )
        {
            self.totalCommitment = totalCommitment
            self.unusedCommitment = unusedCommitment
            self.usedCommitment = usedCommitment
            self.utilizationPercentage = utilizationPercentage
        }
    }
}

extension CostExplorerClientTypes {

    /// The amount of Savings Plans utilization (in hours).
    public struct SavingsPlansUtilizationByTime: Swift.Sendable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The time period of the request.
        /// This member is required.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.timePeriod = timePeriod
            self.utilization = utilization
        }
    }
}

extension CostExplorerClientTypes {

    /// The aggregated utilization metrics for your Savings Plans usage.
    public struct SavingsPlansUtilizationAggregates: Swift.Sendable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.utilization = utilization
        }
    }
}

public struct GetSavingsPlansUtilizationOutput: Swift.Sendable {
    /// The amount of cost/commitment that you used your Savings Plans. You can use it to specify date ranges.
    public var savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]?
    /// The total amount of cost/commitment that you used your Savings Plans, regardless of date ranges.
    /// This member is required.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init(
        savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTime
        self.total = total
    }
}

extension CostExplorerClientTypes {

    public enum SavingsPlansDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amortizedCommitment
        case attributes
        case savings
        case utilization
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlansDataType] {
            return [
                .amortizedCommitment,
                .attributes,
                .savings,
                .utilization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amortizedCommitment: return "AMORTIZED_COMMITMENT"
            case .attributes: return "ATTRIBUTES"
            case .savings: return "SAVINGS"
            case .utilization: return "UTILIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// A single daily or monthly Savings Plans utilization rate and details for your account. A management account in an organization have access to member accounts. You can use GetDimensionValues to determine the possible dimension values.
    public struct SavingsPlansUtilizationDetail: Swift.Sendable {
        /// The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String: Swift.String]?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The unique Amazon Resource Name (ARN) for a particular Savings Plan.
        public var savingsPlanArn: Swift.String?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            savingsPlanArn: Swift.String? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.attributes = attributes
            self.savings = savings
            self.savingsPlanArn = savingsPlanArn
            self.utilization = utilization
        }
    }
}

public struct GetSavingsPlansUtilizationDetailsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// Retrieves a single daily or monthly Savings Plans utilization rate and details for your account.
    /// This member is required.
    public var savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?
    /// The total Savings Plans utilization, regardless of time period.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init(
        nextToken: Swift.String? = nil,
        savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansUtilizationDetails = savingsPlansUtilizationDetails
        self.timePeriod = timePeriod
        self.total = total
    }
}

public struct GetTagsOutput: Swift.Sendable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of query results that Amazon Web Services returns at a time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The tags that match your request.
    /// This member is required.
    public var tags: [Swift.String]?
    /// The total number of query results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        tags: [Swift.String]? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.tags = tags
        self.totalSize = totalSize
    }
}

/// Cost Explorer was unable to identify the usage unit. Provide UsageType/UsageTypeGroup filter selections that contain matching units, for example: hours.
public struct UnresolvableUsageUnitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnresolvableUsageUnitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetUsageForecastOutput: Swift.Sendable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you're forecasted to use over the forecast period.
    public var total: CostExplorerClientTypes.MetricValue?

    public init(
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

public struct ListCostAllocationTagBackfillHistoryInput: Swift.Sendable {
    /// The maximum number of objects that are returned for this request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CostExplorerClientTypes {

    public enum CostAllocationTagBackfillStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CostAllocationTagBackfillStatus] {
            return [
                .failed,
                .processing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    /// The cost allocation tag backfill request structure that contains metadata and details of a certain backfill.
    public struct CostAllocationTagBackfillRequest: Swift.Sendable {
        /// The date the backfill starts from.
        public var backfillFrom: Swift.String?
        /// The status of the cost allocation tag backfill request.
        public var backfillStatus: CostExplorerClientTypes.CostAllocationTagBackfillStatus?
        /// The backfill completion time.
        public var completedAt: Swift.String?
        /// The time when the backfill status was last updated.
        public var lastUpdatedAt: Swift.String?
        /// The time when the backfill was requested.
        public var requestedAt: Swift.String?

        public init(
            backfillFrom: Swift.String? = nil,
            backfillStatus: CostExplorerClientTypes.CostAllocationTagBackfillStatus? = nil,
            completedAt: Swift.String? = nil,
            lastUpdatedAt: Swift.String? = nil,
            requestedAt: Swift.String? = nil
        )
        {
            self.backfillFrom = backfillFrom
            self.backfillStatus = backfillStatus
            self.completedAt = completedAt
            self.lastUpdatedAt = lastUpdatedAt
            self.requestedAt = requestedAt
        }
    }
}

public struct ListCostAllocationTagBackfillHistoryOutput: Swift.Sendable {
    /// The list of historical cost allocation tag backfill requests.
    public var backfillRequests: [CostExplorerClientTypes.CostAllocationTagBackfillRequest]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        backfillRequests: [CostExplorerClientTypes.CostAllocationTagBackfillRequest]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backfillRequests = backfillRequests
        self.nextToken = nextToken
    }
}

extension CostExplorerClientTypes {

    public enum CostAllocationTagStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CostAllocationTagStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CostExplorerClientTypes {

    public enum CostAllocationTagType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsGenerated
        case userDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [CostAllocationTagType] {
            return [
                .awsGenerated,
                .userDefined
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsGenerated: return "AWSGenerated"
            case .userDefined: return "UserDefined"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListCostAllocationTagsInput: Swift.Sendable {
    /// The maximum number of objects that are returned for this request. By default, the request returns 100 results.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The status of cost allocation tag keys that are returned for this request.
    public var status: CostExplorerClientTypes.CostAllocationTagStatus?
    /// The list of cost allocation tag keys that are returned for this request.
    public var tagKeys: [Swift.String]?
    /// The type of CostAllocationTag object that are returned for this request. The AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The UserDefined type tags are tags that you define, create, and apply to resources.
    public var type: CostExplorerClientTypes.CostAllocationTagType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
        tagKeys: [Swift.String]? = nil,
        type: CostExplorerClientTypes.CostAllocationTagType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.tagKeys = tagKeys
        self.type = type
    }
}

extension CostExplorerClientTypes {

    /// The cost allocation tag structure. This includes detailed metadata for the CostAllocationTag object.
    public struct CostAllocationTag: Swift.Sendable {
        /// The last date that the tag was either activated or deactivated.
        public var lastUpdatedDate: Swift.String?
        /// The last month that the tag was used on an Amazon Web Services resource.
        public var lastUsedDate: Swift.String?
        /// The status of a cost allocation tag.
        /// This member is required.
        public var status: CostExplorerClientTypes.CostAllocationTagStatus?
        /// The key for the cost allocation tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// The type of cost allocation tag. You can use AWSGenerated or UserDefined type tags. AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. UserDefined type tags are tags that you define, create, and apply to resources.
        /// This member is required.
        public var type: CostExplorerClientTypes.CostAllocationTagType?

        public init(
            lastUpdatedDate: Swift.String? = nil,
            lastUsedDate: Swift.String? = nil,
            status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
            tagKey: Swift.String? = nil,
            type: CostExplorerClientTypes.CostAllocationTagType? = nil
        )
        {
            self.lastUpdatedDate = lastUpdatedDate
            self.lastUsedDate = lastUsedDate
            self.status = status
            self.tagKey = tagKey
            self.type = type
        }
    }
}

public struct ListCostAllocationTagsOutput: Swift.Sendable {
    /// A list of cost allocation tags that includes the detailed metadata for each one.
    public var costAllocationTags: [CostExplorerClientTypes.CostAllocationTag]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        costAllocationTags: [CostExplorerClientTypes.CostAllocationTag]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.costAllocationTags = costAllocationTags
        self.nextToken = nextToken
    }
}

public struct ListCostCategoryDefinitionsInput: Swift.Sendable {
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        effectiveOn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveOn = effectiveOn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CostExplorerClientTypes {

    /// A reference to a Cost Category containing only enough information to identify the Cost Category. You can use this information to retrieve the full Cost Category information using DescribeCostCategory.
    public struct CostCategoryReference: Swift.Sendable {
        /// The unique identifier for your Cost Category.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The Cost Category's effective end date.
        public var effectiveEnd: Swift.String?
        /// The Cost Category's effective start date.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        public var name: Swift.String?
        /// The number of rules that are associated with a specific Cost Category.
        public var numberOfRules: Swift.Int
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// A list of unique cost category values in a specific cost category.
        public var values: [Swift.String]?

        public init(
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfRules: Swift.Int = 0,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.numberOfRules = numberOfRules
            self.processingStatus = processingStatus
            self.values = values
        }
    }
}

public struct ListCostCategoryDefinitionsOutput: Swift.Sendable {
    /// A reference to a Cost Category that contains enough information to identify the Cost Category.
    public var costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.costCategoryReferences = costCategoryReferences
        self.nextToken = nextToken
    }
}

extension CostExplorerClientTypes {

    public enum GenerationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [GenerationStatus] {
            return [
                .failed,
                .processing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSavingsPlansPurchaseRecommendationGenerationInput: Swift.Sendable {
    /// The status of the recommendation generation.
    public var generationStatus: CostExplorerClientTypes.GenerationStatus?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The IDs for each specific recommendation.
    public var recommendationIds: [Swift.String]?

    public init(
        generationStatus: CostExplorerClientTypes.GenerationStatus? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.generationStatus = generationStatus
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.recommendationIds = recommendationIds
    }
}

extension CostExplorerClientTypes {

    /// The summary of the Savings Plans recommendation generation.
    public struct GenerationSummary: Swift.Sendable {
        /// Indicates the estimated time for when the recommendation generation will complete.
        public var estimatedCompletionTime: Swift.String?
        /// Indicates the completion time of the recommendation generation.
        public var generationCompletionTime: Swift.String?
        /// Indicates the start time of the recommendation generation.
        public var generationStartedTime: Swift.String?
        /// Indicates whether the recommendation generation succeeded, is processing, or failed.
        public var generationStatus: CostExplorerClientTypes.GenerationStatus?
        /// Indicates the ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init(
            estimatedCompletionTime: Swift.String? = nil,
            generationCompletionTime: Swift.String? = nil,
            generationStartedTime: Swift.String? = nil,
            generationStatus: CostExplorerClientTypes.GenerationStatus? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.estimatedCompletionTime = estimatedCompletionTime
            self.generationCompletionTime = generationCompletionTime
            self.generationStartedTime = generationStartedTime
            self.generationStatus = generationStatus
            self.recommendationId = recommendationId
        }
    }
}

public struct ListSavingsPlansPurchaseRecommendationGenerationOutput: Swift.Sendable {
    /// The list of historical recommendation generations.
    public var generationSummaryList: [CostExplorerClientTypes.GenerationSummary]?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?

    public init(
        generationSummaryList: [CostExplorerClientTypes.GenerationSummary]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.generationSummaryList = generationSummaryList
        self.nextPageToken = nextPageToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tag key value pairs that are associated with the resource.
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

public struct ProvideAnomalyFeedbackInput: Swift.Sendable {
    /// A cost anomaly ID.
    /// This member is required.
    public var anomalyId: Swift.String?
    /// Describes whether the cost anomaly was a planned activity or you considered it an anomaly.
    /// This member is required.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?

    public init(
        anomalyId: Swift.String? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil
    )
    {
        self.anomalyId = anomalyId
        self.feedback = feedback
    }
}

public struct ProvideAnomalyFeedbackOutput: Swift.Sendable {
    /// The ID of the modified cost anomaly.
    /// This member is required.
    public var anomalyId: Swift.String?

    public init(
        anomalyId: Swift.String? = nil
    )
    {
        self.anomalyId = anomalyId
    }
}

/// A request to backfill is already in progress. Once the previous request is complete, you can create another request.
public struct BackfillLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BackfillLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartCostAllocationTagBackfillInput: Swift.Sendable {
    /// The date you want the backfill to start from. The date can only be a first day of the month (a billing start date). Dates can't precede the previous twelve months, or in the future.
    /// This member is required.
    public var backfillFrom: Swift.String?

    public init(
        backfillFrom: Swift.String? = nil
    )
    {
        self.backfillFrom = backfillFrom
    }
}

public struct StartCostAllocationTagBackfillOutput: Swift.Sendable {
    /// An object containing detailed metadata of your new backfill request.
    public var backfillRequest: CostExplorerClientTypes.CostAllocationTagBackfillRequest?

    public init(
        backfillRequest: CostExplorerClientTypes.CostAllocationTagBackfillRequest? = nil
    )
    {
        self.backfillRequest = backfillRequest
    }
}

/// A request to generate a recommendation is already in progress.
public struct GenerationExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GenerationExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartSavingsPlansPurchaseRecommendationGenerationInput: Swift.Sendable {

    public init() { }
}

public struct StartSavingsPlansPurchaseRecommendationGenerationOutput: Swift.Sendable {
    /// The estimated time for when the recommendation generation will complete.
    public var estimatedCompletionTime: Swift.String?
    /// The start time of the recommendation generation.
    public var generationStartedTime: Swift.String?
    /// The ID for this specific recommendation.
    public var recommendationId: Swift.String?

    public init(
        estimatedCompletionTime: Swift.String? = nil,
        generationStartedTime: Swift.String? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.estimatedCompletionTime = estimatedCompletionTime
        self.generationStartedTime = generationStartedTime
        self.recommendationId = recommendationId
    }
}

/// Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs to be added to the resource. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    /// This member is required.
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAnomalyMonitorInput: Swift.Sendable {
    /// Cost anomaly monitor Amazon Resource Names (ARNs).
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The new name for the cost anomaly monitor.
    public var monitorName: Swift.String?

    public init(
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
        self.monitorName = monitorName
    }
}

public struct UpdateAnomalyMonitorOutput: Swift.Sendable {
    /// A cost anomaly monitor ARN.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

public struct UpdateAnomalySubscriptionOutput: Swift.Sendable {
    /// A cost anomaly subscription ARN.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

extension CostExplorerClientTypes {

    /// The cost allocation tag status. The status of a key can either be active or inactive.
    public struct CostAllocationTagStatusEntry: Swift.Sendable {
        /// The status of a cost allocation tag.
        /// This member is required.
        public var status: CostExplorerClientTypes.CostAllocationTagStatus?
        /// The key for the cost allocation tag.
        /// This member is required.
        public var tagKey: Swift.String?

        public init(
            status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
            tagKey: Swift.String? = nil
        )
        {
            self.status = status
            self.tagKey = tagKey
        }
    }
}

public struct UpdateCostAllocationTagsStatusInput: Swift.Sendable {
    /// The list of CostAllocationTagStatusEntry objects that are used to update cost allocation tags status for this request.
    /// This member is required.
    public var costAllocationTagsStatus: [CostExplorerClientTypes.CostAllocationTagStatusEntry]?

    public init(
        costAllocationTagsStatus: [CostExplorerClientTypes.CostAllocationTagStatusEntry]? = nil
    )
    {
        self.costAllocationTagsStatus = costAllocationTagsStatus
    }
}

extension CostExplorerClientTypes {

    /// Gives a detailed description of the result of an action. It's on each cost allocation tag entry in the request.
    public struct UpdateCostAllocationTagsStatusError: Swift.Sendable {
        /// An error code representing why the action failed on this entry.
        public var code: Swift.String?
        /// A message explaining why the action failed on this entry.
        public var message: Swift.String?
        /// The key for the cost allocation tag.
        public var tagKey: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            tagKey: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.tagKey = tagKey
        }
    }
}

public struct UpdateCostAllocationTagsStatusOutput: Swift.Sendable {
    /// A list of UpdateCostAllocationTagsStatusError objects with error details about each cost allocation tag that can't be updated. If there's no failure, an empty array returns.
    public var errors: [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]?

    public init(
        errors: [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct UpdateCostCategoryDefinitionOutput: Swift.Sendable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
    public var effectiveStart: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

extension CostExplorerClientTypes {

    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public struct Expression: Swift.Sendable {
        /// Return results that match both Dimension objects.
        public var and: [CostExplorerClientTypes.Expression]?
        /// The filter that's based on CostCategory values.
        public var costCategories: CostExplorerClientTypes.CostCategoryValues?
        /// The specific Dimension to use for Expression.
        public var dimensions: CostExplorerClientTypes.DimensionValues?
        /// Return results that don't match a Dimension object.
        @Indirect public var not: CostExplorerClientTypes.Expression?
        /// Return results that match either Dimension object.
        public var or: [CostExplorerClientTypes.Expression]?
        /// The specific Tag to use for Expression.
        public var tags: CostExplorerClientTypes.TagValues?

        public init(
            and: [CostExplorerClientTypes.Expression]? = nil,
            costCategories: CostExplorerClientTypes.CostCategoryValues? = nil,
            dimensions: CostExplorerClientTypes.DimensionValues? = nil,
            not: CostExplorerClientTypes.Expression? = nil,
            or: [CostExplorerClientTypes.Expression]? = nil,
            tags: CostExplorerClientTypes.TagValues? = nil
        )
        {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }
    }
}

extension CostExplorerClientTypes {

    /// This object continuously inspects your account's cost data for anomalies. It's based on MonitorType and MonitorSpecification. The content consists of detailed metadata and the current status of the monitor object.
    public struct AnomalyMonitor: Swift.Sendable {
        /// The date when the monitor was created.
        public var creationDate: Swift.String?
        /// The value for evaluated dimensions.
        public var dimensionalValueCount: Swift.Int
        /// The date when the monitor last evaluated for anomalies.
        public var lastEvaluatedDate: Swift.String?
        /// The date when the monitor was last updated.
        public var lastUpdatedDate: Swift.String?
        /// The Amazon Resource Name (ARN) value.
        public var monitorArn: Swift.String?
        /// The dimensions to evaluate.
        public var monitorDimension: CostExplorerClientTypes.MonitorDimension?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
        ///
        /// * Simple dimension values.
        ///
        /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
        ///
        /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
        ///
        /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
        ///
        /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
        ///
        ///
        ///
        ///
        /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
        ///
        /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
        ///
        /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
        ///
        /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
        ///
        ///
        ///
        ///
        /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
        ///
        /// * For example, you can filter for linked account names that start with "a".
        ///
        /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * Compound Expression types with logical operations.
        ///
        /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
        ///
        /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
        ///
        /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
        ///
        ///
        /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
        ///
        ///
        /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
        public var monitorSpecification: CostExplorerClientTypes.Expression?
        /// The possible type values.
        /// This member is required.
        public var monitorType: CostExplorerClientTypes.MonitorType?

        public init(
            creationDate: Swift.String? = nil,
            dimensionalValueCount: Swift.Int = 0,
            lastEvaluatedDate: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            monitorArn: Swift.String? = nil,
            monitorDimension: CostExplorerClientTypes.MonitorDimension? = nil,
            monitorName: Swift.String? = nil,
            monitorSpecification: CostExplorerClientTypes.Expression? = nil,
            monitorType: CostExplorerClientTypes.MonitorType? = nil
        )
        {
            self.creationDate = creationDate
            self.dimensionalValueCount = dimensionalValueCount
            self.lastEvaluatedDate = lastEvaluatedDate
            self.lastUpdatedDate = lastUpdatedDate
            self.monitorArn = monitorArn
            self.monitorDimension = monitorDimension
            self.monitorName = monitorName
            self.monitorSpecification = monitorSpecification
            self.monitorType = monitorType
        }
    }
}

extension CostExplorerClientTypes {

    /// An AnomalySubscription resource (also referred to as an alert subscription) sends notifications about specific anomalies that meet an alerting criteria defined by you. You can specify the frequency of the alerts and the subscribers to notify. Anomaly subscriptions can be associated with one or more [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html) resources, and they only send notifications about anomalies detected by those associated monitors. You can also configure a threshold to further control which anomalies are included in the notifications. Anomalies that don’t exceed the chosen threshold and therefore don’t trigger notifications from an anomaly subscription will still be available on the console and from the [GetAnomalies](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_GetAnomalies.html) API.
    public struct AnomalySubscription: Swift.Sendable {
        /// Your unique account identifier.
        public var accountId: Swift.String?
        /// The frequency that anomaly notifications are sent. Notifications are sent either over email (for DAILY and WEEKLY frequencies) or SNS (for IMMEDIATE frequency). For more information, see [Creating an Amazon SNS topic for anomaly notifications](https://docs.aws.amazon.com/cost-management/latest/userguide/ad-SNS.html).
        /// This member is required.
        public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
        /// A list of cost anomaly monitors.
        /// This member is required.
        public var monitorArnList: [Swift.String]?
        /// A list of subscribers to notify.
        /// This member is required.
        public var subscribers: [CostExplorerClientTypes.Subscriber]?
        /// The AnomalySubscription Amazon Resource Name (ARN).
        public var subscriptionArn: Swift.String?
        /// The name for the subscription.
        /// This member is required.
        public var subscriptionName: Swift.String?
        /// (deprecated) An absolute dollar value that must be exceeded by the anomaly's total impact (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details) for an anomaly notification to be generated. This field has been deprecated. To specify a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression. One of Threshold or ThresholdExpression is required for this resource. You cannot specify both.
        @available(*, deprecated, message: "Threshold has been deprecated in favor of ThresholdExpression")
        public var threshold: Swift.Double?
        /// An [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE, corresponding to an anomaly’s TotalImpact and TotalImpactPercentage, respectively (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details). The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000 in string format. One of Threshold or ThresholdExpression is required for this resource. You cannot specify both. The following are examples of valid ThresholdExpressions:
        ///
        /// * Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
        ///
        /// * Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
        ///
        /// * AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        ///
        /// * OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        public var thresholdExpression: CostExplorerClientTypes.Expression?

        public init(
            accountId: Swift.String? = nil,
            frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
            monitorArnList: [Swift.String]? = nil,
            subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            threshold: Swift.Double? = nil,
            thresholdExpression: CostExplorerClientTypes.Expression? = nil
        )
        {
            self.accountId = accountId
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = threshold
            self.thresholdExpression = thresholdExpression
        }
    }
}

extension CostExplorerClientTypes {

    /// Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
    public struct CostCategoryRule: Swift.Sendable {
        /// The value the line item is categorized as if the line item contains the matched dimension.
        public var inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension?
        /// An [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to categorize costs. This supports dimensions, tags, and nested expressions. Currently the only dimensions supported are LINKED_ACCOUNT, SERVICE_CODE, RECORD_TYPE, LINKED_ACCOUNT_NAME, REGION, and USAGE_TYPE. RECORD_TYPE is a dimension used for Cost Explorer APIs, and is also supported for Cost Category expressions. This dimension uses different terms, depending on whether you're using the console or API/JSON editor. For a detailed comparison, see [Term Comparisons](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms) in the Billing and Cost Management User Guide.
        public var rule: CostExplorerClientTypes.Expression?
        /// You can define the CostCategoryRule rule type as either REGULAR or INHERITED_VALUE. The INHERITED_VALUE rule type adds the flexibility to define a rule that dynamically inherits the cost category value. This value is from the dimension value that's defined by CostCategoryInheritedValueDimension. For example, suppose that you want to costs to be dynamically grouped based on the value of a specific tag key. First, choose an inherited value rule type, and then choose the tag dimension and specify the tag key to use.
        public var type: CostExplorerClientTypes.CostCategoryRuleType?
        /// The default value for the cost category.
        public var value: Swift.String?

        public init(
            inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension? = nil,
            rule: CostExplorerClientTypes.Expression? = nil,
            type: CostExplorerClientTypes.CostCategoryRuleType? = nil,
            value: Swift.String? = nil
        )
        {
            self.inheritedValue = inheritedValue
            self.rule = rule
            self.type = type
            self.value = value
        }
    }
}

public struct GetCostAndUsageInput: Swift.Sendable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html). Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY or DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, either MONTHLY or DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types. Valid values for the DIMENSION type are AZ, INSTANCE_TYPE, LEGAL_ENTITY_NAME, INVOICING_ENTITY, LINKED_ACCOUNT, OPERATION, PLATFORM, PURCHASE_TYPE, SERVICE, TENANCY, RECORD_TYPE, and USAGE_TYPE. When you group by the TAG type and include a valid tag key, you get all tag values, including empty strings.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsage requests.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

public struct GetCostAndUsageWithResourcesInput: Swift.Sendable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html). The GetCostAndUsageWithResources operation requires that you either group by or filter by a ResourceId. It requires the [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html)"SERVICE = Amazon Elastic Compute Cloud - Compute" in the filter. Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
    /// This member is required.
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY, DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, MONTHLY, DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups: DIMENSION, TAG, COST_CATEGORY.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsageWithResources requests.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

public struct GetCostCategoriesInput: Swift.Sendable {
    /// The unique name of the Cost Category.
    public var costCategoryName: Swift.String?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when the SortBy value is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with the SortBy value, the request returns 1000 results as the default value for this parameter. For GetCostCategories, MaxResults has an upper quota of 1000.
    public var maxResults: Swift.Int?
    /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for. If you don't specify a CostCategoryName, SearchString is used to filter Cost Category names that match the SearchString pattern. If you specify a CostCategoryName, SearchString is used to filter Cost Category values that match the SearchString pattern.
    public var searchString: Swift.String?
    /// The value that you sort the data by. The key represents the cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported key values for the SortOrder value are ASCENDING and DESCENDING. When you use the SortBy value, the NextPageToken and SearchString key values aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        costCategoryName: Swift.String? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.costCategoryName = costCategoryName
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetCostForecastInput: Swift.Sendable {
    /// The filters that you want to use to filter your forecast. The GetCostForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetCostForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values for a GetCostForecast call are the following:
    ///
    /// * AMORTIZED_COST
    ///
    /// * BLENDED_COST
    ///
    /// * NET_AMORTIZED_COST
    ///
    /// * NET_UNBLENDED_COST
    ///
    /// * UNBLENDED_COST
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

public struct GetDimensionValuesInput: Swift.Sendable {
    /// The context for the call to GetDimensionValues. This can be RESERVATIONS or COST_AND_USAGE. The default value is COST_AND_USAGE. If the context is set to RESERVATIONS, the resulting dimension values can be used in the GetReservationUtilization operation. If the context is set to COST_AND_USAGE, the resulting dimension values can be used in the GetCostAndUsage operation. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following: - Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Servicesservices. - AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Servicesservices in India. - Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are Compute Optimized (for example, C4, C5, C6g, and C7g), Memory Optimization (for example, R4, R5n, R5b, and R6g).
    ///
    /// * INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.
    public var context: CostExplorerClientTypes.Context?
    /// The name of the dimension. Each Dimension is available for a different Context. For more information, see Context. LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html).
    /// This member is required.
    public var dimension: CostExplorerClientTypes.Dimension?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetDimensionValues, MaxResults has an upper limit of 1000.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for.
    public var searchString: Swift.String?
    /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported values for the SortOrder key are ASCENDING or DESCENDING. When you specify a SortBy paramater, the context must be COST_AND_USAGE. Further, when using SortBy, NextPageToken and SearchString aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        context: CostExplorerClientTypes.Context? = nil,
        dimension: CostExplorerClientTypes.Dimension? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.context = context
        self.dimension = dimension
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

/// You can use the following request parameters to query for how much of your instance usage a reservation covered.
public struct GetReservationCoverageInput: Swift.Sendable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * TAG
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together. If you don't provide a SERVICE filter, Cost Explorer defaults to EC2. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for the reservation. Valid values are MONTHLY and DAILY. If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. The GetReservationCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data by the following attributes:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * INVOICING_ENTITY
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * TENANCY
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The measurement that you want your reservation coverage reported in. Valid values are Hour, Unit, and Cost. You can use multiple values in a request.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * OnDemandCost
    ///
    /// * CoverageHoursPercentage
    ///
    /// * OnDemandHours
    ///
    /// * ReservedHours
    ///
    /// * TotalRunningHours
    ///
    /// * CoverageNormalizedUnitsPercentage
    ///
    /// * OnDemandNormalizedUnits
    ///
    /// * ReservedNormalizedUnits
    ///
    /// * TotalRunningNormalizedUnits
    ///
    /// * Time
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetReservationPurchaseRecommendationInput: Swift.Sendable {
    /// The account ID that's associated with the recommendation.
    public var accountId: Swift.String?
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The reservation purchase option that you want recommendations for.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The specific service that you want recommendations for.
    /// This member is required.
    public var service: Swift.String?
    /// The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.
    public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
    /// The reservation term that you want recommendations for.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init(
        accountId: Swift.String? = nil,
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        service: Swift.String? = nil,
        serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountId = accountId
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.service = service
        self.serviceSpecification = serviceSpecification
        self.termInYears = termInYears
    }
}

public struct GetReservationUtilizationInput: Swift.Sendable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * SCOPE
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.
    public var filter: CostExplorerClientTypes.Expression?
    /// If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. If both GroupBy and Granularity aren't set, GetReservationUtilization defaults to DAILY. The GetReservationUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Groups only by SUBSCRIPTION_ID. Metadata is included.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * UtilizationPercentageInUnits
    ///
    /// * PurchasedHours
    ///
    /// * PurchasedUnits
    ///
    /// * TotalActualHours
    ///
    /// * TotalActualUnits
    ///
    /// * UnusedHours
    ///
    /// * UnusedUnits
    ///
    /// * OnDemandCostOfRIHoursUsed
    ///
    /// * NetRISavings
    ///
    /// * TotalPotentialRISavings
    ///
    /// * AmortizedUpfrontFee
    ///
    /// * AmortizedRecurringFee
    ///
    /// * TotalAmortizedFee
    ///
    /// * RICostForUnusedHours
    ///
    /// * RealizedSavings
    ///
    /// * UnrealizedSavings
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetRightsizingRecommendationInput: Swift.Sendable {
    /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The specific service that you want recommendations for. The only valid value for GetRightsizingRecommendation is "AmazonEC2".
    /// This member is required.
    public var service: Swift.String?

    public init(
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        service: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.filter = filter
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.service = service
    }
}

public struct GetSavingsPlansCoverageInput: Swift.Sendable {
    /// Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * INSTANCE_FAMILY
    ///
    ///
    /// GetSavingsPlansCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. If there are multiple values for a dimension, they are OR'd together. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for your Savings Plans. Granularity can't be set if GroupBy is set. The GetSavingsPlansCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data using the attributes INSTANCE_FAMILY, REGION, or SERVICE.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int?
    /// The measurement that you want your Savings Plans coverage reported in. The only valid value is SpendCoveredBySavingsPlans.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * SpendCoveredBySavingsPlan
    ///
    /// * OnDemandCost
    ///
    /// * CoveragePercentage
    ///
    /// * TotalCost
    ///
    /// * InstanceFamily
    ///
    /// * Region
    ///
    /// * Service
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetSavingsPlansPurchaseRecommendationInput: Swift.Sendable {
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// You can filter your recommendations by Account ID with the LINKED_ACCOUNT dimension. To filter your recommendations by Account ID, specify Key as LINKED_ACCOUNT and Value as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for. For GetSavingsPlansPurchaseRecommendation, the Filter doesn't include CostCategories or Tags. It only includes Dimensions. With Dimensions, Key must be LINKED_ACCOUNT and Value can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. AND and OR operators are not supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The lookback period that's used to generate the recommendation.
    /// This member is required.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The payment option that's used to generate these recommendations.
    /// This member is required.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The Savings Plans recommendation type that's requested.
    /// This member is required.
    public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
    /// The savings plan recommendation term that's used to generate these recommendations.
    /// This member is required.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init(
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = 0,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.savingsPlansType = savingsPlansType
        self.termInYears = termInYears
    }
}

public struct GetSavingsPlansUtilizationDetailsInput: Swift.Sendable {
    /// The data type.
    public var dataType: [CostExplorerClientTypes.SavingsPlansDataType]?
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilizationDetails uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    /// * AmortizedRecurringCommitment
    ///
    /// * AmortizedUpfrontCommitment
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        dataType: [CostExplorerClientTypes.SavingsPlansDataType]? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.dataType = dataType
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetSavingsPlansUtilizationInput: Swift.Sendable {
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * SAVINGS_PLANS_TYPE
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services utillization data for your Savings Plans. The GetSavingsPlansUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

public struct GetTagsInput: Swift.Sendable {
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetTags, MaxResults has an upper quota of 1000.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search for.
    public var searchString: Swift.String?
    /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING. When you use SortBy, NextPageToken and SearchString aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The key of the tag that you want to return values for.
    public var tagKey: Swift.String?
    /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        tagKey: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.tagKey = tagKey
        self.timePeriod = timePeriod
    }
}

public struct GetUsageForecastInput: Swift.Sendable {
    /// The filters that you want to use to filter your forecast. The GetUsageForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetUsageForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. Valid values for a GetUsageForecast call are the following:
    ///
    /// * USAGE_QUANTITY
    ///
    /// * NORMALIZED_USAGE_AMOUNT
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01. The start date must be equal to or later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

public struct UpdateAnomalySubscriptionInput: Swift.Sendable {
    /// The update to the frequency value that subscribers receive notifications.
    public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The update to the subscriber list.
    public var subscribers: [CostExplorerClientTypes.Subscriber]?
    /// A cost anomaly subscription Amazon Resource Name (ARN).
    /// This member is required.
    public var subscriptionArn: Swift.String?
    /// The new name of the subscription.
    public var subscriptionName: Swift.String?
    /// (deprecated) The update to the threshold value for receiving notifications. This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression. You can specify either Threshold or ThresholdExpression, but not both.
    @available(*, deprecated, message: "Threshold has been deprecated in favor of ThresholdExpression")
    public var threshold: Swift.Double?
    /// The update to the [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE, corresponding to an anomaly’s TotalImpact and TotalImpactPercentage, respectively (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details). The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000 in string format. You can specify either Threshold or ThresholdExpression, but not both. The following are examples of valid ThresholdExpressions:
    ///
    /// * Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
    ///
    /// * Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
    ///
    /// * AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
    ///
    /// * OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
    public var thresholdExpression: CostExplorerClientTypes.Expression?

    public init(
        frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
        monitorArnList: [Swift.String]? = nil,
        subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
        subscriptionArn: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        threshold: Swift.Double? = nil,
        thresholdExpression: CostExplorerClientTypes.Expression? = nil
    )
    {
        self.frequency = frequency
        self.monitorArnList = monitorArnList
        self.subscribers = subscribers
        self.subscriptionArn = subscriptionArn
        self.subscriptionName = subscriptionName
        self.threshold = threshold
        self.thresholdExpression = thresholdExpression
    }
}

public struct CreateAnomalyMonitorInput: Swift.Sendable {
    /// The cost anomaly detection monitor object that you want to create.
    /// This member is required.
    public var anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor?
    /// An optional list of tags to associate with the specified [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html). You can use resource tags to control access to your monitor using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.anomalyMonitor = anomalyMonitor
        self.resourceTags = resourceTags
    }
}

public struct CreateAnomalySubscriptionInput: Swift.Sendable {
    /// The cost anomaly subscription object that you want to create.
    /// This member is required.
    public var anomalySubscription: CostExplorerClientTypes.AnomalySubscription?
    /// An optional list of tags to associate with the specified [AnomalySubscription](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html). You can use resource tags to control access to your subscription using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        anomalySubscription: CostExplorerClientTypes.AnomalySubscription? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.anomalySubscription = anomalySubscription
        self.resourceTags = resourceTags
    }
}

extension CostExplorerClientTypes {

    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public struct CostCategory: Swift.Sendable {
        /// The unique identifier for your Cost Category.
        /// This member is required.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The effective end date of your Cost Category.
        public var effectiveEnd: Swift.String?
        /// The effective start date of your Cost Category.
        /// This member is required.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        /// This member is required.
        public var name: Swift.String?
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// The rule schema version in this particular Cost Category.
        /// This member is required.
        public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
        /// The rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
        /// This member is required.
        public var rules: [CostExplorerClientTypes.CostCategoryRule]?
        /// The split charge rules that are used to allocate your charges between your Cost Category values.
        public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

        public init(
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
            rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
            splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.processingStatus = processingStatus
            self.ruleVersion = ruleVersion
            self.rules = rules
            self.splitChargeRules = splitChargeRules
        }
    }
}

public struct CreateCostCategoryDefinitionInput: Swift.Sendable {
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
    public var effectiveStart: Swift.String?
    /// The unique name of the Cost Category.
    /// This member is required.
    public var name: Swift.String?
    /// An optional list of tags to associate with the specified [CostCategory](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html). You can use resource tags to control access to your cost category using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Cost Category rules used to categorize costs. For more information, see [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init(
        defaultValue: Swift.String? = nil,
        effectiveStart: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.defaultValue = defaultValue
        self.effectiveStart = effectiveStart
        self.name = name
        self.resourceTags = resourceTags
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

public struct GetAnomalyMonitorsOutput: Swift.Sendable {
    /// A list of cost anomaly monitors that includes the detailed metadata for each monitor.
    /// This member is required.
    public var anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalyMonitors = anomalyMonitors
        self.nextPageToken = nextPageToken
    }
}

public struct GetAnomalySubscriptionsOutput: Swift.Sendable {
    /// A list of cost anomaly subscriptions that includes the detailed metadata for each one.
    /// This member is required.
    public var anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalySubscriptions = anomalySubscriptions
        self.nextPageToken = nextPageToken
    }
}

public struct UpdateCostCategoryDefinitionInput: Swift.Sendable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
    public var effectiveStart: Swift.String?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Expression object used to categorize costs. For more information, see [CostCategoryRule ](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init(
        costCategoryArn: Swift.String? = nil,
        defaultValue: Swift.String? = nil,
        effectiveStart: Swift.String? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.effectiveStart = effectiveStart
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

public struct DescribeCostCategoryDefinitionOutput: Swift.Sendable {
    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public var costCategory: CostExplorerClientTypes.CostCategory?

    public init(
        costCategory: CostExplorerClientTypes.CostCategory? = nil
    )
    {
        self.costCategory = costCategory
    }
}

extension CreateAnomalyMonitorInput {

    static func urlPathProvider(_ value: CreateAnomalyMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAnomalySubscriptionInput {

    static func urlPathProvider(_ value: CreateAnomalySubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCostCategoryDefinitionInput {

    static func urlPathProvider(_ value: CreateCostCategoryDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAnomalyMonitorInput {

    static func urlPathProvider(_ value: DeleteAnomalyMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAnomalySubscriptionInput {

    static func urlPathProvider(_ value: DeleteAnomalySubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCostCategoryDefinitionInput {

    static func urlPathProvider(_ value: DeleteCostCategoryDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeCostCategoryDefinitionInput {

    static func urlPathProvider(_ value: DescribeCostCategoryDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension GetAnomaliesInput {

    static func urlPathProvider(_ value: GetAnomaliesInput) -> Swift.String? {
        return "/"
    }
}

extension GetAnomalyMonitorsInput {

    static func urlPathProvider(_ value: GetAnomalyMonitorsInput) -> Swift.String? {
        return "/"
    }
}

extension GetAnomalySubscriptionsInput {

    static func urlPathProvider(_ value: GetAnomalySubscriptionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetApproximateUsageRecordsInput {

    static func urlPathProvider(_ value: GetApproximateUsageRecordsInput) -> Swift.String? {
        return "/"
    }
}

extension GetCostAndUsageInput {

    static func urlPathProvider(_ value: GetCostAndUsageInput) -> Swift.String? {
        return "/"
    }
}

extension GetCostAndUsageWithResourcesInput {

    static func urlPathProvider(_ value: GetCostAndUsageWithResourcesInput) -> Swift.String? {
        return "/"
    }
}

extension GetCostCategoriesInput {

    static func urlPathProvider(_ value: GetCostCategoriesInput) -> Swift.String? {
        return "/"
    }
}

extension GetCostForecastInput {

    static func urlPathProvider(_ value: GetCostForecastInput) -> Swift.String? {
        return "/"
    }
}

extension GetDimensionValuesInput {

    static func urlPathProvider(_ value: GetDimensionValuesInput) -> Swift.String? {
        return "/"
    }
}

extension GetReservationCoverageInput {

    static func urlPathProvider(_ value: GetReservationCoverageInput) -> Swift.String? {
        return "/"
    }
}

extension GetReservationPurchaseRecommendationInput {

    static func urlPathProvider(_ value: GetReservationPurchaseRecommendationInput) -> Swift.String? {
        return "/"
    }
}

extension GetReservationUtilizationInput {

    static func urlPathProvider(_ value: GetReservationUtilizationInput) -> Swift.String? {
        return "/"
    }
}

extension GetRightsizingRecommendationInput {

    static func urlPathProvider(_ value: GetRightsizingRecommendationInput) -> Swift.String? {
        return "/"
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsInput {

    static func urlPathProvider(_ value: GetSavingsPlanPurchaseRecommendationDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetSavingsPlansCoverageInput {

    static func urlPathProvider(_ value: GetSavingsPlansCoverageInput) -> Swift.String? {
        return "/"
    }
}

extension GetSavingsPlansPurchaseRecommendationInput {

    static func urlPathProvider(_ value: GetSavingsPlansPurchaseRecommendationInput) -> Swift.String? {
        return "/"
    }
}

extension GetSavingsPlansUtilizationInput {

    static func urlPathProvider(_ value: GetSavingsPlansUtilizationInput) -> Swift.String? {
        return "/"
    }
}

extension GetSavingsPlansUtilizationDetailsInput {

    static func urlPathProvider(_ value: GetSavingsPlansUtilizationDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension GetTagsInput {

    static func urlPathProvider(_ value: GetTagsInput) -> Swift.String? {
        return "/"
    }
}

extension GetUsageForecastInput {

    static func urlPathProvider(_ value: GetUsageForecastInput) -> Swift.String? {
        return "/"
    }
}

extension ListCostAllocationTagBackfillHistoryInput {

    static func urlPathProvider(_ value: ListCostAllocationTagBackfillHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension ListCostAllocationTagsInput {

    static func urlPathProvider(_ value: ListCostAllocationTagsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCostCategoryDefinitionsInput {

    static func urlPathProvider(_ value: ListCostCategoryDefinitionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationInput {

    static func urlPathProvider(_ value: ListSavingsPlansPurchaseRecommendationGenerationInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ProvideAnomalyFeedbackInput {

    static func urlPathProvider(_ value: ProvideAnomalyFeedbackInput) -> Swift.String? {
        return "/"
    }
}

extension StartCostAllocationTagBackfillInput {

    static func urlPathProvider(_ value: StartCostAllocationTagBackfillInput) -> Swift.String? {
        return "/"
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationInput {

    static func urlPathProvider(_ value: StartSavingsPlansPurchaseRecommendationGenerationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAnomalyMonitorInput {

    static func urlPathProvider(_ value: UpdateAnomalyMonitorInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAnomalySubscriptionInput {

    static func urlPathProvider(_ value: UpdateAnomalySubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCostAllocationTagsStatusInput {

    static func urlPathProvider(_ value: UpdateCostAllocationTagsStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateCostCategoryDefinitionInput {

    static func urlPathProvider(_ value: UpdateCostCategoryDefinitionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAnomalyMonitorInput {

    static func write(value: CreateAnomalyMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyMonitor"].write(value.anomalyMonitor, with: CostExplorerClientTypes.AnomalyMonitor.write(value:to:))
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: CostExplorerClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAnomalySubscriptionInput {

    static func write(value: CreateAnomalySubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalySubscription"].write(value.anomalySubscription, with: CostExplorerClientTypes.AnomalySubscription.write(value:to:))
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: CostExplorerClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCostCategoryDefinitionInput {

    static func write(value: CreateCostCategoryDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["EffectiveStart"].write(value.effectiveStart)
        try writer["Name"].write(value.name)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: CostExplorerClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RuleVersion"].write(value.ruleVersion)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: CostExplorerClientTypes.CostCategoryRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SplitChargeRules"].writeList(value.splitChargeRules, memberWritingClosure: CostExplorerClientTypes.CostCategorySplitChargeRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteAnomalyMonitorInput {

    static func write(value: DeleteAnomalyMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorArn"].write(value.monitorArn)
    }
}

extension DeleteAnomalySubscriptionInput {

    static func write(value: DeleteAnomalySubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SubscriptionArn"].write(value.subscriptionArn)
    }
}

extension DeleteCostCategoryDefinitionInput {

    static func write(value: DeleteCostCategoryDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CostCategoryArn"].write(value.costCategoryArn)
    }
}

extension DescribeCostCategoryDefinitionInput {

    static func write(value: DescribeCostCategoryDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CostCategoryArn"].write(value.costCategoryArn)
        try writer["EffectiveOn"].write(value.effectiveOn)
    }
}

extension GetAnomaliesInput {

    static func write(value: GetAnomaliesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DateInterval"].write(value.dateInterval, with: CostExplorerClientTypes.AnomalyDateInterval.write(value:to:))
        try writer["Feedback"].write(value.feedback)
        try writer["MaxResults"].write(value.maxResults)
        try writer["MonitorArn"].write(value.monitorArn)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["TotalImpact"].write(value.totalImpact, with: CostExplorerClientTypes.TotalImpactFilter.write(value:to:))
    }
}

extension GetAnomalyMonitorsInput {

    static func write(value: GetAnomalyMonitorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["MonitorArnList"].writeList(value.monitorArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextPageToken"].write(value.nextPageToken)
    }
}

extension GetAnomalySubscriptionsInput {

    static func write(value: GetAnomalySubscriptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["MonitorArn"].write(value.monitorArn)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SubscriptionArnList"].writeList(value.subscriptionArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetApproximateUsageRecordsInput {

    static func write(value: GetApproximateUsageRecordsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApproximationDimension"].write(value.approximationDimension)
        try writer["Granularity"].write(value.granularity)
        try writer["Services"].writeList(value.services, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetCostAndUsageInput {

    static func write(value: GetCostAndUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: CostExplorerClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetCostAndUsageWithResourcesInput {

    static func write(value: GetCostAndUsageWithResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: CostExplorerClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetCostCategoriesInput {

    static func write(value: GetCostCategoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CostCategoryName"].write(value.costCategoryName)
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SearchString"].write(value.searchString)
        try writer["SortBy"].writeList(value.sortBy, memberWritingClosure: CostExplorerClientTypes.SortDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetCostForecastInput {

    static func write(value: GetCostForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["Metric"].write(value.metric)
        try writer["PredictionIntervalLevel"].write(value.predictionIntervalLevel)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetDimensionValuesInput {

    static func write(value: GetDimensionValuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Context"].write(value.context)
        try writer["Dimension"].write(value.dimension)
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SearchString"].write(value.searchString)
        try writer["SortBy"].writeList(value.sortBy, memberWritingClosure: CostExplorerClientTypes.SortDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetReservationCoverageInput {

    static func write(value: GetReservationCoverageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: CostExplorerClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SortBy"].write(value.sortBy, with: CostExplorerClientTypes.SortDefinition.write(value:to:))
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetReservationPurchaseRecommendationInput {

    static func write(value: GetReservationPurchaseRecommendationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["AccountScope"].write(value.accountScope)
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["LookbackPeriodInDays"].write(value.lookbackPeriodInDays)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["PageSize"].write(value.pageSize)
        try writer["PaymentOption"].write(value.paymentOption)
        try writer["Service"].write(value.service)
        try writer["ServiceSpecification"].write(value.serviceSpecification, with: CostExplorerClientTypes.ServiceSpecification.write(value:to:))
        try writer["TermInYears"].write(value.termInYears)
    }
}

extension GetReservationUtilizationInput {

    static func write(value: GetReservationUtilizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: CostExplorerClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SortBy"].write(value.sortBy, with: CostExplorerClientTypes.SortDefinition.write(value:to:))
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetRightsizingRecommendationInput {

    static func write(value: GetRightsizingRecommendationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configuration"].write(value.configuration, with: CostExplorerClientTypes.RightsizingRecommendationConfiguration.write(value:to:))
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["PageSize"].write(value.pageSize)
        try writer["Service"].write(value.service)
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsInput {

    static func write(value: GetSavingsPlanPurchaseRecommendationDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RecommendationDetailId"].write(value.recommendationDetailId)
    }
}

extension GetSavingsPlansCoverageInput {

    static func write(value: GetSavingsPlansCoverageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["GroupBy"].writeList(value.groupBy, memberWritingClosure: CostExplorerClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortBy"].write(value.sortBy, with: CostExplorerClientTypes.SortDefinition.write(value:to:))
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetSavingsPlansPurchaseRecommendationInput {

    static func write(value: GetSavingsPlansPurchaseRecommendationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountScope"].write(value.accountScope)
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["LookbackPeriodInDays"].write(value.lookbackPeriodInDays)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["PageSize"].write(value.pageSize)
        try writer["PaymentOption"].write(value.paymentOption)
        try writer["SavingsPlansType"].write(value.savingsPlansType)
        try writer["TermInYears"].write(value.termInYears)
    }
}

extension GetSavingsPlansUtilizationInput {

    static func write(value: GetSavingsPlansUtilizationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["SortBy"].write(value.sortBy, with: CostExplorerClientTypes.SortDefinition.write(value:to:))
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetSavingsPlansUtilizationDetailsInput {

    static func write(value: GetSavingsPlansUtilizationDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataType"].writeList(value.dataType, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CostExplorerClientTypes.SavingsPlansDataType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["SortBy"].write(value.sortBy, with: CostExplorerClientTypes.SortDefinition.write(value:to:))
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetTagsInput {

    static func write(value: GetTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["SearchString"].write(value.searchString)
        try writer["SortBy"].writeList(value.sortBy, memberWritingClosure: CostExplorerClientTypes.SortDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TagKey"].write(value.tagKey)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension GetUsageForecastInput {

    static func write(value: GetUsageForecastInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Granularity"].write(value.granularity)
        try writer["Metric"].write(value.metric)
        try writer["PredictionIntervalLevel"].write(value.predictionIntervalLevel)
        try writer["TimePeriod"].write(value.timePeriod, with: CostExplorerClientTypes.DateInterval.write(value:to:))
    }
}

extension ListCostAllocationTagBackfillHistoryInput {

    static func write(value: ListCostAllocationTagBackfillHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCostAllocationTagsInput {

    static func write(value: ListCostAllocationTagsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Status"].write(value.status)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension ListCostCategoryDefinitionsInput {

    static func write(value: ListCostCategoryDefinitionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EffectiveOn"].write(value.effectiveOn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationInput {

    static func write(value: ListSavingsPlansPurchaseRecommendationGenerationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GenerationStatus"].write(value.generationStatus)
        try writer["NextPageToken"].write(value.nextPageToken)
        try writer["PageSize"].write(value.pageSize)
        try writer["RecommendationIds"].writeList(value.recommendationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ProvideAnomalyFeedbackInput {

    static func write(value: ProvideAnomalyFeedbackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AnomalyId"].write(value.anomalyId)
        try writer["Feedback"].write(value.feedback)
    }
}

extension StartCostAllocationTagBackfillInput {

    static func write(value: StartCostAllocationTagBackfillInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BackfillFrom"].write(value.backfillFrom)
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationInput {

    static func write(value: StartSavingsPlansPurchaseRecommendationGenerationInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: CostExplorerClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAnomalyMonitorInput {

    static func write(value: UpdateAnomalyMonitorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MonitorArn"].write(value.monitorArn)
        try writer["MonitorName"].write(value.monitorName)
    }
}

extension UpdateAnomalySubscriptionInput {

    static func write(value: UpdateAnomalySubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Frequency"].write(value.frequency)
        try writer["MonitorArnList"].writeList(value.monitorArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: CostExplorerClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubscriptionArn"].write(value.subscriptionArn)
        try writer["SubscriptionName"].write(value.subscriptionName)
        try writer["Threshold"].write(value.threshold)
        try writer["ThresholdExpression"].write(value.thresholdExpression, with: CostExplorerClientTypes.Expression.write(value:to:))
    }
}

extension UpdateCostAllocationTagsStatusInput {

    static func write(value: UpdateCostAllocationTagsStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CostAllocationTagsStatus"].writeList(value.costAllocationTagsStatus, memberWritingClosure: CostExplorerClientTypes.CostAllocationTagStatusEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateCostCategoryDefinitionInput {

    static func write(value: UpdateCostCategoryDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CostCategoryArn"].write(value.costCategoryArn)
        try writer["DefaultValue"].write(value.defaultValue)
        try writer["EffectiveStart"].write(value.effectiveStart)
        try writer["RuleVersion"].write(value.ruleVersion)
        try writer["Rules"].writeList(value.rules, memberWritingClosure: CostExplorerClientTypes.CostCategoryRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SplitChargeRules"].writeList(value.splitChargeRules, memberWritingClosure: CostExplorerClientTypes.CostCategorySplitChargeRule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAnomalyMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnomalyMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnomalyMonitorOutput()
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAnomalySubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnomalySubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnomalySubscriptionOutput()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateCostCategoryDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCostCategoryDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCostCategoryDefinitionOutput()
        value.costCategoryArn = try reader["CostCategoryArn"].readIfPresent()
        value.effectiveStart = try reader["EffectiveStart"].readIfPresent()
        return value
    }
}

extension DeleteAnomalyMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnomalyMonitorOutput {
        return DeleteAnomalyMonitorOutput()
    }
}

extension DeleteAnomalySubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnomalySubscriptionOutput {
        return DeleteAnomalySubscriptionOutput()
    }
}

extension DeleteCostCategoryDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCostCategoryDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteCostCategoryDefinitionOutput()
        value.costCategoryArn = try reader["CostCategoryArn"].readIfPresent()
        value.effectiveEnd = try reader["EffectiveEnd"].readIfPresent()
        return value
    }
}

extension DescribeCostCategoryDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeCostCategoryDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeCostCategoryDefinitionOutput()
        value.costCategory = try reader["CostCategory"].readIfPresent(with: CostExplorerClientTypes.CostCategory.read(from:))
        return value
    }
}

extension GetAnomaliesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnomaliesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnomaliesOutput()
        value.anomalies = try reader["Anomalies"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.Anomaly.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension GetAnomalyMonitorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnomalyMonitorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnomalyMonitorsOutput()
        value.anomalyMonitors = try reader["AnomalyMonitors"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.AnomalyMonitor.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension GetAnomalySubscriptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnomalySubscriptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnomalySubscriptionsOutput()
        value.anomalySubscriptions = try reader["AnomalySubscriptions"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.AnomalySubscription.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension GetApproximateUsageRecordsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApproximateUsageRecordsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApproximateUsageRecordsOutput()
        value.lookbackPeriod = try reader["LookbackPeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.services = try reader["Services"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.totalRecords = try reader["TotalRecords"].readIfPresent() ?? 0
        return value
    }
}

extension GetCostAndUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCostAndUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCostAndUsageOutput()
        value.dimensionValueAttributes = try reader["DimensionValueAttributes"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.DimensionValuesWithAttributes.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupDefinitions = try reader["GroupDefinitions"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.resultsByTime = try reader["ResultsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ResultByTime.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCostAndUsageWithResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCostAndUsageWithResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCostAndUsageWithResourcesOutput()
        value.dimensionValueAttributes = try reader["DimensionValueAttributes"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.DimensionValuesWithAttributes.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.groupDefinitions = try reader["GroupDefinitions"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.resultsByTime = try reader["ResultsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ResultByTime.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetCostCategoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCostCategoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCostCategoriesOutput()
        value.costCategoryNames = try reader["CostCategoryNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.costCategoryValues = try reader["CostCategoryValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.returnSize = try reader["ReturnSize"].readIfPresent() ?? 0
        value.totalSize = try reader["TotalSize"].readIfPresent() ?? 0
        return value
    }
}

extension GetCostForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCostForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCostForecastOutput()
        value.forecastResultsByTime = try reader["ForecastResultsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ForecastResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.MetricValue.read(from:))
        return value
    }
}

extension GetDimensionValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDimensionValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDimensionValuesOutput()
        value.dimensionValues = try reader["DimensionValues"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.DimensionValuesWithAttributes.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.returnSize = try reader["ReturnSize"].readIfPresent() ?? 0
        value.totalSize = try reader["TotalSize"].readIfPresent() ?? 0
        return value
    }
}

extension GetReservationCoverageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReservationCoverageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReservationCoverageOutput()
        value.coveragesByTime = try reader["CoveragesByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CoverageByTime.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.Coverage.read(from:))
        return value
    }
}

extension GetReservationPurchaseRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReservationPurchaseRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReservationPurchaseRecommendationOutput()
        value.metadata = try reader["Metadata"].readIfPresent(with: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata.read(from:))
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.recommendations = try reader["Recommendations"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ReservationPurchaseRecommendation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetReservationUtilizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReservationUtilizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReservationUtilizationOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.ReservationAggregates.read(from:))
        value.utilizationsByTime = try reader["UtilizationsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.UtilizationByTime.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetRightsizingRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRightsizingRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRightsizingRecommendationOutput()
        value.configuration = try reader["Configuration"].readIfPresent(with: CostExplorerClientTypes.RightsizingRecommendationConfiguration.read(from:))
        value.metadata = try reader["Metadata"].readIfPresent(with: CostExplorerClientTypes.RightsizingRecommendationMetadata.read(from:))
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.rightsizingRecommendations = try reader["RightsizingRecommendations"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.RightsizingRecommendation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.summary = try reader["Summary"].readIfPresent(with: CostExplorerClientTypes.RightsizingRecommendationSummary.read(from:))
        return value
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSavingsPlanPurchaseRecommendationDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSavingsPlanPurchaseRecommendationDetailsOutput()
        value.recommendationDetailData = try reader["RecommendationDetailData"].readIfPresent(with: CostExplorerClientTypes.RecommendationDetailData.read(from:))
        value.recommendationDetailId = try reader["RecommendationDetailId"].readIfPresent()
        return value
    }
}

extension GetSavingsPlansCoverageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSavingsPlansCoverageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSavingsPlansCoverageOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.savingsPlansCoverages = try reader["SavingsPlansCoverages"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.SavingsPlansCoverage.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetSavingsPlansPurchaseRecommendationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSavingsPlansPurchaseRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSavingsPlansPurchaseRecommendationOutput()
        value.metadata = try reader["Metadata"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata.read(from:))
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.savingsPlansPurchaseRecommendation = try reader["SavingsPlansPurchaseRecommendation"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation.read(from:))
        return value
    }
}

extension GetSavingsPlansUtilizationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSavingsPlansUtilizationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSavingsPlansUtilizationOutput()
        value.savingsPlansUtilizationsByTime = try reader["SavingsPlansUtilizationsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.SavingsPlansUtilizationByTime.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansUtilizationAggregates.read(from:))
        return value
    }
}

extension GetSavingsPlansUtilizationDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSavingsPlansUtilizationDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSavingsPlansUtilizationDetailsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.savingsPlansUtilizationDetails = try reader["SavingsPlansUtilizationDetails"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.SavingsPlansUtilizationDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansUtilizationAggregates.read(from:))
        return value
    }
}

extension GetTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTagsOutput()
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        value.returnSize = try reader["ReturnSize"].readIfPresent() ?? 0
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.totalSize = try reader["TotalSize"].readIfPresent() ?? 0
        return value
    }
}

extension GetUsageForecastOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUsageForecastOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUsageForecastOutput()
        value.forecastResultsByTime = try reader["ForecastResultsByTime"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ForecastResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.MetricValue.read(from:))
        return value
    }
}

extension ListCostAllocationTagBackfillHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCostAllocationTagBackfillHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCostAllocationTagBackfillHistoryOutput()
        value.backfillRequests = try reader["BackfillRequests"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostAllocationTagBackfillRequest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCostAllocationTagsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCostAllocationTagsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCostAllocationTagsOutput()
        value.costAllocationTags = try reader["CostAllocationTags"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostAllocationTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCostCategoryDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCostCategoryDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCostCategoryDefinitionsOutput()
        value.costCategoryReferences = try reader["CostCategoryReferences"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategoryReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSavingsPlansPurchaseRecommendationGenerationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSavingsPlansPurchaseRecommendationGenerationOutput()
        value.generationSummaryList = try reader["GenerationSummaryList"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.GenerationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextPageToken = try reader["NextPageToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ProvideAnomalyFeedbackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ProvideAnomalyFeedbackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ProvideAnomalyFeedbackOutput()
        value.anomalyId = try reader["AnomalyId"].readIfPresent() ?? ""
        return value
    }
}

extension StartCostAllocationTagBackfillOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartCostAllocationTagBackfillOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartCostAllocationTagBackfillOutput()
        value.backfillRequest = try reader["BackfillRequest"].readIfPresent(with: CostExplorerClientTypes.CostAllocationTagBackfillRequest.read(from:))
        return value
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSavingsPlansPurchaseRecommendationGenerationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSavingsPlansPurchaseRecommendationGenerationOutput()
        value.estimatedCompletionTime = try reader["EstimatedCompletionTime"].readIfPresent()
        value.generationStartedTime = try reader["GenerationStartedTime"].readIfPresent()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAnomalyMonitorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnomalyMonitorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnomalyMonitorOutput()
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateAnomalySubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnomalySubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnomalySubscriptionOutput()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateCostAllocationTagsStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCostAllocationTagsStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCostAllocationTagsStatusOutput()
        value.errors = try reader["Errors"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.UpdateCostAllocationTagsStatusError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateCostCategoryDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCostCategoryDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCostCategoryDefinitionOutput()
        value.costCategoryArn = try reader["CostCategoryArn"].readIfPresent()
        value.effectiveStart = try reader["EffectiveStart"].readIfPresent()
        return value
    }
}

enum CreateAnomalyMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAnomalySubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownMonitorException": return try UnknownMonitorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCostCategoryDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnomalyMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownMonitorException": return try UnknownMonitorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnomalySubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownSubscriptionException": return try UnknownSubscriptionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCostCategoryDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeCostCategoryDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnomaliesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnomalyMonitorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownMonitorException": return try UnknownMonitorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnomalySubscriptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownSubscriptionException": return try UnknownSubscriptionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApproximateUsageRecordsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCostAndUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillExpirationException": return try BillExpirationException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RequestChangedException": return try RequestChangedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCostAndUsageWithResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillExpirationException": return try BillExpirationException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RequestChangedException": return try RequestChangedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCostCategoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillExpirationException": return try BillExpirationException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RequestChangedException": return try RequestChangedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCostForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDimensionValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillExpirationException": return try BillExpirationException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RequestChangedException": return try RequestChangedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReservationCoverageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReservationPurchaseRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReservationUtilizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRightsizingRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSavingsPlanPurchaseRecommendationDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSavingsPlansCoverageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSavingsPlansPurchaseRecommendationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSavingsPlansUtilizationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSavingsPlansUtilizationDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BillExpirationException": return try BillExpirationException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "RequestChangedException": return try RequestChangedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUsageForecastOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnresolvableUsageUnitException": return try UnresolvableUsageUnitException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCostAllocationTagBackfillHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCostAllocationTagsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCostCategoryDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSavingsPlansPurchaseRecommendationGenerationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ProvideAnomalyFeedbackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartCostAllocationTagBackfillOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BackfillLimitExceededException": return try BackfillLimitExceededException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSavingsPlansPurchaseRecommendationGenerationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "GenerationExistsException": return try GenerationExistsException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnomalyMonitorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownMonitorException": return try UnknownMonitorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnomalySubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "UnknownMonitorException": return try UnknownMonitorException.makeError(baseError: baseError)
            case "UnknownSubscriptionException": return try UnknownSubscriptionException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCostAllocationTagsStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCostCategoryDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnknownMonitorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnknownMonitorException {
        let reader = baseError.errorBodyReader
        var value = UnknownMonitorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnknownSubscriptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnknownSubscriptionException {
        let reader = baseError.errorBodyReader
        var value = UnknownSubscriptionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DataUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DataUnavailableException {
        let reader = baseError.errorBodyReader
        var value = DataUnavailableException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BillExpirationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BillExpirationException {
        let reader = baseError.errorBodyReader
        var value = BillExpirationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestChangedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RequestChangedException {
        let reader = baseError.errorBodyReader
        var value = RequestChangedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnresolvableUsageUnitException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnresolvableUsageUnitException {
        let reader = baseError.errorBodyReader
        var value = UnresolvableUsageUnitException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BackfillLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> BackfillLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = BackfillLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GenerationExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> GenerationExistsException {
        let reader = baseError.errorBodyReader
        var value = GenerationExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CostExplorerClientTypes.CostCategory {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategory()
        value.costCategoryArn = try reader["CostCategoryArn"].readIfPresent() ?? ""
        value.effectiveStart = try reader["EffectiveStart"].readIfPresent() ?? ""
        value.effectiveEnd = try reader["EffectiveEnd"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.ruleVersion = try reader["RuleVersion"].readIfPresent() ?? .sdkUnknown("")
        value.rules = try reader["Rules"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategoryRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.splitChargeRules = try reader["SplitChargeRules"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategorySplitChargeRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.processingStatus = try reader["ProcessingStatus"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategoryProcessingStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CostCategoryProcessingStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategoryProcessingStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategoryProcessingStatus()
        value.component = try reader["Component"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CostCategorySplitChargeRule {

    static func write(value: CostExplorerClientTypes.CostCategorySplitChargeRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Method"].write(value.method)
        try writer["Parameters"].writeList(value.parameters, memberWritingClosure: CostExplorerClientTypes.CostCategorySplitChargeRuleParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategorySplitChargeRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategorySplitChargeRule()
        value.source = try reader["Source"].readIfPresent() ?? ""
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.method = try reader["Method"].readIfPresent() ?? .sdkUnknown("")
        value.parameters = try reader["Parameters"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategorySplitChargeRuleParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.CostCategorySplitChargeRuleParameter {

    static func write(value: CostExplorerClientTypes.CostCategorySplitChargeRuleParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategorySplitChargeRuleParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategorySplitChargeRuleParameter()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CostExplorerClientTypes.CostCategoryRule {

    static func write(value: CostExplorerClientTypes.CostCategoryRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InheritedValue"].write(value.inheritedValue, with: CostExplorerClientTypes.CostCategoryInheritedValueDimension.write(value:to:))
        try writer["Rule"].write(value.rule, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Type"].write(value.type)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategoryRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategoryRule()
        value.value = try reader["Value"].readIfPresent()
        value.rule = try reader["Rule"].readIfPresent(with: CostExplorerClientTypes.Expression.read(from:))
        value.inheritedValue = try reader["InheritedValue"].readIfPresent(with: CostExplorerClientTypes.CostCategoryInheritedValueDimension.read(from:))
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CostCategoryInheritedValueDimension {

    static func write(value: CostExplorerClientTypes.CostCategoryInheritedValueDimension?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DimensionKey"].write(value.dimensionKey)
        try writer["DimensionName"].write(value.dimensionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategoryInheritedValueDimension {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategoryInheritedValueDimension()
        value.dimensionName = try reader["DimensionName"].readIfPresent()
        value.dimensionKey = try reader["DimensionKey"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.Expression {

    static func write(value: CostExplorerClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["And"].writeList(value.and, memberWritingClosure: CostExplorerClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CostCategories"].write(value.costCategories, with: CostExplorerClientTypes.CostCategoryValues.write(value:to:))
        try writer["Dimensions"].write(value.dimensions, with: CostExplorerClientTypes.DimensionValues.write(value:to:))
        try writer["Not"].write(value.not, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["Or"].writeList(value.or, memberWritingClosure: CostExplorerClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].write(value.tags, with: CostExplorerClientTypes.TagValues.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Expression()
        value.or = try reader["Or"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.and = try reader["And"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.not = try reader["Not"].readIfPresent(with: CostExplorerClientTypes.Expression.read(from:))
        value.dimensions = try reader["Dimensions"].readIfPresent(with: CostExplorerClientTypes.DimensionValues.read(from:))
        value.tags = try reader["Tags"].readIfPresent(with: CostExplorerClientTypes.TagValues.read(from:))
        value.costCategories = try reader["CostCategories"].readIfPresent(with: CostExplorerClientTypes.CostCategoryValues.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.CostCategoryValues {

    static func write(value: CostExplorerClientTypes.CostCategoryValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["MatchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CostExplorerClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategoryValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategoryValues()
        value.key = try reader["Key"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchOptions = try reader["MatchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CostExplorerClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.TagValues {

    static func write(value: CostExplorerClientTypes.TagValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["MatchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CostExplorerClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.TagValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.TagValues()
        value.key = try reader["Key"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchOptions = try reader["MatchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CostExplorerClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.DimensionValues {

    static func write(value: CostExplorerClientTypes.DimensionValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["MatchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CostExplorerClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.DimensionValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.DimensionValues()
        value.key = try reader["Key"].readIfPresent()
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchOptions = try reader["MatchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CostExplorerClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.Anomaly {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Anomaly {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Anomaly()
        value.anomalyId = try reader["AnomalyId"].readIfPresent() ?? ""
        value.anomalyStartDate = try reader["AnomalyStartDate"].readIfPresent()
        value.anomalyEndDate = try reader["AnomalyEndDate"].readIfPresent()
        value.dimensionValue = try reader["DimensionValue"].readIfPresent()
        value.rootCauses = try reader["RootCauses"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.RootCause.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.anomalyScore = try reader["AnomalyScore"].readIfPresent(with: CostExplorerClientTypes.AnomalyScore.read(from:))
        value.impact = try reader["Impact"].readIfPresent(with: CostExplorerClientTypes.Impact.read(from:))
        value.monitorArn = try reader["MonitorArn"].readIfPresent() ?? ""
        value.feedback = try reader["Feedback"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.Impact {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Impact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Impact()
        value.maxImpact = try reader["MaxImpact"].readIfPresent() ?? 0
        value.totalImpact = try reader["TotalImpact"].readIfPresent() ?? 0
        value.totalActualSpend = try reader["TotalActualSpend"].readIfPresent()
        value.totalExpectedSpend = try reader["TotalExpectedSpend"].readIfPresent()
        value.totalImpactPercentage = try reader["TotalImpactPercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.AnomalyScore {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.AnomalyScore {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.AnomalyScore()
        value.maxScore = try reader["MaxScore"].readIfPresent() ?? 0
        value.currentScore = try reader["CurrentScore"].readIfPresent() ?? 0
        return value
    }
}

extension CostExplorerClientTypes.RootCause {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RootCause {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RootCause()
        value.service = try reader["Service"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.linkedAccount = try reader["LinkedAccount"].readIfPresent()
        value.usageType = try reader["UsageType"].readIfPresent()
        value.linkedAccountName = try reader["LinkedAccountName"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.AnomalyMonitor {

    static func write(value: CostExplorerClientTypes.AnomalyMonitor?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreationDate"].write(value.creationDate)
        try writer["DimensionalValueCount"].write(value.dimensionalValueCount)
        try writer["LastEvaluatedDate"].write(value.lastEvaluatedDate)
        try writer["LastUpdatedDate"].write(value.lastUpdatedDate)
        try writer["MonitorArn"].write(value.monitorArn)
        try writer["MonitorDimension"].write(value.monitorDimension)
        try writer["MonitorName"].write(value.monitorName)
        try writer["MonitorSpecification"].write(value.monitorSpecification, with: CostExplorerClientTypes.Expression.write(value:to:))
        try writer["MonitorType"].write(value.monitorType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.AnomalyMonitor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.AnomalyMonitor()
        value.monitorArn = try reader["MonitorArn"].readIfPresent()
        value.monitorName = try reader["MonitorName"].readIfPresent() ?? ""
        value.creationDate = try reader["CreationDate"].readIfPresent()
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readIfPresent()
        value.lastEvaluatedDate = try reader["LastEvaluatedDate"].readIfPresent()
        value.monitorType = try reader["MonitorType"].readIfPresent() ?? .sdkUnknown("")
        value.monitorDimension = try reader["MonitorDimension"].readIfPresent()
        value.monitorSpecification = try reader["MonitorSpecification"].readIfPresent(with: CostExplorerClientTypes.Expression.read(from:))
        value.dimensionalValueCount = try reader["DimensionalValueCount"].readIfPresent() ?? 0
        return value
    }
}

extension CostExplorerClientTypes.AnomalySubscription {

    static func write(value: CostExplorerClientTypes.AnomalySubscription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Frequency"].write(value.frequency)
        try writer["MonitorArnList"].writeList(value.monitorArnList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: CostExplorerClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubscriptionArn"].write(value.subscriptionArn)
        try writer["SubscriptionName"].write(value.subscriptionName)
        try writer["Threshold"].write(value.threshold)
        try writer["ThresholdExpression"].write(value.thresholdExpression, with: CostExplorerClientTypes.Expression.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.AnomalySubscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.AnomalySubscription()
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.monitorArnList = try reader["MonitorArnList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subscribers = try reader["Subscribers"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.Subscriber.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.threshold = try reader["Threshold"].readIfPresent()
        value.frequency = try reader["Frequency"].readIfPresent() ?? .sdkUnknown("")
        value.subscriptionName = try reader["SubscriptionName"].readIfPresent() ?? ""
        value.thresholdExpression = try reader["ThresholdExpression"].readIfPresent(with: CostExplorerClientTypes.Expression.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.Subscriber {

    static func write(value: CostExplorerClientTypes.Subscriber?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["Status"].write(value.status)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Subscriber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Subscriber()
        value.address = try reader["Address"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.DateInterval {

    static func write(value: CostExplorerClientTypes.DateInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end)
        try writer["Start"].write(value.start)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.DateInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.DateInterval()
        value.start = try reader["Start"].readIfPresent() ?? ""
        value.end = try reader["End"].readIfPresent() ?? ""
        return value
    }
}

extension CostExplorerClientTypes.GroupDefinition {

    static func write(value: CostExplorerClientTypes.GroupDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.GroupDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.GroupDefinition()
        value.type = try reader["Type"].readIfPresent()
        value.key = try reader["Key"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ResultByTime {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ResultByTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ResultByTime()
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.total = try reader["Total"].readMapIfPresent(valueReadingClosure: CostExplorerClientTypes.MetricValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.Group.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.estimated = try reader["Estimated"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.Group {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Group {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Group()
        value.keys = try reader["Keys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.metrics = try reader["Metrics"].readMapIfPresent(valueReadingClosure: CostExplorerClientTypes.MetricValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.MetricValue {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.MetricValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.MetricValue()
        value.amount = try reader["Amount"].readIfPresent()
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.DimensionValuesWithAttributes {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.DimensionValuesWithAttributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.DimensionValuesWithAttributes()
        value.value = try reader["Value"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.ForecastResult {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ForecastResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ForecastResult()
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.meanValue = try reader["MeanValue"].readIfPresent()
        value.predictionIntervalLowerBound = try reader["PredictionIntervalLowerBound"].readIfPresent()
        value.predictionIntervalUpperBound = try reader["PredictionIntervalUpperBound"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CoverageByTime {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CoverageByTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CoverageByTime()
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ReservationCoverageGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.Coverage.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.Coverage {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.Coverage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.Coverage()
        value.coverageHours = try reader["CoverageHours"].readIfPresent(with: CostExplorerClientTypes.CoverageHours.read(from:))
        value.coverageNormalizedUnits = try reader["CoverageNormalizedUnits"].readIfPresent(with: CostExplorerClientTypes.CoverageNormalizedUnits.read(from:))
        value.coverageCost = try reader["CoverageCost"].readIfPresent(with: CostExplorerClientTypes.CoverageCost.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.CoverageCost {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CoverageCost {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CoverageCost()
        value.onDemandCost = try reader["OnDemandCost"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CoverageNormalizedUnits {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CoverageNormalizedUnits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CoverageNormalizedUnits()
        value.onDemandNormalizedUnits = try reader["OnDemandNormalizedUnits"].readIfPresent()
        value.reservedNormalizedUnits = try reader["ReservedNormalizedUnits"].readIfPresent()
        value.totalRunningNormalizedUnits = try reader["TotalRunningNormalizedUnits"].readIfPresent()
        value.coverageNormalizedUnitsPercentage = try reader["CoverageNormalizedUnitsPercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CoverageHours {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CoverageHours {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CoverageHours()
        value.onDemandHours = try reader["OnDemandHours"].readIfPresent()
        value.reservedHours = try reader["ReservedHours"].readIfPresent()
        value.totalRunningHours = try reader["TotalRunningHours"].readIfPresent()
        value.coverageHoursPercentage = try reader["CoverageHoursPercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ReservationCoverageGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationCoverageGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationCoverageGroup()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.coverage = try reader["Coverage"].readIfPresent(with: CostExplorerClientTypes.Coverage.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        value.generationTimestamp = try reader["GenerationTimestamp"].readIfPresent()
        value.additionalMetadata = try reader["AdditionalMetadata"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ReservationPurchaseRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationPurchaseRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationPurchaseRecommendation()
        value.accountScope = try reader["AccountScope"].readIfPresent()
        value.lookbackPeriodInDays = try reader["LookbackPeriodInDays"].readIfPresent()
        value.termInYears = try reader["TermInYears"].readIfPresent()
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.serviceSpecification = try reader["ServiceSpecification"].readIfPresent(with: CostExplorerClientTypes.ServiceSpecification.read(from:))
        value.recommendationDetails = try reader["RecommendationDetails"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ReservationPurchaseRecommendationDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.recommendationSummary = try reader["RecommendationSummary"].readIfPresent(with: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationPurchaseRecommendationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationPurchaseRecommendationSummary()
        value.totalEstimatedMonthlySavingsAmount = try reader["TotalEstimatedMonthlySavingsAmount"].readIfPresent()
        value.totalEstimatedMonthlySavingsPercentage = try reader["TotalEstimatedMonthlySavingsPercentage"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationPurchaseRecommendationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationPurchaseRecommendationDetail()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.instanceDetails = try reader["InstanceDetails"].readIfPresent(with: CostExplorerClientTypes.InstanceDetails.read(from:))
        value.recommendedNumberOfInstancesToPurchase = try reader["RecommendedNumberOfInstancesToPurchase"].readIfPresent()
        value.recommendedNormalizedUnitsToPurchase = try reader["RecommendedNormalizedUnitsToPurchase"].readIfPresent()
        value.minimumNumberOfInstancesUsedPerHour = try reader["MinimumNumberOfInstancesUsedPerHour"].readIfPresent()
        value.minimumNormalizedUnitsUsedPerHour = try reader["MinimumNormalizedUnitsUsedPerHour"].readIfPresent()
        value.maximumNumberOfInstancesUsedPerHour = try reader["MaximumNumberOfInstancesUsedPerHour"].readIfPresent()
        value.maximumNormalizedUnitsUsedPerHour = try reader["MaximumNormalizedUnitsUsedPerHour"].readIfPresent()
        value.averageNumberOfInstancesUsedPerHour = try reader["AverageNumberOfInstancesUsedPerHour"].readIfPresent()
        value.averageNormalizedUnitsUsedPerHour = try reader["AverageNormalizedUnitsUsedPerHour"].readIfPresent()
        value.averageUtilization = try reader["AverageUtilization"].readIfPresent()
        value.estimatedBreakEvenInMonths = try reader["EstimatedBreakEvenInMonths"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.estimatedMonthlySavingsAmount = try reader["EstimatedMonthlySavingsAmount"].readIfPresent()
        value.estimatedMonthlySavingsPercentage = try reader["EstimatedMonthlySavingsPercentage"].readIfPresent()
        value.estimatedMonthlyOnDemandCost = try reader["EstimatedMonthlyOnDemandCost"].readIfPresent()
        value.estimatedReservationCostForLookbackPeriod = try reader["EstimatedReservationCostForLookbackPeriod"].readIfPresent()
        value.upfrontCost = try reader["UpfrontCost"].readIfPresent()
        value.recurringStandardMonthlyCost = try reader["RecurringStandardMonthlyCost"].readIfPresent()
        value.reservedCapacityDetails = try reader["ReservedCapacityDetails"].readIfPresent(with: CostExplorerClientTypes.ReservedCapacityDetails.read(from:))
        value.recommendedNumberOfCapacityUnitsToPurchase = try reader["RecommendedNumberOfCapacityUnitsToPurchase"].readIfPresent()
        value.minimumNumberOfCapacityUnitsUsedPerHour = try reader["MinimumNumberOfCapacityUnitsUsedPerHour"].readIfPresent()
        value.maximumNumberOfCapacityUnitsUsedPerHour = try reader["MaximumNumberOfCapacityUnitsUsedPerHour"].readIfPresent()
        value.averageNumberOfCapacityUnitsUsedPerHour = try reader["AverageNumberOfCapacityUnitsUsedPerHour"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ReservedCapacityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservedCapacityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservedCapacityDetails()
        value.dynamoDBCapacityDetails = try reader["DynamoDBCapacityDetails"].readIfPresent(with: CostExplorerClientTypes.DynamoDBCapacityDetails.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.DynamoDBCapacityDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.DynamoDBCapacityDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.DynamoDBCapacityDetails()
        value.capacityUnits = try reader["CapacityUnits"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.InstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.InstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.InstanceDetails()
        value.ec2InstanceDetails = try reader["EC2InstanceDetails"].readIfPresent(with: CostExplorerClientTypes.EC2InstanceDetails.read(from:))
        value.rdsInstanceDetails = try reader["RDSInstanceDetails"].readIfPresent(with: CostExplorerClientTypes.RDSInstanceDetails.read(from:))
        value.redshiftInstanceDetails = try reader["RedshiftInstanceDetails"].readIfPresent(with: CostExplorerClientTypes.RedshiftInstanceDetails.read(from:))
        value.elastiCacheInstanceDetails = try reader["ElastiCacheInstanceDetails"].readIfPresent(with: CostExplorerClientTypes.ElastiCacheInstanceDetails.read(from:))
        value.esInstanceDetails = try reader["ESInstanceDetails"].readIfPresent(with: CostExplorerClientTypes.ESInstanceDetails.read(from:))
        value.memoryDBInstanceDetails = try reader["MemoryDBInstanceDetails"].readIfPresent(with: CostExplorerClientTypes.MemoryDBInstanceDetails.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.MemoryDBInstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.MemoryDBInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.MemoryDBInstanceDetails()
        value.family = try reader["Family"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.ESInstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ESInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ESInstanceDetails()
        value.instanceClass = try reader["InstanceClass"].readIfPresent()
        value.instanceSize = try reader["InstanceSize"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.ElastiCacheInstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ElastiCacheInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ElastiCacheInstanceDetails()
        value.family = try reader["Family"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.productDescription = try reader["ProductDescription"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.RedshiftInstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RedshiftInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RedshiftInstanceDetails()
        value.family = try reader["Family"].readIfPresent()
        value.nodeType = try reader["NodeType"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.RDSInstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RDSInstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RDSInstanceDetails()
        value.family = try reader["Family"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.databaseEngine = try reader["DatabaseEngine"].readIfPresent()
        value.databaseEdition = try reader["DatabaseEdition"].readIfPresent()
        value.deploymentOption = try reader["DeploymentOption"].readIfPresent()
        value.licenseModel = try reader["LicenseModel"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.EC2InstanceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.EC2InstanceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.EC2InstanceDetails()
        value.family = try reader["Family"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.availabilityZone = try reader["AvailabilityZone"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.tenancy = try reader["Tenancy"].readIfPresent()
        value.currentGeneration = try reader["CurrentGeneration"].readIfPresent() ?? false
        value.sizeFlexEligible = try reader["SizeFlexEligible"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.ServiceSpecification {

    static func write(value: CostExplorerClientTypes.ServiceSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EC2Specification"].write(value.ec2Specification, with: CostExplorerClientTypes.EC2Specification.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ServiceSpecification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ServiceSpecification()
        value.ec2Specification = try reader["EC2Specification"].readIfPresent(with: CostExplorerClientTypes.EC2Specification.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.EC2Specification {

    static func write(value: CostExplorerClientTypes.EC2Specification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OfferingClass"].write(value.offeringClass)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.EC2Specification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.EC2Specification()
        value.offeringClass = try reader["OfferingClass"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.UtilizationByTime {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.UtilizationByTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.UtilizationByTime()
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.ReservationUtilizationGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.total = try reader["Total"].readIfPresent(with: CostExplorerClientTypes.ReservationAggregates.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.ReservationAggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationAggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationAggregates()
        value.utilizationPercentage = try reader["UtilizationPercentage"].readIfPresent()
        value.utilizationPercentageInUnits = try reader["UtilizationPercentageInUnits"].readIfPresent()
        value.purchasedHours = try reader["PurchasedHours"].readIfPresent()
        value.purchasedUnits = try reader["PurchasedUnits"].readIfPresent()
        value.totalActualHours = try reader["TotalActualHours"].readIfPresent()
        value.totalActualUnits = try reader["TotalActualUnits"].readIfPresent()
        value.unusedHours = try reader["UnusedHours"].readIfPresent()
        value.unusedUnits = try reader["UnusedUnits"].readIfPresent()
        value.onDemandCostOfRIHoursUsed = try reader["OnDemandCostOfRIHoursUsed"].readIfPresent()
        value.netRISavings = try reader["NetRISavings"].readIfPresent()
        value.totalPotentialRISavings = try reader["TotalPotentialRISavings"].readIfPresent()
        value.amortizedUpfrontFee = try reader["AmortizedUpfrontFee"].readIfPresent()
        value.amortizedRecurringFee = try reader["AmortizedRecurringFee"].readIfPresent()
        value.totalAmortizedFee = try reader["TotalAmortizedFee"].readIfPresent()
        value.riCostForUnusedHours = try reader["RICostForUnusedHours"].readIfPresent()
        value.realizedSavings = try reader["RealizedSavings"].readIfPresent()
        value.unrealizedSavings = try reader["UnrealizedSavings"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ReservationUtilizationGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ReservationUtilizationGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ReservationUtilizationGroup()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.utilization = try reader["Utilization"].readIfPresent(with: CostExplorerClientTypes.ReservationAggregates.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.RightsizingRecommendationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RightsizingRecommendationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RightsizingRecommendationMetadata()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        value.generationTimestamp = try reader["GenerationTimestamp"].readIfPresent()
        value.lookbackPeriodInDays = try reader["LookbackPeriodInDays"].readIfPresent()
        value.additionalMetadata = try reader["AdditionalMetadata"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.RightsizingRecommendationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RightsizingRecommendationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RightsizingRecommendationSummary()
        value.totalRecommendationCount = try reader["TotalRecommendationCount"].readIfPresent()
        value.estimatedTotalMonthlySavingsAmount = try reader["EstimatedTotalMonthlySavingsAmount"].readIfPresent()
        value.savingsCurrencyCode = try reader["SavingsCurrencyCode"].readIfPresent()
        value.savingsPercentage = try reader["SavingsPercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.RightsizingRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RightsizingRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RightsizingRecommendation()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.currentInstance = try reader["CurrentInstance"].readIfPresent(with: CostExplorerClientTypes.CurrentInstance.read(from:))
        value.rightsizingType = try reader["RightsizingType"].readIfPresent()
        value.modifyRecommendationDetail = try reader["ModifyRecommendationDetail"].readIfPresent(with: CostExplorerClientTypes.ModifyRecommendationDetail.read(from:))
        value.terminateRecommendationDetail = try reader["TerminateRecommendationDetail"].readIfPresent(with: CostExplorerClientTypes.TerminateRecommendationDetail.read(from:))
        value.findingReasonCodes = try reader["FindingReasonCodes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CostExplorerClientTypes.FindingReasonCode>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.TerminateRecommendationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.TerminateRecommendationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.TerminateRecommendationDetail()
        value.estimatedMonthlySavings = try reader["EstimatedMonthlySavings"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ModifyRecommendationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ModifyRecommendationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ModifyRecommendationDetail()
        value.targetInstances = try reader["TargetInstances"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.TargetInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.TargetInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.TargetInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.TargetInstance()
        value.estimatedMonthlyCost = try reader["EstimatedMonthlyCost"].readIfPresent()
        value.estimatedMonthlySavings = try reader["EstimatedMonthlySavings"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.defaultTargetInstance = try reader["DefaultTargetInstance"].readIfPresent() ?? false
        value.resourceDetails = try reader["ResourceDetails"].readIfPresent(with: CostExplorerClientTypes.ResourceDetails.read(from:))
        value.expectedResourceUtilization = try reader["ExpectedResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.ResourceUtilization.read(from:))
        value.platformDifferences = try reader["PlatformDifferences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CostExplorerClientTypes.PlatformDifference>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.ResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ResourceUtilization()
        value.ec2ResourceUtilization = try reader["EC2ResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.EC2ResourceUtilization.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.EC2ResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.EC2ResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.EC2ResourceUtilization()
        value.maxCpuUtilizationPercentage = try reader["MaxCpuUtilizationPercentage"].readIfPresent()
        value.maxMemoryUtilizationPercentage = try reader["MaxMemoryUtilizationPercentage"].readIfPresent()
        value.maxStorageUtilizationPercentage = try reader["MaxStorageUtilizationPercentage"].readIfPresent()
        value.ebsResourceUtilization = try reader["EBSResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.EBSResourceUtilization.read(from:))
        value.diskResourceUtilization = try reader["DiskResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.DiskResourceUtilization.read(from:))
        value.networkResourceUtilization = try reader["NetworkResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.NetworkResourceUtilization.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.NetworkResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.NetworkResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.NetworkResourceUtilization()
        value.networkInBytesPerSecond = try reader["NetworkInBytesPerSecond"].readIfPresent()
        value.networkOutBytesPerSecond = try reader["NetworkOutBytesPerSecond"].readIfPresent()
        value.networkPacketsInPerSecond = try reader["NetworkPacketsInPerSecond"].readIfPresent()
        value.networkPacketsOutPerSecond = try reader["NetworkPacketsOutPerSecond"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.DiskResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.DiskResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.DiskResourceUtilization()
        value.diskReadOpsPerSecond = try reader["DiskReadOpsPerSecond"].readIfPresent()
        value.diskWriteOpsPerSecond = try reader["DiskWriteOpsPerSecond"].readIfPresent()
        value.diskReadBytesPerSecond = try reader["DiskReadBytesPerSecond"].readIfPresent()
        value.diskWriteBytesPerSecond = try reader["DiskWriteBytesPerSecond"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.EBSResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.EBSResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.EBSResourceUtilization()
        value.ebsReadOpsPerSecond = try reader["EbsReadOpsPerSecond"].readIfPresent()
        value.ebsWriteOpsPerSecond = try reader["EbsWriteOpsPerSecond"].readIfPresent()
        value.ebsReadBytesPerSecond = try reader["EbsReadBytesPerSecond"].readIfPresent()
        value.ebsWriteBytesPerSecond = try reader["EbsWriteBytesPerSecond"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ResourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ResourceDetails()
        value.ec2ResourceDetails = try reader["EC2ResourceDetails"].readIfPresent(with: CostExplorerClientTypes.EC2ResourceDetails.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.EC2ResourceDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.EC2ResourceDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.EC2ResourceDetails()
        value.hourlyOnDemandRate = try reader["HourlyOnDemandRate"].readIfPresent()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.platform = try reader["Platform"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.sku = try reader["Sku"].readIfPresent()
        value.memory = try reader["Memory"].readIfPresent()
        value.networkPerformance = try reader["NetworkPerformance"].readIfPresent()
        value.storage = try reader["Storage"].readIfPresent()
        value.vcpu = try reader["Vcpu"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CurrentInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CurrentInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CurrentInstance()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.instanceName = try reader["InstanceName"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.TagValues.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.resourceDetails = try reader["ResourceDetails"].readIfPresent(with: CostExplorerClientTypes.ResourceDetails.read(from:))
        value.resourceUtilization = try reader["ResourceUtilization"].readIfPresent(with: CostExplorerClientTypes.ResourceUtilization.read(from:))
        value.reservationCoveredHoursInLookbackPeriod = try reader["ReservationCoveredHoursInLookbackPeriod"].readIfPresent()
        value.savingsPlansCoveredHoursInLookbackPeriod = try reader["SavingsPlansCoveredHoursInLookbackPeriod"].readIfPresent()
        value.onDemandHoursInLookbackPeriod = try reader["OnDemandHoursInLookbackPeriod"].readIfPresent()
        value.totalRunningHoursInLookbackPeriod = try reader["TotalRunningHoursInLookbackPeriod"].readIfPresent()
        value.monthlyCost = try reader["MonthlyCost"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.RightsizingRecommendationConfiguration {

    static func write(value: CostExplorerClientTypes.RightsizingRecommendationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BenefitsConsidered"].write(value.benefitsConsidered)
        try writer["RecommendationTarget"].write(value.recommendationTarget)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RightsizingRecommendationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RightsizingRecommendationConfiguration()
        value.recommendationTarget = try reader["RecommendationTarget"].readIfPresent() ?? .sdkUnknown("")
        value.benefitsConsidered = try reader["BenefitsConsidered"].readIfPresent() ?? false
        return value
    }
}

extension CostExplorerClientTypes.RecommendationDetailData {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RecommendationDetailData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RecommendationDetailData()
        value.accountScope = try reader["AccountScope"].readIfPresent()
        value.lookbackPeriodInDays = try reader["LookbackPeriodInDays"].readIfPresent()
        value.savingsPlansType = try reader["SavingsPlansType"].readIfPresent()
        value.termInYears = try reader["TermInYears"].readIfPresent()
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.instanceFamily = try reader["InstanceFamily"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        value.offeringId = try reader["OfferingId"].readIfPresent()
        value.generationTimestamp = try reader["GenerationTimestamp"].readIfPresent()
        value.latestUsageTimestamp = try reader["LatestUsageTimestamp"].readIfPresent()
        value.currentAverageHourlyOnDemandSpend = try reader["CurrentAverageHourlyOnDemandSpend"].readIfPresent()
        value.currentMaximumHourlyOnDemandSpend = try reader["CurrentMaximumHourlyOnDemandSpend"].readIfPresent()
        value.currentMinimumHourlyOnDemandSpend = try reader["CurrentMinimumHourlyOnDemandSpend"].readIfPresent()
        value.estimatedAverageUtilization = try reader["EstimatedAverageUtilization"].readIfPresent()
        value.estimatedMonthlySavingsAmount = try reader["EstimatedMonthlySavingsAmount"].readIfPresent()
        value.estimatedOnDemandCost = try reader["EstimatedOnDemandCost"].readIfPresent()
        value.estimatedOnDemandCostWithCurrentCommitment = try reader["EstimatedOnDemandCostWithCurrentCommitment"].readIfPresent()
        value.estimatedROI = try reader["EstimatedROI"].readIfPresent()
        value.estimatedSPCost = try reader["EstimatedSPCost"].readIfPresent()
        value.estimatedSavingsAmount = try reader["EstimatedSavingsAmount"].readIfPresent()
        value.estimatedSavingsPercentage = try reader["EstimatedSavingsPercentage"].readIfPresent()
        value.existingHourlyCommitment = try reader["ExistingHourlyCommitment"].readIfPresent()
        value.hourlyCommitmentToPurchase = try reader["HourlyCommitmentToPurchase"].readIfPresent()
        value.upfrontCost = try reader["UpfrontCost"].readIfPresent()
        value.currentAverageCoverage = try reader["CurrentAverageCoverage"].readIfPresent()
        value.estimatedAverageCoverage = try reader["EstimatedAverageCoverage"].readIfPresent()
        value.metricsOverLookbackPeriod = try reader["MetricsOverLookbackPeriod"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.RecommendationDetailHourlyMetrics.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CostExplorerClientTypes.RecommendationDetailHourlyMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.RecommendationDetailHourlyMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.RecommendationDetailHourlyMetrics()
        value.startTime = try reader["StartTime"].readIfPresent()
        value.estimatedOnDemandCost = try reader["EstimatedOnDemandCost"].readIfPresent()
        value.currentCoverage = try reader["CurrentCoverage"].readIfPresent()
        value.estimatedCoverage = try reader["EstimatedCoverage"].readIfPresent()
        value.estimatedNewCommitmentUtilization = try reader["EstimatedNewCommitmentUtilization"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansCoverage {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansCoverage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansCoverage()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.coverage = try reader["Coverage"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansCoverageData.read(from:))
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansCoverageData {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansCoverageData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansCoverageData()
        value.spendCoveredBySavingsPlans = try reader["SpendCoveredBySavingsPlans"].readIfPresent()
        value.onDemandCost = try reader["OnDemandCost"].readIfPresent()
        value.totalCost = try reader["TotalCost"].readIfPresent()
        value.coveragePercentage = try reader["CoveragePercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        value.generationTimestamp = try reader["GenerationTimestamp"].readIfPresent()
        value.additionalMetadata = try reader["AdditionalMetadata"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansPurchaseRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansPurchaseRecommendation()
        value.accountScope = try reader["AccountScope"].readIfPresent()
        value.savingsPlansType = try reader["SavingsPlansType"].readIfPresent()
        value.termInYears = try reader["TermInYears"].readIfPresent()
        value.paymentOption = try reader["PaymentOption"].readIfPresent()
        value.lookbackPeriodInDays = try reader["LookbackPeriodInDays"].readIfPresent()
        value.savingsPlansPurchaseRecommendationDetails = try reader["SavingsPlansPurchaseRecommendationDetails"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.savingsPlansPurchaseRecommendationSummary = try reader["SavingsPlansPurchaseRecommendationSummary"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary()
        value.estimatedROI = try reader["EstimatedROI"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.estimatedTotalCost = try reader["EstimatedTotalCost"].readIfPresent()
        value.currentOnDemandSpend = try reader["CurrentOnDemandSpend"].readIfPresent()
        value.estimatedSavingsAmount = try reader["EstimatedSavingsAmount"].readIfPresent()
        value.totalRecommendationCount = try reader["TotalRecommendationCount"].readIfPresent()
        value.dailyCommitmentToPurchase = try reader["DailyCommitmentToPurchase"].readIfPresent()
        value.hourlyCommitmentToPurchase = try reader["HourlyCommitmentToPurchase"].readIfPresent()
        value.estimatedSavingsPercentage = try reader["EstimatedSavingsPercentage"].readIfPresent()
        value.estimatedMonthlySavingsAmount = try reader["EstimatedMonthlySavingsAmount"].readIfPresent()
        value.estimatedOnDemandCostWithCurrentCommitment = try reader["EstimatedOnDemandCostWithCurrentCommitment"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail()
        value.savingsPlansDetails = try reader["SavingsPlansDetails"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansDetails.read(from:))
        value.accountId = try reader["AccountId"].readIfPresent()
        value.upfrontCost = try reader["UpfrontCost"].readIfPresent()
        value.estimatedROI = try reader["EstimatedROI"].readIfPresent()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent()
        value.estimatedSPCost = try reader["EstimatedSPCost"].readIfPresent()
        value.estimatedOnDemandCost = try reader["EstimatedOnDemandCost"].readIfPresent()
        value.estimatedOnDemandCostWithCurrentCommitment = try reader["EstimatedOnDemandCostWithCurrentCommitment"].readIfPresent()
        value.estimatedSavingsAmount = try reader["EstimatedSavingsAmount"].readIfPresent()
        value.estimatedSavingsPercentage = try reader["EstimatedSavingsPercentage"].readIfPresent()
        value.hourlyCommitmentToPurchase = try reader["HourlyCommitmentToPurchase"].readIfPresent()
        value.estimatedAverageUtilization = try reader["EstimatedAverageUtilization"].readIfPresent()
        value.estimatedMonthlySavingsAmount = try reader["EstimatedMonthlySavingsAmount"].readIfPresent()
        value.currentMinimumHourlyOnDemandSpend = try reader["CurrentMinimumHourlyOnDemandSpend"].readIfPresent()
        value.currentMaximumHourlyOnDemandSpend = try reader["CurrentMaximumHourlyOnDemandSpend"].readIfPresent()
        value.currentAverageHourlyOnDemandSpend = try reader["CurrentAverageHourlyOnDemandSpend"].readIfPresent()
        value.recommendationDetailId = try reader["RecommendationDetailId"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansDetails()
        value.region = try reader["Region"].readIfPresent()
        value.instanceFamily = try reader["InstanceFamily"].readIfPresent()
        value.offeringId = try reader["OfferingId"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansUtilizationByTime {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansUtilizationByTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansUtilizationByTime()
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: CostExplorerClientTypes.DateInterval.read(from:))
        value.utilization = try reader["Utilization"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansUtilization.read(from:))
        value.savings = try reader["Savings"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansSavings.read(from:))
        value.amortizedCommitment = try reader["AmortizedCommitment"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansAmortizedCommitment.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansAmortizedCommitment {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansAmortizedCommitment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansAmortizedCommitment()
        value.amortizedRecurringCommitment = try reader["AmortizedRecurringCommitment"].readIfPresent()
        value.amortizedUpfrontCommitment = try reader["AmortizedUpfrontCommitment"].readIfPresent()
        value.totalAmortizedCommitment = try reader["TotalAmortizedCommitment"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansSavings {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansSavings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansSavings()
        value.netSavings = try reader["NetSavings"].readIfPresent()
        value.onDemandCostEquivalent = try reader["OnDemandCostEquivalent"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansUtilization()
        value.totalCommitment = try reader["TotalCommitment"].readIfPresent()
        value.usedCommitment = try reader["UsedCommitment"].readIfPresent()
        value.unusedCommitment = try reader["UnusedCommitment"].readIfPresent()
        value.utilizationPercentage = try reader["UtilizationPercentage"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansUtilizationAggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansUtilizationAggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansUtilizationAggregates()
        value.utilization = try reader["Utilization"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansUtilization.read(from:))
        value.savings = try reader["Savings"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansSavings.read(from:))
        value.amortizedCommitment = try reader["AmortizedCommitment"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansAmortizedCommitment.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.SavingsPlansUtilizationDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.SavingsPlansUtilizationDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.SavingsPlansUtilizationDetail()
        value.savingsPlanArn = try reader["SavingsPlanArn"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.utilization = try reader["Utilization"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansUtilization.read(from:))
        value.savings = try reader["Savings"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansSavings.read(from:))
        value.amortizedCommitment = try reader["AmortizedCommitment"].readIfPresent(with: CostExplorerClientTypes.SavingsPlansAmortizedCommitment.read(from:))
        return value
    }
}

extension CostExplorerClientTypes.CostAllocationTagBackfillRequest {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostAllocationTagBackfillRequest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostAllocationTagBackfillRequest()
        value.backfillFrom = try reader["BackfillFrom"].readIfPresent()
        value.requestedAt = try reader["RequestedAt"].readIfPresent()
        value.completedAt = try reader["CompletedAt"].readIfPresent()
        value.backfillStatus = try reader["BackfillStatus"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CostAllocationTag {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostAllocationTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostAllocationTag()
        value.tagKey = try reader["TagKey"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedDate = try reader["LastUpdatedDate"].readIfPresent()
        value.lastUsedDate = try reader["LastUsedDate"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.CostCategoryReference {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.CostCategoryReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.CostCategoryReference()
        value.costCategoryArn = try reader["CostCategoryArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.effectiveStart = try reader["EffectiveStart"].readIfPresent()
        value.effectiveEnd = try reader["EffectiveEnd"].readIfPresent()
        value.numberOfRules = try reader["NumberOfRules"].readIfPresent() ?? 0
        value.processingStatus = try reader["ProcessingStatus"].readListIfPresent(memberReadingClosure: CostExplorerClientTypes.CostCategoryProcessingStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["Values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.defaultValue = try reader["DefaultValue"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.GenerationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.GenerationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.GenerationSummary()
        value.recommendationId = try reader["RecommendationId"].readIfPresent()
        value.generationStatus = try reader["GenerationStatus"].readIfPresent()
        value.generationStartedTime = try reader["GenerationStartedTime"].readIfPresent()
        value.generationCompletionTime = try reader["GenerationCompletionTime"].readIfPresent()
        value.estimatedCompletionTime = try reader["EstimatedCompletionTime"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.ResourceTag {

    static func write(value: CostExplorerClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension CostExplorerClientTypes.UpdateCostAllocationTagsStatusError {

    static func read(from reader: SmithyJSON.Reader) throws -> CostExplorerClientTypes.UpdateCostAllocationTagsStatusError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CostExplorerClientTypes.UpdateCostAllocationTagsStatusError()
        value.tagKey = try reader["TagKey"].readIfPresent()
        value.code = try reader["Code"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        return value
    }
}

extension CostExplorerClientTypes.AnomalyDateInterval {

    static func write(value: CostExplorerClientTypes.AnomalyDateInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndDate"].write(value.endDate)
        try writer["StartDate"].write(value.startDate)
    }
}

extension CostExplorerClientTypes.TotalImpactFilter {

    static func write(value: CostExplorerClientTypes.TotalImpactFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndValue"].write(value.endValue)
        try writer["NumericOperator"].write(value.numericOperator)
        try writer["StartValue"].write(value.startValue)
    }
}

extension CostExplorerClientTypes.SortDefinition {

    static func write(value: CostExplorerClientTypes.SortDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension CostExplorerClientTypes.CostAllocationTagStatusEntry {

    static func write(value: CostExplorerClientTypes.CostAllocationTagStatusEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
        try writer["TagKey"].write(value.tagKey)
    }
}

public enum CostExplorerClientTypes {}
