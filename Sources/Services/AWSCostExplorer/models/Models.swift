// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CostExplorerClientTypes {
    public enum AccountScope: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linked
        case payer
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountScope] {
            return [
                .linked,
                .payer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linked: return "LINKED"
            case .payer: return "PAYER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountScope(rawValue: rawValue) ?? AccountScope.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Anomaly: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyEndDate = "AnomalyEndDate"
        case anomalyId = "AnomalyId"
        case anomalyScore = "AnomalyScore"
        case anomalyStartDate = "AnomalyStartDate"
        case dimensionValue = "DimensionValue"
        case feedback = "Feedback"
        case impact = "Impact"
        case monitorArn = "MonitorArn"
        case rootCauses = "RootCauses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyEndDate = self.anomalyEndDate {
            try encodeContainer.encode(anomalyEndDate, forKey: .anomalyEndDate)
        }
        if let anomalyId = self.anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let anomalyScore = self.anomalyScore {
            try encodeContainer.encode(anomalyScore, forKey: .anomalyScore)
        }
        if let anomalyStartDate = self.anomalyStartDate {
            try encodeContainer.encode(anomalyStartDate, forKey: .anomalyStartDate)
        }
        if let dimensionValue = self.dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let impact = self.impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let rootCauses = rootCauses {
            var rootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootCauses)
            for rootcause0 in rootCauses {
                try rootCausesContainer.encode(rootcause0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let anomalyStartDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyStartDate)
        anomalyStartDate = anomalyStartDateDecoded
        let anomalyEndDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyEndDate)
        anomalyEndDate = anomalyEndDateDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let rootCausesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.RootCause?].self, forKey: .rootCauses)
        var rootCausesDecoded0:[CostExplorerClientTypes.RootCause]? = nil
        if let rootCausesContainer = rootCausesContainer {
            rootCausesDecoded0 = [CostExplorerClientTypes.RootCause]()
            for structure0 in rootCausesContainer {
                if let structure0 = structure0 {
                    rootCausesDecoded0?.append(structure0)
                }
            }
        }
        rootCauses = rootCausesDecoded0
        let anomalyScoreDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyScore.self, forKey: .anomalyScore)
        anomalyScore = anomalyScoreDecoded
        let impactDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Impact.self, forKey: .impact)
        impact = impactDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension CostExplorerClientTypes {
    /// An unusual cost pattern. This consists of the detailed metadata and the current status of the anomaly object.
    public struct Anomaly: Swift.Equatable {
        /// The last day the anomaly is detected.
        public var anomalyEndDate: Swift.String?
        /// The unique identifier for the anomaly.
        /// This member is required.
        public var anomalyId: Swift.String?
        /// The latest and maximum score for the anomaly.
        /// This member is required.
        public var anomalyScore: CostExplorerClientTypes.AnomalyScore?
        /// The first day the anomaly is detected.
        public var anomalyStartDate: Swift.String?
        /// The dimension for the anomaly (for example, an Amazon Web Service in a service monitor).
        public var dimensionValue: Swift.String?
        /// The feedback value.
        public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
        /// The dollar impact for the anomaly.
        /// This member is required.
        public var impact: CostExplorerClientTypes.Impact?
        /// The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly.
        /// This member is required.
        public var monitorArn: Swift.String?
        /// The list of identified root causes for the anomaly.
        public var rootCauses: [CostExplorerClientTypes.RootCause]?

        public init(
            anomalyEndDate: Swift.String? = nil,
            anomalyId: Swift.String? = nil,
            anomalyScore: CostExplorerClientTypes.AnomalyScore? = nil,
            anomalyStartDate: Swift.String? = nil,
            dimensionValue: Swift.String? = nil,
            feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
            impact: CostExplorerClientTypes.Impact? = nil,
            monitorArn: Swift.String? = nil,
            rootCauses: [CostExplorerClientTypes.RootCause]? = nil
        )
        {
            self.anomalyEndDate = anomalyEndDate
            self.anomalyId = anomalyId
            self.anomalyScore = anomalyScore
            self.anomalyStartDate = anomalyStartDate
            self.dimensionValue = dimensionValue
            self.feedback = feedback
            self.impact = impact
            self.monitorArn = monitorArn
            self.rootCauses = rootCauses
        }
    }

}

extension CostExplorerClientTypes.AnomalyDateInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endDate = "EndDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = self.endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let startDate = self.startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension CostExplorerClientTypes {
    /// The time period for an anomaly.
    public struct AnomalyDateInterval: Swift.Equatable {
        /// The last date an anomaly was observed.
        public var endDate: Swift.String?
        /// The first date an anomaly was observed.
        /// This member is required.
        public var startDate: Swift.String?

        public init(
            endDate: Swift.String? = nil,
            startDate: Swift.String? = nil
        )
        {
            self.endDate = endDate
            self.startDate = startDate
        }
    }

}

extension CostExplorerClientTypes {
    public enum AnomalyFeedbackType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case plannedActivity
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalyFeedbackType] {
            return [
                .no,
                .plannedActivity,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .plannedActivity: return "PLANNED_ACTIVITY"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalyFeedbackType(rawValue: rawValue) ?? AnomalyFeedbackType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.AnomalyMonitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate = "CreationDate"
        case dimensionalValueCount = "DimensionalValueCount"
        case lastEvaluatedDate = "LastEvaluatedDate"
        case lastUpdatedDate = "LastUpdatedDate"
        case monitorArn = "MonitorArn"
        case monitorDimension = "MonitorDimension"
        case monitorName = "MonitorName"
        case monitorSpecification = "MonitorSpecification"
        case monitorType = "MonitorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if dimensionalValueCount != 0 {
            try encodeContainer.encode(dimensionalValueCount, forKey: .dimensionalValueCount)
        }
        if let lastEvaluatedDate = self.lastEvaluatedDate {
            try encodeContainer.encode(lastEvaluatedDate, forKey: .lastEvaluatedDate)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDimension = self.monitorDimension {
            try encodeContainer.encode(monitorDimension.rawValue, forKey: .monitorDimension)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let monitorSpecification = self.monitorSpecification {
            try encodeContainer.encode(monitorSpecification, forKey: .monitorSpecification)
        }
        if let monitorType = self.monitorType {
            try encodeContainer.encode(monitorType.rawValue, forKey: .monitorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let lastEvaluatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastEvaluatedDate)
        lastEvaluatedDate = lastEvaluatedDateDecoded
        let monitorTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MonitorType.self, forKey: .monitorType)
        monitorType = monitorTypeDecoded
        let monitorDimensionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MonitorDimension.self, forKey: .monitorDimension)
        monitorDimension = monitorDimensionDecoded
        let monitorSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .monitorSpecification)
        monitorSpecification = monitorSpecificationDecoded
        let dimensionalValueCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dimensionalValueCount) ?? 0
        dimensionalValueCount = dimensionalValueCountDecoded
    }
}

extension CostExplorerClientTypes {
    /// This object continuously inspects your account's cost data for anomalies. It's based on MonitorType and MonitorSpecification. The content consists of detailed metadata and the current status of the monitor object.
    public struct AnomalyMonitor: Swift.Equatable {
        /// The date when the monitor was created.
        public var creationDate: Swift.String?
        /// The value for evaluated dimensions.
        public var dimensionalValueCount: Swift.Int
        /// The date when the monitor last evaluated for anomalies.
        public var lastEvaluatedDate: Swift.String?
        /// The date when the monitor was last updated.
        public var lastUpdatedDate: Swift.String?
        /// The Amazon Resource Name (ARN) value.
        public var monitorArn: Swift.String?
        /// The dimensions to evaluate.
        public var monitorDimension: CostExplorerClientTypes.MonitorDimension?
        /// The name of the monitor.
        /// This member is required.
        public var monitorName: Swift.String?
        /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
        ///
        /// * Simple dimension values.
        ///
        /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
        ///
        /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
        ///
        /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
        ///
        /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
        ///
        ///
        ///
        ///
        /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
        ///
        /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
        ///
        /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
        ///
        /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
        ///
        ///
        ///
        ///
        /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
        ///
        /// * For example, you can filter for linked account names that start with "a".
        ///
        /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
        ///
        ///
        ///
        ///
        ///
        ///
        ///
        /// * Compound Expression types with logical operations.
        ///
        /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
        ///
        /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
        ///
        /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
        ///
        ///
        /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
        ///
        ///
        /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
        public var monitorSpecification: CostExplorerClientTypes.Expression?
        /// The possible type values.
        /// This member is required.
        public var monitorType: CostExplorerClientTypes.MonitorType?

        public init(
            creationDate: Swift.String? = nil,
            dimensionalValueCount: Swift.Int = 0,
            lastEvaluatedDate: Swift.String? = nil,
            lastUpdatedDate: Swift.String? = nil,
            monitorArn: Swift.String? = nil,
            monitorDimension: CostExplorerClientTypes.MonitorDimension? = nil,
            monitorName: Swift.String? = nil,
            monitorSpecification: CostExplorerClientTypes.Expression? = nil,
            monitorType: CostExplorerClientTypes.MonitorType? = nil
        )
        {
            self.creationDate = creationDate
            self.dimensionalValueCount = dimensionalValueCount
            self.lastEvaluatedDate = lastEvaluatedDate
            self.lastUpdatedDate = lastUpdatedDate
            self.monitorArn = monitorArn
            self.monitorDimension = monitorDimension
            self.monitorName = monitorName
            self.monitorSpecification = monitorSpecification
            self.monitorType = monitorType
        }
    }

}

extension CostExplorerClientTypes.AnomalyScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentScore = "CurrentScore"
        case maxScore = "MaxScore"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentScore != 0.0 {
            try encodeContainer.encode(currentScore, forKey: .currentScore)
        }
        if maxScore != 0.0 {
            try encodeContainer.encode(maxScore, forKey: .maxScore)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxScore) ?? 0.0
        maxScore = maxScoreDecoded
        let currentScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .currentScore) ?? 0.0
        currentScore = currentScoreDecoded
    }
}

extension CostExplorerClientTypes {
    /// Quantifies the anomaly. The higher score means that it's more anomalous.
    public struct AnomalyScore: Swift.Equatable {
        /// The last observed score.
        /// This member is required.
        public var currentScore: Swift.Double
        /// The maximum score that's observed during the AnomalyDateInterval.
        /// This member is required.
        public var maxScore: Swift.Double

        public init(
            currentScore: Swift.Double = 0.0,
            maxScore: Swift.Double = 0.0
        )
        {
            self.currentScore = currentScore
            self.maxScore = maxScore
        }
    }

}

extension CostExplorerClientTypes.AnomalySubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
        case thresholdExpression = "ThresholdExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for arn0 in monitorArnList {
                try monitorArnListContainer.encode(arn0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
        if let subscriptionArn = self.subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdExpression = self.thresholdExpression {
            try encodeContainer.encode(thresholdExpression, forKey: .thresholdExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[CostExplorerClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [CostExplorerClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let thresholdExpressionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .thresholdExpression)
        thresholdExpression = thresholdExpressionDecoded
    }
}

extension CostExplorerClientTypes {
    /// An AnomalySubscription resource (also referred to as an alert subscription) sends notifications about specific anomalies that meet an alerting criteria defined by you. You can specify the frequency of the alerts and the subscribers to notify. Anomaly subscriptions can be associated with one or more [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html) resources, and they only send notifications about anomalies detected by those associated monitors. You can also configure a threshold to further control which anomalies are included in the notifications. Anomalies that don’t exceed the chosen threshold and therefore don’t trigger notifications from an anomaly subscription will still be available on the console and from the [GetAnomalies](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_GetAnomalies.html) API.
    public struct AnomalySubscription: Swift.Equatable {
        /// Your unique account identifier.
        public var accountId: Swift.String?
        /// The frequency that anomaly notifications are sent. Notifications are sent either over email (for DAILY and WEEKLY frequencies) or SNS (for IMMEDIATE frequency). For more information, see [Creating an Amazon SNS topic for anomaly notifications](https://docs.aws.amazon.com/cost-management/latest/userguide/ad-SNS.html).
        /// This member is required.
        public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
        /// A list of cost anomaly monitors.
        /// This member is required.
        public var monitorArnList: [Swift.String]?
        /// A list of subscribers to notify.
        /// This member is required.
        public var subscribers: [CostExplorerClientTypes.Subscriber]?
        /// The AnomalySubscription Amazon Resource Name (ARN).
        public var subscriptionArn: Swift.String?
        /// The name for the subscription.
        /// This member is required.
        public var subscriptionName: Swift.String?
        /// (deprecated) An absolute dollar value that must be exceeded by the anomaly's total impact (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details) for an anomaly notification to be generated. This field has been deprecated. To specify a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression. One of Threshold or ThresholdExpression is required for this resource. You cannot specify both.
        @available(*, deprecated, message: "Threshold has been deprecated in favor of ThresholdExpression")
        public var threshold: Swift.Double?
        /// An [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE, corresponding to an anomaly’s TotalImpact and TotalImpactPercentage, respectively (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details). The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000 in string format. One of Threshold or ThresholdExpression is required for this resource. You cannot specify both. The following are examples of valid ThresholdExpressions:
        ///
        /// * Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
        ///
        /// * Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
        ///
        /// * AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        ///
        /// * OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
        public var thresholdExpression: CostExplorerClientTypes.Expression?

        public init(
            accountId: Swift.String? = nil,
            frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
            monitorArnList: [Swift.String]? = nil,
            subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionName: Swift.String? = nil,
            threshold: Swift.Double? = nil,
            thresholdExpression: CostExplorerClientTypes.Expression? = nil
        )
        {
            self.accountId = accountId
            self.frequency = frequency
            self.monitorArnList = monitorArnList
            self.subscribers = subscribers
            self.subscriptionArn = subscriptionArn
            self.subscriptionName = subscriptionName
            self.threshold = threshold
            self.thresholdExpression = thresholdExpression
        }
    }

}

extension CostExplorerClientTypes {
    public enum AnomalySubscriptionFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case immediate
        case weekly
        case sdkUnknown(Swift.String)

        public static var allCases: [AnomalySubscriptionFrequency] {
            return [
                .daily,
                .immediate,
                .weekly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .immediate: return "IMMEDIATE"
            case .weekly: return "WEEKLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnomalySubscriptionFrequency(rawValue: rawValue) ?? AnomalySubscriptionFrequency.sdkUnknown(rawValue)
        }
    }
}

extension BillExpirationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BillExpirationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested report expired. Update the date interval and try again.
public struct BillExpirationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BillExpirationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BillExpirationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BillExpirationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes {
    public enum Context: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costAndUsage
        case reservations
        case savingsPlans
        case sdkUnknown(Swift.String)

        public static var allCases: [Context] {
            return [
                .costAndUsage,
                .reservations,
                .savingsPlans,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costAndUsage: return "COST_AND_USAGE"
            case .reservations: return "RESERVATIONS"
            case .savingsPlans: return "SAVINGS_PLANS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Context(rawValue: rawValue) ?? Context.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostAllocationTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdatedDate = "LastUpdatedDate"
        case lastUsedDate = "LastUsedDate"
        case status = "Status"
        case tagKey = "TagKey"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let lastUsedDate = self.lastUsedDate {
            try encodeContainer.encode(lastUsedDate, forKey: .lastUsedDate)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostAllocationTagType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostAllocationTagStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let lastUsedDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUsedDate)
        lastUsedDate = lastUsedDateDecoded
    }
}

extension CostExplorerClientTypes {
    /// The cost allocation tag structure. This includes detailed metadata for the CostAllocationTag object.
    public struct CostAllocationTag: Swift.Equatable {
        /// The last date that the tag was either activated or deactivated.
        public var lastUpdatedDate: Swift.String?
        /// The last month that the tag was used on an Amazon Web Services resource.
        public var lastUsedDate: Swift.String?
        /// The status of a cost allocation tag.
        /// This member is required.
        public var status: CostExplorerClientTypes.CostAllocationTagStatus?
        /// The key for the cost allocation tag.
        /// This member is required.
        public var tagKey: Swift.String?
        /// The type of cost allocation tag. You can use AWSGenerated or UserDefined type tags. AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. UserDefined type tags are tags that you define, create, and apply to resources.
        /// This member is required.
        public var type: CostExplorerClientTypes.CostAllocationTagType?

        public init(
            lastUpdatedDate: Swift.String? = nil,
            lastUsedDate: Swift.String? = nil,
            status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
            tagKey: Swift.String? = nil,
            type: CostExplorerClientTypes.CostAllocationTagType? = nil
        )
        {
            self.lastUpdatedDate = lastUpdatedDate
            self.lastUsedDate = lastUsedDate
            self.status = status
            self.tagKey = tagKey
            self.type = type
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostAllocationTagStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [CostAllocationTagStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostAllocationTagStatus(rawValue: rawValue) ?? CostAllocationTagStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostAllocationTagStatusEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostAllocationTagStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostExplorerClientTypes {
    /// The cost allocation tag status. The status of a key can either be active or inactive.
    public struct CostAllocationTagStatusEntry: Swift.Equatable {
        /// The status of a cost allocation tag.
        /// This member is required.
        public var status: CostExplorerClientTypes.CostAllocationTagStatus?
        /// The key for the cost allocation tag.
        /// This member is required.
        public var tagKey: Swift.String?

        public init(
            status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
            tagKey: Swift.String? = nil
        )
        {
            self.status = status
            self.tagKey = tagKey
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostAllocationTagType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsGenerated
        case userDefined
        case sdkUnknown(Swift.String)

        public static var allCases: [CostAllocationTagType] {
            return [
                .awsGenerated,
                .userDefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsGenerated: return "AWSGenerated"
            case .userDefined: return "UserDefined"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostAllocationTagType(rawValue: rawValue) ?? CostAllocationTagType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case processingStatus = "ProcessingStatus"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = self.costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = self.effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = self.effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatus0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatus0)
            }
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryrule0 in rules {
                try rulesContainer.encode(costcategoryrule0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargerule0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargerule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
        let processingStatusContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostExplorerClientTypes.CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public struct CostCategory: Swift.Equatable {
        /// The unique identifier for your Cost Category.
        /// This member is required.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The effective end date of your Cost Category.
        public var effectiveEnd: Swift.String?
        /// The effective start date of your Cost Category.
        /// This member is required.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        /// This member is required.
        public var name: Swift.String?
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// The rule schema version in this particular Cost Category.
        /// This member is required.
        public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
        /// The rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
        /// This member is required.
        public var rules: [CostExplorerClientTypes.CostCategoryRule]?
        /// The split charge rules that are used to allocate your charges between your Cost Category values.
        public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

        public init(
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
            rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
            splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.processingStatus = processingStatus
            self.ruleVersion = ruleVersion
            self.rules = rules
            self.splitChargeRules = splitChargeRules
        }
    }

}

extension CostExplorerClientTypes.CostCategoryInheritedValueDimension: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionKey = "DimensionKey"
        case dimensionName = "DimensionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = self.dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if let dimensionName = self.dimensionName {
            try encodeContainer.encode(dimensionName.rawValue, forKey: .dimensionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryInheritedValueDimensionName.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
    }
}

extension CostExplorerClientTypes {
    /// When you create or update a cost category, you can define the CostCategoryRule rule type as INHERITED_VALUE. This rule type adds the flexibility to define a rule that dynamically inherits the cost category value from the dimension value that's defined by CostCategoryInheritedValueDimension. For example, suppose that you want to dynamically group costs that are based on the value of a specific tag key. First, choose an inherited value rule type, and then choose the tag dimension and specify the tag key to use.
    public struct CostCategoryInheritedValueDimension: Swift.Equatable {
        /// The key to extract cost category values.
        public var dimensionKey: Swift.String?
        /// The name of the dimension that's used to group costs. If you specify LINKED_ACCOUNT_NAME, the cost category value is based on account name. If you specify TAG, the cost category value is based on the value of the specified tag key.
        public var dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName?

        public init(
            dimensionKey: Swift.String? = nil,
            dimensionName: CostExplorerClientTypes.CostCategoryInheritedValueDimensionName? = nil
        )
        {
            self.dimensionKey = dimensionKey
            self.dimensionName = dimensionName
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategoryInheritedValueDimensionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linkedAccountName
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryInheritedValueDimensionName] {
            return [
                .linkedAccountName,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryInheritedValueDimensionName(rawValue: rawValue) ?? CostCategoryInheritedValueDimensionName.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategoryProcessingStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = self.component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryStatusComponent.self, forKey: .component)
        component = componentDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostExplorerClientTypes {
    /// The list of processing statuses for Cost Management products for a specific cost category.
    public struct CostCategoryProcessingStatus: Swift.Equatable {
        /// The Cost Management product name of the applied status.
        public var component: CostExplorerClientTypes.CostCategoryStatusComponent?
        /// The process status for a specific cost category.
        public var status: CostExplorerClientTypes.CostCategoryStatus?

        public init(
            component: CostExplorerClientTypes.CostCategoryStatusComponent? = nil,
            status: CostExplorerClientTypes.CostCategoryStatus? = nil
        )
        {
            self.component = component
            self.status = status
        }
    }

}

extension CostExplorerClientTypes.CostCategoryReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case numberOfRules = "NumberOfRules"
        case processingStatus = "ProcessingStatus"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = self.costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = self.effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = self.effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfRules != 0 {
            try encodeContainer.encode(numberOfRules, forKey: .numberOfRules)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatus0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatus0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for costcategoryvalue0 in values {
                try valuesContainer.encode(costcategoryvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let numberOfRulesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRules) ?? 0
        numberOfRules = numberOfRulesDecoded
        let processingStatusContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostExplorerClientTypes.CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// A reference to a Cost Category containing only enough information to identify the Cost Category. You can use this information to retrieve the full Cost Category information using DescribeCostCategory.
    public struct CostCategoryReference: Swift.Equatable {
        /// The unique identifier for your Cost Category.
        public var costCategoryArn: Swift.String?
        /// The default value for the cost category.
        public var defaultValue: Swift.String?
        /// The Cost Category's effective end date.
        public var effectiveEnd: Swift.String?
        /// The Cost Category's effective start date.
        public var effectiveStart: Swift.String?
        /// The unique name of the Cost Category.
        public var name: Swift.String?
        /// The number of rules that are associated with a specific Cost Category.
        public var numberOfRules: Swift.Int
        /// The list of processing statuses for Cost Management products for a specific cost category.
        public var processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]?
        /// A list of unique cost category values in a specific cost category.
        public var values: [Swift.String]?

        public init(
            costCategoryArn: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            effectiveEnd: Swift.String? = nil,
            effectiveStart: Swift.String? = nil,
            name: Swift.String? = nil,
            numberOfRules: Swift.Int = 0,
            processingStatus: [CostExplorerClientTypes.CostCategoryProcessingStatus]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.costCategoryArn = costCategoryArn
            self.defaultValue = defaultValue
            self.effectiveEnd = effectiveEnd
            self.effectiveStart = effectiveStart
            self.name = name
            self.numberOfRules = numberOfRules
            self.processingStatus = processingStatus
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.CostCategoryRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inheritedValue = "InheritedValue"
        case rule = "Rule"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inheritedValue = self.inheritedValue {
            try encodeContainer.encode(inheritedValue, forKey: .inheritedValue)
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .rule)
        rule = ruleDecoded
        let inheritedValueDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryInheritedValueDimension.self, forKey: .inheritedValue)
        inheritedValue = inheritedValueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
    public struct CostCategoryRule: Swift.Equatable {
        /// The value the line item is categorized as if the line item contains the matched dimension.
        public var inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension?
        /// An [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to categorize costs. This supports dimensions, tags, and nested expressions. Currently the only dimensions supported are LINKED_ACCOUNT, SERVICE_CODE, RECORD_TYPE, LINKED_ACCOUNT_NAME, REGION, and USAGE_TYPE. RECORD_TYPE is a dimension used for Cost Explorer APIs, and is also supported for Cost Category expressions. This dimension uses different terms, depending on whether you're using the console or API/JSON editor. For a detailed comparison, see [Term Comparisons](https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms) in the Billing and Cost Management User Guide.
        public var rule: CostExplorerClientTypes.Expression?
        /// You can define the CostCategoryRule rule type as either REGULAR or INHERITED_VALUE. The INHERITED_VALUE rule type adds the flexibility to define a rule that dynamically inherits the cost category value. This value is from the dimension value that's defined by CostCategoryInheritedValueDimension. For example, suppose that you want to costs to be dynamically grouped based on the value of a specific tag key. First, choose an inherited value rule type, and then choose the tag dimension and specify the tag key to use.
        public var type: CostExplorerClientTypes.CostCategoryRuleType?
        /// The default value for the cost category.
        public var value: Swift.String?

        public init(
            inheritedValue: CostExplorerClientTypes.CostCategoryInheritedValueDimension? = nil,
            rule: CostExplorerClientTypes.Expression? = nil,
            type: CostExplorerClientTypes.CostCategoryRuleType? = nil,
            value: Swift.String? = nil
        )
        {
            self.inheritedValue = inheritedValue
            self.rule = rule
            self.type = type
            self.value = value
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategoryRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inheritedValue
        case regular
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleType] {
            return [
                .inheritedValue,
                .regular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inheritedValue: return "INHERITED_VALUE"
            case .regular: return "REGULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryRuleType(rawValue: rawValue) ?? CostCategoryRuleType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    /// The rule schema version in this particular Cost Category.
    public enum CostCategoryRuleVersion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costcategoryexpressionv1
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryRuleVersion] {
            return [
                .costcategoryexpressionv1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costcategoryexpressionv1: return "CostCategoryExpression.v1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryRuleVersion(rawValue: rawValue) ?? CostCategoryRuleVersion.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategorySplitChargeMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case even
        case fixed
        case proportional
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeMethod] {
            return [
                .even,
                .fixed,
                .proportional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .even: return "EVEN"
            case .fixed: return "FIXED"
            case .proportional: return "PROPORTIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategorySplitChargeMethod(rawValue: rawValue) ?? CostCategorySplitChargeMethod.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategorySplitChargeRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case method = "Method"
        case parameters = "Parameters"
        case source = "Source"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let method = self.method {
            try encodeContainer.encode(method.rawValue, forKey: .method)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for costcategorysplitchargeruleparameter0 in parameters {
                try parametersContainer.encode(costcategorysplitchargeruleparameter0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for genericstring0 in targets {
                try targetsContainer.encode(genericstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let methodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategorySplitChargeMethod.self, forKey: .method)
        method = methodDecoded
        let parametersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRuleParameter?].self, forKey: .parameters)
        var parametersDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Use the split charge rule to split the cost of one Cost Category value across several other target values.
    public struct CostCategorySplitChargeRule: Swift.Equatable {
        /// The method that's used to define how to split your source costs across your targets. Proportional - Allocates charges across your targets based on the proportional weighted cost of each target. Fixed - Allocates charges across your targets based on your defined allocation percentage. >Even - Allocates costs evenly across all targets.
        /// This member is required.
        public var method: CostExplorerClientTypes.CostCategorySplitChargeMethod?
        /// The parameters for a split charge method. This is only required for the FIXED method.
        public var parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]?
        /// The Cost Category value that you want to split. That value can't be used as a source or a target in other split charge rules. To indicate uncategorized costs, you can use an empty string as the source.
        /// This member is required.
        public var source: Swift.String?
        /// The Cost Category values that you want to split costs across. These values can't be used as a source in other split charge rules.
        /// This member is required.
        public var targets: [Swift.String]?

        public init(
            method: CostExplorerClientTypes.CostCategorySplitChargeMethod? = nil,
            parameters: [CostExplorerClientTypes.CostCategorySplitChargeRuleParameter]? = nil,
            source: Swift.String? = nil,
            targets: [Swift.String]? = nil
        )
        {
            self.method = method
            self.parameters = parameters
            self.source = source
            self.targets = targets
        }
    }

}

extension CostExplorerClientTypes.CostCategorySplitChargeRuleParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for genericstring0 in values {
                try valuesContainer.encode(genericstring0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The parameters for a split charge method.
    public struct CostCategorySplitChargeRuleParameter: Swift.Equatable {
        /// The parameter type.
        /// This member is required.
        public var type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType?
        /// The parameter values.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            type: CostExplorerClientTypes.CostCategorySplitChargeRuleParameterType? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.type = type
            self.values = values
        }
    }

}

extension CostExplorerClientTypes {
    public enum CostCategorySplitChargeRuleParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allocationPercentages
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategorySplitChargeRuleParameterType] {
            return [
                .allocationPercentages,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allocationPercentages: return "ALLOCATION_PERCENTAGES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategorySplitChargeRuleParameterType(rawValue: rawValue) ?? CostCategorySplitChargeRuleParameterType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategoryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applied
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatus] {
            return [
                .applied,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applied: return "APPLIED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryStatus(rawValue: rawValue) ?? CostCategoryStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum CostCategoryStatusComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costExplorer
        case sdkUnknown(Swift.String)

        public static var allCases: [CostCategoryStatusComponent] {
            return [
                .costExplorer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costExplorer: return "COST_EXPLORER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CostCategoryStatusComponent(rawValue: rawValue) ?? CostCategoryStatusComponent.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.CostCategoryValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoption0 in matchOptions {
                try matchOptionsContainer.encode(matchoption0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for enum0 in matchOptionsContainer {
                if let enum0 = enum0 {
                    matchOptionsDecoded0?.append(enum0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The Cost Categories values used for filtering the costs. If Values and Key are not specified, the ABSENTMatchOption is applied to all Cost Categories. That is, it filters on resources that aren't mapped to any Cost Categories. If Values is provided and Key isn't specified, the ABSENTMatchOption is applied to the Cost Categories Key only. That is, it filters on resources without the given Cost Categories key.
    public struct CostCategoryValues: Swift.Equatable {
        /// The unique name of the Cost Category.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for MatchOptions is EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the Cost Category.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.Coverage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageCost = "CoverageCost"
        case coverageHours = "CoverageHours"
        case coverageNormalizedUnits = "CoverageNormalizedUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageCost = self.coverageCost {
            try encodeContainer.encode(coverageCost, forKey: .coverageCost)
        }
        if let coverageHours = self.coverageHours {
            try encodeContainer.encode(coverageHours, forKey: .coverageHours)
        }
        if let coverageNormalizedUnits = self.coverageNormalizedUnits {
            try encodeContainer.encode(coverageNormalizedUnits, forKey: .coverageNormalizedUnits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coverageHoursDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageHours.self, forKey: .coverageHours)
        coverageHours = coverageHoursDecoded
        let coverageNormalizedUnitsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageNormalizedUnits.self, forKey: .coverageNormalizedUnits)
        coverageNormalizedUnits = coverageNormalizedUnitsDecoded
        let coverageCostDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CoverageCost.self, forKey: .coverageCost)
        coverageCost = coverageCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of instance usage that a reservation covered.
    public struct Coverage: Swift.Equatable {
        /// The amount of cost that the reservation covered.
        public var coverageCost: CostExplorerClientTypes.CoverageCost?
        /// The amount of instance usage that the reservation covered, in hours.
        public var coverageHours: CostExplorerClientTypes.CoverageHours?
        /// The amount of instance usage that the reservation covered, in normalized units.
        public var coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits?

        public init(
            coverageCost: CostExplorerClientTypes.CoverageCost? = nil,
            coverageHours: CostExplorerClientTypes.CoverageHours? = nil,
            coverageNormalizedUnits: CostExplorerClientTypes.CoverageNormalizedUnits? = nil
        )
        {
            self.coverageCost = coverageCost
            self.coverageHours = coverageHours
            self.coverageNormalizedUnits = coverageNormalizedUnits
        }
    }

}

extension CostExplorerClientTypes.CoverageByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationcoveragegroup0 in groups {
                try groupsContainer.encode(reservationcoveragegroup0)
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationCoverageGroup?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.ReservationCoverageGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.ReservationCoverageGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .total)
        total = totalDecoded
    }
}

extension CostExplorerClientTypes {
    /// Reservation coverage for a specified period, in hours.
    public struct CoverageByTime: Swift.Equatable {
        /// The groups of instances that the reservation covered.
        public var groups: [CostExplorerClientTypes.ReservationCoverageGroup]?
        /// The period that this coverage was used over.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total reservation coverage, in hours.
        public var total: CostExplorerClientTypes.Coverage?

        public init(
            groups: [CostExplorerClientTypes.ReservationCoverageGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}

extension CostExplorerClientTypes.CoverageCost: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case onDemandCost = "OnDemandCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onDemandCost = self.onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// How much it costs to run an instance.
    public struct CoverageCost: Swift.Equatable {
        /// How much an On-Demand Instance costs.
        public var onDemandCost: Swift.String?

        public init(
            onDemandCost: Swift.String? = nil
        )
        {
            self.onDemandCost = onDemandCost
        }
    }

}

extension CostExplorerClientTypes.CoverageHours: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageHoursPercentage = "CoverageHoursPercentage"
        case onDemandHours = "OnDemandHours"
        case reservedHours = "ReservedHours"
        case totalRunningHours = "TotalRunningHours"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageHoursPercentage = self.coverageHoursPercentage {
            try encodeContainer.encode(coverageHoursPercentage, forKey: .coverageHoursPercentage)
        }
        if let onDemandHours = self.onDemandHours {
            try encodeContainer.encode(onDemandHours, forKey: .onDemandHours)
        }
        if let reservedHours = self.reservedHours {
            try encodeContainer.encode(reservedHours, forKey: .reservedHours)
        }
        if let totalRunningHours = self.totalRunningHours {
            try encodeContainer.encode(totalRunningHours, forKey: .totalRunningHours)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandHours)
        onDemandHours = onDemandHoursDecoded
        let reservedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedHours)
        reservedHours = reservedHoursDecoded
        let totalRunningHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningHours)
        totalRunningHours = totalRunningHoursDecoded
        let coverageHoursPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coverageHoursPercentage)
        coverageHoursPercentage = coverageHoursPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// How long a running instance either used a reservation or was On-Demand.
    public struct CoverageHours: Swift.Equatable {
        /// The percentage of instance hours that a reservation covered.
        public var coverageHoursPercentage: Swift.String?
        /// The number of instance running hours that On-Demand Instances covered.
        public var onDemandHours: Swift.String?
        /// The number of instance running hours that reservations covered.
        public var reservedHours: Swift.String?
        /// The total instance usage, in hours.
        public var totalRunningHours: Swift.String?

        public init(
            coverageHoursPercentage: Swift.String? = nil,
            onDemandHours: Swift.String? = nil,
            reservedHours: Swift.String? = nil,
            totalRunningHours: Swift.String? = nil
        )
        {
            self.coverageHoursPercentage = coverageHoursPercentage
            self.onDemandHours = onDemandHours
            self.reservedHours = reservedHours
            self.totalRunningHours = totalRunningHours
        }
    }

}

extension CostExplorerClientTypes.CoverageNormalizedUnits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageNormalizedUnitsPercentage = "CoverageNormalizedUnitsPercentage"
        case onDemandNormalizedUnits = "OnDemandNormalizedUnits"
        case reservedNormalizedUnits = "ReservedNormalizedUnits"
        case totalRunningNormalizedUnits = "TotalRunningNormalizedUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageNormalizedUnitsPercentage = self.coverageNormalizedUnitsPercentage {
            try encodeContainer.encode(coverageNormalizedUnitsPercentage, forKey: .coverageNormalizedUnitsPercentage)
        }
        if let onDemandNormalizedUnits = self.onDemandNormalizedUnits {
            try encodeContainer.encode(onDemandNormalizedUnits, forKey: .onDemandNormalizedUnits)
        }
        if let reservedNormalizedUnits = self.reservedNormalizedUnits {
            try encodeContainer.encode(reservedNormalizedUnits, forKey: .reservedNormalizedUnits)
        }
        if let totalRunningNormalizedUnits = self.totalRunningNormalizedUnits {
            try encodeContainer.encode(totalRunningNormalizedUnits, forKey: .totalRunningNormalizedUnits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandNormalizedUnits)
        onDemandNormalizedUnits = onDemandNormalizedUnitsDecoded
        let reservedNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedNormalizedUnits)
        reservedNormalizedUnits = reservedNormalizedUnitsDecoded
        let totalRunningNormalizedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningNormalizedUnits)
        totalRunningNormalizedUnits = totalRunningNormalizedUnitsDecoded
        let coverageNormalizedUnitsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coverageNormalizedUnitsPercentage)
        coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of instance usage, in normalized units. You can use normalized units to see your EC2 usage for multiple sizes of instances in a uniform way. For example, suppose that you run an xlarge instance and a 2xlarge instance. If you run both instances for the same amount of time, the 2xlarge instance uses twice as much of your reservation as the xlarge instance, even though both instances show only one instance-hour. When you use normalized units instead of instance-hours, the xlarge instance used 8 normalized units, and the 2xlarge instance used 16 normalized units. For more information, see [Modifying Reserved Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html) in the Amazon Elastic Compute Cloud User Guide for Linux Instances.
    public struct CoverageNormalizedUnits: Swift.Equatable {
        /// The percentage of your used instance normalized units that a reservation covers.
        public var coverageNormalizedUnitsPercentage: Swift.String?
        /// The number of normalized units that are covered by On-Demand Instances instead of a reservation.
        public var onDemandNormalizedUnits: Swift.String?
        /// The number of normalized units that a reservation covers.
        public var reservedNormalizedUnits: Swift.String?
        /// The total number of normalized units that you used.
        public var totalRunningNormalizedUnits: Swift.String?

        public init(
            coverageNormalizedUnitsPercentage: Swift.String? = nil,
            onDemandNormalizedUnits: Swift.String? = nil,
            reservedNormalizedUnits: Swift.String? = nil,
            totalRunningNormalizedUnits: Swift.String? = nil
        )
        {
            self.coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage
            self.onDemandNormalizedUnits = onDemandNormalizedUnits
            self.reservedNormalizedUnits = reservedNormalizedUnits
            self.totalRunningNormalizedUnits = totalRunningNormalizedUnits
        }
    }

}

extension CreateAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
        case resourceTags = "ResourceTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyMonitor = self.anomalyMonitor {
            try encodeContainer.encode(anomalyMonitor, forKey: .anomalyMonitor)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
    }
}

extension CreateAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAnomalyMonitorInput: Swift.Equatable {
    /// The cost anomaly detection monitor object that you want to create.
    /// This member is required.
    public var anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor?
    /// An optional list of tags to associate with the specified [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html). You can use resource tags to control access to your monitor using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.anomalyMonitor = anomalyMonitor
        self.resourceTags = resourceTags
    }
}

struct CreateAnomalyMonitorInputBody: Swift.Equatable {
    let anomalyMonitor: CostExplorerClientTypes.AnomalyMonitor?
    let resourceTags: [CostExplorerClientTypes.ResourceTag]?
}

extension CreateAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyMonitor.self, forKey: .anomalyMonitor)
        anomalyMonitor = anomalyMonitorDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[CostExplorerClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [CostExplorerClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension CreateAnomalyMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAnomalyMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct CreateAnomalyMonitorOutput: Swift.Equatable {
    /// The unique identifier of your newly created cost anomaly detection monitor.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct CreateAnomalyMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension CreateAnomalyMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

enum CreateAnomalyMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscription = "AnomalySubscription"
        case resourceTags = "ResourceTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalySubscription = self.anomalySubscription {
            try encodeContainer.encode(anomalySubscription, forKey: .anomalySubscription)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
    }
}

extension CreateAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAnomalySubscriptionInput: Swift.Equatable {
    /// The cost anomaly subscription object that you want to create.
    /// This member is required.
    public var anomalySubscription: CostExplorerClientTypes.AnomalySubscription?
    /// An optional list of tags to associate with the specified [AnomalySubscription](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html). You can use resource tags to control access to your subscription using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        anomalySubscription: CostExplorerClientTypes.AnomalySubscription? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.anomalySubscription = anomalySubscription
        self.resourceTags = resourceTags
    }
}

struct CreateAnomalySubscriptionInputBody: Swift.Equatable {
    let anomalySubscription: CostExplorerClientTypes.AnomalySubscription?
    let resourceTags: [CostExplorerClientTypes.ResourceTag]?
}

extension CreateAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscription = "AnomalySubscription"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscription.self, forKey: .anomalySubscription)
        anomalySubscription = anomalySubscriptionDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[CostExplorerClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [CostExplorerClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension CreateAnomalySubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAnomalySubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct CreateAnomalySubscriptionOutput: Swift.Equatable {
    /// The unique identifier of your newly created cost anomaly subscription.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct CreateAnomalySubscriptionOutputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension CreateAnomalySubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

enum CreateAnomalySubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownMonitorException": return try await UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case resourceTags = "ResourceTags"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveStart = self.effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryrule0 in rules {
                try rulesContainer.encode(costcategoryrule0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargerule0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargerule0)
            }
        }
    }
}

extension CreateCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCostCategoryDefinitionInput: Swift.Equatable {
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
    public var effectiveStart: Swift.String?
    /// The unique name of the Cost Category.
    /// This member is required.
    public var name: Swift.String?
    /// An optional list of tags to associate with the specified [CostCategory](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html). You can use resource tags to control access to your cost category using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Cost Category rules used to categorize costs. For more information, see [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init(
        defaultValue: Swift.String? = nil,
        effectiveStart: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.defaultValue = defaultValue
        self.effectiveStart = effectiveStart
        self.name = name
        self.resourceTags = resourceTags
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

struct CreateCostCategoryDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
    let effectiveStart: Swift.String?
    let ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    let rules: [CostExplorerClientTypes.CostCategoryRule]?
    let defaultValue: Swift.String?
    let splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?
    let resourceTags: [CostExplorerClientTypes.ResourceTag]?
}

extension CreateCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case resourceTags = "ResourceTags"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
        let resourceTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[CostExplorerClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [CostExplorerClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension CreateCostCategoryDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCostCategoryDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct CreateCostCategoryDefinitionOutput: Swift.Equatable {
    /// The unique identifier for your newly created Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
    public var effectiveStart: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct CreateCostCategoryDefinitionOutputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveStart: Swift.String?
}

extension CreateCostCategoryDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

enum CreateCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.CurrentInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case instanceName = "InstanceName"
        case monthlyCost = "MonthlyCost"
        case onDemandHoursInLookbackPeriod = "OnDemandHoursInLookbackPeriod"
        case reservationCoveredHoursInLookbackPeriod = "ReservationCoveredHoursInLookbackPeriod"
        case resourceDetails = "ResourceDetails"
        case resourceId = "ResourceId"
        case resourceUtilization = "ResourceUtilization"
        case savingsPlansCoveredHoursInLookbackPeriod = "SavingsPlansCoveredHoursInLookbackPeriod"
        case tags = "Tags"
        case totalRunningHoursInLookbackPeriod = "TotalRunningHoursInLookbackPeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let instanceName = self.instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let monthlyCost = self.monthlyCost {
            try encodeContainer.encode(monthlyCost, forKey: .monthlyCost)
        }
        if let onDemandHoursInLookbackPeriod = self.onDemandHoursInLookbackPeriod {
            try encodeContainer.encode(onDemandHoursInLookbackPeriod, forKey: .onDemandHoursInLookbackPeriod)
        }
        if let reservationCoveredHoursInLookbackPeriod = self.reservationCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(reservationCoveredHoursInLookbackPeriod, forKey: .reservationCoveredHoursInLookbackPeriod)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceUtilization = self.resourceUtilization {
            try encodeContainer.encode(resourceUtilization, forKey: .resourceUtilization)
        }
        if let savingsPlansCoveredHoursInLookbackPeriod = self.savingsPlansCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(savingsPlansCoveredHoursInLookbackPeriod, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagvalues0 in tags {
                try tagsContainer.encode(tagvalues0)
            }
        }
        if let totalRunningHoursInLookbackPeriod = self.totalRunningHoursInLookbackPeriod {
            try encodeContainer.encode(totalRunningHoursInLookbackPeriod, forKey: .totalRunningHoursInLookbackPeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.TagValues?].self, forKey: .tags)
        var tagsDecoded0:[CostExplorerClientTypes.TagValues]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CostExplorerClientTypes.TagValues]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let resourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceUtilization.self, forKey: .resourceUtilization)
        resourceUtilization = resourceUtilizationDecoded
        let reservationCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationCoveredHoursInLookbackPeriod)
        reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriodDecoded
        let savingsPlansCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriodDecoded
        let onDemandHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandHoursInLookbackPeriod)
        onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriodDecoded
        let totalRunningHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRunningHoursInLookbackPeriod)
        totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriodDecoded
        let monthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyCost)
        monthlyCost = monthlyCostDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Context about the current instance.
    public struct CurrentInstance: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The name that you given an instance. This field shows as blank if you haven't given the instance a name.
        public var instanceName: Swift.String?
        /// The current On-Demand cost of operating this instance on a monthly basis.
        public var monthlyCost: Swift.String?
        /// The number of hours during the lookback period that's billed at On-Demand rates.
        public var onDemandHoursInLookbackPeriod: Swift.String?
        /// The number of hours during the lookback period that's covered by reservations.
        public var reservationCoveredHoursInLookbackPeriod: Swift.String?
        /// Details about the resource and utilization.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?
        /// Resource ID of the current instance.
        public var resourceId: Swift.String?
        /// Utilization information of the current instance during the lookback period.
        public var resourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// The number of hours during the lookback period that's covered by Savings Plans.
        public var savingsPlansCoveredHoursInLookbackPeriod: Swift.String?
        /// Cost allocation resource tags that are applied to the instance.
        public var tags: [CostExplorerClientTypes.TagValues]?
        /// The total number of hours that the instance ran during the lookback period.
        public var totalRunningHoursInLookbackPeriod: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            monthlyCost: Swift.String? = nil,
            onDemandHoursInLookbackPeriod: Swift.String? = nil,
            reservationCoveredHoursInLookbackPeriod: Swift.String? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil,
            resourceId: Swift.String? = nil,
            resourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            savingsPlansCoveredHoursInLookbackPeriod: Swift.String? = nil,
            tags: [CostExplorerClientTypes.TagValues]? = nil,
            totalRunningHoursInLookbackPeriod: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.instanceName = instanceName
            self.monthlyCost = monthlyCost
            self.onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod
            self.reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.resourceUtilization = resourceUtilization
            self.savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod
            self.tags = tags
            self.totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod
        }
    }

}

extension DataUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DataUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested data is unavailable.
public struct DataUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DataUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DataUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.DateInterval: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
    }
}

extension CostExplorerClientTypes {
    /// The time period of the request.
    public struct DateInterval: Swift.Equatable {
        /// The end of the time period. The end date is exclusive. For example, if end is 2017-05-01, Amazon Web Services retrieves cost and usage data from the start date up to, but not including, 2017-05-01.
        /// This member is required.
        public var end: Swift.String?
        /// The beginning of the time period. The start date is inclusive. For example, if start is 2017-01-01, Amazon Web Services retrieves cost and usage data starting at 2017-01-01 up to the end date. The start date must be equal to or no later than the current date to avoid a validation error.
        /// This member is required.
        public var start: Swift.String?

        public init(
            end: Swift.String? = nil,
            start: Swift.String? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension DeleteAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

extension DeleteAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAnomalyMonitorInput: Swift.Equatable {
    /// The unique identifier of the cost anomaly monitor that you want to delete.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DeleteAnomalyMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension DeleteAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DeleteAnomalyMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAnomalyMonitorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAnomalyMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownMonitorException": return try await UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionArn = self.subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
    }
}

extension DeleteAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAnomalySubscriptionInput: Swift.Equatable {
    /// The unique identifier of the cost anomaly subscription that you want to delete.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct DeleteAnomalySubscriptionInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension DeleteAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension DeleteAnomalySubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAnomalySubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAnomalySubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownSubscriptionException": return try await UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = self.costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
    }
}

extension DeleteCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
    }
}

struct DeleteCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
}

extension DeleteCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
    }
}

extension DeleteCostCategoryDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteCostCategoryDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveEnd = output.effectiveEnd
        } else {
            self.costCategoryArn = nil
            self.effectiveEnd = nil
        }
    }
}

public struct DeleteCostCategoryDefinitionOutput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The effective end date of the Cost Category as a result of deleting it. No costs after this date is categorized by the deleted Cost Category.
    public var effectiveEnd: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveEnd: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveEnd = effectiveEnd
    }
}

struct DeleteCostCategoryDefinitionOutputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveEnd: Swift.String?
}

extension DeleteCostCategoryDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveEnd = "EffectiveEnd"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
    }
}

enum DeleteCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = self.costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let effectiveOn = self.effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
    }
}

extension DescribeCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveOn: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveOn = effectiveOn
    }
}

struct DescribeCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveOn: Swift.String?
}

extension DescribeCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension DescribeCostCategoryDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeCostCategoryDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategory = output.costCategory
        } else {
            self.costCategory = nil
        }
    }
}

public struct DescribeCostCategoryDefinitionOutput: Swift.Equatable {
    /// The structure of Cost Categories. This includes detailed metadata and the set of rules for the CostCategory object.
    public var costCategory: CostExplorerClientTypes.CostCategory?

    public init(
        costCategory: CostExplorerClientTypes.CostCategory? = nil
    )
    {
        self.costCategory = costCategory
    }
}

struct DescribeCostCategoryDefinitionOutputBody: Swift.Equatable {
    let costCategory: CostExplorerClientTypes.CostCategory?
}

extension DescribeCostCategoryDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategory = "CostCategory"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategory.self, forKey: .costCategory)
        costCategory = costCategoryDecoded
    }
}

enum DescribeCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes {
    public enum Dimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agreementEndDateTimeAfter
        case agreementEndDateTimeBefore
        case anomalyTotalImpactAbsolute
        case anomalyTotalImpactPercentage
        case az
        case billingEntity
        case cacheEngine
        case databaseEngine
        case deploymentOption
        case instanceType
        case instanceTypeFamily
        case invoicingEntity
        case legalEntityName
        case linkedAccount
        case linkedAccountName
        case operatingSystem
        case operation
        case paymentOption
        case platform
        case purchaseType
        case recordType
        case region
        case reservationId
        case resourceId
        case rightsizingType
        case savingsPlansType
        case savingsPlanArn
        case scope
        case service
        case serviceCode
        case subscriptionId
        case tenancy
        case usageType
        case usageTypeGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .agreementEndDateTimeAfter,
                .agreementEndDateTimeBefore,
                .anomalyTotalImpactAbsolute,
                .anomalyTotalImpactPercentage,
                .az,
                .billingEntity,
                .cacheEngine,
                .databaseEngine,
                .deploymentOption,
                .instanceType,
                .instanceTypeFamily,
                .invoicingEntity,
                .legalEntityName,
                .linkedAccount,
                .linkedAccountName,
                .operatingSystem,
                .operation,
                .paymentOption,
                .platform,
                .purchaseType,
                .recordType,
                .region,
                .reservationId,
                .resourceId,
                .rightsizingType,
                .savingsPlansType,
                .savingsPlanArn,
                .scope,
                .service,
                .serviceCode,
                .subscriptionId,
                .tenancy,
                .usageType,
                .usageTypeGroup,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agreementEndDateTimeAfter: return "AGREEMENT_END_DATE_TIME_AFTER"
            case .agreementEndDateTimeBefore: return "AGREEMENT_END_DATE_TIME_BEFORE"
            case .anomalyTotalImpactAbsolute: return "ANOMALY_TOTAL_IMPACT_ABSOLUTE"
            case .anomalyTotalImpactPercentage: return "ANOMALY_TOTAL_IMPACT_PERCENTAGE"
            case .az: return "AZ"
            case .billingEntity: return "BILLING_ENTITY"
            case .cacheEngine: return "CACHE_ENGINE"
            case .databaseEngine: return "DATABASE_ENGINE"
            case .deploymentOption: return "DEPLOYMENT_OPTION"
            case .instanceType: return "INSTANCE_TYPE"
            case .instanceTypeFamily: return "INSTANCE_TYPE_FAMILY"
            case .invoicingEntity: return "INVOICING_ENTITY"
            case .legalEntityName: return "LEGAL_ENTITY_NAME"
            case .linkedAccount: return "LINKED_ACCOUNT"
            case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .operation: return "OPERATION"
            case .paymentOption: return "PAYMENT_OPTION"
            case .platform: return "PLATFORM"
            case .purchaseType: return "PURCHASE_TYPE"
            case .recordType: return "RECORD_TYPE"
            case .region: return "REGION"
            case .reservationId: return "RESERVATION_ID"
            case .resourceId: return "RESOURCE_ID"
            case .rightsizingType: return "RIGHTSIZING_TYPE"
            case .savingsPlansType: return "SAVINGS_PLANS_TYPE"
            case .savingsPlanArn: return "SAVINGS_PLAN_ARN"
            case .scope: return "SCOPE"
            case .service: return "SERVICE"
            case .serviceCode: return "SERVICE_CODE"
            case .subscriptionId: return "SUBSCRIPTION_ID"
            case .tenancy: return "TENANCY"
            case .usageType: return "USAGE_TYPE"
            case .usageTypeGroup: return "USAGE_TYPE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Dimension(rawValue: rawValue) ?? Dimension.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.DimensionValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoption0 in matchOptions {
                try matchOptionsContainer.encode(matchoption0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Dimension.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for enum0 in matchOptionsContainer {
                if let enum0 = enum0 {
                    matchOptionsDecoded0?.append(enum0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The metadata that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValues: Swift.Equatable {
        /// The names of the metadata types that you can use to filter and group your results. For example, AZ returns a list of Availability Zones. Not all dimensions are supported in each API. Refer to the documentation for each specific API to see what is supported. LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html). ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE can only be used in [AnomalySubscriptions](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html).
        public var key: CostExplorerClientTypes.Dimension?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category and Anomaly Subscriptions. Refer to the documentation for each specific API to see what is supported. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The metadata values that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
        public var values: [Swift.String]?

        public init(
            key: CostExplorerClientTypes.Dimension? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.DimensionValuesWithAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The metadata of a specific type that you can use to filter and group your results. You can use GetDimensionValues to find specific values.
    public struct DimensionValuesWithAttributes: Swift.Equatable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The value of a dimension with a specific attribute.
        public var value: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.value = value
        }
    }

}

extension CostExplorerClientTypes.DiskResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskReadBytesPerSecond = "DiskReadBytesPerSecond"
        case diskReadOpsPerSecond = "DiskReadOpsPerSecond"
        case diskWriteBytesPerSecond = "DiskWriteBytesPerSecond"
        case diskWriteOpsPerSecond = "DiskWriteOpsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskReadBytesPerSecond = self.diskReadBytesPerSecond {
            try encodeContainer.encode(diskReadBytesPerSecond, forKey: .diskReadBytesPerSecond)
        }
        if let diskReadOpsPerSecond = self.diskReadOpsPerSecond {
            try encodeContainer.encode(diskReadOpsPerSecond, forKey: .diskReadOpsPerSecond)
        }
        if let diskWriteBytesPerSecond = self.diskWriteBytesPerSecond {
            try encodeContainer.encode(diskWriteBytesPerSecond, forKey: .diskWriteBytesPerSecond)
        }
        if let diskWriteOpsPerSecond = self.diskWriteOpsPerSecond {
            try encodeContainer.encode(diskWriteOpsPerSecond, forKey: .diskWriteOpsPerSecond)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskReadOpsPerSecond)
        diskReadOpsPerSecond = diskReadOpsPerSecondDecoded
        let diskWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskWriteOpsPerSecond)
        diskWriteOpsPerSecond = diskWriteOpsPerSecondDecoded
        let diskReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskReadBytesPerSecond)
        diskReadBytesPerSecond = diskReadBytesPerSecondDecoded
        let diskWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .diskWriteBytesPerSecond)
        diskWriteBytesPerSecond = diskWriteBytesPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
    public struct DiskResourceUtilization: Swift.Equatable {
        /// The maximum read throughput operations per second.
        public var diskReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var diskReadOpsPerSecond: Swift.String?
        /// The maximum write throughput operations per second.
        public var diskWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var diskWriteOpsPerSecond: Swift.String?

        public init(
            diskReadBytesPerSecond: Swift.String? = nil,
            diskReadOpsPerSecond: Swift.String? = nil,
            diskWriteBytesPerSecond: Swift.String? = nil,
            diskWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.diskReadBytesPerSecond = diskReadBytesPerSecond
            self.diskReadOpsPerSecond = diskReadOpsPerSecond
            self.diskWriteBytesPerSecond = diskWriteBytesPerSecond
            self.diskWriteOpsPerSecond = diskWriteOpsPerSecond
        }
    }

}

extension CostExplorerClientTypes.EBSResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsReadBytesPerSecond = "EbsReadBytesPerSecond"
        case ebsReadOpsPerSecond = "EbsReadOpsPerSecond"
        case ebsWriteBytesPerSecond = "EbsWriteBytesPerSecond"
        case ebsWriteOpsPerSecond = "EbsWriteOpsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsReadBytesPerSecond = self.ebsReadBytesPerSecond {
            try encodeContainer.encode(ebsReadBytesPerSecond, forKey: .ebsReadBytesPerSecond)
        }
        if let ebsReadOpsPerSecond = self.ebsReadOpsPerSecond {
            try encodeContainer.encode(ebsReadOpsPerSecond, forKey: .ebsReadOpsPerSecond)
        }
        if let ebsWriteBytesPerSecond = self.ebsWriteBytesPerSecond {
            try encodeContainer.encode(ebsWriteBytesPerSecond, forKey: .ebsWriteBytesPerSecond)
        }
        if let ebsWriteOpsPerSecond = self.ebsWriteOpsPerSecond {
            try encodeContainer.encode(ebsWriteOpsPerSecond, forKey: .ebsWriteOpsPerSecond)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsReadOpsPerSecond)
        ebsReadOpsPerSecond = ebsReadOpsPerSecondDecoded
        let ebsWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsWriteOpsPerSecond)
        ebsWriteOpsPerSecond = ebsWriteOpsPerSecondDecoded
        let ebsReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsReadBytesPerSecond)
        ebsReadBytesPerSecond = ebsReadBytesPerSecondDecoded
        let ebsWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsWriteBytesPerSecond)
        ebsWriteBytesPerSecond = ebsWriteBytesPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
    public struct EBSResourceUtilization: Swift.Equatable {
        /// The maximum size of read operations per second
        public var ebsReadBytesPerSecond: Swift.String?
        /// The maximum number of read operations per second.
        public var ebsReadOpsPerSecond: Swift.String?
        /// The maximum size of write operations per second.
        public var ebsWriteBytesPerSecond: Swift.String?
        /// The maximum number of write operations per second.
        public var ebsWriteOpsPerSecond: Swift.String?

        public init(
            ebsReadBytesPerSecond: Swift.String? = nil,
            ebsReadOpsPerSecond: Swift.String? = nil,
            ebsWriteBytesPerSecond: Swift.String? = nil,
            ebsWriteOpsPerSecond: Swift.String? = nil
        )
        {
            self.ebsReadBytesPerSecond = ebsReadBytesPerSecond
            self.ebsReadOpsPerSecond = ebsReadOpsPerSecond
            self.ebsWriteBytesPerSecond = ebsWriteBytesPerSecond
            self.ebsWriteOpsPerSecond = ebsWriteOpsPerSecond
        }
    }

}

extension CostExplorerClientTypes.EC2InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case instanceType = "InstanceType"
        case platform = "Platform"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration) ?? false
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible) ?? false
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon EC2 instances that Amazon Web Services recommends that you purchase.
    public struct EC2InstanceDetails: Swift.Equatable {
        /// The Availability Zone of the recommended reservation.
        public var availabilityZone: Swift.String?
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool
        /// Determines whether the recommended reservation is dedicated or shared.
        public var tenancy: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false,
            tenancy: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.currentGeneration = currentGeneration
            self.family = family
            self.instanceType = instanceType
            self.platform = platform
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
        }
    }

}

extension CostExplorerClientTypes.EC2ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hourlyOnDemandRate = "HourlyOnDemandRate"
        case instanceType = "InstanceType"
        case memory = "Memory"
        case networkPerformance = "NetworkPerformance"
        case platform = "Platform"
        case region = "Region"
        case sku = "Sku"
        case storage = "Storage"
        case vcpu = "Vcpu"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hourlyOnDemandRate = self.hourlyOnDemandRate {
            try encodeContainer.encode(hourlyOnDemandRate, forKey: .hourlyOnDemandRate)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkPerformance = self.networkPerformance {
            try encodeContainer.encode(networkPerformance, forKey: .networkPerformance)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let sku = self.sku {
            try encodeContainer.encode(sku, forKey: .sku)
        }
        if let storage = self.storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let vcpu = self.vcpu {
            try encodeContainer.encode(vcpu, forKey: .vcpu)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hourlyOnDemandRateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyOnDemandRate)
        hourlyOnDemandRate = hourlyOnDemandRateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let skuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sku)
        sku = skuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let networkPerformanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPerformance)
        networkPerformance = networkPerformanceDecoded
        let storageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storage)
        storage = storageDecoded
        let vcpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcpu)
        vcpu = vcpuDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details on the Amazon EC2 Resource.
    public struct EC2ResourceDetails: Swift.Equatable {
        /// The hourly public On-Demand rate for the instance type.
        public var hourlyOnDemandRate: Swift.String?
        /// The type of Amazon Web Services instance.
        public var instanceType: Swift.String?
        /// The memory capacity of the Amazon Web Services instance.
        public var memory: Swift.String?
        /// The network performance capacity of the Amazon Web Services instance.
        public var networkPerformance: Swift.String?
        /// The platform of the Amazon Web Services instance. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the instance.
        public var region: Swift.String?
        /// The SKU of the product.
        public var sku: Swift.String?
        /// The disk storage of the Amazon Web Services instance. This doesn't include EBS storage.
        public var storage: Swift.String?
        /// The number of VCPU cores in the Amazon Web Services instance type.
        public var vcpu: Swift.String?

        public init(
            hourlyOnDemandRate: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            memory: Swift.String? = nil,
            networkPerformance: Swift.String? = nil,
            platform: Swift.String? = nil,
            region: Swift.String? = nil,
            sku: Swift.String? = nil,
            storage: Swift.String? = nil,
            vcpu: Swift.String? = nil
        )
        {
            self.hourlyOnDemandRate = hourlyOnDemandRate
            self.instanceType = instanceType
            self.memory = memory
            self.networkPerformance = networkPerformance
            self.platform = platform
            self.region = region
            self.sku = sku
            self.storage = storage
            self.vcpu = vcpu
        }
    }

}

extension CostExplorerClientTypes.EC2ResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskResourceUtilization = "DiskResourceUtilization"
        case ebsResourceUtilization = "EBSResourceUtilization"
        case maxCpuUtilizationPercentage = "MaxCpuUtilizationPercentage"
        case maxMemoryUtilizationPercentage = "MaxMemoryUtilizationPercentage"
        case maxStorageUtilizationPercentage = "MaxStorageUtilizationPercentage"
        case networkResourceUtilization = "NetworkResourceUtilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskResourceUtilization = self.diskResourceUtilization {
            try encodeContainer.encode(diskResourceUtilization, forKey: .diskResourceUtilization)
        }
        if let ebsResourceUtilization = self.ebsResourceUtilization {
            try encodeContainer.encode(ebsResourceUtilization, forKey: .ebsResourceUtilization)
        }
        if let maxCpuUtilizationPercentage = self.maxCpuUtilizationPercentage {
            try encodeContainer.encode(maxCpuUtilizationPercentage, forKey: .maxCpuUtilizationPercentage)
        }
        if let maxMemoryUtilizationPercentage = self.maxMemoryUtilizationPercentage {
            try encodeContainer.encode(maxMemoryUtilizationPercentage, forKey: .maxMemoryUtilizationPercentage)
        }
        if let maxStorageUtilizationPercentage = self.maxStorageUtilizationPercentage {
            try encodeContainer.encode(maxStorageUtilizationPercentage, forKey: .maxStorageUtilizationPercentage)
        }
        if let networkResourceUtilization = self.networkResourceUtilization {
            try encodeContainer.encode(networkResourceUtilization, forKey: .networkResourceUtilization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxCpuUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxCpuUtilizationPercentage)
        maxCpuUtilizationPercentage = maxCpuUtilizationPercentageDecoded
        let maxMemoryUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxMemoryUtilizationPercentage)
        maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentageDecoded
        let maxStorageUtilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxStorageUtilizationPercentage)
        maxStorageUtilizationPercentage = maxStorageUtilizationPercentageDecoded
        let ebsResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EBSResourceUtilization.self, forKey: .ebsResourceUtilization)
        ebsResourceUtilization = ebsResourceUtilizationDecoded
        let diskResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DiskResourceUtilization.self, forKey: .diskResourceUtilization)
        diskResourceUtilization = diskResourceUtilizationDecoded
        let networkResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.NetworkResourceUtilization.self, forKey: .networkResourceUtilization)
        networkResourceUtilization = networkResourceUtilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Utilization metrics for the instance.
    public struct EC2ResourceUtilization: Swift.Equatable {
        /// The field that contains a list of disk (local storage) metrics that are associated with the current instance.
        public var diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization?
        /// The EBS field that contains a list of EBS metrics that are associated with the current instance.
        public var ebsResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization?
        /// The maximum observed or expected CPU utilization of the instance.
        public var maxCpuUtilizationPercentage: Swift.String?
        /// The maximum observed or expected memory utilization of the instance.
        public var maxMemoryUtilizationPercentage: Swift.String?
        /// The maximum observed or expected storage utilization of the instance. This doesn't include EBS storage.
        public var maxStorageUtilizationPercentage: Swift.String?
        /// The network field that contains a list of network metrics that are associated with the current instance.
        public var networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization?

        public init(
            diskResourceUtilization: CostExplorerClientTypes.DiskResourceUtilization? = nil,
            ebsResourceUtilization: CostExplorerClientTypes.EBSResourceUtilization? = nil,
            maxCpuUtilizationPercentage: Swift.String? = nil,
            maxMemoryUtilizationPercentage: Swift.String? = nil,
            maxStorageUtilizationPercentage: Swift.String? = nil,
            networkResourceUtilization: CostExplorerClientTypes.NetworkResourceUtilization? = nil
        )
        {
            self.diskResourceUtilization = diskResourceUtilization
            self.ebsResourceUtilization = ebsResourceUtilization
            self.maxCpuUtilizationPercentage = maxCpuUtilizationPercentage
            self.maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage
            self.maxStorageUtilizationPercentage = maxStorageUtilizationPercentage
            self.networkResourceUtilization = networkResourceUtilization
        }
    }

}

extension CostExplorerClientTypes.EC2Specification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offeringClass = "OfferingClass"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringClass = self.offeringClass {
            try encodeContainer.encode(offeringClass.rawValue, forKey: .offeringClass)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringClassDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.OfferingClass.self, forKey: .offeringClass)
        offeringClass = offeringClassDecoded
    }
}

extension CostExplorerClientTypes {
    /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
    public struct EC2Specification: Swift.Equatable {
        /// Indicates whether you want a recommendation for standard or convertible reservations.
        public var offeringClass: CostExplorerClientTypes.OfferingClass?

        public init(
            offeringClass: CostExplorerClientTypes.OfferingClass? = nil
        )
        {
            self.offeringClass = offeringClass
        }
    }

}

extension CostExplorerClientTypes.ESInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case instanceClass = "InstanceClass"
        case instanceSize = "InstanceSize"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceClass = self.instanceClass {
            try encodeContainer.encode(instanceClass, forKey: .instanceClass)
        }
        if let instanceSize = self.instanceSize {
            try encodeContainer.encode(instanceSize, forKey: .instanceSize)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceClass)
        instanceClass = instanceClassDecoded
        let instanceSizeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceSize)
        instanceSize = instanceSizeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration) ?? false
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible) ?? false
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon OpenSearch Service instances that Amazon Web Services recommends that you purchase.
    public struct ESInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The class of instance that Amazon Web Services recommends.
        public var instanceClass: Swift.String?
        /// The size of instance that Amazon Web Services recommends.
        public var instanceSize: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            instanceClass: Swift.String? = nil,
            instanceSize: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.instanceClass = instanceClass
            self.instanceSize = instanceSize
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes.ElastiCacheInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case productDescription = "ProductDescription"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let productDescription = self.productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration) ?? false
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible) ?? false
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon ElastiCache instances that Amazon Web Services recommends that you purchase.
    public struct ElastiCacheInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The description of the recommended reservation.
        public var productDescription: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            productDescription: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.productDescription = productDescription
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes.Expression: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and = "And"
        case costCategories = "CostCategories"
        case dimensions = "Dimensions"
        case not = "Not"
        case or = "Or"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for expression0 in and {
                try andContainer.encode(expression0)
            }
        }
        if let costCategories = self.costCategories {
            try encodeContainer.encode(costCategories, forKey: .costCategories)
        }
        if let dimensions = self.dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let not = self.not {
            try encodeContainer.encode(not.value, forKey: .not)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for expression0 in or {
                try orContainer.encode(expression0)
            }
        }
        if let tags = self.tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Expression?].self, forKey: .or)
        var orDecoded0:[CostExplorerClientTypes.Expression]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [CostExplorerClientTypes.Expression]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Expression?].self, forKey: .and)
        var andDecoded0:[CostExplorerClientTypes.Expression]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [CostExplorerClientTypes.Expression]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let notDecoded = try containerValues.decodeIfPresent(Box<CostExplorerClientTypes.Expression>.self, forKey: .not)
        not = notDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DimensionValues.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TagValues.self, forKey: .tags)
        tags = tagsDecoded
        let costCategoriesDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryValues.self, forKey: .costCategories)
        costCategories = costCategoriesDecoded
    }
}

extension CostExplorerClientTypes {
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public struct Expression: Swift.Equatable {
        /// Return results that match both Dimension objects.
        public var and: [CostExplorerClientTypes.Expression]?
        /// The filter that's based on CostCategory values.
        public var costCategories: CostExplorerClientTypes.CostCategoryValues?
        /// The specific Dimension to use for Expression.
        public var dimensions: CostExplorerClientTypes.DimensionValues?
        /// Return results that don't match a Dimension object.
        public var not: Box<CostExplorerClientTypes.Expression>?
        /// Return results that match either Dimension object.
        public var or: [CostExplorerClientTypes.Expression]?
        /// The specific Tag to use for Expression.
        public var tags: CostExplorerClientTypes.TagValues?

        public init(
            and: [CostExplorerClientTypes.Expression]? = nil,
            costCategories: CostExplorerClientTypes.CostCategoryValues? = nil,
            dimensions: CostExplorerClientTypes.DimensionValues? = nil,
            not: Box<CostExplorerClientTypes.Expression>? = nil,
            or: [CostExplorerClientTypes.Expression]? = nil,
            tags: CostExplorerClientTypes.TagValues? = nil
        )
        {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }
    }

}

extension CostExplorerClientTypes {
    public enum FindingReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cpuOverProvisioned
        case cpuUnderProvisioned
        case diskIopsOverProvisioned
        case diskIopsUnderProvisioned
        case diskThroughputOverProvisioned
        case diskThroughputUnderProvisioned
        case ebsIopsOverProvisioned
        case ebsIopsUnderProvisioned
        case ebsThroughputOverProvisioned
        case ebsThroughputUnderProvisioned
        case memoryOverProvisioned
        case memoryUnderProvisioned
        case networkBandwidthOverProvisioned
        case networkBandwidthUnderProvisioned
        case networkPpsOverProvisioned
        case networkPpsUnderProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingReasonCode] {
            return [
                .cpuOverProvisioned,
                .cpuUnderProvisioned,
                .diskIopsOverProvisioned,
                .diskIopsUnderProvisioned,
                .diskThroughputOverProvisioned,
                .diskThroughputUnderProvisioned,
                .ebsIopsOverProvisioned,
                .ebsIopsUnderProvisioned,
                .ebsThroughputOverProvisioned,
                .ebsThroughputUnderProvisioned,
                .memoryOverProvisioned,
                .memoryUnderProvisioned,
                .networkBandwidthOverProvisioned,
                .networkBandwidthUnderProvisioned,
                .networkPpsOverProvisioned,
                .networkPpsUnderProvisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cpuOverProvisioned: return "CPU_OVER_PROVISIONED"
            case .cpuUnderProvisioned: return "CPU_UNDER_PROVISIONED"
            case .diskIopsOverProvisioned: return "DISK_IOPS_OVER_PROVISIONED"
            case .diskIopsUnderProvisioned: return "DISK_IOPS_UNDER_PROVISIONED"
            case .diskThroughputOverProvisioned: return "DISK_THROUGHPUT_OVER_PROVISIONED"
            case .diskThroughputUnderProvisioned: return "DISK_THROUGHPUT_UNDER_PROVISIONED"
            case .ebsIopsOverProvisioned: return "EBS_IOPS_OVER_PROVISIONED"
            case .ebsIopsUnderProvisioned: return "EBS_IOPS_UNDER_PROVISIONED"
            case .ebsThroughputOverProvisioned: return "EBS_THROUGHPUT_OVER_PROVISIONED"
            case .ebsThroughputUnderProvisioned: return "EBS_THROUGHPUT_UNDER_PROVISIONED"
            case .memoryOverProvisioned: return "MEMORY_OVER_PROVISIONED"
            case .memoryUnderProvisioned: return "MEMORY_UNDER_PROVISIONED"
            case .networkBandwidthOverProvisioned: return "NETWORK_BANDWIDTH_OVER_PROVISIONED"
            case .networkBandwidthUnderProvisioned: return "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
            case .networkPpsOverProvisioned: return "NETWORK_PPS_OVER_PROVISIONED"
            case .networkPpsUnderProvisioned: return "NETWORK_PPS_UNDER_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingReasonCode(rawValue: rawValue) ?? FindingReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.ForecastResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case meanValue = "MeanValue"
        case predictionIntervalLowerBound = "PredictionIntervalLowerBound"
        case predictionIntervalUpperBound = "PredictionIntervalUpperBound"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanValue = self.meanValue {
            try encodeContainer.encode(meanValue, forKey: .meanValue)
        }
        if let predictionIntervalLowerBound = self.predictionIntervalLowerBound {
            try encodeContainer.encode(predictionIntervalLowerBound, forKey: .predictionIntervalLowerBound)
        }
        if let predictionIntervalUpperBound = self.predictionIntervalUpperBound {
            try encodeContainer.encode(predictionIntervalUpperBound, forKey: .predictionIntervalUpperBound)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let meanValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .meanValue)
        meanValue = meanValueDecoded
        let predictionIntervalLowerBoundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionIntervalLowerBound)
        predictionIntervalLowerBound = predictionIntervalLowerBoundDecoded
        let predictionIntervalUpperBoundDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionIntervalUpperBound)
        predictionIntervalUpperBound = predictionIntervalUpperBoundDecoded
    }
}

extension CostExplorerClientTypes {
    /// The forecast that's created for your query.
    public struct ForecastResult: Swift.Equatable {
        /// The mean value of the forecast.
        public var meanValue: Swift.String?
        /// The lower limit for the prediction interval.
        public var predictionIntervalLowerBound: Swift.String?
        /// The upper limit for the prediction interval.
        public var predictionIntervalUpperBound: Swift.String?
        /// The period of time that the forecast covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init(
            meanValue: Swift.String? = nil,
            predictionIntervalLowerBound: Swift.String? = nil,
            predictionIntervalUpperBound: Swift.String? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.meanValue = meanValue
            self.predictionIntervalLowerBound = predictionIntervalLowerBound
            self.predictionIntervalUpperBound = predictionIntervalUpperBound
            self.timePeriod = timePeriod
        }
    }

}

extension GenerationExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerationExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A request to generate a recommendation is already in progress.
public struct GenerationExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "GenerationExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct GenerationExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GenerationExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes {
    public enum GenerationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [GenerationStatus] {
            return [
                .failed,
                .processing,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GenerationStatus(rawValue: rawValue) ?? GenerationStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.GenerationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedCompletionTime = "EstimatedCompletionTime"
        case generationCompletionTime = "GenerationCompletionTime"
        case generationStartedTime = "GenerationStartedTime"
        case generationStatus = "GenerationStatus"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedCompletionTime = self.estimatedCompletionTime {
            try encodeContainer.encode(estimatedCompletionTime, forKey: .estimatedCompletionTime)
        }
        if let generationCompletionTime = self.generationCompletionTime {
            try encodeContainer.encode(generationCompletionTime, forKey: .generationCompletionTime)
        }
        if let generationStartedTime = self.generationStartedTime {
            try encodeContainer.encode(generationStartedTime, forKey: .generationStartedTime)
        }
        if let generationStatus = self.generationStatus {
            try encodeContainer.encode(generationStatus.rawValue, forKey: .generationStatus)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationStatusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.GenerationStatus.self, forKey: .generationStatus)
        generationStatus = generationStatusDecoded
        let generationStartedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationStartedTime)
        generationStartedTime = generationStartedTimeDecoded
        let generationCompletionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationCompletionTime)
        generationCompletionTime = generationCompletionTimeDecoded
        let estimatedCompletionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedCompletionTime)
        estimatedCompletionTime = estimatedCompletionTimeDecoded
    }
}

extension CostExplorerClientTypes {
    /// The summary of the Savings Plans recommendation generation.
    public struct GenerationSummary: Swift.Equatable {
        /// Indicates the estimated time for when the recommendation generation will complete.
        public var estimatedCompletionTime: Swift.String?
        /// Indicates the completion time of the recommendation generation.
        public var generationCompletionTime: Swift.String?
        /// Indicates the start time of the recommendation generation.
        public var generationStartedTime: Swift.String?
        /// Indicates whether the recommendation generation succeeded, is processing, or failed.
        public var generationStatus: CostExplorerClientTypes.GenerationStatus?
        /// Indicates the ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init(
            estimatedCompletionTime: Swift.String? = nil,
            generationCompletionTime: Swift.String? = nil,
            generationStartedTime: Swift.String? = nil,
            generationStatus: CostExplorerClientTypes.GenerationStatus? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.estimatedCompletionTime = estimatedCompletionTime
            self.generationCompletionTime = generationCompletionTime
            self.generationStartedTime = generationStartedTime
            self.generationStatus = generationStatus
            self.recommendationId = recommendationId
        }
    }

}

extension GetAnomaliesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateInterval = self.dateInterval {
            try encodeContainer.encode(dateInterval, forKey: .dateInterval)
        }
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let totalImpact = self.totalImpact {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
    }
}

extension GetAnomaliesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomaliesInput: Swift.Equatable {
    /// Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object will have an AnomalyEndDate in the specified time range.
    /// This member is required.
    public var dateInterval: CostExplorerClientTypes.AnomalyDateInterval?
    /// Filters anomaly results by the feedback field on the anomaly object.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon Resource Name (ARN).
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Filters anomaly results by the total impact field on the anomaly object. For example, you can filter anomalies GREATER_THAN 200.00 to retrieve anomalies, with an estimated dollar impact greater than 200.
    public var totalImpact: CostExplorerClientTypes.TotalImpactFilter?

    public init(
        dateInterval: CostExplorerClientTypes.AnomalyDateInterval? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil,
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        totalImpact: CostExplorerClientTypes.TotalImpactFilter? = nil
    )
    {
        self.dateInterval = dateInterval
        self.feedback = feedback
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.totalImpact = totalImpact
    }
}

struct GetAnomaliesInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let dateInterval: CostExplorerClientTypes.AnomalyDateInterval?
    let feedback: CostExplorerClientTypes.AnomalyFeedbackType?
    let totalImpact: CostExplorerClientTypes.TotalImpactFilter?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomaliesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let dateIntervalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyDateInterval.self, forKey: .dateInterval)
        dateInterval = dateIntervalDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
        let totalImpactDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TotalImpactFilter.self, forKey: .totalImpact)
        totalImpact = totalImpactDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomaliesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnomaliesOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalies = output.anomalies
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalies = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomaliesOutput: Swift.Equatable {
    /// A list of cost anomalies.
    /// This member is required.
    public var anomalies: [CostExplorerClientTypes.Anomaly]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalies: [CostExplorerClientTypes.Anomaly]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalies = anomalies
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomaliesOutputBody: Swift.Equatable {
    let anomalies: [CostExplorerClientTypes.Anomaly]?
    let nextPageToken: Swift.String?
}

extension GetAnomaliesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalies = "Anomalies"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomaliesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[CostExplorerClientTypes.Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [CostExplorerClientTypes.Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetAnomaliesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAnomalyMonitorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for value0 in monitorArnList {
                try monitorArnListContainer.encode(value0)
            }
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
    }
}

extension GetAnomalyMonitorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomalyMonitorsInput: Swift.Equatable {
    /// The number of entries that a paginated response contains.
    public var maxResults: Swift.Int?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        monitorArnList: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArnList = monitorArnList
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsInputBody: Swift.Equatable {
    let monitorArnList: [Swift.String]?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomalyMonitorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalyMonitorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnomalyMonitorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalyMonitors = output.anomalyMonitors
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalyMonitors = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalyMonitorsOutput: Swift.Equatable {
    /// A list of cost anomaly monitors that includes the detailed metadata for each monitor.
    /// This member is required.
    public var anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalyMonitors = anomalyMonitors
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsOutputBody: Swift.Equatable {
    let anomalyMonitors: [CostExplorerClientTypes.AnomalyMonitor]?
    let nextPageToken: Swift.String?
}

extension GetAnomalyMonitorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyMonitors = "AnomalyMonitors"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.AnomalyMonitor?].self, forKey: .anomalyMonitors)
        var anomalyMonitorsDecoded0:[CostExplorerClientTypes.AnomalyMonitor]? = nil
        if let anomalyMonitorsContainer = anomalyMonitorsContainer {
            anomalyMonitorsDecoded0 = [CostExplorerClientTypes.AnomalyMonitor]()
            for structure0 in anomalyMonitorsContainer {
                if let structure0 = structure0 {
                    anomalyMonitorsDecoded0?.append(structure0)
                }
            }
        }
        anomalyMonitors = anomalyMonitorsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetAnomalyMonitorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownMonitorException": return try await UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAnomalySubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let subscriptionArnList = subscriptionArnList {
            var subscriptionArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionArnList)
            for value0 in subscriptionArnList {
                try subscriptionArnListContainer.encode(value0)
            }
        }
    }
}

extension GetAnomalySubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAnomalySubscriptionsInput: Swift.Equatable {
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// Cost anomaly monitor ARNs.
    public var monitorArn: Swift.String?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// A list of cost anomaly subscription ARNs.
    public var subscriptionArnList: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        monitorArn: Swift.String? = nil,
        nextPageToken: Swift.String? = nil,
        subscriptionArnList: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.subscriptionArnList = subscriptionArnList
    }
}

struct GetAnomalySubscriptionsInputBody: Swift.Equatable {
    let subscriptionArnList: [Swift.String]?
    let monitorArn: Swift.String?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetAnomalySubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscriptionArnList)
        var subscriptionArnListDecoded0:[Swift.String]? = nil
        if let subscriptionArnListContainer = subscriptionArnListContainer {
            subscriptionArnListDecoded0 = [Swift.String]()
            for string0 in subscriptionArnListContainer {
                if let string0 = string0 {
                    subscriptionArnListDecoded0?.append(string0)
                }
            }
        }
        subscriptionArnList = subscriptionArnListDecoded0
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalySubscriptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnomalySubscriptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalySubscriptions = output.anomalySubscriptions
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalySubscriptions = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalySubscriptionsOutput: Swift.Equatable {
    /// A list of cost anomaly subscriptions that includes the detailed metadata for each one.
    /// This member is required.
    public var anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?

    public init(
        anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.anomalySubscriptions = anomalySubscriptions
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalySubscriptionsOutputBody: Swift.Equatable {
    let anomalySubscriptions: [CostExplorerClientTypes.AnomalySubscription]?
    let nextPageToken: Swift.String?
}

extension GetAnomalySubscriptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalySubscriptions = "AnomalySubscriptions"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.AnomalySubscription?].self, forKey: .anomalySubscriptions)
        var anomalySubscriptionsDecoded0:[CostExplorerClientTypes.AnomalySubscription]? = nil
        if let anomalySubscriptionsContainer = anomalySubscriptionsContainer {
            anomalySubscriptionsDecoded0 = [CostExplorerClientTypes.AnomalySubscription]()
            for structure0 in anomalySubscriptionsContainer {
                if let structure0 = structure0 {
                    anomalySubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        anomalySubscriptions = anomalySubscriptionsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetAnomalySubscriptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownSubscriptionException": return try await UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCostAndUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinition0 in groupBy {
                try groupByContainer.encode(groupdefinition0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricname0 in metrics {
                try metricsContainer.encode(metricname0)
            }
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostAndUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostAndUsageInput: Swift.Equatable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html). Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY or DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, either MONTHLY or DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups, either dimensions, tag keys, cost categories, or any two group by types. Valid values for the DIMENSION type are AZ, INSTANCE_TYPE, LEGAL_ENTITY_NAME, INVOICING_ENTITY, LINKED_ACCOUNT, OPERATION, PLATFORM, PURCHASE_TYPE, SERVICE, TENANCY, RECORD_TYPE, and USAGE_TYPE. When you group by the TAG type and include a valid tag key, you get all tag values, including empty strings.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking into account the units. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hours and GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsage requests.
    /// This member is required.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start date and end date for retrieving Amazon Web Services costs. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let nextPageToken: Swift.String?
}

extension GetCostAndUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCostAndUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageOutput: Swift.Equatable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that's covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init(
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageOutputBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    let resultsByTime: [CostExplorerClientTypes.ResultByTime]?
    let dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
}

extension GetCostAndUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[CostExplorerClientTypes.ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [CostExplorerClientTypes.ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

enum GetCostAndUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BillExpirationException": return try await BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestChangedException": return try await RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCostAndUsageWithResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinition0 in groupBy {
                try groupByContainer.encode(groupdefinition0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricname0 in metrics {
                try metricsContainer.encode(metricname0)
            }
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostAndUsageWithResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostAndUsageWithResourcesInput: Swift.Equatable {
    /// Filters Amazon Web Services costs by different dimensions. For example, you can specify SERVICE and LINKED_ACCOUNT and get the costs that are associated with that account's usage of that service. You can nest Expression objects to define any combination of dimension filters. For more information, see [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html). The GetCostAndUsageWithResources operation requires that you either group by or filter by a ResourceId. It requires the [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html)"SERVICE = Amazon Elastic Compute Cloud - Compute" in the filter. Valid values for MatchOptions for Dimensions are EQUALS and CASE_SENSITIVE. Valid values for MatchOptions for CostCategories and Tags are EQUALS, ABSENT, and CASE_SENSITIVE. Default values are EQUALS and CASE_SENSITIVE.
    /// This member is required.
    public var filter: CostExplorerClientTypes.Expression?
    /// Sets the Amazon Web Services cost granularity to MONTHLY, DAILY, or HOURLY. If Granularity isn't set, the response object doesn't include the Granularity, MONTHLY, DAILY, or HOURLY.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group Amazon Web Services costs using up to two different groups: DIMENSION, TAG, COST_CATEGORY.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// Which metrics are returned in the query. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity. If you return the UsageQuantity metric, the service aggregates all usage numbers without taking the units into account. For example, if you aggregate usageQuantity across all of Amazon EC2, the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units (for example, hour or GB). To get more meaningful UsageQuantity metrics, filter by UsageType or UsageTypeGroups. Metrics is required for GetCostAndUsageWithResources requests.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageWithResourcesInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let nextPageToken: Swift.String?
}

extension GetCostAndUsageWithResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageWithResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCostAndUsageWithResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageWithResourcesOutput: Swift.Equatable {
    /// The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.
    public var dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The groups that are specified by the Filter or GroupBy parameters in the request.
    public var groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The time period that's covered by the results in the response.
    public var resultsByTime: [CostExplorerClientTypes.ResultByTime]?

    public init(
        dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [CostExplorerClientTypes.GroupDefinition]? = nil,
        nextPageToken: Swift.String? = nil,
        resultsByTime: [CostExplorerClientTypes.ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageWithResourcesOutputBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let groupDefinitions: [CostExplorerClientTypes.GroupDefinition]?
    let resultsByTime: [CostExplorerClientTypes.ResultByTime]?
    let dimensionValueAttributes: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
}

extension GetCostAndUsageWithResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[CostExplorerClientTypes.ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [CostExplorerClientTypes.ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

enum GetCostAndUsageWithResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BillExpirationException": return try await BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestChangedException": return try await RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCostCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryName = self.costCategoryName {
            try encodeContainer.encode(costCategoryName, forKey: .costCategoryName)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = self.searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinition0 in sortBy {
                try sortByContainer.encode(sortdefinition0)
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostCategoriesInput: Swift.Equatable {
    /// The unique name of the Cost Category.
    public var costCategoryName: Swift.String?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when the SortBy value is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with the SortBy value, the request returns 1000 results as the default value for this parameter. For GetCostCategories, MaxResults has an upper quota of 1000.
    public var maxResults: Swift.Int?
    /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the previous call in your next request.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for. If you don't specify a CostCategoryName, SearchString is used to filter Cost Category names that match the SearchString pattern. If you specify a CostCategoryName, SearchString is used to filter Cost Category values that match the SearchString pattern.
    public var searchString: Swift.String?
    /// The value that you sort the data by. The key represents the cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported key values for the SortOrder value are ASCENDING and DESCENDING. When you use the SortBy value, the NextPageToken and SearchString key values aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        costCategoryName: Swift.String? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.costCategoryName = costCategoryName
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetCostCategoriesInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let costCategoryName: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetCostCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let costCategoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryName)
        costCategoryName = costCategoryNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostCategoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCostCategoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryNames = output.costCategoryNames
            self.costCategoryValues = output.costCategoryValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.costCategoryNames = nil
            self.costCategoryValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetCostCategoriesOutput: Swift.Equatable {
    /// The names of the Cost Categories.
    public var costCategoryNames: [Swift.String]?
    /// The Cost Category values. If the CostCategoryName key isn't specified in the request, the CostCategoryValues fields aren't returned.
    public var costCategoryValues: [Swift.String]?
    /// If the number of objects that are still available for retrieval exceeds the quota, Amazon Web Services returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.
    public var nextPageToken: Swift.String?
    /// The number of objects that are returned.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of objects.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        costCategoryNames: [Swift.String]? = nil,
        costCategoryValues: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.costCategoryNames = costCategoryNames
        self.costCategoryValues = costCategoryValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetCostCategoriesOutputBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let costCategoryNames: [Swift.String]?
    let costCategoryValues: [Swift.String]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
}

extension GetCostCategoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryNames = "CostCategoryNames"
        case costCategoryValues = "CostCategoryValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let costCategoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .costCategoryNames)
        var costCategoryNamesDecoded0:[Swift.String]? = nil
        if let costCategoryNamesContainer = costCategoryNamesContainer {
            costCategoryNamesDecoded0 = [Swift.String]()
            for string0 in costCategoryNamesContainer {
                if let string0 = string0 {
                    costCategoryNamesDecoded0?.append(string0)
                }
            }
        }
        costCategoryNames = costCategoryNamesDecoded0
        let costCategoryValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .costCategoryValues)
        var costCategoryValuesDecoded0:[Swift.String]? = nil
        if let costCategoryValuesContainer = costCategoryValuesContainer {
            costCategoryValuesDecoded0 = [Swift.String]()
            for string0 in costCategoryValuesContainer {
                if let string0 = string0 {
                    costCategoryValuesDecoded0?.append(string0)
                }
            }
        }
        costCategoryValues = costCategoryValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

enum GetCostCategoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BillExpirationException": return try await BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestChangedException": return try await RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCostForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = self.predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetCostForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCostForecastInput: Swift.Equatable {
    /// The filters that you want to use to filter your forecast. The GetCostForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetCostForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see [Why does the "blended" annotation appear on some line items in my bill?](http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/). Valid values for a GetCostForecast call are the following:
    ///
    /// * AMORTIZED_COST
    ///
    /// * BLENDED_COST
    ///
    /// * NET_AMORTIZED_COST
    ///
    /// * NET_UNBLENDED_COST
    ///
    /// * UNBLENDED_COST
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetCostForecastInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let metric: CostExplorerClientTypes.Metric?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let predictionIntervalLevel: Swift.Int?
}

extension GetCostForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetCostForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCostForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetCostForecastOutput: Swift.Equatable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you are forecasted to spend over the forecast period, in USD.
    public var total: CostExplorerClientTypes.MetricValue?

    public init(
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetCostForecastOutputBody: Swift.Equatable {
    let total: CostExplorerClientTypes.MetricValue?
    let forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
}

extension GetCostForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[CostExplorerClientTypes.ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [CostExplorerClientTypes.ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

enum GetCostForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDimensionValuesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = self.context {
            try encodeContainer.encode(context.rawValue, forKey: .context)
        }
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension.rawValue, forKey: .dimension)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = self.searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinition0 in sortBy {
                try sortByContainer.encode(sortdefinition0)
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetDimensionValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDimensionValuesInput: Swift.Equatable {
    /// The context for the call to GetDimensionValues. This can be RESERVATIONS or COST_AND_USAGE. The default value is COST_AND_USAGE. If the context is set to RESERVATIONS, the resulting dimension values can be used in the GetReservationUtilization operation. If the context is set to COST_AND_USAGE, the resulting dimension values can be used in the GetCostAndUsage operation. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * BILLING_ENTITY - The Amazon Web Services seller that your account is with. Possible values are the following: - Amazon Web Services(Amazon Web Services): The entity that sells Amazon Web Services. - AISPL (Amazon Internet Services Pvt. Ltd.): The local Indian entity that's an acting reseller for Amazon Web Services in India. - Amazon Web Services Marketplace: The entity that supports the sale of solutions that are built on Amazon Web Services by third-party software providers.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * INSTANCE_TYPE_FAMILY - A family of instance types optimized to fit different use cases. Examples are Compute Optimized (for example, C4, C5, C6g, and C7g), Memory Optimization (for example, R4, R5n, R5b, and R6g).
    ///
    /// * INVOICING_ENTITY - The name of the entity that issues the Amazon Web Services invoice.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase that this usage is related to. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * RESERVATION_ID - The unique identifier for an Amazon Web Services Reservation Instance.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute).
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * RECORD_TYPE - The different types of charges such as Reserved Instance (RI) fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - The payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plans.
    public var context: CostExplorerClientTypes.Context?
    /// The name of the dimension. Each Dimension is available for a different Context. For more information, see Context. LINK_ACCOUNT_NAME and SERVICE_CODE can only be used in [CostCategoryRule](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/AAPI_CostCategoryRule.html).
    /// This member is required.
    public var dimension: CostExplorerClientTypes.Dimension?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetDimensionValues, MaxResults has an upper limit of 1000.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search the filter values for.
    public var searchString: Swift.String?
    /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported values for the SortOrder key are ASCENDING or DESCENDING. When you specify a SortBy paramater, the context must be COST_AND_USAGE. Further, when using SortBy, NextPageToken and SearchString aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The start date and end date for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        context: CostExplorerClientTypes.Context? = nil,
        dimension: CostExplorerClientTypes.Dimension? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.context = context
        self.dimension = dimension
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetDimensionValuesInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let dimension: CostExplorerClientTypes.Dimension?
    let context: CostExplorerClientTypes.Context?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetDimensionValuesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Dimension.self, forKey: .dimension)
        dimension = dimensionDecoded
        let contextDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Context.self, forKey: .context)
        context = contextDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetDimensionValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDimensionValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dimensionValues = output.dimensionValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.dimensionValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetDimensionValuesOutput: Swift.Equatable {
    /// The filters that you used to filter your request. Some dimensions are available only for a specific context. If you set the context to COST_AND_USAGE, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LEGAL_ENTITY_NAME - The name of the organization that sells you Amazon Web Services services, such as Amazon Web Services.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.
    ///
    /// * OPERATION - The action performed. Examples include RunInstance and CreateBucket.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand Instances and Standard Reserved Instances.
    ///
    /// * SERVICE - The Amazon Web Services service such as Amazon DynamoDB.
    ///
    /// * USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the GetDimensionValues operation includes a unit attribute. Examples include GB and Hrs.
    ///
    /// * USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this operation includes a unit attribute.
    ///
    /// * RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.
    ///
    /// * RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service. You can opt-in by enabling Hourly and Resource Level Data in Cost Management Console preferences.
    ///
    ///
    /// If you set the context to RESERVATIONS, you can use the following dimensions for searching:
    ///
    /// * AZ - The Availability Zone. An example is us-east-1a.
    ///
    /// * CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.
    ///
    /// * DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are SingleAZ and MultiAZ.
    ///
    /// * INSTANCE_TYPE - The type of Amazon EC2 instance. An example is m4.xlarge.
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.
    ///
    /// * TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).
    ///
    /// * TENANCY - The tenancy of a resource. Examples are shared or dedicated.
    ///
    ///
    /// If you set the context to SAVINGS_PLANS, you can use the following dimensions for searching:
    ///
    /// * SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)
    ///
    /// * PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)
    ///
    /// * REGION - The Amazon Web Services Region.
    ///
    /// * INSTANCE_TYPE_FAMILY - The family of instances (For example, m5)
    ///
    /// * LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value field contains the Amazon Web Services ID of the member account.
    ///
    /// * SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan
    /// This member is required.
    public var dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of results that Amazon Web Services returned at one time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The total number of search results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil,
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.dimensionValues = dimensionValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetDimensionValuesOutputBody: Swift.Equatable {
    let dimensionValues: [CostExplorerClientTypes.DimensionValuesWithAttributes]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetDimensionValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimensionValues = "DimensionValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValuesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.DimensionValuesWithAttributes?].self, forKey: .dimensionValues)
        var dimensionValuesDecoded0:[CostExplorerClientTypes.DimensionValuesWithAttributes]? = nil
        if let dimensionValuesContainer = dimensionValuesContainer {
            dimensionValuesDecoded0 = [CostExplorerClientTypes.DimensionValuesWithAttributes]()
            for structure0 in dimensionValuesContainer {
                if let structure0 = structure0 {
                    dimensionValuesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValues = dimensionValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetDimensionValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BillExpirationException": return try await BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestChangedException": return try await RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReservationCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinition0 in groupBy {
                try groupByContainer.encode(groupdefinition0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricname0 in metrics {
                try metricsContainer.encode(metricname0)
            }
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetReservationCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// You can use the following request parameters to query for how much of your instance usage a reservation covered.
public struct GetReservationCoverageInput: Swift.Equatable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * TAG
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. You can nest only one level deep. If there are multiple values for a dimension, they are OR'd together. If you don't provide a SERVICE filter, Cost Explorer defaults to EC2. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for the reservation. Valid values are MONTHLY and DAILY. If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. The GetReservationCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data by the following attributes:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DATABASE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * INVOICING_ENTITY
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * TENANCY
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The measurement that you want your reservation coverage reported in. Valid values are Hour, Unit, and Cost. You can use multiple values in a request.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value by which you want to sort the data. The following values are supported for Key:
    ///
    /// * OnDemandCost
    ///
    /// * CoverageHoursPercentage
    ///
    /// * OnDemandHours
    ///
    /// * ReservedHours
    ///
    /// * TotalRunningHours
    ///
    /// * CoverageNormalizedUnitsPercentage
    ///
    /// * OnDemandNormalizedUnits
    ///
    /// * ReservedNormalizedUnits
    ///
    /// * TotalRunningNormalizedUnits
    ///
    /// * Time
    ///
    ///
    /// Supported values for SortOrder are ASCENDING or DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationCoverageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let nextPageToken: Swift.String?
    let sortBy: CostExplorerClientTypes.SortDefinition?
    let maxResults: Swift.Int?
}

extension GetReservationCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationCoverageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReservationCoverageOutputBody = try responseDecoder.decode(responseBody: data)
            self.coveragesByTime = output.coveragesByTime
            self.nextPageToken = output.nextPageToken
            self.total = output.total
        } else {
            self.coveragesByTime = nil
            self.nextPageToken = nil
            self.total = nil
        }
    }
}

public struct GetReservationCoverageOutput: Swift.Equatable {
    /// The amount of time that your reservations covered.
    /// This member is required.
    public var coveragesByTime: [CostExplorerClientTypes.CoverageByTime]?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of instance usage that a reservation covered.
    public var total: CostExplorerClientTypes.Coverage?

    public init(
        coveragesByTime: [CostExplorerClientTypes.CoverageByTime]? = nil,
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.Coverage? = nil
    )
    {
        self.coveragesByTime = coveragesByTime
        self.nextPageToken = nextPageToken
        self.total = total
    }
}

struct GetReservationCoverageOutputBody: Swift.Equatable {
    let coveragesByTime: [CostExplorerClientTypes.CoverageByTime]?
    let total: CostExplorerClientTypes.Coverage?
    let nextPageToken: Swift.String?
}

extension GetReservationCoverageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveragesByTime = "CoveragesByTime"
        case nextPageToken = "NextPageToken"
        case total = "Total"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coveragesByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CoverageByTime?].self, forKey: .coveragesByTime)
        var coveragesByTimeDecoded0:[CostExplorerClientTypes.CoverageByTime]? = nil
        if let coveragesByTimeContainer = coveragesByTimeContainer {
            coveragesByTimeDecoded0 = [CostExplorerClientTypes.CoverageByTime]()
            for structure0 in coveragesByTimeContainer {
                if let structure0 = structure0 {
                    coveragesByTimeDecoded0?.append(structure0)
                }
            }
        }
        coveragesByTime = coveragesByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetReservationCoverageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReservationPurchaseRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceSpecification = self.serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = self.termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

extension GetReservationPurchaseRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReservationPurchaseRecommendationInput: Swift.Equatable {
    /// The account ID that's associated with the recommendation.
    public var accountId: Swift.String?
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of previous days that you want Amazon Web Services to consider when it calculates your recommendations.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The reservation purchase option that you want recommendations for.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The specific service that you want recommendations for.
    /// This member is required.
    public var service: Swift.String?
    /// The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.
    public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
    /// The reservation term that you want recommendations for.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init(
        accountId: Swift.String? = nil,
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        service: Swift.String? = nil,
        serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountId = accountId
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.service = service
        self.serviceSpecification = serviceSpecification
        self.termInYears = termInYears
    }
}

struct GetReservationPurchaseRecommendationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let service: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let accountScope: CostExplorerClientTypes.AccountScope?
    let lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    let termInYears: CostExplorerClientTypes.TermInYears?
    let paymentOption: CostExplorerClientTypes.PaymentOption?
    let serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
    let pageSize: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetReservationPurchaseRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationPurchaseRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReservationPurchaseRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.recommendations = output.recommendations
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetReservationPurchaseRecommendationOutput: Swift.Equatable {
    /// Information about this specific recommendation call, such as the time stamp for when Cost Explorer generated this recommendation.
    public var metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata?
    /// The pagination token for the next set of retrievable results.
    public var nextPageToken: Swift.String?
    /// Recommendations for reservations to purchase.
    public var recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]?

    public init(
        metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.recommendations = recommendations
    }
}

struct GetReservationPurchaseRecommendationOutputBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata?
    let recommendations: [CostExplorerClientTypes.ReservationPurchaseRecommendation]?
    let nextPageToken: Swift.String?
}

extension GetReservationPurchaseRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case recommendations = "Recommendations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationPurchaseRecommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[CostExplorerClientTypes.ReservationPurchaseRecommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [CostExplorerClientTypes.ReservationPurchaseRecommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetReservationPurchaseRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReservationUtilizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinition0 in groupBy {
                try groupByContainer.encode(groupdefinition0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetReservationUtilizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReservationUtilizationInput: Swift.Equatable {
    /// Filters utilization data by dimensions. You can filter by the following dimensions:
    ///
    /// * AZ
    ///
    /// * CACHE_ENGINE
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * PLATFORM
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * SCOPE
    ///
    /// * TENANCY
    ///
    ///
    /// GetReservationUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension, and nesting is supported up to only one level deep. If there are multiple values for a dimension, they are OR'd together.
    public var filter: CostExplorerClientTypes.Expression?
    /// If GroupBy is set, Granularity can't be set. If Granularity isn't set, the response object doesn't include Granularity, either MONTHLY or DAILY. If both GroupBy and Granularity aren't set, GetReservationUtilization defaults to DAILY. The GetReservationUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Groups only by SUBSCRIPTION_ID. Metadata is included.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The maximum number of objects that you returned for this request. If more objects are available, in the response, Amazon Web Services provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * UtilizationPercentageInUnits
    ///
    /// * PurchasedHours
    ///
    /// * PurchasedUnits
    ///
    /// * TotalActualHours
    ///
    /// * TotalActualUnits
    ///
    /// * UnusedHours
    ///
    /// * UnusedUnits
    ///
    /// * OnDemandCostOfRIHoursUsed
    ///
    /// * NetRISavings
    ///
    /// * TotalPotentialRISavings
    ///
    /// * AmortizedUpfrontFee
    ///
    /// * AmortizedRecurringFee
    ///
    /// * TotalAmortizedFee
    ///
    /// * RICostForUnusedHours
    ///
    /// * RealizedSavings
    ///
    /// * UnrealizedSavings
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// Sets the start and end dates for retrieving Reserved Instance (RI) utilization. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationUtilizationInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: CostExplorerClientTypes.SortDefinition?
    let nextPageToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetReservationUtilizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationUtilizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReservationUtilizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.total = output.total
            self.utilizationsByTime = output.utilizationsByTime
        } else {
            self.nextPageToken = nil
            self.total = nil
            self.utilizationsByTime = nil
        }
    }
}

public struct GetReservationUtilizationOutput: Swift.Equatable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The total amount of time that you used your Reserved Instances (RIs).
    public var total: CostExplorerClientTypes.ReservationAggregates?
    /// The amount of time that you used your Reserved Instances (RIs).
    /// This member is required.
    public var utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]?

    public init(
        nextPageToken: Swift.String? = nil,
        total: CostExplorerClientTypes.ReservationAggregates? = nil,
        utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.total = total
        self.utilizationsByTime = utilizationsByTime
    }
}

struct GetReservationUtilizationOutputBody: Swift.Equatable {
    let utilizationsByTime: [CostExplorerClientTypes.UtilizationByTime]?
    let total: CostExplorerClientTypes.ReservationAggregates?
    let nextPageToken: Swift.String?
}

extension GetReservationUtilizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case total = "Total"
        case utilizationsByTime = "UtilizationsByTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.UtilizationByTime?].self, forKey: .utilizationsByTime)
        var utilizationsByTimeDecoded0:[CostExplorerClientTypes.UtilizationByTime]? = nil
        if let utilizationsByTimeContainer = utilizationsByTimeContainer {
            utilizationsByTimeDecoded0 = [CostExplorerClientTypes.UtilizationByTime]()
            for structure0 in utilizationsByTimeContainer {
                if let structure0 = structure0 {
                    utilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        utilizationsByTime = utilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetReservationUtilizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRightsizingRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

extension GetRightsizingRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRightsizingRecommendationInput: Swift.Equatable {
    /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// The pagination token that indicates the next set of results that you want to retrieve.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The specific service that you want recommendations for. The only valid value for GetRightsizingRecommendation is "AmazonEC2".
    /// This member is required.
    public var service: Swift.String?

    public init(
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        service: Swift.String? = nil
    )
    {
        self.configuration = configuration
        self.filter = filter
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.service = service
    }
}

struct GetRightsizingRecommendationInputBody: Swift.Equatable {
    let filter: CostExplorerClientTypes.Expression?
    let configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    let service: Swift.String?
    let pageSize: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetRightsizingRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetRightsizingRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRightsizingRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuration = output.configuration
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.rightsizingRecommendations = output.rightsizingRecommendations
            self.summary = output.summary
        } else {
            self.configuration = nil
            self.metadata = nil
            self.nextPageToken = nil
            self.rightsizingRecommendations = nil
            self.summary = nil
        }
    }
}

public struct GetRightsizingRecommendationOutput: Swift.Equatable {
    /// You can use Configuration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or RI benefits, or neither.
    public var configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
    /// Information regarding this specific recommendation set.
    public var metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?
    /// Recommendations to rightsize resources.
    public var rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]?
    /// Summary of this recommendation set.
    public var summary: CostExplorerClientTypes.RightsizingRecommendationSummary?

    public init(
        configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration? = nil,
        metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]? = nil,
        summary: CostExplorerClientTypes.RightsizingRecommendationSummary? = nil
    )
    {
        self.configuration = configuration
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.rightsizingRecommendations = rightsizingRecommendations
        self.summary = summary
    }
}

struct GetRightsizingRecommendationOutputBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.RightsizingRecommendationMetadata?
    let summary: CostExplorerClientTypes.RightsizingRecommendationSummary?
    let rightsizingRecommendations: [CostExplorerClientTypes.RightsizingRecommendation]?
    let nextPageToken: Swift.String?
    let configuration: CostExplorerClientTypes.RightsizingRecommendationConfiguration?
}

extension GetRightsizingRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case rightsizingRecommendations = "RightsizingRecommendations"
        case summary = "Summary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationSummary.self, forKey: .summary)
        summary = summaryDecoded
        let rightsizingRecommendationsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.RightsizingRecommendation?].self, forKey: .rightsizingRecommendations)
        var rightsizingRecommendationsDecoded0:[CostExplorerClientTypes.RightsizingRecommendation]? = nil
        if let rightsizingRecommendationsContainer = rightsizingRecommendationsContainer {
            rightsizingRecommendationsDecoded0 = [CostExplorerClientTypes.RightsizingRecommendation]()
            for structure0 in rightsizingRecommendationsContainer {
                if let structure0 = structure0 {
                    rightsizingRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        rightsizingRecommendations = rightsizingRecommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

enum GetRightsizingRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationDetailId = "RecommendationDetailId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationDetailId = self.recommendationDetailId {
            try encodeContainer.encode(recommendationDetailId, forKey: .recommendationDetailId)
        }
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlanPurchaseRecommendationDetailsInput: Swift.Equatable {
    /// The ID that is associated with the Savings Plan recommendation.
    /// This member is required.
    public var recommendationDetailId: Swift.String?

    public init(
        recommendationDetailId: Swift.String? = nil
    )
    {
        self.recommendationDetailId = recommendationDetailId
    }
}

struct GetSavingsPlanPurchaseRecommendationDetailsInputBody: Swift.Equatable {
    let recommendationDetailId: Swift.String?
}

extension GetSavingsPlanPurchaseRecommendationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationDetailId = "RecommendationDetailId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDetailIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationDetailId)
        recommendationDetailId = recommendationDetailIdDecoded
    }
}

extension GetSavingsPlanPurchaseRecommendationDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSavingsPlanPurchaseRecommendationDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommendationDetailData = output.recommendationDetailData
            self.recommendationDetailId = output.recommendationDetailId
        } else {
            self.recommendationDetailData = nil
            self.recommendationDetailId = nil
        }
    }
}

public struct GetSavingsPlanPurchaseRecommendationDetailsOutput: Swift.Equatable {
    /// Contains detailed information about a specific Savings Plan recommendation.
    public var recommendationDetailData: CostExplorerClientTypes.RecommendationDetailData?
    /// The ID that is associated with the Savings Plan recommendation.
    public var recommendationDetailId: Swift.String?

    public init(
        recommendationDetailData: CostExplorerClientTypes.RecommendationDetailData? = nil,
        recommendationDetailId: Swift.String? = nil
    )
    {
        self.recommendationDetailData = recommendationDetailData
        self.recommendationDetailId = recommendationDetailId
    }
}

struct GetSavingsPlanPurchaseRecommendationDetailsOutputBody: Swift.Equatable {
    let recommendationDetailId: Swift.String?
    let recommendationDetailData: CostExplorerClientTypes.RecommendationDetailData?
}

extension GetSavingsPlanPurchaseRecommendationDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationDetailData = "RecommendationDetailData"
        case recommendationDetailId = "RecommendationDetailId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDetailIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationDetailId)
        recommendationDetailId = recommendationDetailIdDecoded
        let recommendationDetailDataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RecommendationDetailData.self, forKey: .recommendationDetailData)
        recommendationDetailData = recommendationDetailDataDecoded
    }
}

enum GetSavingsPlanPurchaseRecommendationDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSavingsPlansCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinition0 in groupBy {
                try groupByContainer.encode(groupdefinition0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricname0 in metrics {
                try metricsContainer.encode(metricname0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansCoverageInput: Swift.Equatable {
    /// Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * INSTANCE_FAMILY
    ///
    ///
    /// GetSavingsPlansCoverage uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension. If there are multiple values for a dimension, they are OR'd together. Cost category is also supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services cost data for your Savings Plans. Granularity can't be set if GroupBy is set. The GetSavingsPlansCoverage operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// You can group the data using the attributes INSTANCE_FAMILY, REGION, or SERVICE.
    public var groupBy: [CostExplorerClientTypes.GroupDefinition]?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int?
    /// The measurement that you want your Savings Plans coverage reported in. The only valid value is SpendCoveredBySavingsPlans.
    public var metrics: [Swift.String]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * SpendCoveredBySavingsPlan
    ///
    /// * OnDemandCost
    ///
    /// * CoveragePercentage
    ///
    /// * TotalCost
    ///
    /// * InstanceFamily
    ///
    /// * Region
    ///
    /// * Service
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        groupBy: [CostExplorerClientTypes.GroupDefinition]? = nil,
        maxResults: Swift.Int? = nil,
        metrics: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansCoverageInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let groupBy: [CostExplorerClientTypes.GroupDefinition]?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let metrics: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[CostExplorerClientTypes.GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [CostExplorerClientTypes.GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .metrics)
        var metricsDecoded0:[Swift.String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansCoverageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSavingsPlansCoverageOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlansCoverages = output.savingsPlansCoverages
        } else {
            self.nextToken = nil
            self.savingsPlansCoverages = nil
        }
    }
}

public struct GetSavingsPlansCoverageOutput: Swift.Equatable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The amount of spend that your Savings Plans covered.
    /// This member is required.
    public var savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]?

    public init(
        nextToken: Swift.String? = nil,
        savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansCoverages = savingsPlansCoverages
    }
}

struct GetSavingsPlansCoverageOutputBody: Swift.Equatable {
    let savingsPlansCoverages: [CostExplorerClientTypes.SavingsPlansCoverage]?
    let nextToken: Swift.String?
}

extension GetSavingsPlansCoverageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case savingsPlansCoverages = "SavingsPlansCoverages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansCoveragesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansCoverage?].self, forKey: .savingsPlansCoverages)
        var savingsPlansCoveragesDecoded0:[CostExplorerClientTypes.SavingsPlansCoverage]? = nil
        if let savingsPlansCoveragesContainer = savingsPlansCoveragesContainer {
            savingsPlansCoveragesDecoded0 = [CostExplorerClientTypes.SavingsPlansCoverage]()
            for structure0 in savingsPlansCoveragesContainer {
                if let structure0 = structure0 {
                    savingsPlansCoveragesDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansCoverages = savingsPlansCoveragesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSavingsPlansCoverageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSavingsPlansPurchaseRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansType = self.savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = self.termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

extension GetSavingsPlansPurchaseRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansPurchaseRecommendationInput: Swift.Equatable {
    /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
    public var accountScope: CostExplorerClientTypes.AccountScope?
    /// You can filter your recommendations by Account ID with the LINKED_ACCOUNT dimension. To filter your recommendations by Account ID, specify Key as LINKED_ACCOUNT and Value as the comma-separated Acount ID(s) that you want to see Savings Plans purchase recommendations for. For GetSavingsPlansPurchaseRecommendation, the Filter doesn't include CostCategories or Tags. It only includes Dimensions. With Dimensions, Key must be LINKED_ACCOUNT and Value can be a single Account ID or multiple comma-separated Account IDs that you want to see Savings Plans Purchase Recommendations for. AND and OR operators are not supported.
    public var filter: CostExplorerClientTypes.Expression?
    /// The lookback period that's used to generate the recommendation.
    /// This member is required.
    public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The payment option that's used to generate these recommendations.
    /// This member is required.
    public var paymentOption: CostExplorerClientTypes.PaymentOption?
    /// The Savings Plans recommendation type that's requested.
    /// This member is required.
    public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
    /// The savings plan recommendation term that's used to generate these recommendations.
    /// This member is required.
    public var termInYears: CostExplorerClientTypes.TermInYears?

    public init(
        accountScope: CostExplorerClientTypes.AccountScope? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
        savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
        termInYears: CostExplorerClientTypes.TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.savingsPlansType = savingsPlansType
        self.termInYears = termInYears
    }
}

struct GetSavingsPlansPurchaseRecommendationInputBody: Swift.Equatable {
    let savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
    let termInYears: CostExplorerClientTypes.TermInYears?
    let paymentOption: CostExplorerClientTypes.PaymentOption?
    let accountScope: CostExplorerClientTypes.AccountScope?
    let nextPageToken: Swift.String?
    let pageSize: Swift.Int?
    let lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
    let filter: CostExplorerClientTypes.Expression?
}

extension GetSavingsPlansPurchaseRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetSavingsPlansPurchaseRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSavingsPlansPurchaseRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.savingsPlansPurchaseRecommendation = output.savingsPlansPurchaseRecommendation
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.savingsPlansPurchaseRecommendation = nil
        }
    }
}

public struct GetSavingsPlansPurchaseRecommendationOutput: Swift.Equatable {
    /// Information that regards this specific recommendation set.
    public var metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata?
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public var savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation?

    public init(
        metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata? = nil,
        nextPageToken: Swift.String? = nil,
        savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendation
    }
}

struct GetSavingsPlansPurchaseRecommendationOutputBody: Swift.Equatable {
    let metadata: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata?
    let savingsPlansPurchaseRecommendation: CostExplorerClientTypes.SavingsPlansPurchaseRecommendation?
    let nextPageToken: Swift.String?
}

extension GetSavingsPlansPurchaseRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case savingsPlansPurchaseRecommendation = "SavingsPlansPurchaseRecommendation"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let savingsPlansPurchaseRecommendationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendation.self, forKey: .savingsPlansPurchaseRecommendation)
        savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendationDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum GetSavingsPlansPurchaseRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSavingsPlansUtilizationDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            var dataTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataType)
            for savingsplansdatatype0 in dataType {
                try dataTypeContainer.encode(savingsplansdatatype0.rawValue)
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansUtilizationDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansUtilizationDetailsInput: Swift.Equatable {
    /// The data type.
    public var dataType: [CostExplorerClientTypes.SavingsPlansDataType]?
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilizationDetails uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The number of items to be returned in a response. The default is 20, with a minimum value of 1.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    /// * AmortizedRecurringCommitment
    ///
    /// * AmortizedUpfrontCommitment
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        dataType: [CostExplorerClientTypes.SavingsPlansDataType]? = nil,
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.dataType = dataType
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationDetailsInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let filter: CostExplorerClientTypes.Expression?
    let dataType: [CostExplorerClientTypes.SavingsPlansDataType]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansUtilizationDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let dataTypeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansDataType?].self, forKey: .dataType)
        var dataTypeDecoded0:[CostExplorerClientTypes.SavingsPlansDataType]? = nil
        if let dataTypeContainer = dataTypeContainer {
            dataTypeDecoded0 = [CostExplorerClientTypes.SavingsPlansDataType]()
            for enum0 in dataTypeContainer {
                if let enum0 = enum0 {
                    dataTypeDecoded0?.append(enum0)
                }
            }
        }
        dataType = dataTypeDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSavingsPlansUtilizationDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlansUtilizationDetails = output.savingsPlansUtilizationDetails
            self.timePeriod = output.timePeriod
            self.total = output.total
        } else {
            self.nextToken = nil
            self.savingsPlansUtilizationDetails = nil
            self.timePeriod = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationDetailsOutput: Swift.Equatable {
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// Retrieves a single daily or monthly Savings Plans utilization rate and details for your account.
    /// This member is required.
    public var savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]?
    /// The time period of the request.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?
    /// The total Savings Plans utilization, regardless of time period.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init(
        nextToken: Swift.String? = nil,
        savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansUtilizationDetails = savingsPlansUtilizationDetails
        self.timePeriod = timePeriod
        self.total = total
    }
}

struct GetSavingsPlansUtilizationDetailsOutputBody: Swift.Equatable {
    let savingsPlansUtilizationDetails: [CostExplorerClientTypes.SavingsPlansUtilizationDetail]?
    let total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let nextToken: Swift.String?
}

extension GetSavingsPlansUtilizationDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case savingsPlansUtilizationDetails = "SavingsPlansUtilizationDetails"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansUtilizationDetail?].self, forKey: .savingsPlansUtilizationDetails)
        var savingsPlansUtilizationDetailsDecoded0:[CostExplorerClientTypes.SavingsPlansUtilizationDetail]? = nil
        if let savingsPlansUtilizationDetailsContainer = savingsPlansUtilizationDetailsContainer {
            savingsPlansUtilizationDetailsDecoded0 = [CostExplorerClientTypes.SavingsPlansUtilizationDetail]()
            for structure0 in savingsPlansUtilizationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationDetails = savingsPlansUtilizationDetailsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetSavingsPlansUtilizationDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSavingsPlansUtilizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetSavingsPlansUtilizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSavingsPlansUtilizationInput: Swift.Equatable {
    /// Filters Savings Plans utilization coverage data for active Savings Plans dimensions. You can filter data with the following dimensions:
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * SAVINGS_PLAN_ARN
    ///
    /// * SAVINGS_PLANS_TYPE
    ///
    /// * REGION
    ///
    /// * PAYMENT_OPTION
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    ///
    /// GetSavingsPlansUtilization uses the same [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object as the other operations, but only AND is supported among each dimension.
    public var filter: CostExplorerClientTypes.Expression?
    /// The granularity of the Amazon Web Services utillization data for your Savings Plans. The GetSavingsPlansUtilization operation supports only DAILY and MONTHLY granularities.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// The value that you want to sort the data by. The following values are supported for Key:
    ///
    /// * UtilizationPercentage
    ///
    /// * TotalCommitment
    ///
    /// * UsedCommitment
    ///
    /// * UnusedCommitment
    ///
    /// * NetSavings
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING.
    public var sortBy: CostExplorerClientTypes.SortDefinition?
    /// The time period that you want the usage and costs for. The Start date must be within 13 months. The End date must be after the Start date, and before the current date. Future dates can't be used as an End date.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        sortBy: CostExplorerClientTypes.SortDefinition? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: CostExplorerClientTypes.SortDefinition?
}

extension GetSavingsPlansUtilizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSavingsPlansUtilizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.savingsPlansUtilizationsByTime = output.savingsPlansUtilizationsByTime
            self.total = output.total
        } else {
            self.savingsPlansUtilizationsByTime = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationOutput: Swift.Equatable {
    /// The amount of cost/commitment that you used your Savings Plans. You can use it to specify date ranges.
    public var savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]?
    /// The total amount of cost/commitment that you used your Savings Plans, regardless of date ranges.
    /// This member is required.
    public var total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?

    public init(
        savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]? = nil,
        total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTime
        self.total = total
    }
}

struct GetSavingsPlansUtilizationOutputBody: Swift.Equatable {
    let savingsPlansUtilizationsByTime: [CostExplorerClientTypes.SavingsPlansUtilizationByTime]?
    let total: CostExplorerClientTypes.SavingsPlansUtilizationAggregates?
}

extension GetSavingsPlansUtilizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case savingsPlansUtilizationsByTime = "SavingsPlansUtilizationsByTime"
        case total = "Total"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansUtilizationByTime?].self, forKey: .savingsPlansUtilizationsByTime)
        var savingsPlansUtilizationsByTimeDecoded0:[CostExplorerClientTypes.SavingsPlansUtilizationByTime]? = nil
        if let savingsPlansUtilizationsByTimeContainer = savingsPlansUtilizationsByTimeContainer {
            savingsPlansUtilizationsByTimeDecoded0 = [CostExplorerClientTypes.SavingsPlansUtilizationByTime]()
            for structure0 in savingsPlansUtilizationsByTimeContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

enum GetSavingsPlansUtilizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = self.searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinition0 in sortBy {
                try sortByContainer.encode(sortdefinition0)
            }
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTagsInput: Swift.Equatable {
    /// Use Expression to filter in various Cost Explorer APIs. Not all Expression types are supported in each API. Refer to the documentation for each specific API to see what is supported. There are two patterns:
    ///
    /// * Simple dimension values.
    ///
    /// * There are three types of simple dimension values: CostCategories, Tags, and Dimensions.
    ///
    /// * Specify the CostCategories field to define a filter that acts on Cost Categories.
    ///
    /// * Specify the Tags field to define a filter that acts on Cost Allocation Tags.
    ///
    /// * Specify the Dimensions field to define a filter that acts on the [DimensionValues](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_DimensionValues.html).
    ///
    ///
    ///
    ///
    /// * For each filter type, you can set the dimension name and values for the filters that you plan to use.
    ///
    /// * For example, you can filter for REGION==us-east-1 OR REGION==us-west-1. For GetRightsizingRecommendation, the Region is a full name (for example, REGION==US East (N. Virginia).
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] } }
    ///
    /// * As shown in the previous example, lists of dimension values are combined with OR when applying the filter.
    ///
    ///
    ///
    ///
    /// * You can also set different match options to further control how the filter behaves. Not all APIs support match options. Refer to the documentation for each specific API to see what is supported.
    ///
    /// * For example, you can filter for linked account names that start with "a".
    ///
    /// * The corresponding Expression for this example is as follows: { "Dimensions": { "Key": "LINKED_ACCOUNT_NAME", "MatchOptions": [ "STARTS_WITH" ], "Values": [ "a" ] } }
    ///
    ///
    ///
    ///
    ///
    ///
    ///
    /// * Compound Expression types with logical operations.
    ///
    /// * You can use multiple Expression types and the logical operators AND/OR/NOT to create a list of one or more Expression objects. By doing this, you can filter by more advanced options.
    ///
    /// * For example, you can filter by ((REGION == us-east-1 OR REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE != DataTransfer).
    ///
    /// * The corresponding Expression for this example is as follows: { "And": [ {"Or": [ {"Dimensions": { "Key": "REGION", "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName", "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE", "Values": ["DataTransfer"] }}} ] }
    ///
    ///
    /// Because each Expression can have only one operator, the service returns an error if more than one is specified. The following example shows an Expression object that creates an error:  { "And": [ ... ], "Dimensions": { "Key": "USAGE_TYPE", "Values": [ "DataTransfer" ] } }  The following is an example of the corresponding error message: "Expression has more than one roots. Only one root operator is allowed for each expression: And, Or, Not, Dimensions, Tags, CostCategories"
    ///
    ///
    /// For the GetRightsizingRecommendation action, a combination of OR and NOT isn't supported. OR isn't supported between different dimensions, or dimensions and tags. NOT operators aren't supported. Dimensions are also limited to LINKED_ACCOUNT, REGION, or RIGHTSIZING_TYPE. For the GetReservationPurchaseRecommendation action, only NOT is supported. AND and OR aren't supported. Dimensions are limited to LINKED_ACCOUNT.
    public var filter: CostExplorerClientTypes.Expression?
    /// This field is only used when SortBy is provided in the request. The maximum number of objects that are returned for this request. If MaxResults isn't specified with SortBy, the request returns 1000 results as the default value for this parameter. For GetTags, MaxResults has an upper quota of 1000.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The value that you want to search for.
    public var searchString: Swift.String?
    /// The value that you want to sort the data by. The key represents cost and usage metrics. The following values are supported:
    ///
    /// * BlendedCost
    ///
    /// * UnblendedCost
    ///
    /// * AmortizedCost
    ///
    /// * NetAmortizedCost
    ///
    /// * NetUnblendedCost
    ///
    /// * UsageQuantity
    ///
    /// * NormalizedUsageAmount
    ///
    ///
    /// The supported values for SortOrder are ASCENDING and DESCENDING. When you use SortBy, NextPageToken and SearchString aren't supported.
    public var sortBy: [CostExplorerClientTypes.SortDefinition]?
    /// The key of the tag that you want to return values for.
    public var tagKey: Swift.String?
    /// The start and end dates for retrieving the dimension values. The start date is inclusive, but the end date is exclusive. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        maxResults: Swift.Int? = nil,
        nextPageToken: Swift.String? = nil,
        searchString: Swift.String? = nil,
        sortBy: [CostExplorerClientTypes.SortDefinition]? = nil,
        tagKey: Swift.String? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.tagKey = tagKey
        self.timePeriod = timePeriod
    }
}

struct GetTagsInputBody: Swift.Equatable {
    let searchString: Swift.String?
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let tagKey: Swift.String?
    let filter: CostExplorerClientTypes.Expression?
    let sortBy: [CostExplorerClientTypes.SortDefinition]?
    let maxResults: Swift.Int?
    let nextPageToken: Swift.String?
}

extension GetTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[CostExplorerClientTypes.SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [CostExplorerClientTypes.SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.tags = output.tags
            self.totalSize = output.totalSize
        } else {
            self.nextPageToken = nil
            self.returnSize = nil
            self.tags = nil
            self.totalSize = nil
        }
    }
}

public struct GetTagsOutput: Swift.Equatable {
    /// The token for the next set of retrievable results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextPageToken: Swift.String?
    /// The number of query results that Amazon Web Services returns at a time.
    /// This member is required.
    public var returnSize: Swift.Int?
    /// The tags that match your request.
    /// This member is required.
    public var tags: [Swift.String]?
    /// The total number of query results.
    /// This member is required.
    public var totalSize: Swift.Int?

    public init(
        nextPageToken: Swift.String? = nil,
        returnSize: Swift.Int? = nil,
        tags: [Swift.String]? = nil,
        totalSize: Swift.Int? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.tags = tags
        self.totalSize = totalSize
    }
}

struct GetTagsOutputBody: Swift.Equatable {
    let nextPageToken: Swift.String?
    let tags: [Swift.String]?
    let returnSize: Swift.Int?
    let totalSize: Swift.Int?
}

extension GetTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case tags = "Tags"
        case totalSize = "TotalSize"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tags)
        var tagsDecoded0:[Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

enum GetTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BillExpirationException": return try await BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestChangedException": return try await RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageForecastInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = self.granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = self.predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension GetUsageForecastInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetUsageForecastInput: Swift.Equatable {
    /// The filters that you want to use to filter your forecast. The GetUsageForecast API supports filtering by the following dimensions:
    ///
    /// * AZ
    ///
    /// * INSTANCE_TYPE
    ///
    /// * LINKED_ACCOUNT
    ///
    /// * LINKED_ACCOUNT_NAME
    ///
    /// * OPERATION
    ///
    /// * PURCHASE_TYPE
    ///
    /// * REGION
    ///
    /// * SERVICE
    ///
    /// * USAGE_TYPE
    ///
    /// * USAGE_TYPE_GROUP
    ///
    /// * RECORD_TYPE
    ///
    /// * OPERATING_SYSTEM
    ///
    /// * TENANCY
    ///
    /// * SCOPE
    ///
    /// * PLATFORM
    ///
    /// * SUBSCRIPTION_ID
    ///
    /// * LEGAL_ENTITY_NAME
    ///
    /// * DEPLOYMENT_OPTION
    ///
    /// * DATABASE_ENGINE
    ///
    /// * INSTANCE_TYPE_FAMILY
    ///
    /// * BILLING_ENTITY
    ///
    /// * RESERVATION_ID
    ///
    /// * SAVINGS_PLAN_ARN
    public var filter: CostExplorerClientTypes.Expression?
    /// How granular you want the forecast to be. You can get 3 months of DAILY forecasts or 12 months of MONTHLY forecasts. The GetUsageForecast operation supports only DAILY and MONTHLY granularities.
    /// This member is required.
    public var granularity: CostExplorerClientTypes.Granularity?
    /// Which metric Cost Explorer uses to create your forecast. Valid values for a GetUsageForecast call are the following:
    ///
    /// * USAGE_QUANTITY
    ///
    /// * NORMALIZED_USAGE_AMOUNT
    /// This member is required.
    public var metric: CostExplorerClientTypes.Metric?
    /// Amazon Web Services Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value falling in the prediction interval. Higher confidence levels result in wider prediction intervals.
    public var predictionIntervalLevel: Swift.Int?
    /// The start and end dates of the period that you want to retrieve usage forecast for. The start date is included in the period, but the end date isn't included in the period. For example, if start is 2017-01-01 and end is 2017-05-01, then the cost and usage data is retrieved from 2017-01-01 up to and including 2017-04-30 but not including 2017-05-01. The start date must be equal to or later than the current date to avoid a validation error.
    /// This member is required.
    public var timePeriod: CostExplorerClientTypes.DateInterval?

    public init(
        filter: CostExplorerClientTypes.Expression? = nil,
        granularity: CostExplorerClientTypes.Granularity? = nil,
        metric: CostExplorerClientTypes.Metric? = nil,
        predictionIntervalLevel: Swift.Int? = nil,
        timePeriod: CostExplorerClientTypes.DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetUsageForecastInputBody: Swift.Equatable {
    let timePeriod: CostExplorerClientTypes.DateInterval?
    let metric: CostExplorerClientTypes.Metric?
    let granularity: CostExplorerClientTypes.Granularity?
    let filter: CostExplorerClientTypes.Expression?
    let predictionIntervalLevel: Swift.Int?
}

extension GetUsageForecastInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetUsageForecastOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageForecastOutputBody = try responseDecoder.decode(responseBody: data)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetUsageForecastOutput: Swift.Equatable {
    /// The forecasts for your query, in order. For DAILY forecasts, this is a list of days. For MONTHLY forecasts, this is a list of months.
    public var forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
    /// How much you're forecasted to use over the forecast period.
    public var total: CostExplorerClientTypes.MetricValue?

    public init(
        forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]? = nil,
        total: CostExplorerClientTypes.MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetUsageForecastOutputBody: Swift.Equatable {
    let total: CostExplorerClientTypes.MetricValue?
    let forecastResultsByTime: [CostExplorerClientTypes.ForecastResult]?
}

extension GetUsageForecastOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[CostExplorerClientTypes.ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [CostExplorerClientTypes.ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

enum GetUsageForecastOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnresolvableUsageUnitException": return try await UnresolvableUsageUnitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes {
    public enum Granularity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [Granularity] {
            return [
                .daily,
                .hourly,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Granularity(rawValue: rawValue) ?? Granularity.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keys = "Keys"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for key0 in keys {
                try keysContainer.encode(key0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metrics)
            for (dictKey0, metrics0) in metrics {
                try metricsContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .keys)
        var keysDecoded0:[Swift.String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [Swift.String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let metricsContainer = try containerValues.decodeIfPresent([Swift.String: CostExplorerClientTypes.MetricValue?].self, forKey: .metrics)
        var metricsDecoded0: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [Swift.String:CostExplorerClientTypes.MetricValue]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// One level of grouped data in the results.
    public struct Group: Swift.Equatable {
        /// The keys that are included in this group.
        public var keys: [Swift.String]?
        /// The metrics that are included in this group.
        public var metrics: [Swift.String:CostExplorerClientTypes.MetricValue]?

        public init(
            keys: [Swift.String]? = nil,
            metrics: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.keys = keys
            self.metrics = metrics
        }
    }

}

extension CostExplorerClientTypes.GroupDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.GroupDefinitionType.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension CostExplorerClientTypes {
    /// Represents a group when you specify a group by criteria or in the response to a query with a specific grouping.
    public struct GroupDefinition: Swift.Equatable {
        /// The string that represents a key for a specified group.
        public var key: Swift.String?
        /// The string that represents the type of group.
        public var type: CostExplorerClientTypes.GroupDefinitionType?

        public init(
            key: Swift.String? = nil,
            type: CostExplorerClientTypes.GroupDefinitionType? = nil
        )
        {
            self.key = key
            self.type = type
        }
    }

}

extension CostExplorerClientTypes {
    public enum GroupDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costCategory
        case dimension
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupDefinitionType] {
            return [
                .costCategory,
                .dimension,
                .tag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costCategory: return "COST_CATEGORY"
            case .dimension: return "DIMENSION"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupDefinitionType(rawValue: rawValue) ?? GroupDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.Impact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxImpact = "MaxImpact"
        case totalActualSpend = "TotalActualSpend"
        case totalExpectedSpend = "TotalExpectedSpend"
        case totalImpact = "TotalImpact"
        case totalImpactPercentage = "TotalImpactPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxImpact != 0.0 {
            try encodeContainer.encode(maxImpact, forKey: .maxImpact)
        }
        if let totalActualSpend = self.totalActualSpend {
            try encodeContainer.encode(totalActualSpend, forKey: .totalActualSpend)
        }
        if let totalExpectedSpend = self.totalExpectedSpend {
            try encodeContainer.encode(totalExpectedSpend, forKey: .totalExpectedSpend)
        }
        if totalImpact != 0.0 {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
        if let totalImpactPercentage = self.totalImpactPercentage {
            try encodeContainer.encode(totalImpactPercentage, forKey: .totalImpactPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxImpactDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maxImpact) ?? 0.0
        maxImpact = maxImpactDecoded
        let totalImpactDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalImpact) ?? 0.0
        totalImpact = totalImpactDecoded
        let totalActualSpendDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalActualSpend)
        totalActualSpend = totalActualSpendDecoded
        let totalExpectedSpendDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalExpectedSpend)
        totalExpectedSpend = totalExpectedSpendDecoded
        let totalImpactPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .totalImpactPercentage)
        totalImpactPercentage = totalImpactPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The dollar value of the anomaly.
    public struct Impact: Swift.Equatable {
        /// The maximum dollar value that's observed for an anomaly.
        /// This member is required.
        public var maxImpact: Swift.Double
        /// The cumulative dollar amount that was actually spent during the anomaly.
        public var totalActualSpend: Swift.Double?
        /// The cumulative dollar amount that was expected to be spent during the anomaly. It is calculated using advanced machine learning models to determine the typical spending pattern based on historical data for a customer.
        public var totalExpectedSpend: Swift.Double?
        /// The cumulative dollar difference between the total actual spend and total expected spend. It is calculated as TotalActualSpend - TotalExpectedSpend.
        public var totalImpact: Swift.Double
        /// The cumulative percentage difference between the total actual spend and total expected spend. It is calculated as (TotalImpact / TotalExpectedSpend) * 100. When TotalExpectedSpend is zero, this field is omitted. Expected spend can be zero in situations such as when you start to use a service for the first time.
        public var totalImpactPercentage: Swift.Double?

        public init(
            maxImpact: Swift.Double = 0.0,
            totalActualSpend: Swift.Double? = nil,
            totalExpectedSpend: Swift.Double? = nil,
            totalImpact: Swift.Double = 0.0,
            totalImpactPercentage: Swift.Double? = nil
        )
        {
            self.maxImpact = maxImpact
            self.totalActualSpend = totalActualSpend
            self.totalExpectedSpend = totalExpectedSpend
            self.totalImpact = totalImpact
            self.totalImpactPercentage = totalImpactPercentage
        }
    }

}

extension CostExplorerClientTypes.InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceDetails = "EC2InstanceDetails"
        case esInstanceDetails = "ESInstanceDetails"
        case elastiCacheInstanceDetails = "ElastiCacheInstanceDetails"
        case rdsInstanceDetails = "RDSInstanceDetails"
        case redshiftInstanceDetails = "RedshiftInstanceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceDetails = self.ec2InstanceDetails {
            try encodeContainer.encode(ec2InstanceDetails, forKey: .ec2InstanceDetails)
        }
        if let esInstanceDetails = self.esInstanceDetails {
            try encodeContainer.encode(esInstanceDetails, forKey: .esInstanceDetails)
        }
        if let elastiCacheInstanceDetails = self.elastiCacheInstanceDetails {
            try encodeContainer.encode(elastiCacheInstanceDetails, forKey: .elastiCacheInstanceDetails)
        }
        if let rdsInstanceDetails = self.rdsInstanceDetails {
            try encodeContainer.encode(rdsInstanceDetails, forKey: .rdsInstanceDetails)
        }
        if let redshiftInstanceDetails = self.redshiftInstanceDetails {
            try encodeContainer.encode(redshiftInstanceDetails, forKey: .redshiftInstanceDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2InstanceDetails.self, forKey: .ec2InstanceDetails)
        ec2InstanceDetails = ec2InstanceDetailsDecoded
        let rdsInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RDSInstanceDetails.self, forKey: .rdsInstanceDetails)
        rdsInstanceDetails = rdsInstanceDetailsDecoded
        let redshiftInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RedshiftInstanceDetails.self, forKey: .redshiftInstanceDetails)
        redshiftInstanceDetails = redshiftInstanceDetailsDecoded
        let elastiCacheInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ElastiCacheInstanceDetails.self, forKey: .elastiCacheInstanceDetails)
        elastiCacheInstanceDetails = elastiCacheInstanceDetailsDecoded
        let esInstanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ESInstanceDetails.self, forKey: .esInstanceDetails)
        esInstanceDetails = esInstanceDetailsDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the instances that Amazon Web Services recommends that you purchase.
    public struct InstanceDetails: Swift.Equatable {
        /// The Amazon EC2 instances that Amazon Web Services recommends that you purchase.
        public var ec2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails?
        /// The ElastiCache instances that Amazon Web Services recommends that you purchase.
        public var elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails?
        /// The Amazon OpenSearch Service instances that Amazon Web Services recommends that you purchase.
        public var esInstanceDetails: CostExplorerClientTypes.ESInstanceDetails?
        /// The Amazon RDS instances that Amazon Web Services recommends that you purchase.
        public var rdsInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails?
        /// The Amazon Redshift instances that Amazon Web Services recommends that you purchase.
        public var redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails?

        public init(
            ec2InstanceDetails: CostExplorerClientTypes.EC2InstanceDetails? = nil,
            elastiCacheInstanceDetails: CostExplorerClientTypes.ElastiCacheInstanceDetails? = nil,
            esInstanceDetails: CostExplorerClientTypes.ESInstanceDetails? = nil,
            rdsInstanceDetails: CostExplorerClientTypes.RDSInstanceDetails? = nil,
            redshiftInstanceDetails: CostExplorerClientTypes.RedshiftInstanceDetails? = nil
        )
        {
            self.ec2InstanceDetails = ec2InstanceDetails
            self.elastiCacheInstanceDetails = elastiCacheInstanceDetails
            self.esInstanceDetails = esInstanceDetails
            self.rdsInstanceDetails = rdsInstanceDetails
            self.redshiftInstanceDetails = redshiftInstanceDetails
        }
    }

}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination token is invalid. Try again without a pagination token.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You made too many calls in a short period of time. Try again later.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCostAllocationTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
        case tagKeys = "TagKeys"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListCostAllocationTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCostAllocationTagsInput: Swift.Equatable {
    /// The maximum number of objects that are returned for this request. By default, the request returns 100 results.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?
    /// The status of cost allocation tag keys that are returned for this request.
    public var status: CostExplorerClientTypes.CostAllocationTagStatus?
    /// The list of cost allocation tag keys that are returned for this request.
    public var tagKeys: [Swift.String]?
    /// The type of CostAllocationTag object that are returned for this request. The AWSGenerated type tags are tags that Amazon Web Services defines and applies to support Amazon Web Services resources for cost allocation purposes. The UserDefined type tags are tags that you define, create, and apply to resources.
    public var type: CostExplorerClientTypes.CostAllocationTagType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: CostExplorerClientTypes.CostAllocationTagStatus? = nil,
        tagKeys: [Swift.String]? = nil,
        type: CostExplorerClientTypes.CostAllocationTagType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
        self.tagKeys = tagKeys
        self.type = type
    }
}

struct ListCostAllocationTagsInputBody: Swift.Equatable {
    let status: CostExplorerClientTypes.CostAllocationTagStatus?
    let tagKeys: [Swift.String]?
    let type: CostExplorerClientTypes.CostAllocationTagType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCostAllocationTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case status = "Status"
        case tagKeys = "TagKeys"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostAllocationTagStatus.self, forKey: .status)
        status = statusDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostAllocationTagType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCostAllocationTagsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCostAllocationTagsOutputBody = try responseDecoder.decode(responseBody: data)
            self.costAllocationTags = output.costAllocationTags
            self.nextToken = output.nextToken
        } else {
            self.costAllocationTags = nil
            self.nextToken = nil
        }
    }
}

public struct ListCostAllocationTagsOutput: Swift.Equatable {
    /// A list of cost allocation tags that includes the detailed metadata for each one.
    public var costAllocationTags: [CostExplorerClientTypes.CostAllocationTag]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        costAllocationTags: [CostExplorerClientTypes.CostAllocationTag]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.costAllocationTags = costAllocationTags
        self.nextToken = nextToken
    }
}

struct ListCostAllocationTagsOutputBody: Swift.Equatable {
    let costAllocationTags: [CostExplorerClientTypes.CostAllocationTag]?
    let nextToken: Swift.String?
}

extension ListCostAllocationTagsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costAllocationTags = "CostAllocationTags"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costAllocationTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostAllocationTag?].self, forKey: .costAllocationTags)
        var costAllocationTagsDecoded0:[CostExplorerClientTypes.CostAllocationTag]? = nil
        if let costAllocationTagsContainer = costAllocationTagsContainer {
            costAllocationTagsDecoded0 = [CostExplorerClientTypes.CostAllocationTag]()
            for structure0 in costAllocationTagsContainer {
                if let structure0 = structure0 {
                    costAllocationTagsDecoded0?.append(structure0)
                }
            }
        }
        costAllocationTags = costAllocationTagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCostAllocationTagsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCostCategoryDefinitionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = self.effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListCostCategoryDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCostCategoryDefinitionsInput: Swift.Equatable {
    /// The date when the Cost Category was effective.
    public var effectiveOn: Swift.String?
    /// The number of entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        effectiveOn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.effectiveOn = effectiveOn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsInputBody: Swift.Equatable {
    let effectiveOn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListCostCategoryDefinitionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveOnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCostCategoryDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCostCategoryDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryReferences = output.costCategoryReferences
            self.nextToken = output.nextToken
        } else {
            self.costCategoryReferences = nil
            self.nextToken = nil
        }
    }
}

public struct ListCostCategoryDefinitionsOutput: Swift.Equatable {
    /// A reference to a Cost Category that contains enough information to identify the Cost Category.
    public var costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]?
    /// The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    public var nextToken: Swift.String?

    public init(
        costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.costCategoryReferences = costCategoryReferences
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsOutputBody: Swift.Equatable {
    let costCategoryReferences: [CostExplorerClientTypes.CostCategoryReference]?
    let nextToken: Swift.String?
}

extension ListCostCategoryDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryReferences = "CostCategoryReferences"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryReferencesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryReference?].self, forKey: .costCategoryReferences)
        var costCategoryReferencesDecoded0:[CostExplorerClientTypes.CostCategoryReference]? = nil
        if let costCategoryReferencesContainer = costCategoryReferencesContainer {
            costCategoryReferencesDecoded0 = [CostExplorerClientTypes.CostCategoryReference]()
            for structure0 in costCategoryReferencesContainer {
                if let structure0 = structure0 {
                    costCategoryReferencesDecoded0?.append(structure0)
                }
            }
        }
        costCategoryReferences = costCategoryReferencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCostCategoryDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationStatus = "GenerationStatus"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case recommendationIds = "RecommendationIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationStatus = self.generationStatus {
            try encodeContainer.encode(generationStatus.rawValue, forKey: .generationStatus)
        }
        if let nextPageToken = self.nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let pageSize = self.pageSize {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for recommendationid0 in recommendationIds {
                try recommendationIdsContainer.encode(recommendationid0)
            }
        }
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSavingsPlansPurchaseRecommendationGenerationInput: Swift.Equatable {
    /// The status of the recommendation generation.
    public var generationStatus: CostExplorerClientTypes.GenerationStatus?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?
    /// The number of recommendations that you want returned in a single response object.
    public var pageSize: Swift.Int?
    /// The IDs for each specific recommendation.
    public var recommendationIds: [Swift.String]?

    public init(
        generationStatus: CostExplorerClientTypes.GenerationStatus? = nil,
        nextPageToken: Swift.String? = nil,
        pageSize: Swift.Int? = nil,
        recommendationIds: [Swift.String]? = nil
    )
    {
        self.generationStatus = generationStatus
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.recommendationIds = recommendationIds
    }
}

struct ListSavingsPlansPurchaseRecommendationGenerationInputBody: Swift.Equatable {
    let generationStatus: CostExplorerClientTypes.GenerationStatus?
    let recommendationIds: [Swift.String]?
    let pageSize: Swift.Int?
    let nextPageToken: Swift.String?
}

extension ListSavingsPlansPurchaseRecommendationGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationStatus = "GenerationStatus"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case recommendationIds = "RecommendationIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generationStatusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.GenerationStatus.self, forKey: .generationStatus)
        generationStatus = generationStatusDecoded
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
        let pageSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ListSavingsPlansPurchaseRecommendationGenerationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSavingsPlansPurchaseRecommendationGenerationOutputBody = try responseDecoder.decode(responseBody: data)
            self.generationSummaryList = output.generationSummaryList
            self.nextPageToken = output.nextPageToken
        } else {
            self.generationSummaryList = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListSavingsPlansPurchaseRecommendationGenerationOutput: Swift.Equatable {
    /// The list of historical recommendation generations.
    public var generationSummaryList: [CostExplorerClientTypes.GenerationSummary]?
    /// The token to retrieve the next set of results.
    public var nextPageToken: Swift.String?

    public init(
        generationSummaryList: [CostExplorerClientTypes.GenerationSummary]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.generationSummaryList = generationSummaryList
        self.nextPageToken = nextPageToken
    }
}

struct ListSavingsPlansPurchaseRecommendationGenerationOutputBody: Swift.Equatable {
    let generationSummaryList: [CostExplorerClientTypes.GenerationSummary]?
    let nextPageToken: Swift.String?
}

extension ListSavingsPlansPurchaseRecommendationGenerationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationSummaryList = "GenerationSummaryList"
        case nextPageToken = "NextPageToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generationSummaryListContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.GenerationSummary?].self, forKey: .generationSummaryList)
        var generationSummaryListDecoded0:[CostExplorerClientTypes.GenerationSummary]? = nil
        if let generationSummaryListContainer = generationSummaryListContainer {
            generationSummaryListDecoded0 = [CostExplorerClientTypes.GenerationSummary]()
            for structure0 in generationSummaryListContainer {
                if let structure0 = structure0 {
                    generationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        generationSummaryList = generationSummaryListDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

enum ListSavingsPlansPurchaseRecommendationGenerationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceTags = output.resourceTags
        } else {
            self.resourceTags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tag key value pairs that are associated with the resource.
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let resourceTags: [CostExplorerClientTypes.ResourceTag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[CostExplorerClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [CostExplorerClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes {
    public enum LookbackPeriodInDays: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sevenDays
        case sixtyDays
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [LookbackPeriodInDays] {
            return [
                .sevenDays,
                .sixtyDays,
                .thirtyDays,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sevenDays: return "SEVEN_DAYS"
            case .sixtyDays: return "SIXTY_DAYS"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LookbackPeriodInDays(rawValue: rawValue) ?? LookbackPeriodInDays.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum MatchOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absent
        case caseInsensitive
        case caseSensitive
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .absent,
                .caseInsensitive,
                .caseSensitive,
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .caseInsensitive: return "CASE_INSENSITIVE"
            case .caseSensitive: return "CASE_SENSITIVE"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MatchOption(rawValue: rawValue) ?? MatchOption.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum Metric: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amortizedCost
        case blendedCost
        case netAmortizedCost
        case netUnblendedCost
        case normalizedUsageAmount
        case unblendedCost
        case usageQuantity
        case sdkUnknown(Swift.String)

        public static var allCases: [Metric] {
            return [
                .amortizedCost,
                .blendedCost,
                .netAmortizedCost,
                .netUnblendedCost,
                .normalizedUsageAmount,
                .unblendedCost,
                .usageQuantity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amortizedCost: return "AMORTIZED_COST"
            case .blendedCost: return "BLENDED_COST"
            case .netAmortizedCost: return "NET_AMORTIZED_COST"
            case .netUnblendedCost: return "NET_UNBLENDED_COST"
            case .normalizedUsageAmount: return "NORMALIZED_USAGE_AMOUNT"
            case .unblendedCost: return "UNBLENDED_COST"
            case .usageQuantity: return "USAGE_QUANTITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Metric(rawValue: rawValue) ?? Metric.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.MetricValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated value for a metric.
    public struct MetricValue: Swift.Equatable {
        /// The actual number that represents the metric.
        public var amount: Swift.String?
        /// The unit that the metric is given in.
        public var unit: Swift.String?

        public init(
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension CostExplorerClientTypes.ModifyRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetInstances = "TargetInstances"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetInstances = targetInstances {
            var targetInstancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetInstances)
            for targetinstance0 in targetInstances {
                try targetInstancesContainer.encode(targetinstance0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetInstancesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.TargetInstance?].self, forKey: .targetInstances)
        var targetInstancesDecoded0:[CostExplorerClientTypes.TargetInstance]? = nil
        if let targetInstancesContainer = targetInstancesContainer {
            targetInstancesDecoded0 = [CostExplorerClientTypes.TargetInstance]()
            for structure0 in targetInstancesContainer {
                if let structure0 = structure0 {
                    targetInstancesDecoded0?.append(structure0)
                }
            }
        }
        targetInstances = targetInstancesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Details for the modification recommendation.
    public struct ModifyRecommendationDetail: Swift.Equatable {
        /// Determines whether this instance type is the Amazon Web Services default recommendation.
        public var targetInstances: [CostExplorerClientTypes.TargetInstance]?

        public init(
            targetInstances: [CostExplorerClientTypes.TargetInstance]? = nil
        )
        {
            self.targetInstances = targetInstances
        }
    }

}

extension CostExplorerClientTypes {
    public enum MonitorDimension: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorDimension] {
            return [
                .service,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorDimension(rawValue: rawValue) ?? MonitorDimension.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum MonitorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case dimensional
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorType] {
            return [
                .custom,
                .dimensional,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .dimensional: return "DIMENSIONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorType(rawValue: rawValue) ?? MonitorType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.NetworkResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkInBytesPerSecond = "NetworkInBytesPerSecond"
        case networkOutBytesPerSecond = "NetworkOutBytesPerSecond"
        case networkPacketsInPerSecond = "NetworkPacketsInPerSecond"
        case networkPacketsOutPerSecond = "NetworkPacketsOutPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInBytesPerSecond = self.networkInBytesPerSecond {
            try encodeContainer.encode(networkInBytesPerSecond, forKey: .networkInBytesPerSecond)
        }
        if let networkOutBytesPerSecond = self.networkOutBytesPerSecond {
            try encodeContainer.encode(networkOutBytesPerSecond, forKey: .networkOutBytesPerSecond)
        }
        if let networkPacketsInPerSecond = self.networkPacketsInPerSecond {
            try encodeContainer.encode(networkPacketsInPerSecond, forKey: .networkPacketsInPerSecond)
        }
        if let networkPacketsOutPerSecond = self.networkPacketsOutPerSecond {
            try encodeContainer.encode(networkPacketsOutPerSecond, forKey: .networkPacketsOutPerSecond)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInBytesPerSecond)
        networkInBytesPerSecond = networkInBytesPerSecondDecoded
        let networkOutBytesPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkOutBytesPerSecond)
        networkOutBytesPerSecond = networkOutBytesPerSecondDecoded
        let networkPacketsInPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPacketsInPerSecond)
        networkPacketsInPerSecond = networkPacketsInPerSecondDecoded
        let networkPacketsOutPerSecondDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkPacketsOutPerSecond)
        networkPacketsOutPerSecond = networkPacketsOutPerSecondDecoded
    }
}

extension CostExplorerClientTypes {
    /// The network field that contains a list of network metrics that are associated with the current instance.
    public struct NetworkResourceUtilization: Swift.Equatable {
        /// The network inbound throughput utilization measured in Bytes per second (Bps).
        public var networkInBytesPerSecond: Swift.String?
        /// The network outbound throughput utilization measured in Bytes per second (Bps).
        public var networkOutBytesPerSecond: Swift.String?
        /// The network inbound packets that are measured in packets per second.
        public var networkPacketsInPerSecond: Swift.String?
        /// The network outbound packets that are measured in packets per second.
        public var networkPacketsOutPerSecond: Swift.String?

        public init(
            networkInBytesPerSecond: Swift.String? = nil,
            networkOutBytesPerSecond: Swift.String? = nil,
            networkPacketsInPerSecond: Swift.String? = nil,
            networkPacketsOutPerSecond: Swift.String? = nil
        )
        {
            self.networkInBytesPerSecond = networkInBytesPerSecond
            self.networkOutBytesPerSecond = networkOutBytesPerSecond
            self.networkPacketsInPerSecond = networkPacketsInPerSecond
            self.networkPacketsOutPerSecond = networkPacketsOutPerSecond
        }
    }

}

extension CostExplorerClientTypes {
    public enum NumericOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case between
        case equal
        case greaterThan
        case greaterThanOrEqual
        case lessThan
        case lessThanOrEqual
        case sdkUnknown(Swift.String)

        public static var allCases: [NumericOperator] {
            return [
                .between,
                .equal,
                .greaterThan,
                .greaterThanOrEqual,
                .lessThan,
                .lessThanOrEqual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .between: return "BETWEEN"
            case .equal: return "EQUAL"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NumericOperator(rawValue: rawValue) ?? NumericOperator.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum OfferingClass: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case convertible
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingClass] {
            return [
                .convertible,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .convertible: return "CONVERTIBLE"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OfferingClass(rawValue: rawValue) ?? OfferingClass.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum PaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case heavyUtilization
        case lightUtilization
        case mediumUtilization
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentOption] {
            return [
                .allUpfront,
                .heavyUtilization,
                .lightUtilization,
                .mediumUtilization,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "ALL_UPFRONT"
            case .heavyUtilization: return "HEAVY_UTILIZATION"
            case .lightUtilization: return "LIGHT_UTILIZATION"
            case .mediumUtilization: return "MEDIUM_UTILIZATION"
            case .noUpfront: return "NO_UPFRONT"
            case .partialUpfront: return "PARTIAL_UPFRONT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PaymentOption(rawValue: rawValue) ?? PaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum PlatformDifference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hypervisor
        case instanceStoreAvailability
        case networkInterface
        case storageInterface
        case virtualizationType
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformDifference] {
            return [
                .hypervisor,
                .instanceStoreAvailability,
                .networkInterface,
                .storageInterface,
                .virtualizationType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hypervisor: return "HYPERVISOR"
            case .instanceStoreAvailability: return "INSTANCE_STORE_AVAILABILITY"
            case .networkInterface: return "NETWORK_INTERFACE"
            case .storageInterface: return "STORAGE_INTERFACE"
            case .virtualizationType: return "VIRTUALIZATION_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformDifference(rawValue: rawValue) ?? PlatformDifference.sdkUnknown(rawValue)
        }
    }
}

extension ProvideAnomalyFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyId = self.anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
    }
}

extension ProvideAnomalyFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvideAnomalyFeedbackInput: Swift.Equatable {
    /// A cost anomaly ID.
    /// This member is required.
    public var anomalyId: Swift.String?
    /// Describes whether the cost anomaly was a planned activity or you considered it an anomaly.
    /// This member is required.
    public var feedback: CostExplorerClientTypes.AnomalyFeedbackType?

    public init(
        anomalyId: Swift.String? = nil,
        feedback: CostExplorerClientTypes.AnomalyFeedbackType? = nil
    )
    {
        self.anomalyId = anomalyId
        self.feedback = feedback
    }
}

struct ProvideAnomalyFeedbackInputBody: Swift.Equatable {
    let anomalyId: Swift.String?
    let feedback: CostExplorerClientTypes.AnomalyFeedbackType?
}

extension ProvideAnomalyFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension ProvideAnomalyFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvideAnomalyFeedbackOutputBody = try responseDecoder.decode(responseBody: data)
            self.anomalyId = output.anomalyId
        } else {
            self.anomalyId = nil
        }
    }
}

public struct ProvideAnomalyFeedbackOutput: Swift.Equatable {
    /// The ID of the modified cost anomaly.
    /// This member is required.
    public var anomalyId: Swift.String?

    public init(
        anomalyId: Swift.String? = nil
    )
    {
        self.anomalyId = anomalyId
    }
}

struct ProvideAnomalyFeedbackOutputBody: Swift.Equatable {
    let anomalyId: Swift.String?
}

extension ProvideAnomalyFeedbackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case anomalyId = "AnomalyId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
    }
}

enum ProvideAnomalyFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.RDSInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case databaseEdition = "DatabaseEdition"
        case databaseEngine = "DatabaseEngine"
        case deploymentOption = "DeploymentOption"
        case family = "Family"
        case instanceType = "InstanceType"
        case licenseModel = "LicenseModel"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let databaseEdition = self.databaseEdition {
            try encodeContainer.encode(databaseEdition, forKey: .databaseEdition)
        }
        if let databaseEngine = self.databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let deploymentOption = self.deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
        let databaseEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEdition)
        databaseEdition = databaseEditionDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration) ?? false
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible) ?? false
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon RDS instances that Amazon Web Services recommends that you purchase.
    public struct RDSInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The database edition that the recommended reservation supports.
        public var databaseEdition: Swift.String?
        /// The database engine that the recommended reservation supports.
        public var databaseEngine: Swift.String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public var deploymentOption: Swift.String?
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The license model that the recommended reservation supports.
        public var licenseModel: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            databaseEdition: Swift.String? = nil,
            databaseEngine: Swift.String? = nil,
            deploymentOption: Swift.String? = nil,
            family: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.family = family
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension CostExplorerClientTypes.RecommendationDetailData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case currencyCode = "CurrencyCode"
        case currentAverageCoverage = "CurrentAverageCoverage"
        case currentAverageHourlyOnDemandSpend = "CurrentAverageHourlyOnDemandSpend"
        case currentMaximumHourlyOnDemandSpend = "CurrentMaximumHourlyOnDemandSpend"
        case currentMinimumHourlyOnDemandSpend = "CurrentMinimumHourlyOnDemandSpend"
        case estimatedAverageCoverage = "EstimatedAverageCoverage"
        case estimatedAverageUtilization = "EstimatedAverageUtilization"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCost = "EstimatedOnDemandCost"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSPCost = "EstimatedSPCost"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case existingHourlyCommitment = "ExistingHourlyCommitment"
        case generationTimestamp = "GenerationTimestamp"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case instanceFamily = "InstanceFamily"
        case latestUsageTimestamp = "LatestUsageTimestamp"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case metricsOverLookbackPeriod = "MetricsOverLookbackPeriod"
        case offeringId = "OfferingId"
        case paymentOption = "PaymentOption"
        case region = "Region"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentAverageCoverage = self.currentAverageCoverage {
            try encodeContainer.encode(currentAverageCoverage, forKey: .currentAverageCoverage)
        }
        if let currentAverageHourlyOnDemandSpend = self.currentAverageHourlyOnDemandSpend {
            try encodeContainer.encode(currentAverageHourlyOnDemandSpend, forKey: .currentAverageHourlyOnDemandSpend)
        }
        if let currentMaximumHourlyOnDemandSpend = self.currentMaximumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMaximumHourlyOnDemandSpend, forKey: .currentMaximumHourlyOnDemandSpend)
        }
        if let currentMinimumHourlyOnDemandSpend = self.currentMinimumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMinimumHourlyOnDemandSpend, forKey: .currentMinimumHourlyOnDemandSpend)
        }
        if let estimatedAverageCoverage = self.estimatedAverageCoverage {
            try encodeContainer.encode(estimatedAverageCoverage, forKey: .estimatedAverageCoverage)
        }
        if let estimatedAverageUtilization = self.estimatedAverageUtilization {
            try encodeContainer.encode(estimatedAverageUtilization, forKey: .estimatedAverageUtilization)
        }
        if let estimatedMonthlySavingsAmount = self.estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCost = self.estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = self.estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = self.estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSPCost = self.estimatedSPCost {
            try encodeContainer.encode(estimatedSPCost, forKey: .estimatedSPCost)
        }
        if let estimatedSavingsAmount = self.estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = self.estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let existingHourlyCommitment = self.existingHourlyCommitment {
            try encodeContainer.encode(existingHourlyCommitment, forKey: .existingHourlyCommitment)
        }
        if let generationTimestamp = self.generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let hourlyCommitmentToPurchase = self.hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let latestUsageTimestamp = self.latestUsageTimestamp {
            try encodeContainer.encode(latestUsageTimestamp, forKey: .latestUsageTimestamp)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let metricsOverLookbackPeriod = metricsOverLookbackPeriod {
            var metricsOverLookbackPeriodContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricsOverLookbackPeriod)
            for recommendationdetailhourlymetrics0 in metricsOverLookbackPeriod {
                try metricsOverLookbackPeriodContainer.encode(recommendationdetailhourlymetrics0)
            }
        }
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let savingsPlansType = self.savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = self.termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let latestUsageTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestUsageTimestamp)
        latestUsageTimestamp = latestUsageTimestampDecoded
        let currentAverageHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAverageHourlyOnDemandSpend)
        currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpendDecoded
        let currentMaximumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMaximumHourlyOnDemandSpend)
        currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpendDecoded
        let currentMinimumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMinimumHourlyOnDemandSpend)
        currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpendDecoded
        let estimatedAverageUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedAverageUtilization)
        estimatedAverageUtilization = estimatedAverageUtilizationDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
        let estimatedROIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let estimatedSPCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSPCost)
        estimatedSPCost = estimatedSPCostDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let existingHourlyCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingHourlyCommitment)
        existingHourlyCommitment = existingHourlyCommitmentDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let currentAverageCoverageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAverageCoverage)
        currentAverageCoverage = currentAverageCoverageDecoded
        let estimatedAverageCoverageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedAverageCoverage)
        estimatedAverageCoverage = estimatedAverageCoverageDecoded
        let metricsOverLookbackPeriodContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.RecommendationDetailHourlyMetrics?].self, forKey: .metricsOverLookbackPeriod)
        var metricsOverLookbackPeriodDecoded0:[CostExplorerClientTypes.RecommendationDetailHourlyMetrics]? = nil
        if let metricsOverLookbackPeriodContainer = metricsOverLookbackPeriodContainer {
            metricsOverLookbackPeriodDecoded0 = [CostExplorerClientTypes.RecommendationDetailHourlyMetrics]()
            for structure0 in metricsOverLookbackPeriodContainer {
                if let structure0 = structure0 {
                    metricsOverLookbackPeriodDecoded0?.append(structure0)
                }
            }
        }
        metricsOverLookbackPeriod = metricsOverLookbackPeriodDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The details and metrics for the given recommendation.
    public struct RecommendationDetailData: Swift.Equatable {
        /// The AccountID that the recommendation is generated for.
        public var accountId: Swift.String?
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// The currency code that Amazon Web Services used to generate the recommendation and present potential savings.
        public var currencyCode: Swift.String?
        /// The average value of hourly coverage over the lookback period.
        public var currentAverageCoverage: Swift.String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentAverageHourlyOnDemandSpend: Swift.String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMaximumHourlyOnDemandSpend: Swift.String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMinimumHourlyOnDemandSpend: Swift.String?
        /// The estimated coverage of the recommended Savings Plan.
        public var estimatedAverageCoverage: Swift.String?
        /// The estimated utilization of the recommended Savings Plan.
        public var estimatedAverageUtilization: Swift.String?
        /// The estimated monthly savings amount based on the recommended Savings Plan.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plan, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment, based on your usage of the selected time period and the Savings Plan you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plan that you purchased. This is calculated as estimatedSavingsAmount/estimatedSPCost*100.
        public var estimatedROI: Swift.String?
        /// The cost of the recommended Savings Plan over the length of the lookback period.
        public var estimatedSPCost: Swift.String?
        /// The estimated savings amount that's based on the recommended Savings Plan over the length of the lookback period.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public var estimatedSavingsPercentage: Swift.String?
        /// The existing hourly commitment for the Savings Plan type.
        public var existingHourlyCommitment: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var generationTimestamp: Swift.String?
        /// The recommended hourly commitment level for the Savings Plan type and the configuration that's based on the usage during the lookback period.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// The instance family of the recommended Savings Plan.
        public var instanceFamily: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var latestUsageTimestamp: Swift.String?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The related hourly cost, coverage, and utilization metrics over the lookback period.
        public var metricsOverLookbackPeriod: [CostExplorerClientTypes.RecommendationDetailHourlyMetrics]?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public var offeringId: Swift.String?
        /// The payment option for the commitment (for example, All Upfront or No Upfront).
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// The region the recommendation is generated for.
        public var region: Swift.String?
        /// The requested Savings Plan recommendation type.
        public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
        /// The term of the commitment in years.
        public var termInYears: CostExplorerClientTypes.TermInYears?
        /// The upfront cost of the recommended Savings Plan, based on the selected payment option.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            currencyCode: Swift.String? = nil,
            currentAverageCoverage: Swift.String? = nil,
            currentAverageHourlyOnDemandSpend: Swift.String? = nil,
            currentMaximumHourlyOnDemandSpend: Swift.String? = nil,
            currentMinimumHourlyOnDemandSpend: Swift.String? = nil,
            estimatedAverageCoverage: Swift.String? = nil,
            estimatedAverageUtilization: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSPCost: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            existingHourlyCommitment: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            latestUsageTimestamp: Swift.String? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            metricsOverLookbackPeriod: [CostExplorerClientTypes.RecommendationDetailHourlyMetrics]? = nil,
            offeringId: Swift.String? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            region: Swift.String? = nil,
            savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountScope = accountScope
            self.currencyCode = currencyCode
            self.currentAverageCoverage = currentAverageCoverage
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageCoverage = estimatedAverageCoverage
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSPCost = estimatedSPCost
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.existingHourlyCommitment = existingHourlyCommitment
            self.generationTimestamp = generationTimestamp
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.instanceFamily = instanceFamily
            self.latestUsageTimestamp = latestUsageTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.metricsOverLookbackPeriod = metricsOverLookbackPeriod
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.region = region
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostExplorerClientTypes.RecommendationDetailHourlyMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentCoverage = "CurrentCoverage"
        case estimatedCoverage = "EstimatedCoverage"
        case estimatedNewCommitmentUtilization = "EstimatedNewCommitmentUtilization"
        case estimatedOnDemandCost = "EstimatedOnDemandCost"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentCoverage = self.currentCoverage {
            try encodeContainer.encode(currentCoverage, forKey: .currentCoverage)
        }
        if let estimatedCoverage = self.estimatedCoverage {
            try encodeContainer.encode(estimatedCoverage, forKey: .estimatedCoverage)
        }
        if let estimatedNewCommitmentUtilization = self.estimatedNewCommitmentUtilization {
            try encodeContainer.encode(estimatedNewCommitmentUtilization, forKey: .estimatedNewCommitmentUtilization)
        }
        if let estimatedOnDemandCost = self.estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let currentCoverageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentCoverage)
        currentCoverage = currentCoverageDecoded
        let estimatedCoverageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedCoverage)
        estimatedCoverage = estimatedCoverageDecoded
        let estimatedNewCommitmentUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedNewCommitmentUtilization)
        estimatedNewCommitmentUtilization = estimatedNewCommitmentUtilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Contains the hourly metrics for the given recommendation over the lookback period.
    public struct RecommendationDetailHourlyMetrics: Swift.Equatable {
        /// The current amount of Savings Plans eligible usage that the Savings Plan covered.
        public var currentCoverage: Swift.String?
        /// The estimated coverage amount based on the recommended Savings Plan.
        public var estimatedCoverage: Swift.String?
        /// The estimated utilization for the recommended Savings Plan.
        public var estimatedNewCommitmentUtilization: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plan, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The period of time that you want the usage and costs for.
        public var startTime: Swift.String?

        public init(
            currentCoverage: Swift.String? = nil,
            estimatedCoverage: Swift.String? = nil,
            estimatedNewCommitmentUtilization: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.currentCoverage = currentCoverage
            self.estimatedCoverage = estimatedCoverage
            self.estimatedNewCommitmentUtilization = estimatedNewCommitmentUtilization
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.startTime = startTime
        }
    }

}

extension CostExplorerClientTypes {
    public enum RecommendationTarget: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case crossInstanceFamily
        case sameInstanceFamily
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationTarget] {
            return [
                .crossInstanceFamily,
                .sameInstanceFamily,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .crossInstanceFamily: return "CROSS_INSTANCE_FAMILY"
            case .sameInstanceFamily: return "SAME_INSTANCE_FAMILY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationTarget(rawValue: rawValue) ?? RecommendationTarget.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.RedshiftInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = self.family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = self.nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .currentGeneration) ?? false
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible) ?? false
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about the Amazon Redshift instances that Amazon Web Services recommends that you purchase.
    public struct RedshiftInstanceDetails: Swift.Equatable {
        /// Determines whether the recommendation is for a current-generation instance.
        public var currentGeneration: Swift.Bool
        /// The instance family of the recommended reservation.
        public var family: Swift.String?
        /// The type of node that Amazon Web Services recommends.
        public var nodeType: Swift.String?
        /// The Amazon Web Services Region of the recommended reservation.
        public var region: Swift.String?
        /// Determines whether the recommended reservation is size flexible.
        public var sizeFlexEligible: Swift.Bool

        public init(
            currentGeneration: Swift.Bool = false,
            family: Swift.String? = nil,
            nodeType: Swift.String? = nil,
            region: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool = false
        )
        {
            self.currentGeneration = currentGeneration
            self.family = family
            self.nodeType = nodeType
            self.region = region
            self.sizeFlexEligible = sizeFlexEligible
        }
    }

}

extension RequestChangedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestChangedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request parameters changed between pages. Try again with the old parameters or without a pagination token.
public struct RequestChangedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestChangedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestChangedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestChangedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.ReservationAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedRecurringFee = "AmortizedRecurringFee"
        case amortizedUpfrontFee = "AmortizedUpfrontFee"
        case netRISavings = "NetRISavings"
        case onDemandCostOfRIHoursUsed = "OnDemandCostOfRIHoursUsed"
        case purchasedHours = "PurchasedHours"
        case purchasedUnits = "PurchasedUnits"
        case riCostForUnusedHours = "RICostForUnusedHours"
        case realizedSavings = "RealizedSavings"
        case totalActualHours = "TotalActualHours"
        case totalActualUnits = "TotalActualUnits"
        case totalAmortizedFee = "TotalAmortizedFee"
        case totalPotentialRISavings = "TotalPotentialRISavings"
        case unrealizedSavings = "UnrealizedSavings"
        case unusedHours = "UnusedHours"
        case unusedUnits = "UnusedUnits"
        case utilizationPercentage = "UtilizationPercentage"
        case utilizationPercentageInUnits = "UtilizationPercentageInUnits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringFee = self.amortizedRecurringFee {
            try encodeContainer.encode(amortizedRecurringFee, forKey: .amortizedRecurringFee)
        }
        if let amortizedUpfrontFee = self.amortizedUpfrontFee {
            try encodeContainer.encode(amortizedUpfrontFee, forKey: .amortizedUpfrontFee)
        }
        if let netRISavings = self.netRISavings {
            try encodeContainer.encode(netRISavings, forKey: .netRISavings)
        }
        if let onDemandCostOfRIHoursUsed = self.onDemandCostOfRIHoursUsed {
            try encodeContainer.encode(onDemandCostOfRIHoursUsed, forKey: .onDemandCostOfRIHoursUsed)
        }
        if let purchasedHours = self.purchasedHours {
            try encodeContainer.encode(purchasedHours, forKey: .purchasedHours)
        }
        if let purchasedUnits = self.purchasedUnits {
            try encodeContainer.encode(purchasedUnits, forKey: .purchasedUnits)
        }
        if let riCostForUnusedHours = self.riCostForUnusedHours {
            try encodeContainer.encode(riCostForUnusedHours, forKey: .riCostForUnusedHours)
        }
        if let realizedSavings = self.realizedSavings {
            try encodeContainer.encode(realizedSavings, forKey: .realizedSavings)
        }
        if let totalActualHours = self.totalActualHours {
            try encodeContainer.encode(totalActualHours, forKey: .totalActualHours)
        }
        if let totalActualUnits = self.totalActualUnits {
            try encodeContainer.encode(totalActualUnits, forKey: .totalActualUnits)
        }
        if let totalAmortizedFee = self.totalAmortizedFee {
            try encodeContainer.encode(totalAmortizedFee, forKey: .totalAmortizedFee)
        }
        if let totalPotentialRISavings = self.totalPotentialRISavings {
            try encodeContainer.encode(totalPotentialRISavings, forKey: .totalPotentialRISavings)
        }
        if let unrealizedSavings = self.unrealizedSavings {
            try encodeContainer.encode(unrealizedSavings, forKey: .unrealizedSavings)
        }
        if let unusedHours = self.unusedHours {
            try encodeContainer.encode(unusedHours, forKey: .unusedHours)
        }
        if let unusedUnits = self.unusedUnits {
            try encodeContainer.encode(unusedUnits, forKey: .unusedUnits)
        }
        if let utilizationPercentage = self.utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
        if let utilizationPercentageInUnits = self.utilizationPercentageInUnits {
            try encodeContainer.encode(utilizationPercentageInUnits, forKey: .utilizationPercentageInUnits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
        let utilizationPercentageInUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentageInUnits)
        utilizationPercentageInUnits = utilizationPercentageInUnitsDecoded
        let purchasedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .purchasedHours)
        purchasedHours = purchasedHoursDecoded
        let purchasedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .purchasedUnits)
        purchasedUnits = purchasedUnitsDecoded
        let totalActualHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalActualHours)
        totalActualHours = totalActualHoursDecoded
        let totalActualUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalActualUnits)
        totalActualUnits = totalActualUnitsDecoded
        let unusedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedHours)
        unusedHours = unusedHoursDecoded
        let unusedUnitsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedUnits)
        unusedUnits = unusedUnitsDecoded
        let onDemandCostOfRIHoursUsedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCostOfRIHoursUsed)
        onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsedDecoded
        let netRISavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netRISavings)
        netRISavings = netRISavingsDecoded
        let totalPotentialRISavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalPotentialRISavings)
        totalPotentialRISavings = totalPotentialRISavingsDecoded
        let amortizedUpfrontFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedUpfrontFee)
        amortizedUpfrontFee = amortizedUpfrontFeeDecoded
        let amortizedRecurringFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedRecurringFee)
        amortizedRecurringFee = amortizedRecurringFeeDecoded
        let totalAmortizedFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalAmortizedFee)
        totalAmortizedFee = totalAmortizedFeeDecoded
        let riCostForUnusedHoursDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .riCostForUnusedHours)
        riCostForUnusedHours = riCostForUnusedHoursDecoded
        let realizedSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .realizedSavings)
        realizedSavings = realizedSavingsDecoded
        let unrealizedSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unrealizedSavings)
        unrealizedSavings = unrealizedSavingsDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated numbers for your reservation usage.
    public struct ReservationAggregates: Swift.Equatable {
        /// The monthly cost of your reservation. It's amortized over the reservation period.
        public var amortizedRecurringFee: Swift.String?
        /// The upfront cost of your reservation. It's amortized over the reservation period.
        public var amortizedUpfrontFee: Swift.String?
        /// How much you saved due to purchasing and utilizing reservation. Amazon Web Services calculates this by subtracting TotalAmortizedFee from OnDemandCostOfRIHoursUsed.
        public var netRISavings: Swift.String?
        /// How much your reservation costs if charged On-Demand rates.
        public var onDemandCostOfRIHoursUsed: Swift.String?
        /// How many reservation hours that you purchased.
        public var purchasedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you purchased. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var purchasedUnits: Swift.String?
        /// The realized savings because of purchasing and using a reservation.
        public var realizedSavings: Swift.String?
        /// The cost of unused hours for your reservation.
        public var riCostForUnusedHours: Swift.String?
        /// The total number of reservation hours that you used.
        public var totalActualHours: Swift.String?
        /// The total number of Amazon EC2 reservation hours that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var totalActualUnits: Swift.String?
        /// The total cost of your reservation. It's amortized over the reservation period.
        public var totalAmortizedFee: Swift.String?
        /// How much you might save if you use your entire reservation.
        public var totalPotentialRISavings: Swift.String?
        /// The unrealized savings because of purchasing and using a reservation.
        public var unrealizedSavings: Swift.String?
        /// The number of reservation hours that you didn't use.
        public var unusedHours: Swift.String?
        /// The number of Amazon EC2 reservation hours that you didn't use. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var unusedUnits: Swift.String?
        /// The percentage of reservation time that you used.
        public var utilizationPercentage: Swift.String?
        /// The percentage of Amazon EC2 reservation time that you used. It's converted to normalized units. Normalized units are available only for Amazon EC2 usage after November 11, 2017.
        public var utilizationPercentageInUnits: Swift.String?

        public init(
            amortizedRecurringFee: Swift.String? = nil,
            amortizedUpfrontFee: Swift.String? = nil,
            netRISavings: Swift.String? = nil,
            onDemandCostOfRIHoursUsed: Swift.String? = nil,
            purchasedHours: Swift.String? = nil,
            purchasedUnits: Swift.String? = nil,
            realizedSavings: Swift.String? = nil,
            riCostForUnusedHours: Swift.String? = nil,
            totalActualHours: Swift.String? = nil,
            totalActualUnits: Swift.String? = nil,
            totalAmortizedFee: Swift.String? = nil,
            totalPotentialRISavings: Swift.String? = nil,
            unrealizedSavings: Swift.String? = nil,
            unusedHours: Swift.String? = nil,
            unusedUnits: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil,
            utilizationPercentageInUnits: Swift.String? = nil
        )
        {
            self.amortizedRecurringFee = amortizedRecurringFee
            self.amortizedUpfrontFee = amortizedUpfrontFee
            self.netRISavings = netRISavings
            self.onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed
            self.purchasedHours = purchasedHours
            self.purchasedUnits = purchasedUnits
            self.realizedSavings = realizedSavings
            self.riCostForUnusedHours = riCostForUnusedHours
            self.totalActualHours = totalActualHours
            self.totalActualUnits = totalActualUnits
            self.totalAmortizedFee = totalAmortizedFee
            self.totalPotentialRISavings = totalPotentialRISavings
            self.unrealizedSavings = unrealizedSavings
            self.unusedHours = unusedHours
            self.unusedUnits = unusedUnits
            self.utilizationPercentage = utilizationPercentage
            self.utilizationPercentageInUnits = utilizationPercentageInUnits
        }
    }

}

extension CostExplorerClientTypes.ReservationCoverageGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let coverage = self.coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Coverage.self, forKey: .coverage)
        coverage = coverageDecoded
    }
}

extension CostExplorerClientTypes {
    /// A group of reservations that share a set of attributes.
    public struct ReservationCoverageGroup: Swift.Equatable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String:Swift.String]?
        /// How much instance usage this group of reservations covered.
        public var coverage: CostExplorerClientTypes.Coverage?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            coverage: CostExplorerClientTypes.Coverage? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case recommendationDetails = "RecommendationDetails"
        case recommendationSummary = "RecommendationSummary"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let recommendationDetails = recommendationDetails {
            var recommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationDetails)
            for reservationpurchaserecommendationdetail0 in recommendationDetails {
                try recommendationDetailsContainer.encode(reservationpurchaserecommendationdetail0)
            }
        }
        if let recommendationSummary = self.recommendationSummary {
            try encodeContainer.encode(recommendationSummary, forKey: .recommendationSummary)
        }
        if let serviceSpecification = self.serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = self.termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let recommendationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationPurchaseRecommendationDetail?].self, forKey: .recommendationDetails)
        var recommendationDetailsDecoded0:[CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]? = nil
        if let recommendationDetailsContainer = recommendationDetailsContainer {
            recommendationDetailsDecoded0 = [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]()
            for structure0 in recommendationDetailsContainer {
                if let structure0 = structure0 {
                    recommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        recommendationDetails = recommendationDetailsDecoded0
        let recommendationSummaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationPurchaseRecommendationSummary.self, forKey: .recommendationSummary)
        recommendationSummary = recommendationSummaryDecoded
    }
}

extension CostExplorerClientTypes {
    /// A specific reservation that Amazon Web Services recommends for purchase.
    public struct ReservationPurchaseRecommendation: Swift.Equatable {
        /// The account scope that Amazon Web Services recommends that you purchase this instance for. For example, you can purchase this reservation for an entire organization in Amazon Web Services Organizations.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// How many days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option for the reservation (for example, AllUpfront or NoUpfront).
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details about the recommended purchases.
        public var recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]?
        /// A summary about the recommended purchase.
        public var recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary?
        /// Hardware specifications for the service that you want recommendations for.
        public var serviceSpecification: CostExplorerClientTypes.ServiceSpecification?
        /// The term of the reservation that you want recommendations for, in years.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init(
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            recommendationDetails: [CostExplorerClientTypes.ReservationPurchaseRecommendationDetail]? = nil,
            recommendationSummary: CostExplorerClientTypes.ReservationPurchaseRecommendationSummary? = nil,
            serviceSpecification: CostExplorerClientTypes.ServiceSpecification? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.recommendationDetails = recommendationDetails
            self.recommendationSummary = recommendationSummary
            self.serviceSpecification = serviceSpecification
            self.termInYears = termInYears
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case averageNormalizedUnitsUsedPerHour = "AverageNormalizedUnitsUsedPerHour"
        case averageNumberOfInstancesUsedPerHour = "AverageNumberOfInstancesUsedPerHour"
        case averageUtilization = "AverageUtilization"
        case currencyCode = "CurrencyCode"
        case estimatedBreakEvenInMonths = "EstimatedBreakEvenInMonths"
        case estimatedMonthlyOnDemandCost = "EstimatedMonthlyOnDemandCost"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedMonthlySavingsPercentage = "EstimatedMonthlySavingsPercentage"
        case estimatedReservationCostForLookbackPeriod = "EstimatedReservationCostForLookbackPeriod"
        case instanceDetails = "InstanceDetails"
        case maximumNormalizedUnitsUsedPerHour = "MaximumNormalizedUnitsUsedPerHour"
        case maximumNumberOfInstancesUsedPerHour = "MaximumNumberOfInstancesUsedPerHour"
        case minimumNormalizedUnitsUsedPerHour = "MinimumNormalizedUnitsUsedPerHour"
        case minimumNumberOfInstancesUsedPerHour = "MinimumNumberOfInstancesUsedPerHour"
        case recommendedNormalizedUnitsToPurchase = "RecommendedNormalizedUnitsToPurchase"
        case recommendedNumberOfInstancesToPurchase = "RecommendedNumberOfInstancesToPurchase"
        case recurringStandardMonthlyCost = "RecurringStandardMonthlyCost"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let averageNormalizedUnitsUsedPerHour = self.averageNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(averageNormalizedUnitsUsedPerHour, forKey: .averageNormalizedUnitsUsedPerHour)
        }
        if let averageNumberOfInstancesUsedPerHour = self.averageNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(averageNumberOfInstancesUsedPerHour, forKey: .averageNumberOfInstancesUsedPerHour)
        }
        if let averageUtilization = self.averageUtilization {
            try encodeContainer.encode(averageUtilization, forKey: .averageUtilization)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedBreakEvenInMonths = self.estimatedBreakEvenInMonths {
            try encodeContainer.encode(estimatedBreakEvenInMonths, forKey: .estimatedBreakEvenInMonths)
        }
        if let estimatedMonthlyOnDemandCost = self.estimatedMonthlyOnDemandCost {
            try encodeContainer.encode(estimatedMonthlyOnDemandCost, forKey: .estimatedMonthlyOnDemandCost)
        }
        if let estimatedMonthlySavingsAmount = self.estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedMonthlySavingsPercentage = self.estimatedMonthlySavingsPercentage {
            try encodeContainer.encode(estimatedMonthlySavingsPercentage, forKey: .estimatedMonthlySavingsPercentage)
        }
        if let estimatedReservationCostForLookbackPeriod = self.estimatedReservationCostForLookbackPeriod {
            try encodeContainer.encode(estimatedReservationCostForLookbackPeriod, forKey: .estimatedReservationCostForLookbackPeriod)
        }
        if let instanceDetails = self.instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let maximumNormalizedUnitsUsedPerHour = self.maximumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(maximumNormalizedUnitsUsedPerHour, forKey: .maximumNormalizedUnitsUsedPerHour)
        }
        if let maximumNumberOfInstancesUsedPerHour = self.maximumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(maximumNumberOfInstancesUsedPerHour, forKey: .maximumNumberOfInstancesUsedPerHour)
        }
        if let minimumNormalizedUnitsUsedPerHour = self.minimumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(minimumNormalizedUnitsUsedPerHour, forKey: .minimumNormalizedUnitsUsedPerHour)
        }
        if let minimumNumberOfInstancesUsedPerHour = self.minimumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(minimumNumberOfInstancesUsedPerHour, forKey: .minimumNumberOfInstancesUsedPerHour)
        }
        if let recommendedNormalizedUnitsToPurchase = self.recommendedNormalizedUnitsToPurchase {
            try encodeContainer.encode(recommendedNormalizedUnitsToPurchase, forKey: .recommendedNormalizedUnitsToPurchase)
        }
        if let recommendedNumberOfInstancesToPurchase = self.recommendedNumberOfInstancesToPurchase {
            try encodeContainer.encode(recommendedNumberOfInstancesToPurchase, forKey: .recommendedNumberOfInstancesToPurchase)
        }
        if let recurringStandardMonthlyCost = self.recurringStandardMonthlyCost {
            try encodeContainer.encode(recurringStandardMonthlyCost, forKey: .recurringStandardMonthlyCost)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let recommendedNumberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedNumberOfInstancesToPurchase)
        recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchaseDecoded
        let recommendedNormalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedNormalizedUnitsToPurchase)
        recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchaseDecoded
        let minimumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumNumberOfInstancesUsedPerHour)
        minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHourDecoded
        let minimumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minimumNormalizedUnitsUsedPerHour)
        minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHourDecoded
        let maximumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumNumberOfInstancesUsedPerHour)
        maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHourDecoded
        let maximumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maximumNormalizedUnitsUsedPerHour)
        maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHourDecoded
        let averageNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageNumberOfInstancesUsedPerHour)
        averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHourDecoded
        let averageNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageNormalizedUnitsUsedPerHour)
        averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHourDecoded
        let averageUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .averageUtilization)
        averageUtilization = averageUtilizationDecoded
        let estimatedBreakEvenInMonthsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedBreakEvenInMonths)
        estimatedBreakEvenInMonths = estimatedBreakEvenInMonthsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsPercentage)
        estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentageDecoded
        let estimatedMonthlyOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlyOnDemandCost)
        estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCostDecoded
        let estimatedReservationCostForLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedReservationCostForLookbackPeriod)
        estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriodDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let recurringStandardMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringStandardMonthlyCost)
        recurringStandardMonthlyCost = recurringStandardMonthlyCostDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details about your recommended reservation purchase.
    public struct ReservationPurchaseRecommendationDetail: Swift.Equatable {
        /// The account that this Reserved Instance (RI) recommendation is for.
        public var accountId: Swift.String?
        /// The average number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNormalizedUnitsUsedPerHour: Swift.String?
        /// The average number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageNumberOfInstancesUsedPerHour: Swift.String?
        /// The average utilization of your instances. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var averageUtilization: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// How long Amazon Web Services estimates that it takes for this instance to start saving you money, in months.
        public var estimatedBreakEvenInMonths: Swift.String?
        /// How much Amazon Web Services estimates that you spend on On-Demand Instances in a month.
        public var estimatedMonthlyOnDemandCost: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// How much Amazon Web Services estimates that this specific recommendation might save you in a month, as a percentage of your overall costs.
        public var estimatedMonthlySavingsPercentage: Swift.String?
        /// How much Amazon Web Services estimates that you might spend for all usage during the specified historical period if you had a reservation.
        public var estimatedReservationCostForLookbackPeriod: Swift.String?
        /// Details about the instances that Amazon Web Services recommends that you purchase.
        public var instanceDetails: CostExplorerClientTypes.InstanceDetails?
        /// The maximum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNormalizedUnitsUsedPerHour: Swift.String?
        /// The maximum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var maximumNumberOfInstancesUsedPerHour: Swift.String?
        /// The minimum number of normalized units that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNormalizedUnitsUsedPerHour: Swift.String?
        /// The minimum number of instances that you used in an hour during the historical period. Amazon Web Services uses this to calculate your recommended reservation purchases.
        public var minimumNumberOfInstancesUsedPerHour: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var recommendedNormalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var recommendedNumberOfInstancesToPurchase: Swift.String?
        /// How much purchasing this instance costs you on a monthly basis.
        public var recurringStandardMonthlyCost: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            averageNormalizedUnitsUsedPerHour: Swift.String? = nil,
            averageNumberOfInstancesUsedPerHour: Swift.String? = nil,
            averageUtilization: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            estimatedBreakEvenInMonths: Swift.String? = nil,
            estimatedMonthlyOnDemandCost: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedMonthlySavingsPercentage: Swift.String? = nil,
            estimatedReservationCostForLookbackPeriod: Swift.String? = nil,
            instanceDetails: CostExplorerClientTypes.InstanceDetails? = nil,
            maximumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            maximumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            minimumNormalizedUnitsUsedPerHour: Swift.String? = nil,
            minimumNumberOfInstancesUsedPerHour: Swift.String? = nil,
            recommendedNormalizedUnitsToPurchase: Swift.String? = nil,
            recommendedNumberOfInstancesToPurchase: Swift.String? = nil,
            recurringStandardMonthlyCost: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour
            self.averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour
            self.averageUtilization = averageUtilization
            self.currencyCode = currencyCode
            self.estimatedBreakEvenInMonths = estimatedBreakEvenInMonths
            self.estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage
            self.estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod
            self.instanceDetails = instanceDetails
            self.maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour
            self.maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour
            self.minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour
            self.minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour
            self.recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase
            self.recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase
            self.recurringStandardMonthlyCost = recurringStandardMonthlyCost
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationTimestamp = self.generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
    }
}

extension CostExplorerClientTypes {
    /// Information about this specific recommendation, such as the timestamp for when Amazon Web Services made a specific recommendation.
    public struct ReservationPurchaseRecommendationMetadata: Swift.Equatable {
        /// The timestamp for when Amazon Web Services made this recommendation.
        public var generationTimestamp: Swift.String?
        /// The ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init(
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.ReservationPurchaseRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case totalEstimatedMonthlySavingsAmount = "TotalEstimatedMonthlySavingsAmount"
        case totalEstimatedMonthlySavingsPercentage = "TotalEstimatedMonthlySavingsPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let totalEstimatedMonthlySavingsAmount = self.totalEstimatedMonthlySavingsAmount {
            try encodeContainer.encode(totalEstimatedMonthlySavingsAmount, forKey: .totalEstimatedMonthlySavingsAmount)
        }
        if let totalEstimatedMonthlySavingsPercentage = self.totalEstimatedMonthlySavingsPercentage {
            try encodeContainer.encode(totalEstimatedMonthlySavingsPercentage, forKey: .totalEstimatedMonthlySavingsPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalEstimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalEstimatedMonthlySavingsAmount)
        totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmountDecoded
        let totalEstimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalEstimatedMonthlySavingsPercentage)
        totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentageDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// A summary about this recommendation, such as the currency code, the amount that Amazon Web Services estimates that you could save, and the total amount of reservation to purchase.
    public struct ReservationPurchaseRecommendationSummary: Swift.Equatable {
        /// The currency code used for this recommendation.
        public var currencyCode: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month.
        public var totalEstimatedMonthlySavingsAmount: Swift.String?
        /// The total amount that Amazon Web Services estimates that this recommendation could save you in a month, as a percentage of your costs.
        public var totalEstimatedMonthlySavingsPercentage: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            totalEstimatedMonthlySavingsAmount: Swift.String? = nil,
            totalEstimatedMonthlySavingsPercentage: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount
            self.totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage
        }
    }

}

extension CostExplorerClientTypes.ReservationUtilizationGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case key = "Key"
        case utilization = "Utilization"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let utilization = self.utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .utilization)
        utilization = utilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// A group of reservations that share a set of attributes.
    public struct ReservationUtilizationGroup: Swift.Equatable {
        /// The attributes for this group of reservations.
        public var attributes: [Swift.String:Swift.String]?
        /// The key for a specific reservation attribute.
        public var key: Swift.String?
        /// How much you used this group of reservations.
        public var utilization: CostExplorerClientTypes.ReservationAggregates?
        /// The value of a specific reservation attribute.
        public var value: Swift.String?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            key: Swift.String? = nil,
            utilization: CostExplorerClientTypes.ReservationAggregates? = nil,
            value: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.key = key
            self.utilization = utilization
            self.value = value
        }
    }

}

extension CostExplorerClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2ResourceDetails = "EC2ResourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2ResourceDetails = self.ec2ResourceDetails {
            try encodeContainer.encode(ec2ResourceDetails, forKey: .ec2ResourceDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ResourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2ResourceDetails.self, forKey: .ec2ResourceDetails)
        ec2ResourceDetails = ec2ResourceDetailsDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details for the resource.
    public struct ResourceDetails: Swift.Equatable {
        /// Details for the Amazon EC2 resource.
        public var ec2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails?

        public init(
            ec2ResourceDetails: CostExplorerClientTypes.EC2ResourceDetails? = nil
        )
        {
            self.ec2ResourceDetails = ec2ResourceDetails
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified ARN in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CostExplorerClientTypes.ResourceTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CostExplorerClientTypes {
    /// The tag structure that contains a tag key and value. Tagging is supported only for the following Cost Explorer resource types: [AnomalyMonitor](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalyMonitor.html), [AnomalySubscription](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_AnomalySubscription.html), [CostCategory](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategory.html).
    public struct ResourceTag: Swift.Equatable {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension CostExplorerClientTypes.ResourceUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2ResourceUtilization = "EC2ResourceUtilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2ResourceUtilization = self.ec2ResourceUtilization {
            try encodeContainer.encode(ec2ResourceUtilization, forKey: .ec2ResourceUtilization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2ResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2ResourceUtilization.self, forKey: .ec2ResourceUtilization)
        ec2ResourceUtilization = ec2ResourceUtilizationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Resource utilization of current resource.
    public struct ResourceUtilization: Swift.Equatable {
        /// The utilization of current Amazon EC2 instance.
        public var ec2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization?

        public init(
            ec2ResourceUtilization: CostExplorerClientTypes.EC2ResourceUtilization? = nil
        )
        {
            self.ec2ResourceUtilization = ec2ResourceUtilization
        }
    }

}

extension CostExplorerClientTypes.ResultByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimated = "Estimated"
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimated != false {
            try encodeContainer.encode(estimated, forKey: .estimated)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for group0 in groups {
                try groupsContainer.encode(group0)
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            var totalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .total)
            for (dictKey0, metrics0) in total {
                try totalContainer.encode(metrics0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let totalContainer = try containerValues.decodeIfPresent([Swift.String: CostExplorerClientTypes.MetricValue?].self, forKey: .total)
        var totalDecoded0: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        if let totalContainer = totalContainer {
            totalDecoded0 = [Swift.String:CostExplorerClientTypes.MetricValue]()
            for (key0, metricvalue0) in totalContainer {
                if let metricvalue0 = metricvalue0 {
                    totalDecoded0?[key0] = metricvalue0
                }
            }
        }
        total = totalDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let estimatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .estimated) ?? false
        estimated = estimatedDecoded
    }
}

extension CostExplorerClientTypes {
    /// The result that's associated with a time period.
    public struct ResultByTime: Swift.Equatable {
        /// Determines whether the result is estimated.
        public var estimated: Swift.Bool
        /// The groups that this time period includes.
        public var groups: [CostExplorerClientTypes.Group]?
        /// The time period that the result covers.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total amount of cost or usage accrued during the time period.
        public var total: [Swift.String:CostExplorerClientTypes.MetricValue]?

        public init(
            estimated: Swift.Bool = false,
            groups: [CostExplorerClientTypes.Group]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: [Swift.String:CostExplorerClientTypes.MetricValue]? = nil
        )
        {
            self.estimated = estimated
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case currentInstance = "CurrentInstance"
        case findingReasonCodes = "FindingReasonCodes"
        case modifyRecommendationDetail = "ModifyRecommendationDetail"
        case rightsizingType = "RightsizingType"
        case terminateRecommendationDetail = "TerminateRecommendationDetail"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currentInstance = self.currentInstance {
            try encodeContainer.encode(currentInstance, forKey: .currentInstance)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for findingreasoncode0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(findingreasoncode0.rawValue)
            }
        }
        if let modifyRecommendationDetail = self.modifyRecommendationDetail {
            try encodeContainer.encode(modifyRecommendationDetail, forKey: .modifyRecommendationDetail)
        }
        if let rightsizingType = self.rightsizingType {
            try encodeContainer.encode(rightsizingType.rawValue, forKey: .rightsizingType)
        }
        if let terminateRecommendationDetail = self.terminateRecommendationDetail {
            try encodeContainer.encode(terminateRecommendationDetail, forKey: .terminateRecommendationDetail)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentInstanceDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CurrentInstance.self, forKey: .currentInstance)
        currentInstance = currentInstanceDecoded
        let rightsizingTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RightsizingType.self, forKey: .rightsizingType)
        rightsizingType = rightsizingTypeDecoded
        let modifyRecommendationDetailDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ModifyRecommendationDetail.self, forKey: .modifyRecommendationDetail)
        modifyRecommendationDetail = modifyRecommendationDetailDecoded
        let terminateRecommendationDetailDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TerminateRecommendationDetail.self, forKey: .terminateRecommendationDetail)
        terminateRecommendationDetail = terminateRecommendationDetailDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.FindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[CostExplorerClientTypes.FindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [CostExplorerClientTypes.FindingReasonCode]()
            for enum0 in findingReasonCodesContainer {
                if let enum0 = enum0 {
                    findingReasonCodesDecoded0?.append(enum0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Recommendations to rightsize resources.
    public struct RightsizingRecommendation: Swift.Equatable {
        /// The account that this recommendation is for.
        public var accountId: Swift.String?
        /// Context regarding the current instance.
        public var currentInstance: CostExplorerClientTypes.CurrentInstance?
        /// The list of possible reasons why the recommendation is generated, such as under- or over-utilization of specific metrics (for example, CPU, Memory, Network).
        public var findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]?
        /// The details for the modification recommendations.
        public var modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail?
        /// A recommendation to either terminate or modify the resource.
        public var rightsizingType: CostExplorerClientTypes.RightsizingType?
        /// The details for termination recommendations.
        public var terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail?

        public init(
            accountId: Swift.String? = nil,
            currentInstance: CostExplorerClientTypes.CurrentInstance? = nil,
            findingReasonCodes: [CostExplorerClientTypes.FindingReasonCode]? = nil,
            modifyRecommendationDetail: CostExplorerClientTypes.ModifyRecommendationDetail? = nil,
            rightsizingType: CostExplorerClientTypes.RightsizingType? = nil,
            terminateRecommendationDetail: CostExplorerClientTypes.TerminateRecommendationDetail? = nil
        )
        {
            self.accountId = accountId
            self.currentInstance = currentInstance
            self.findingReasonCodes = findingReasonCodes
            self.modifyRecommendationDetail = modifyRecommendationDetail
            self.rightsizingType = rightsizingType
            self.terminateRecommendationDetail = terminateRecommendationDetail
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case benefitsConsidered = "BenefitsConsidered"
        case recommendationTarget = "RecommendationTarget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if benefitsConsidered != false {
            try encodeContainer.encode(benefitsConsidered, forKey: .benefitsConsidered)
        }
        if let recommendationTarget = self.recommendationTarget {
            try encodeContainer.encode(recommendationTarget.rawValue, forKey: .recommendationTarget)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTargetDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.RecommendationTarget.self, forKey: .recommendationTarget)
        recommendationTarget = recommendationTargetDecoded
        let benefitsConsideredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .benefitsConsidered) ?? false
        benefitsConsidered = benefitsConsideredDecoded
    }
}

extension CostExplorerClientTypes {
    /// You can use RightsizingRecommendationConfiguration to customize recommendations across two attributes. You can choose to view recommendations for instances within the same instance families or across different instance families. You can also choose to view your estimated savings that are associated with recommendations with consideration of existing Savings Plans or Reserved Instance (RI) benefits, or neither.
    public struct RightsizingRecommendationConfiguration: Swift.Equatable {
        /// The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is TRUE.
        /// This member is required.
        public var benefitsConsidered: Swift.Bool
        /// The option to see recommendations within the same instance family or recommendations for instances across other families. The default value is SAME_INSTANCE_FAMILY.
        /// This member is required.
        public var recommendationTarget: CostExplorerClientTypes.RecommendationTarget?

        public init(
            benefitsConsidered: Swift.Bool = false,
            recommendationTarget: CostExplorerClientTypes.RecommendationTarget? = nil
        )
        {
            self.benefitsConsidered = benefitsConsidered
            self.recommendationTarget = recommendationTarget
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = self.additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = self.generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension CostExplorerClientTypes {
    /// Metadata for this recommendation set.
    public struct RightsizingRecommendationMetadata: Swift.Equatable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp for when Amazon Web Services made this recommendation.
        public var generationTimestamp: Swift.String?
        /// The number of days of previous usage that Amazon Web Services considers when making this recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The ID for this specific recommendation.
        public var recommendationId: Swift.String?

        public init(
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.RightsizingRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedTotalMonthlySavingsAmount = "EstimatedTotalMonthlySavingsAmount"
        case savingsCurrencyCode = "SavingsCurrencyCode"
        case savingsPercentage = "SavingsPercentage"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedTotalMonthlySavingsAmount = self.estimatedTotalMonthlySavingsAmount {
            try encodeContainer.encode(estimatedTotalMonthlySavingsAmount, forKey: .estimatedTotalMonthlySavingsAmount)
        }
        if let savingsCurrencyCode = self.savingsCurrencyCode {
            try encodeContainer.encode(savingsCurrencyCode, forKey: .savingsCurrencyCode)
        }
        if let savingsPercentage = self.savingsPercentage {
            try encodeContainer.encode(savingsPercentage, forKey: .savingsPercentage)
        }
        if let totalRecommendationCount = self.totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let estimatedTotalMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedTotalMonthlySavingsAmount)
        estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmountDecoded
        let savingsCurrencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsCurrencyCode)
        savingsCurrencyCode = savingsCurrencyCodeDecoded
        let savingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPercentage)
        savingsPercentage = savingsPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The summary of rightsizing recommendations
    public struct RightsizingRecommendationSummary: Swift.Equatable {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public var estimatedTotalMonthlySavingsAmount: Swift.String?
        /// The currency code that Amazon Web Services used to calculate the savings.
        public var savingsCurrencyCode: Swift.String?
        /// The savings percentage based on the recommended modifications. It's relative to the total On-Demand costs that are associated with these instances.
        public var savingsPercentage: Swift.String?
        /// The total number of instance recommendations.
        public var totalRecommendationCount: Swift.String?

        public init(
            estimatedTotalMonthlySavingsAmount: Swift.String? = nil,
            savingsCurrencyCode: Swift.String? = nil,
            savingsPercentage: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount
            self.savingsCurrencyCode = savingsCurrencyCode
            self.savingsPercentage = savingsPercentage
            self.totalRecommendationCount = totalRecommendationCount
        }
    }

}

extension CostExplorerClientTypes {
    public enum RightsizingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case modify
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [RightsizingType] {
            return [
                .modify,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .modify: return "MODIFY"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RightsizingType(rawValue: rawValue) ?? RightsizingType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.RootCause: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linkedAccount = "LinkedAccount"
        case linkedAccountName = "LinkedAccountName"
        case region = "Region"
        case service = "Service"
        case usageType = "UsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkedAccount = self.linkedAccount {
            try encodeContainer.encode(linkedAccount, forKey: .linkedAccount)
        }
        if let linkedAccountName = self.linkedAccountName {
            try encodeContainer.encode(linkedAccountName, forKey: .linkedAccountName)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let linkedAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkedAccount)
        linkedAccount = linkedAccountDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let linkedAccountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linkedAccountName)
        linkedAccountName = linkedAccountNameDecoded
    }
}

extension CostExplorerClientTypes {
    /// The combination of Amazon Web Service, linked account, linked account name, Region, and usage type where a cost anomaly is observed. The linked account name will only be available when the account name can be identified.
    public struct RootCause: Swift.Equatable {
        /// The member account value that's associated with the cost anomaly.
        public var linkedAccount: Swift.String?
        /// The member account name value that's associated with the cost anomaly.
        public var linkedAccountName: Swift.String?
        /// The Amazon Web Services Region that's associated with the cost anomaly.
        public var region: Swift.String?
        /// The Amazon Web Service name that's associated with the cost anomaly.
        public var service: Swift.String?
        /// The UsageType value that's associated with the cost anomaly.
        public var usageType: Swift.String?

        public init(
            linkedAccount: Swift.String? = nil,
            linkedAccountName: Swift.String? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.linkedAccount = linkedAccount
            self.linkedAccountName = linkedAccountName
            self.region = region
            self.service = service
            self.usageType = usageType
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansAmortizedCommitment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedRecurringCommitment = "AmortizedRecurringCommitment"
        case amortizedUpfrontCommitment = "AmortizedUpfrontCommitment"
        case totalAmortizedCommitment = "TotalAmortizedCommitment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringCommitment = self.amortizedRecurringCommitment {
            try encodeContainer.encode(amortizedRecurringCommitment, forKey: .amortizedRecurringCommitment)
        }
        if let amortizedUpfrontCommitment = self.amortizedUpfrontCommitment {
            try encodeContainer.encode(amortizedUpfrontCommitment, forKey: .amortizedUpfrontCommitment)
        }
        if let totalAmortizedCommitment = self.totalAmortizedCommitment {
            try encodeContainer.encode(totalAmortizedCommitment, forKey: .totalAmortizedCommitment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amortizedRecurringCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedRecurringCommitment)
        amortizedRecurringCommitment = amortizedRecurringCommitmentDecoded
        let amortizedUpfrontCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amortizedUpfrontCommitment)
        amortizedUpfrontCommitment = amortizedUpfrontCommitmentDecoded
        let totalAmortizedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalAmortizedCommitment)
        totalAmortizedCommitment = totalAmortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amortized amount of Savings Plans purchased in a specific account during a specific time interval.
    public struct SavingsPlansAmortizedCommitment: Swift.Equatable {
        /// The amortized amount of your Savings Plans commitment that was purchased with either a Partial or a NoUpfront.
        public var amortizedRecurringCommitment: Swift.String?
        /// The amortized amount of your Savings Plans commitment that was purchased with an Upfront or PartialUpfront Savings Plans.
        public var amortizedUpfrontCommitment: Swift.String?
        /// The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method.
        public var totalAmortizedCommitment: Swift.String?

        public init(
            amortizedRecurringCommitment: Swift.String? = nil,
            amortizedUpfrontCommitment: Swift.String? = nil,
            totalAmortizedCommitment: Swift.String? = nil
        )
        {
            self.amortizedRecurringCommitment = amortizedRecurringCommitment
            self.amortizedUpfrontCommitment = amortizedUpfrontCommitment
            self.totalAmortizedCommitment = totalAmortizedCommitment
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansCoverage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let coverage = self.coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansCoverageData.self, forKey: .coverage)
        coverage = coverageDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of Savings Plans eligible usage that's covered by Savings Plans. All calculations consider the On-Demand equivalent of your Savings Plans usage.
    public struct SavingsPlansCoverage: Swift.Equatable {
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The amount of Savings Plans eligible usage that the Savings Plans covered.
        public var coverage: CostExplorerClientTypes.SavingsPlansCoverageData?
        /// The time period of the request.
        public var timePeriod: CostExplorerClientTypes.DateInterval?

        public init(
            attributes: [Swift.String:Swift.String]? = nil,
            coverage: CostExplorerClientTypes.SavingsPlansCoverageData? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil
        )
        {
            self.attributes = attributes
            self.coverage = coverage
            self.timePeriod = timePeriod
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansCoverageData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coveragePercentage = "CoveragePercentage"
        case onDemandCost = "OnDemandCost"
        case spendCoveredBySavingsPlans = "SpendCoveredBySavingsPlans"
        case totalCost = "TotalCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coveragePercentage = self.coveragePercentage {
            try encodeContainer.encode(coveragePercentage, forKey: .coveragePercentage)
        }
        if let onDemandCost = self.onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
        if let spendCoveredBySavingsPlans = self.spendCoveredBySavingsPlans {
            try encodeContainer.encode(spendCoveredBySavingsPlans, forKey: .spendCoveredBySavingsPlans)
        }
        if let totalCost = self.totalCost {
            try encodeContainer.encode(totalCost, forKey: .totalCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spendCoveredBySavingsPlansDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .spendCoveredBySavingsPlans)
        spendCoveredBySavingsPlans = spendCoveredBySavingsPlansDecoded
        let onDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
        let totalCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalCost)
        totalCost = totalCostDecoded
        let coveragePercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coveragePercentage)
        coveragePercentage = coveragePercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// Specific coverage percentage, On-Demand costs, and spend covered by Savings Plans, and total Savings Plans costs for an account.
    public struct SavingsPlansCoverageData: Swift.Equatable {
        /// The percentage of your existing Savings Plans covered usage, divided by all of your eligible Savings Plans usage in an account (or set of accounts).
        public var coveragePercentage: Swift.String?
        /// The cost of your Amazon Web Services usage at the public On-Demand rate.
        public var onDemandCost: Swift.String?
        /// The amount of your Amazon Web Services usage that's covered by a Savings Plans.
        public var spendCoveredBySavingsPlans: Swift.String?
        /// The total cost of your Amazon Web Services usage, regardless of your purchase option.
        public var totalCost: Swift.String?

        public init(
            coveragePercentage: Swift.String? = nil,
            onDemandCost: Swift.String? = nil,
            spendCoveredBySavingsPlans: Swift.String? = nil,
            totalCost: Swift.String? = nil
        )
        {
            self.coveragePercentage = coveragePercentage
            self.onDemandCost = onDemandCost
            self.spendCoveredBySavingsPlans = spendCoveredBySavingsPlans
            self.totalCost = totalCost
        }
    }

}

extension CostExplorerClientTypes {
    public enum SavingsPlansDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amortizedCommitment
        case attributes
        case savings
        case utilization
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlansDataType] {
            return [
                .amortizedCommitment,
                .attributes,
                .savings,
                .utilization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amortizedCommitment: return "AMORTIZED_COMMITMENT"
            case .attributes: return "ATTRIBUTES"
            case .savings: return "SAVINGS"
            case .utilization: return "UTILIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlansDataType(rawValue: rawValue) ?? SavingsPlansDataType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.SavingsPlansDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceFamily = "InstanceFamily"
        case offeringId = "OfferingId"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
    }
}

extension CostExplorerClientTypes {
    /// The attribute details on a specific Savings Plan.
    public struct SavingsPlansDetails: Swift.Equatable {
        /// A group of instance types that Savings Plans applies to.
        public var instanceFamily: Swift.String?
        /// The unique ID that's used to distinguish Savings Plans from one another.
        public var offeringId: Swift.String?
        /// A collection of Amazon Web Services resources in a geographic area. Each Amazon Web Services Region is isolated and independent of the other Regions.
        public var region: Swift.String?

        public init(
            instanceFamily: Swift.String? = nil,
            offeringId: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.instanceFamily = instanceFamily
            self.offeringId = offeringId
            self.region = region
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case savingsPlansPurchaseRecommendationDetails = "SavingsPlansPurchaseRecommendationDetails"
        case savingsPlansPurchaseRecommendationSummary = "SavingsPlansPurchaseRecommendationSummary"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = self.lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails {
            var savingsPlansPurchaseRecommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlansPurchaseRecommendationDetails)
            for savingsplanspurchaserecommendationdetail0 in savingsPlansPurchaseRecommendationDetails {
                try savingsPlansPurchaseRecommendationDetailsContainer.encode(savingsplanspurchaserecommendationdetail0)
            }
        }
        if let savingsPlansPurchaseRecommendationSummary = self.savingsPlansPurchaseRecommendationSummary {
            try encodeContainer.encode(savingsPlansPurchaseRecommendationSummary, forKey: .savingsPlansPurchaseRecommendationSummary)
        }
        if let savingsPlansType = self.savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = self.termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let savingsPlansPurchaseRecommendationDetailsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail?].self, forKey: .savingsPlansPurchaseRecommendationDetails)
        var savingsPlansPurchaseRecommendationDetailsDecoded0:[CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]? = nil
        if let savingsPlansPurchaseRecommendationDetailsContainer = savingsPlansPurchaseRecommendationDetailsContainer {
            savingsPlansPurchaseRecommendationDetailsDecoded0 = [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]()
            for structure0 in savingsPlansPurchaseRecommendationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansPurchaseRecommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetailsDecoded0
        let savingsPlansPurchaseRecommendationSummaryDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary.self, forKey: .savingsPlansPurchaseRecommendationSummary)
        savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummaryDecoded
    }
}

extension CostExplorerClientTypes {
    /// Contains your request parameters, Savings Plan Recommendations Summary, and Details.
    public struct SavingsPlansPurchaseRecommendation: Swift.Equatable {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations that include the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: CostExplorerClientTypes.AccountScope?
        /// The lookback period in days that's used to generate the recommendation.
        public var lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays?
        /// The payment option that's used to generate the recommendation.
        public var paymentOption: CostExplorerClientTypes.PaymentOption?
        /// Details for the Savings Plans that we recommend that you purchase to cover existing Savings Plans eligible workloads.
        public var savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]?
        /// Summary metrics for your Savings Plans Recommendations.
        public var savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary?
        /// The requested Savings Plans recommendation type.
        public var savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType?
        /// The Savings Plans recommendation term in years. It's used to generate the recommendation.
        public var termInYears: CostExplorerClientTypes.TermInYears?

        public init(
            accountScope: CostExplorerClientTypes.AccountScope? = nil,
            lookbackPeriodInDays: CostExplorerClientTypes.LookbackPeriodInDays? = nil,
            paymentOption: CostExplorerClientTypes.PaymentOption? = nil,
            savingsPlansPurchaseRecommendationDetails: [CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail]? = nil,
            savingsPlansPurchaseRecommendationSummary: CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary? = nil,
            savingsPlansType: CostExplorerClientTypes.SupportedSavingsPlansType? = nil,
            termInYears: CostExplorerClientTypes.TermInYears? = nil
        )
        {
            self.accountScope = accountScope
            self.lookbackPeriodInDays = lookbackPeriodInDays
            self.paymentOption = paymentOption
            self.savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails
            self.savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary
            self.savingsPlansType = savingsPlansType
            self.termInYears = termInYears
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case currencyCode = "CurrencyCode"
        case currentAverageHourlyOnDemandSpend = "CurrentAverageHourlyOnDemandSpend"
        case currentMaximumHourlyOnDemandSpend = "CurrentMaximumHourlyOnDemandSpend"
        case currentMinimumHourlyOnDemandSpend = "CurrentMinimumHourlyOnDemandSpend"
        case estimatedAverageUtilization = "EstimatedAverageUtilization"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCost = "EstimatedOnDemandCost"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSPCost = "EstimatedSPCost"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case recommendationDetailId = "RecommendationDetailId"
        case savingsPlansDetails = "SavingsPlansDetails"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentAverageHourlyOnDemandSpend = self.currentAverageHourlyOnDemandSpend {
            try encodeContainer.encode(currentAverageHourlyOnDemandSpend, forKey: .currentAverageHourlyOnDemandSpend)
        }
        if let currentMaximumHourlyOnDemandSpend = self.currentMaximumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMaximumHourlyOnDemandSpend, forKey: .currentMaximumHourlyOnDemandSpend)
        }
        if let currentMinimumHourlyOnDemandSpend = self.currentMinimumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMinimumHourlyOnDemandSpend, forKey: .currentMinimumHourlyOnDemandSpend)
        }
        if let estimatedAverageUtilization = self.estimatedAverageUtilization {
            try encodeContainer.encode(estimatedAverageUtilization, forKey: .estimatedAverageUtilization)
        }
        if let estimatedMonthlySavingsAmount = self.estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCost = self.estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = self.estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = self.estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSPCost = self.estimatedSPCost {
            try encodeContainer.encode(estimatedSPCost, forKey: .estimatedSPCost)
        }
        if let estimatedSavingsAmount = self.estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = self.estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let hourlyCommitmentToPurchase = self.hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let recommendationDetailId = self.recommendationDetailId {
            try encodeContainer.encode(recommendationDetailId, forKey: .recommendationDetailId)
        }
        if let savingsPlansDetails = self.savingsPlansDetails {
            try encodeContainer.encode(savingsPlansDetails, forKey: .savingsPlansDetails)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansDetails.self, forKey: .savingsPlansDetails)
        savingsPlansDetails = savingsPlansDetailsDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let estimatedROIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedSPCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSPCost)
        estimatedSPCost = estimatedSPCostDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedAverageUtilizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedAverageUtilization)
        estimatedAverageUtilization = estimatedAverageUtilizationDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let currentMinimumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMinimumHourlyOnDemandSpend)
        currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpendDecoded
        let currentMaximumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentMaximumHourlyOnDemandSpend)
        currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpendDecoded
        let currentAverageHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentAverageHourlyOnDemandSpend)
        currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpendDecoded
        let recommendationDetailIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationDetailId)
        recommendationDetailId = recommendationDetailIdDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details for your recommended Savings Plans.
    public struct SavingsPlansPurchaseRecommendationDetail: Swift.Equatable {
        /// The AccountID the recommendation is generated for.
        public var accountId: Swift.String?
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The average value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentAverageHourlyOnDemandSpend: Swift.String?
        /// The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMaximumHourlyOnDemandSpend: Swift.String?
        /// The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.
        public var currentMinimumHourlyOnDemandSpend: Swift.String?
        /// The estimated utilization of the recommended Savings Plans.
        public var estimatedAverageUtilization: Swift.String?
        /// The estimated monthly savings amount based on the recommended Savings Plans.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans that you purchased. This is calculated as estimatedSavingsAmount/ estimatedSPCost*100.
        public var estimatedROI: Swift.String?
        /// The cost of the recommended Savings Plans over the length of the lookback period.
        public var estimatedSPCost: Swift.String?
        /// The estimated savings amount that's based on the recommended Savings Plans over the length of the lookback period.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.
        public var estimatedSavingsPercentage: Swift.String?
        /// The recommended hourly commitment level for the Savings Plans type and the configuration that's based on the usage during the lookback period.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// Contains detailed information about a specific Savings Plan recommendation.
        public var recommendationDetailId: Swift.String?
        /// Details for your recommended Savings Plans.
        public var savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails?
        /// The upfront cost of the recommended Savings Plans, based on the selected payment option.
        public var upfrontCost: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            currentAverageHourlyOnDemandSpend: Swift.String? = nil,
            currentMaximumHourlyOnDemandSpend: Swift.String? = nil,
            currentMinimumHourlyOnDemandSpend: Swift.String? = nil,
            estimatedAverageUtilization: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCost: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSPCost: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            recommendationDetailId: Swift.String? = nil,
            savingsPlansDetails: CostExplorerClientTypes.SavingsPlansDetails? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.currencyCode = currencyCode
            self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
            self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
            self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
            self.estimatedAverageUtilization = estimatedAverageUtilization
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSPCost = estimatedSPCost
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.recommendationDetailId = recommendationDetailId
            self.savingsPlansDetails = savingsPlansDetails
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = self.additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = self.generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension CostExplorerClientTypes {
    /// Metadata about your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationMetadata: Swift.Equatable {
        /// Additional metadata that might be applicable to the recommendation.
        public var additionalMetadata: Swift.String?
        /// The timestamp that shows when the recommendations were generated.
        public var generationTimestamp: Swift.String?
        /// The unique identifier for the recommendation set.
        public var recommendationId: Swift.String?

        public init(
            additionalMetadata: Swift.String? = nil,
            generationTimestamp: Swift.String? = nil,
            recommendationId: Swift.String? = nil
        )
        {
            self.additionalMetadata = additionalMetadata
            self.generationTimestamp = generationTimestamp
            self.recommendationId = recommendationId
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansPurchaseRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case currentOnDemandSpend = "CurrentOnDemandSpend"
        case dailyCommitmentToPurchase = "DailyCommitmentToPurchase"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case estimatedTotalCost = "EstimatedTotalCost"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentOnDemandSpend = self.currentOnDemandSpend {
            try encodeContainer.encode(currentOnDemandSpend, forKey: .currentOnDemandSpend)
        }
        if let dailyCommitmentToPurchase = self.dailyCommitmentToPurchase {
            try encodeContainer.encode(dailyCommitmentToPurchase, forKey: .dailyCommitmentToPurchase)
        }
        if let estimatedMonthlySavingsAmount = self.estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = self.estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = self.estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSavingsAmount = self.estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = self.estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let estimatedTotalCost = self.estimatedTotalCost {
            try encodeContainer.encode(estimatedTotalCost, forKey: .estimatedTotalCost)
        }
        if let hourlyCommitmentToPurchase = self.hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let totalRecommendationCount = self.totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedROIDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedTotalCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedTotalCost)
        estimatedTotalCost = estimatedTotalCostDecoded
        let currentOnDemandSpendDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentOnDemandSpend)
        currentOnDemandSpend = currentOnDemandSpendDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let dailyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dailyCommitmentToPurchase)
        dailyCommitmentToPurchase = dailyCommitmentToPurchaseDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// Summary metrics for your Savings Plans Purchase Recommendations.
    public struct SavingsPlansPurchaseRecommendationSummary: Swift.Equatable {
        /// The currency code that Amazon Web Services used to generate the recommendations and present potential savings.
        public var currencyCode: Swift.String?
        /// The current total on demand spend of the applicable usage types over the lookback period.
        public var currentOnDemandSpend: Swift.String?
        /// The recommended Savings Plans cost on a daily (24 hourly) basis.
        public var dailyCommitmentToPurchase: Swift.String?
        /// The estimated monthly savings amount that's based on the recommended Savings Plans purchase.
        public var estimatedMonthlySavingsAmount: Swift.String?
        /// The estimated On-Demand costs you expect with no additional commitment. It's based on your usage of the selected time period and the Savings Plans you own.
        public var estimatedOnDemandCostWithCurrentCommitment: Swift.String?
        /// The estimated return on investment that's based on the recommended Savings Plans and estimated savings.
        public var estimatedROI: Swift.String?
        /// The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.
        public var estimatedSavingsAmount: Swift.String?
        /// The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as estimatedSavingsAmount/ CurrentOnDemandSpend*100.
        public var estimatedSavingsPercentage: Swift.String?
        /// The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.
        public var estimatedTotalCost: Swift.String?
        /// The recommended hourly commitment that's based on the recommendation parameters.
        public var hourlyCommitmentToPurchase: Swift.String?
        /// The aggregate number of Savings Plans recommendations that exist for your account.
        public var totalRecommendationCount: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            currentOnDemandSpend: Swift.String? = nil,
            dailyCommitmentToPurchase: Swift.String? = nil,
            estimatedMonthlySavingsAmount: Swift.String? = nil,
            estimatedOnDemandCostWithCurrentCommitment: Swift.String? = nil,
            estimatedROI: Swift.String? = nil,
            estimatedSavingsAmount: Swift.String? = nil,
            estimatedSavingsPercentage: Swift.String? = nil,
            estimatedTotalCost: Swift.String? = nil,
            hourlyCommitmentToPurchase: Swift.String? = nil,
            totalRecommendationCount: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.currentOnDemandSpend = currentOnDemandSpend
            self.dailyCommitmentToPurchase = dailyCommitmentToPurchase
            self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
            self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
            self.estimatedROI = estimatedROI
            self.estimatedSavingsAmount = estimatedSavingsAmount
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.estimatedTotalCost = estimatedTotalCost
            self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
            self.totalRecommendationCount = totalRecommendationCount
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansSavings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case netSavings = "NetSavings"
        case onDemandCostEquivalent = "OnDemandCostEquivalent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let netSavings = self.netSavings {
            try encodeContainer.encode(netSavings, forKey: .netSavings)
        }
        if let onDemandCostEquivalent = self.onDemandCostEquivalent {
            try encodeContainer.encode(onDemandCostEquivalent, forKey: .onDemandCostEquivalent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let netSavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netSavings)
        netSavings = netSavingsDecoded
        let onDemandCostEquivalentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .onDemandCostEquivalent)
        onDemandCostEquivalent = onDemandCostEquivalentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of savings that you're accumulating, against the public On-Demand rate of the usage accrued in an account.
    public struct SavingsPlansSavings: Swift.Equatable {
        /// The savings amount that you're accumulating for the usage that's covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.
        public var netSavings: Swift.String?
        /// How much the amount that the usage would have cost if it was accrued at the On-Demand rate.
        public var onDemandCostEquivalent: Swift.String?

        public init(
            netSavings: Swift.String? = nil,
            onDemandCostEquivalent: Swift.String? = nil
        )
        {
            self.netSavings = netSavings
            self.onDemandCostEquivalent = onDemandCostEquivalent
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalCommitment = "TotalCommitment"
        case unusedCommitment = "UnusedCommitment"
        case usedCommitment = "UsedCommitment"
        case utilizationPercentage = "UtilizationPercentage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalCommitment = self.totalCommitment {
            try encodeContainer.encode(totalCommitment, forKey: .totalCommitment)
        }
        if let unusedCommitment = self.unusedCommitment {
            try encodeContainer.encode(unusedCommitment, forKey: .unusedCommitment)
        }
        if let usedCommitment = self.usedCommitment {
            try encodeContainer.encode(usedCommitment, forKey: .usedCommitment)
        }
        if let utilizationPercentage = self.utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .totalCommitment)
        totalCommitment = totalCommitmentDecoded
        let usedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usedCommitment)
        usedCommitment = usedCommitmentDecoded
        let unusedCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unusedCommitment)
        unusedCommitment = unusedCommitmentDecoded
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
    }
}

extension CostExplorerClientTypes {
    /// The measurement of how well you're using your existing Savings Plans.
    public struct SavingsPlansUtilization: Swift.Equatable {
        /// The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).
        public var totalCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that wasn't consumed from Savings Plans eligible usage in a specific period.
        public var unusedCommitment: Swift.String?
        /// The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.
        public var usedCommitment: Swift.String?
        /// The amount of UsedCommitment divided by the TotalCommitment for your Savings Plans.
        public var utilizationPercentage: Swift.String?

        public init(
            totalCommitment: Swift.String? = nil,
            unusedCommitment: Swift.String? = nil,
            usedCommitment: Swift.String? = nil,
            utilizationPercentage: Swift.String? = nil
        )
        {
            self.totalCommitment = totalCommitment
            self.unusedCommitment = unusedCommitment
            self.usedCommitment = usedCommitment
            self.utilizationPercentage = utilizationPercentage
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = self.amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = self.savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let utilization = self.utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The aggregated utilization metrics for your Savings Plans usage.
    public struct SavingsPlansUtilizationAggregates: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.utilization = utilization
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case timePeriod = "TimePeriod"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = self.amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = self.savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let utilization = self.utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of Savings Plans utilization (in hours).
    public struct SavingsPlansUtilizationByTime: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The amount that's saved by using existing Savings Plans. Savings returns both net savings from Savings Plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The time period of the request.
        /// This member is required.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        /// This member is required.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.savings = savings
            self.timePeriod = timePeriod
            self.utilization = utilization
        }
    }

}

extension CostExplorerClientTypes.SavingsPlansUtilizationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case attributes = "Attributes"
        case savings = "Savings"
        case savingsPlanArn = "SavingsPlanArn"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = self.amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let savings = self.savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let savingsPlanArn = self.savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let utilization = self.utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension CostExplorerClientTypes {
    /// A single daily or monthly Savings Plans utilization rate and details for your account. A management account in an organization have access to member accounts. You can use GetDimensionValues to determine the possible dimension values.
    public struct SavingsPlansUtilizationDetail: Swift.Equatable {
        /// The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.
        public var amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment?
        /// The attribute that applies to a specific Dimension.
        public var attributes: [Swift.String:Swift.String]?
        /// The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans and also the onDemandCostEquivalent of the Savings Plans when considering the utilization rate.
        public var savings: CostExplorerClientTypes.SavingsPlansSavings?
        /// The unique Amazon Resource Name (ARN) for a particular Savings Plan.
        public var savingsPlanArn: Swift.String?
        /// A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.
        public var utilization: CostExplorerClientTypes.SavingsPlansUtilization?

        public init(
            amortizedCommitment: CostExplorerClientTypes.SavingsPlansAmortizedCommitment? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            savings: CostExplorerClientTypes.SavingsPlansSavings? = nil,
            savingsPlanArn: Swift.String? = nil,
            utilization: CostExplorerClientTypes.SavingsPlansUtilization? = nil
        )
        {
            self.amortizedCommitment = amortizedCommitment
            self.attributes = attributes
            self.savings = savings
            self.savingsPlanArn = savingsPlanArn
            self.utilization = utilization
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached the limit on the number of resources you can create, or exceeded the size of an individual resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes.ServiceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2Specification = "EC2Specification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2Specification = self.ec2Specification {
            try encodeContainer.encode(ec2Specification, forKey: .ec2Specification)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2SpecificationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.EC2Specification.self, forKey: .ec2Specification)
        ec2Specification = ec2SpecificationDecoded
    }
}

extension CostExplorerClientTypes {
    /// Hardware specifications for the service that you want recommendations for.
    public struct ServiceSpecification: Swift.Equatable {
        /// The Amazon EC2 hardware specifications that you want Amazon Web Services to provide recommendations for.
        public var ec2Specification: CostExplorerClientTypes.EC2Specification?

        public init(
            ec2Specification: CostExplorerClientTypes.EC2Specification? = nil
        )
        {
            self.ec2Specification = ec2Specification
        }
    }

}

extension CostExplorerClientTypes.SortDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension CostExplorerClientTypes {
    /// The details for how to sort the data.
    public struct SortDefinition: Swift.Equatable {
        /// The key that's used to sort the data.
        /// This member is required.
        public var key: Swift.String?
        /// The order that's used to sort the data.
        public var sortOrder: CostExplorerClientTypes.SortOrder?

        public init(
            key: Swift.String? = nil,
            sortOrder: CostExplorerClientTypes.SortOrder? = nil
        )
        {
            self.key = key
            self.sortOrder = sortOrder
        }
    }

}

extension CostExplorerClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSavingsPlansPurchaseRecommendationGenerationInput: Swift.Equatable {

    public init() { }
}

struct StartSavingsPlansPurchaseRecommendationGenerationInputBody: Swift.Equatable {
}

extension StartSavingsPlansPurchaseRecommendationGenerationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartSavingsPlansPurchaseRecommendationGenerationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSavingsPlansPurchaseRecommendationGenerationOutputBody = try responseDecoder.decode(responseBody: data)
            self.estimatedCompletionTime = output.estimatedCompletionTime
            self.generationStartedTime = output.generationStartedTime
            self.recommendationId = output.recommendationId
        } else {
            self.estimatedCompletionTime = nil
            self.generationStartedTime = nil
            self.recommendationId = nil
        }
    }
}

public struct StartSavingsPlansPurchaseRecommendationGenerationOutput: Swift.Equatable {
    /// The estimated time for when the recommendation generation will complete.
    public var estimatedCompletionTime: Swift.String?
    /// The start time of the recommendation generation.
    public var generationStartedTime: Swift.String?
    /// The ID for this specific recommendation.
    public var recommendationId: Swift.String?

    public init(
        estimatedCompletionTime: Swift.String? = nil,
        generationStartedTime: Swift.String? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.estimatedCompletionTime = estimatedCompletionTime
        self.generationStartedTime = generationStartedTime
        self.recommendationId = recommendationId
    }
}

struct StartSavingsPlansPurchaseRecommendationGenerationOutputBody: Swift.Equatable {
    let recommendationId: Swift.String?
    let generationStartedTime: Swift.String?
    let estimatedCompletionTime: Swift.String?
}

extension StartSavingsPlansPurchaseRecommendationGenerationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedCompletionTime = "EstimatedCompletionTime"
        case generationStartedTime = "GenerationStartedTime"
        case recommendationId = "RecommendationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationStartedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generationStartedTime)
        generationStartedTime = generationStartedTimeDecoded
        let estimatedCompletionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedCompletionTime)
        estimatedCompletionTime = estimatedCompletionTimeDecoded
    }
}

enum StartSavingsPlansPurchaseRecommendationGenerationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DataUnavailableException": return try await DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "GenerationExistsException": return try await GenerationExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.Subscriber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SubscriberType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.SubscriberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostExplorerClientTypes {
    /// The recipient of AnomalySubscription notifications.
    public struct Subscriber: Swift.Equatable {
        /// The email address or SNS Amazon Resource Name (ARN). This depends on the Type.
        public var address: Swift.String?
        /// Indicates if the subscriber accepts the notifications.
        public var status: CostExplorerClientTypes.SubscriberStatus?
        /// The notification delivery channel.
        public var type: CostExplorerClientTypes.SubscriberType?

        public init(
            address: Swift.String? = nil,
            status: CostExplorerClientTypes.SubscriberStatus? = nil,
            type: CostExplorerClientTypes.SubscriberType? = nil
        )
        {
            self.address = address
            self.status = status
            self.type = type
        }
    }

}

extension CostExplorerClientTypes {
    public enum SubscriberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmed
        case declined
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberStatus] {
            return [
                .confirmed,
                .declined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "CONFIRMED"
            case .declined: return "DECLINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriberStatus(rawValue: rawValue) ?? SubscriberStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum SubscriberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriberType] {
            return [
                .email,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriberType(rawValue: rawValue) ?? SubscriberType.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes {
    public enum SupportedSavingsPlansType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeSp
        case ec2InstanceSp
        case sagemakerSp
        case sdkUnknown(Swift.String)

        public static var allCases: [SupportedSavingsPlansType] {
            return [
                .computeSp,
                .ec2InstanceSp,
                .sagemakerSp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeSp: return "COMPUTE_SP"
            case .ec2InstanceSp: return "EC2_INSTANCE_SP"
            case .sagemakerSp: return "SAGEMAKER_SP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SupportedSavingsPlansType(rawValue: rawValue) ?? SupportedSavingsPlansType.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTags = "ResourceTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTags)
            for resourcetag0 in resourceTags {
                try resourceTagsContainer.encode(resourcetag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs to be added to the resource. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services use
    ///
    /// * The maximum length of a key is 128 characters
    ///
    /// * The maximum length of a value is 256 characters
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-
    ///
    /// * Keys and values are case sensitive
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces
    ///
    /// * Don’t use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services use
    /// This member is required.
    public var resourceTags: [CostExplorerClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [CostExplorerClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceTags: [CostExplorerClientTypes.ResourceTag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTags = "ResourceTags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ResourceTag?].self, forKey: .resourceTags)
        var resourceTagsDecoded0:[CostExplorerClientTypes.ResourceTag]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [CostExplorerClientTypes.ResourceTag]()
            for structure0 in resourceTagsContainer {
                if let structure0 = structure0 {
                    resourceTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceTags = resourceTagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.TagValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoption0 in matchOptions {
                try matchOptionsContainer.encode(matchoption0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for value0 in values {
                try valuesContainer.encode(value0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[CostExplorerClientTypes.MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [CostExplorerClientTypes.MatchOption]()
            for enum0 in matchOptionsContainer {
                if let enum0 = enum0 {
                    matchOptionsDecoded0?.append(enum0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostExplorerClientTypes {
    /// The values that are available for a tag. If Values and Key aren't specified, the ABSENTMatchOption is applied to all tags. That is, it's filtered on resources with no tags. If Key is provided and Values isn't specified, the ABSENTMatchOption is applied to the tag Key only. That is, it's filtered on resources without the given tag key.
    public struct TagValues: Swift.Equatable {
        /// The key for the tag.
        public var key: Swift.String?
        /// The match options that you can use to filter your results. MatchOptions is only applicable for actions related to Cost Category. The default values for MatchOptions are EQUALS and CASE_SENSITIVE.
        public var matchOptions: [CostExplorerClientTypes.MatchOption]?
        /// The specific value of the tag.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [CostExplorerClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }

}

extension CostExplorerClientTypes.TargetInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case defaultTargetInstance = "DefaultTargetInstance"
        case estimatedMonthlyCost = "EstimatedMonthlyCost"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
        case expectedResourceUtilization = "ExpectedResourceUtilization"
        case platformDifferences = "PlatformDifferences"
        case resourceDetails = "ResourceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if defaultTargetInstance != false {
            try encodeContainer.encode(defaultTargetInstance, forKey: .defaultTargetInstance)
        }
        if let estimatedMonthlyCost = self.estimatedMonthlyCost {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if let estimatedMonthlySavings = self.estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let expectedResourceUtilization = self.expectedResourceUtilization {
            try encodeContainer.encode(expectedResourceUtilization, forKey: .expectedResourceUtilization)
        }
        if let platformDifferences = platformDifferences {
            var platformDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformDifferences)
            for platformdifference0 in platformDifferences {
                try platformDifferencesContainer.encode(platformdifference0.rawValue)
            }
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let defaultTargetInstanceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .defaultTargetInstance) ?? false
        defaultTargetInstance = defaultTargetInstanceDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let expectedResourceUtilizationDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ResourceUtilization.self, forKey: .expectedResourceUtilization)
        expectedResourceUtilization = expectedResourceUtilizationDecoded
        let platformDifferencesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.PlatformDifference?].self, forKey: .platformDifferences)
        var platformDifferencesDecoded0:[CostExplorerClientTypes.PlatformDifference]? = nil
        if let platformDifferencesContainer = platformDifferencesContainer {
            platformDifferencesDecoded0 = [CostExplorerClientTypes.PlatformDifference]()
            for enum0 in platformDifferencesContainer {
                if let enum0 = enum0 {
                    platformDifferencesDecoded0?.append(enum0)
                }
            }
        }
        platformDifferences = platformDifferencesDecoded0
    }
}

extension CostExplorerClientTypes {
    /// Details on recommended instance.
    public struct TargetInstance: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// Determines whether this recommendation is the defaulted Amazon Web Services recommendation.
        public var defaultTargetInstance: Swift.Bool
        /// The expected cost to operate this instance type on a monthly basis.
        public var estimatedMonthlyCost: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?
        /// The expected utilization metrics for target instance type.
        public var expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization?
        /// Explains the actions that you might need to take to successfully migrate your workloads from the current instance type to the recommended instance type.
        public var platformDifferences: [CostExplorerClientTypes.PlatformDifference]?
        /// Details on the target instance type.
        public var resourceDetails: CostExplorerClientTypes.ResourceDetails?

        public init(
            currencyCode: Swift.String? = nil,
            defaultTargetInstance: Swift.Bool = false,
            estimatedMonthlyCost: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil,
            expectedResourceUtilization: CostExplorerClientTypes.ResourceUtilization? = nil,
            platformDifferences: [CostExplorerClientTypes.PlatformDifference]? = nil,
            resourceDetails: CostExplorerClientTypes.ResourceDetails? = nil
        )
        {
            self.currencyCode = currencyCode
            self.defaultTargetInstance = defaultTargetInstance
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.expectedResourceUtilization = expectedResourceUtilization
            self.platformDifferences = platformDifferences
            self.resourceDetails = resourceDetails
        }
    }

}

extension CostExplorerClientTypes {
    public enum TermInYears: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneYear
        case threeYears
        case sdkUnknown(Swift.String)

        public static var allCases: [TermInYears] {
            return [
                .oneYear,
                .threeYears,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneYear: return "ONE_YEAR"
            case .threeYears: return "THREE_YEARS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TermInYears(rawValue: rawValue) ?? TermInYears.sdkUnknown(rawValue)
        }
    }
}

extension CostExplorerClientTypes.TerminateRecommendationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "CurrencyCode"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedMonthlySavings = self.estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CostExplorerClientTypes {
    /// Details on termination recommendation.
    public struct TerminateRecommendationDetail: Swift.Equatable {
        /// The currency code that Amazon Web Services used to calculate the costs for this instance.
        public var currencyCode: Swift.String?
        /// The estimated savings that result from modification, on a monthly basis.
        public var estimatedMonthlySavings: Swift.String?

        public init(
            currencyCode: Swift.String? = nil,
            estimatedMonthlySavings: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.estimatedMonthlySavings = estimatedMonthlySavings
        }
    }

}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Can occur if you specify a number of tags for a resource greater than the maximum 50 user tags per resource.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension CostExplorerClientTypes.TotalImpactFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endValue = "EndValue"
        case numericOperator = "NumericOperator"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if endValue != 0.0 {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let numericOperator = self.numericOperator {
            try encodeContainer.encode(numericOperator.rawValue, forKey: .numericOperator)
        }
        if startValue != 0.0 {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericOperatorDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.NumericOperator.self, forKey: .numericOperator)
        numericOperator = numericOperatorDecoded
        let startValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .startValue) ?? 0.0
        startValue = startValueDecoded
        let endValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .endValue) ?? 0.0
        endValue = endValueDecoded
    }
}

extension CostExplorerClientTypes {
    /// Filters cost anomalies based on the total impact.
    public struct TotalImpactFilter: Swift.Equatable {
        /// The upper bound dollar value that's used in the filter.
        public var endValue: Swift.Double
        /// The comparing value that's used in the filter.
        /// This member is required.
        public var numericOperator: CostExplorerClientTypes.NumericOperator?
        /// The lower bound dollar value that's used in the filter.
        /// This member is required.
        public var startValue: Swift.Double

        public init(
            endValue: Swift.Double = 0.0,
            numericOperator: CostExplorerClientTypes.NumericOperator? = nil,
            startValue: Swift.Double = 0.0
        )
        {
            self.endValue = endValue
            self.numericOperator = numericOperator
            self.startValue = startValue
        }
    }

}

extension UnknownMonitorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnknownMonitorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The cost anomaly monitor does not exist for the account.
public struct UnknownMonitorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownMonitorException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnknownMonitorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownMonitorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownSubscriptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnknownSubscriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The cost anomaly subscription does not exist for the account.
public struct UnknownSubscriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnknownSubscriptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnknownSubscriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnknownSubscriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnresolvableUsageUnitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnresolvableUsageUnitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Cost Explorer was unable to identify the usage unit. Provide UsageType/UsageTypeGroup filter selections that contain matching units, for example: hours.
public struct UnresolvableUsageUnitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnresolvableUsageUnitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnresolvableUsageUnitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnresolvableUsageUnitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTagKeys = "ResourceTagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceTagKeys = resourceTagKeys {
            var resourceTagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTagKeys)
            for resourcetagkey0 in resourceTagKeys {
                try resourceTagKeysContainer.encode(resourcetagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource. For a list of supported resources, see [ResourceTag](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_ResourceTag.html).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys associated with tags that need to be removed from the resource. If you specify a tag key that doesn't exist, it's ignored. Although the maximum number of array members is 200, user-tag maximum is 50. The remaining are reserved for Amazon Web Services use.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let resourceTagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case resourceTagKeys = "ResourceTagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceTagKeys)
        var resourceTagKeysDecoded0:[Swift.String]? = nil
        if let resourceTagKeysContainer = resourceTagKeysContainer {
            resourceTagKeysDecoded0 = [Swift.String]()
            for string0 in resourceTagKeysContainer {
                if let string0 = string0 {
                    resourceTagKeysDecoded0?.append(string0)
                }
            }
        }
        resourceTagKeys = resourceTagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnomalyMonitorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = self.monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = self.monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
    }
}

extension UpdateAnomalyMonitorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAnomalyMonitorInput: Swift.Equatable {
    /// Cost anomaly monitor Amazon Resource Names (ARNs).
    /// This member is required.
    public var monitorArn: Swift.String?
    /// The new name for the cost anomaly monitor.
    public var monitorName: Swift.String?

    public init(
        monitorArn: Swift.String? = nil,
        monitorName: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
        self.monitorName = monitorName
    }
}

struct UpdateAnomalyMonitorInputBody: Swift.Equatable {
    let monitorArn: Swift.String?
    let monitorName: Swift.String?
}

extension UpdateAnomalyMonitorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
    }
}

extension UpdateAnomalyMonitorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnomalyMonitorOutputBody = try responseDecoder.decode(responseBody: data)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct UpdateAnomalyMonitorOutput: Swift.Equatable {
    /// A cost anomaly monitor ARN.
    /// This member is required.
    public var monitorArn: Swift.String?

    public init(
        monitorArn: Swift.String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct UpdateAnomalyMonitorOutputBody: Swift.Equatable {
    let monitorArn: Swift.String?
}

extension UpdateAnomalyMonitorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

enum UpdateAnomalyMonitorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownMonitorException": return try await UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnomalySubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
        case thresholdExpression = "ThresholdExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for arn0 in monitorArnList {
                try monitorArnListContainer.encode(arn0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
        if let subscriptionArn = self.subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = self.subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdExpression = self.thresholdExpression {
            try encodeContainer.encode(thresholdExpression, forKey: .thresholdExpression)
        }
    }
}

extension UpdateAnomalySubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAnomalySubscriptionInput: Swift.Equatable {
    /// The update to the frequency value that subscribers receive notifications.
    public var frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
    /// A list of cost anomaly monitor ARNs.
    public var monitorArnList: [Swift.String]?
    /// The update to the subscriber list.
    public var subscribers: [CostExplorerClientTypes.Subscriber]?
    /// A cost anomaly subscription Amazon Resource Name (ARN).
    /// This member is required.
    public var subscriptionArn: Swift.String?
    /// The new name of the subscription.
    public var subscriptionName: Swift.String?
    /// (deprecated) The update to the threshold value for receiving notifications. This field has been deprecated. To update a threshold, use ThresholdExpression. Continued use of Threshold will be treated as shorthand syntax for a ThresholdExpression. You can specify either Threshold or ThresholdExpression, but not both.
    @available(*, deprecated, message: "Threshold has been deprecated in favor of ThresholdExpression")
    public var threshold: Swift.Double?
    /// The update to the [Expression](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html) object used to specify the anomalies that you want to generate alerts for. This supports dimensions and nested expressions. The supported dimensions are ANOMALY_TOTAL_IMPACT_ABSOLUTE and ANOMALY_TOTAL_IMPACT_PERCENTAGE, corresponding to an anomaly’s TotalImpact and TotalImpactPercentage, respectively (see [Impact](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Impact.html) for more details). The supported nested expression types are AND and OR. The match option GREATER_THAN_OR_EQUAL is required. Values must be numbers between 0 and 10,000,000,000 in string format. You can specify either Threshold or ThresholdExpression, but not both. The following are examples of valid ThresholdExpressions:
    ///
    /// * Absolute threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
    ///
    /// * Percentage threshold: { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }
    ///
    /// * AND two thresholds together: { "And": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
    ///
    /// * OR two thresholds together: { "Or": [ { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_ABSOLUTE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } }, { "Dimensions": { "Key": "ANOMALY_TOTAL_IMPACT_PERCENTAGE", "MatchOptions": [ "GREATER_THAN_OR_EQUAL" ], "Values": [ "100" ] } } ] }
    public var thresholdExpression: CostExplorerClientTypes.Expression?

    public init(
        frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency? = nil,
        monitorArnList: [Swift.String]? = nil,
        subscribers: [CostExplorerClientTypes.Subscriber]? = nil,
        subscriptionArn: Swift.String? = nil,
        subscriptionName: Swift.String? = nil,
        threshold: Swift.Double? = nil,
        thresholdExpression: CostExplorerClientTypes.Expression? = nil
    )
    {
        self.frequency = frequency
        self.monitorArnList = monitorArnList
        self.subscribers = subscribers
        self.subscriptionArn = subscriptionArn
        self.subscriptionName = subscriptionName
        self.threshold = threshold
        self.thresholdExpression = thresholdExpression
    }
}

struct UpdateAnomalySubscriptionInputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
    let threshold: Swift.Double?
    let frequency: CostExplorerClientTypes.AnomalySubscriptionFrequency?
    let monitorArnList: [Swift.String]?
    let subscribers: [CostExplorerClientTypes.Subscriber]?
    let subscriptionName: Swift.String?
    let thresholdExpression: CostExplorerClientTypes.Expression?
}

extension UpdateAnomalySubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
        case thresholdExpression = "ThresholdExpression"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[Swift.String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [Swift.String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[CostExplorerClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [CostExplorerClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
        let thresholdExpressionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.Expression.self, forKey: .thresholdExpression)
        thresholdExpression = thresholdExpressionDecoded
    }
}

extension UpdateAnomalySubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnomalySubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct UpdateAnomalySubscriptionOutput: Swift.Equatable {
    /// A cost anomaly subscription ARN.
    /// This member is required.
    public var subscriptionArn: Swift.String?

    public init(
        subscriptionArn: Swift.String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct UpdateAnomalySubscriptionOutputBody: Swift.Equatable {
    let subscriptionArn: Swift.String?
}

extension UpdateAnomalySubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

enum UpdateAnomalySubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownMonitorException": return try await UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnknownSubscriptionException": return try await UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.UpdateCostAllocationTagsStatusError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
        case tagKey = "TagKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let tagKey = self.tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostExplorerClientTypes {
    /// Gives a detailed description of the result of an action. It's on each cost allocation tag entry in the request.
    public struct UpdateCostAllocationTagsStatusError: Swift.Equatable {
        /// An error code representing why the action failed on this entry.
        public var code: Swift.String?
        /// A message explaining why the action failed on this entry.
        public var message: Swift.String?
        /// The key for the cost allocation tag.
        public var tagKey: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            tagKey: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.tagKey = tagKey
        }
    }

}

extension UpdateCostAllocationTagsStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costAllocationTagsStatus = "CostAllocationTagsStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costAllocationTagsStatus = costAllocationTagsStatus {
            var costAllocationTagsStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .costAllocationTagsStatus)
            for costallocationtagstatusentry0 in costAllocationTagsStatus {
                try costAllocationTagsStatusContainer.encode(costallocationtagstatusentry0)
            }
        }
    }
}

extension UpdateCostAllocationTagsStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCostAllocationTagsStatusInput: Swift.Equatable {
    /// The list of CostAllocationTagStatusEntry objects that are used to update cost allocation tags status for this request.
    /// This member is required.
    public var costAllocationTagsStatus: [CostExplorerClientTypes.CostAllocationTagStatusEntry]?

    public init(
        costAllocationTagsStatus: [CostExplorerClientTypes.CostAllocationTagStatusEntry]? = nil
    )
    {
        self.costAllocationTagsStatus = costAllocationTagsStatus
    }
}

struct UpdateCostAllocationTagsStatusInputBody: Swift.Equatable {
    let costAllocationTagsStatus: [CostExplorerClientTypes.CostAllocationTagStatusEntry]?
}

extension UpdateCostAllocationTagsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costAllocationTagsStatus = "CostAllocationTagsStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costAllocationTagsStatusContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostAllocationTagStatusEntry?].self, forKey: .costAllocationTagsStatus)
        var costAllocationTagsStatusDecoded0:[CostExplorerClientTypes.CostAllocationTagStatusEntry]? = nil
        if let costAllocationTagsStatusContainer = costAllocationTagsStatusContainer {
            costAllocationTagsStatusDecoded0 = [CostExplorerClientTypes.CostAllocationTagStatusEntry]()
            for structure0 in costAllocationTagsStatusContainer {
                if let structure0 = structure0 {
                    costAllocationTagsStatusDecoded0?.append(structure0)
                }
            }
        }
        costAllocationTagsStatus = costAllocationTagsStatusDecoded0
    }
}

extension UpdateCostAllocationTagsStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCostAllocationTagsStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct UpdateCostAllocationTagsStatusOutput: Swift.Equatable {
    /// A list of UpdateCostAllocationTagsStatusError objects with error details about each cost allocation tag that can't be updated. If there's no failure, an empty array returns.
    public var errors: [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]?

    public init(
        errors: [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]? = nil
    )
    {
        self.errors = errors
    }
}

struct UpdateCostAllocationTagsStatusOutputBody: Swift.Equatable {
    let errors: [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]?
}

extension UpdateCostAllocationTagsStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "Errors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.UpdateCostAllocationTagsStatusError?].self, forKey: .errors)
        var errorsDecoded0:[CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CostExplorerClientTypes.UpdateCostAllocationTagsStatusError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum UpdateCostAllocationTagsStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCostCategoryDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveStart = "EffectiveStart"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = self.costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveStart = self.effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryrule0 in rules {
                try rulesContainer.encode(costcategoryrule0)
            }
        }
        if let splitChargeRules = splitChargeRules {
            var splitChargeRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .splitChargeRules)
            for costcategorysplitchargerule0 in splitChargeRules {
                try splitChargeRulesContainer.encode(costcategorysplitchargerule0)
            }
        }
    }
}

extension UpdateCostCategoryDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCostCategoryDefinitionInput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    /// This member is required.
    public var costCategoryArn: Swift.String?
    /// The default value for the cost category.
    public var defaultValue: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month). If the date isn't provided, it's the first day of the current month. Dates can't be before the previous twelve months, or in the future.
    public var effectiveStart: Swift.String?
    /// The rule schema version in this particular Cost Category.
    /// This member is required.
    public var ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    /// The Expression object used to categorize costs. For more information, see [CostCategoryRule ](https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html).
    /// This member is required.
    public var rules: [CostExplorerClientTypes.CostCategoryRule]?
    /// The split charge rules used to allocate your charges between your Cost Category values.
    public var splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?

    public init(
        costCategoryArn: Swift.String? = nil,
        defaultValue: Swift.String? = nil,
        effectiveStart: Swift.String? = nil,
        ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion? = nil,
        rules: [CostExplorerClientTypes.CostCategoryRule]? = nil,
        splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.effectiveStart = effectiveStart
        self.ruleVersion = ruleVersion
        self.rules = rules
        self.splitChargeRules = splitChargeRules
    }
}

struct UpdateCostCategoryDefinitionInputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveStart: Swift.String?
    let ruleVersion: CostExplorerClientTypes.CostCategoryRuleVersion?
    let rules: [CostExplorerClientTypes.CostCategoryRule]?
    let defaultValue: Swift.String?
    let splitChargeRules: [CostExplorerClientTypes.CostCategorySplitChargeRule]?
}

extension UpdateCostCategoryDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveStart = "EffectiveStart"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
        case splitChargeRules = "SplitChargeRules"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostExplorerClientTypes.CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostExplorerClientTypes.CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let splitChargeRulesContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.CostCategorySplitChargeRule?].self, forKey: .splitChargeRules)
        var splitChargeRulesDecoded0:[CostExplorerClientTypes.CostCategorySplitChargeRule]? = nil
        if let splitChargeRulesContainer = splitChargeRulesContainer {
            splitChargeRulesDecoded0 = [CostExplorerClientTypes.CostCategorySplitChargeRule]()
            for structure0 in splitChargeRulesContainer {
                if let structure0 = structure0 {
                    splitChargeRulesDecoded0?.append(structure0)
                }
            }
        }
        splitChargeRules = splitChargeRulesDecoded0
    }
}

extension UpdateCostCategoryDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCostCategoryDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct UpdateCostCategoryDefinitionOutput: Swift.Equatable {
    /// The unique identifier for your Cost Category.
    public var costCategoryArn: Swift.String?
    /// The Cost Category's effective start date. It can only be a billing start date (first day of the month).
    public var effectiveStart: Swift.String?

    public init(
        costCategoryArn: Swift.String? = nil,
        effectiveStart: Swift.String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct UpdateCostCategoryDefinitionOutputBody: Swift.Equatable {
    let costCategoryArn: Swift.String?
    let effectiveStart: Swift.String?
}

extension UpdateCostCategoryDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

enum UpdateCostCategoryDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostExplorerClientTypes.UtilizationByTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationutilizationgroup0 in groups {
                try groupsContainer.encode(reservationutilizationgroup0)
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([CostExplorerClientTypes.ReservationUtilizationGroup?].self, forKey: .groups)
        var groupsDecoded0:[CostExplorerClientTypes.ReservationUtilizationGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [CostExplorerClientTypes.ReservationUtilizationGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(CostExplorerClientTypes.ReservationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

extension CostExplorerClientTypes {
    /// The amount of utilization, in hours.
    public struct UtilizationByTime: Swift.Equatable {
        /// The groups that this utilization result uses.
        public var groups: [CostExplorerClientTypes.ReservationUtilizationGroup]?
        /// The period of time that this utilization was used for.
        public var timePeriod: CostExplorerClientTypes.DateInterval?
        /// The total number of reservation hours that were used.
        public var total: CostExplorerClientTypes.ReservationAggregates?

        public init(
            groups: [CostExplorerClientTypes.ReservationUtilizationGroup]? = nil,
            timePeriod: CostExplorerClientTypes.DateInterval? = nil,
            total: CostExplorerClientTypes.ReservationAggregates? = nil
        )
        {
            self.groups = groups
            self.timePeriod = timePeriod
            self.total = total
        }
    }

}
