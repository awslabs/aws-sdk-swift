// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates the specified AttackId does not exist, or the requester does not have the appropriate permissions to access the AttackId.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedForDependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedForDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// In order to grant the necessary access to the Shield Response Team (SRT) the user submitting the request must have the iam:PassRole permission. This error indicates the user did not have the appropriate permissions. For more information, see [Granting a User Permissions to Pass a Role to an Amazon Web Services Service](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html).
public struct AccessDeniedForDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedForDependencyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedForDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedForDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ApplicationLayerAutomaticResponseStatus.self, forKey: .status)
        status = statusDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension ShieldClientTypes {
    /// The automatic application layer DDoS mitigation settings for a [Protection]. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
    public struct ApplicationLayerAutomaticResponseConfiguration: Swift.Equatable {
        /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
        /// This member is required.
        public var action: ShieldClientTypes.ResponseAction?
        /// Indicates whether automatic application layer DDoS mitigation is enabled for the protection.
        /// This member is required.
        public var status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus?

        public init(
            action: ShieldClientTypes.ResponseAction? = nil,
            status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus? = nil
        )
        {
            self.action = action
            self.status = status
        }
    }

}

extension ShieldClientTypes {
    public enum ApplicationLayerAutomaticResponseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLayerAutomaticResponseStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationLayerAutomaticResponseStatus(rawValue: rawValue) ?? ApplicationLayerAutomaticResponseStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateDRTLogBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = self.logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

extension AssociateDRTLogBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDRTLogBucketInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init(
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct AssociateDRTLogBucketInputBody: Swift.Equatable {
    let logBucket: Swift.String?
}

extension AssociateDRTLogBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension AssociateDRTLogBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDRTLogBucketOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDRTLogBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedForDependencyException": return try await AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitsExceededException": return try await LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAssociatedRoleException": return try await NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateDRTRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateDRTRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDRTRoleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the role the SRT will use to access your Amazon Web Services account. Prior to making the AssociateDRTRole request, you must attach the [AWSShieldDRTAccessPolicy](https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy) managed policy to this role. For more information see [Attaching and Detaching IAM Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateDRTRoleInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateDRTRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateDRTRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateDRTRoleOutput: Swift.Equatable {

    public init() { }
}

enum AssociateDRTRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedForDependencyException": return try await AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateHealthCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = self.healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = self.protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension AssociateHealthCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateHealthCheckInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the health check to associate with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to add the health check association to.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct AssociateHealthCheckInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let healthCheckArn: Swift.String?
}

extension AssociateHealthCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension AssociateHealthCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateHealthCheckOutput: Swift.Equatable {

    public init() { }
}

enum AssociateHealthCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitsExceededException": return try await LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateProactiveEngagementDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontact0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontact0)
            }
        }
    }
}

extension AssociateProactiveEngagementDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateProactiveEngagementDetailsInput: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you for escalations to the SRT and to initiate proactive customer support. To enable proactive engagement, the contact list must include at least one phone number. The contacts that you provide here replace any contacts that were already defined. If you already have contacts defined and want to use them, retrieve the list using DescribeEmergencyContactSettings and then provide it here.
    /// This member is required.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct AssociateProactiveEngagementDetailsInputBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension AssociateProactiveEngagementDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension AssociateProactiveEngagementDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateProactiveEngagementDetailsOutput: Swift.Equatable {

    public init() { }
}

enum AssociateProactiveEngagementDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShieldClientTypes.AttackDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackCounters = "AttackCounters"
        case attackId = "AttackId"
        case attackProperties = "AttackProperties"
        case endTime = "EndTime"
        case mitigations = "Mitigations"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
        case subResources = "SubResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackCounters = attackCounters {
            var attackCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackCounters)
            for summarizedcounter0 in attackCounters {
                try attackCountersContainer.encode(summarizedcounter0)
            }
        }
        if let attackId = self.attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackProperties = attackProperties {
            var attackPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackProperties)
            for attackproperty0 in attackProperties {
                try attackPropertiesContainer.encode(attackproperty0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let mitigations = mitigations {
            var mitigationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mitigations)
            for mitigation0 in mitigations {
                try mitigationsContainer.encode(mitigation0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let subResources = subResources {
            var subResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subResources)
            for subresourcesummary0 in subResources {
                try subResourcesContainer.encode(subresourcesummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let subResourcesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SubResourceSummary?].self, forKey: .subResources)
        var subResourcesDecoded0:[ShieldClientTypes.SubResourceSummary]? = nil
        if let subResourcesContainer = subResourcesContainer {
            subResourcesDecoded0 = [ShieldClientTypes.SubResourceSummary]()
            for structure0 in subResourcesContainer {
                if let structure0 = structure0 {
                    subResourcesDecoded0?.append(structure0)
                }
            }
        }
        subResources = subResourcesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let attackCountersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .attackCounters)
        var attackCountersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let attackCountersContainer = attackCountersContainer {
            attackCountersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in attackCountersContainer {
                if let structure0 = structure0 {
                    attackCountersDecoded0?.append(structure0)
                }
            }
        }
        attackCounters = attackCountersDecoded0
        let attackPropertiesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackProperty?].self, forKey: .attackProperties)
        var attackPropertiesDecoded0:[ShieldClientTypes.AttackProperty]? = nil
        if let attackPropertiesContainer = attackPropertiesContainer {
            attackPropertiesDecoded0 = [ShieldClientTypes.AttackProperty]()
            for structure0 in attackPropertiesContainer {
                if let structure0 = structure0 {
                    attackPropertiesDecoded0?.append(structure0)
                }
            }
        }
        attackProperties = attackPropertiesDecoded0
        let mitigationsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Mitigation?].self, forKey: .mitigations)
        var mitigationsDecoded0:[ShieldClientTypes.Mitigation]? = nil
        if let mitigationsContainer = mitigationsContainer {
            mitigationsDecoded0 = [ShieldClientTypes.Mitigation]()
            for structure0 in mitigationsContainer {
                if let structure0 = structure0 {
                    mitigationsDecoded0?.append(structure0)
                }
            }
        }
        mitigations = mitigationsDecoded0
    }
}

extension ShieldClientTypes {
    /// The details of a DDoS attack.
    public struct AttackDetail: Swift.Equatable {
        /// List of counters that describe the attack for the specified time period.
        public var attackCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The array of objects that provide details of the Shield event. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackProperties: [ShieldClientTypes.AttackProperty]?
        /// The time the attack ended, in Unix time in seconds.
        public var endTime: ClientRuntime.Date?
        /// List of mitigation actions taken for the attack.
        public var mitigations: [ShieldClientTypes.Mitigation]?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The time the attack started, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?
        /// If applicable, additional detail about the resource being attacked, for example, IP address or URL.
        public var subResources: [ShieldClientTypes.SubResourceSummary]?

        public init(
            attackCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            attackId: Swift.String? = nil,
            attackProperties: [ShieldClientTypes.AttackProperty]? = nil,
            endTime: ClientRuntime.Date? = nil,
            mitigations: [ShieldClientTypes.Mitigation]? = nil,
            resourceArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            subResources: [ShieldClientTypes.SubResourceSummary]? = nil
        )
        {
            self.attackCounters = attackCounters
            self.attackId = attackId
            self.attackProperties = attackProperties
            self.endTime = endTime
            self.mitigations = mitigations
            self.resourceArn = resourceArn
            self.startTime = startTime
            self.subResources = subResources
        }
    }

}

extension ShieldClientTypes {
    public enum AttackLayer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackLayer] {
            return [
                .application,
                .network,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .network: return "NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttackLayer(rawValue: rawValue) ?? AttackLayer.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.AttackProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackLayer = "AttackLayer"
        case attackPropertyIdentifier = "AttackPropertyIdentifier"
        case topContributors = "TopContributors"
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackLayer = self.attackLayer {
            try encodeContainer.encode(attackLayer.rawValue, forKey: .attackLayer)
        }
        if let attackPropertyIdentifier = self.attackPropertyIdentifier {
            try encodeContainer.encode(attackPropertyIdentifier.rawValue, forKey: .attackPropertyIdentifier)
        }
        if let topContributors = topContributors {
            var topContributorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topContributors)
            for contributor0 in topContributors {
                try topContributorsContainer.encode(contributor0)
            }
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackLayerDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackLayer.self, forKey: .attackLayer)
        attackLayer = attackLayerDecoded
        let attackPropertyIdentifierDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackPropertyIdentifier.self, forKey: .attackPropertyIdentifier)
        attackPropertyIdentifier = attackPropertyIdentifierDecoded
        let topContributorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Contributor?].self, forKey: .topContributors)
        var topContributorsDecoded0:[ShieldClientTypes.Contributor]? = nil
        if let topContributorsContainer = topContributorsContainer {
            topContributorsDecoded0 = [ShieldClientTypes.Contributor]()
            for structure0 in topContributorsContainer {
                if let structure0 = structure0 {
                    topContributorsDecoded0?.append(structure0)
                }
            }
        }
        topContributors = topContributorsDecoded0
        let unitDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total) ?? 0
        total = totalDecoded
    }
}

extension ShieldClientTypes {
    /// Details of a Shield event. This is provided as part of an [AttackDetail].
    public struct AttackProperty: Swift.Equatable {
        /// The type of Shield event that was observed. NETWORK indicates layer 3 and layer 4 events and APPLICATION indicates layer 7 events. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackLayer: ShieldClientTypes.AttackLayer?
        /// Defines the Shield event property information that is provided. The WORDPRESS_PINGBACK_REFLECTOR and WORDPRESS_PINGBACK_SOURCE values are valid only for WordPress reflective pingback events.
        public var attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier?
        /// Contributor objects for the top five contributors to a Shield event. A contributor is a source of traffic that Shield Advanced identifies as responsible for some or all of an event.
        public var topContributors: [ShieldClientTypes.Contributor]?
        /// The total contributions made to this Shield event by all contributors.
        public var total: Swift.Int
        /// The unit used for the ContributorValue property.
        public var unit: ShieldClientTypes.Unit?

        public init(
            attackLayer: ShieldClientTypes.AttackLayer? = nil,
            attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier? = nil,
            topContributors: [ShieldClientTypes.Contributor]? = nil,
            total: Swift.Int = 0,
            unit: ShieldClientTypes.Unit? = nil
        )
        {
            self.attackLayer = attackLayer
            self.attackPropertyIdentifier = attackPropertyIdentifier
            self.topContributors = topContributors
            self.total = total
            self.unit = unit
        }
    }

}

extension ShieldClientTypes {
    public enum AttackPropertyIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destinationUrl
        case referrer
        case sourceAsn
        case sourceCountry
        case sourceIpAddress
        case sourceUserAgent
        case wordpressPingbackReflector
        case wordpressPingbackSource
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackPropertyIdentifier] {
            return [
                .destinationUrl,
                .referrer,
                .sourceAsn,
                .sourceCountry,
                .sourceIpAddress,
                .sourceUserAgent,
                .wordpressPingbackReflector,
                .wordpressPingbackSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destinationUrl: return "DESTINATION_URL"
            case .referrer: return "REFERRER"
            case .sourceAsn: return "SOURCE_ASN"
            case .sourceCountry: return "SOURCE_COUNTRY"
            case .sourceIpAddress: return "SOURCE_IP_ADDRESS"
            case .sourceUserAgent: return "SOURCE_USER_AGENT"
            case .wordpressPingbackReflector: return "WORDPRESS_PINGBACK_REFLECTOR"
            case .wordpressPingbackSource: return "WORDPRESS_PINGBACK_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttackPropertyIdentifier(rawValue: rawValue) ?? AttackPropertyIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.AttackStatisticsDataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackCount = "AttackCount"
        case attackVolume = "AttackVolume"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attackCount != 0 {
            try encodeContainer.encode(attackCount, forKey: .attackCount)
        }
        if let attackVolume = self.attackVolume {
            try encodeContainer.encode(attackVolume, forKey: .attackVolume)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackVolumeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolume.self, forKey: .attackVolume)
        attackVolume = attackVolumeDecoded
        let attackCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attackCount) ?? 0
        attackCount = attackCountDecoded
    }
}

extension ShieldClientTypes {
    /// A single attack statistics data record. This is returned by [DescribeAttackStatistics] along with a time range indicating the time period that the attack statistics apply to.
    public struct AttackStatisticsDataItem: Swift.Equatable {
        /// The number of attacks detected during the time period. This is always present, but might be zero.
        /// This member is required.
        public var attackCount: Swift.Int
        /// Information about the volume of attacks during the time period. If the accompanying AttackCount is zero, this setting might be empty.
        public var attackVolume: ShieldClientTypes.AttackVolume?

        public init(
            attackCount: Swift.Int = 0,
            attackVolume: ShieldClientTypes.AttackVolume? = nil
        )
        {
            self.attackCount = attackCount
            self.attackVolume = attackVolume
        }
    }

}

extension ShieldClientTypes.AttackSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
        case attackVectors = "AttackVectors"
        case endTime = "EndTime"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = self.attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for attackvectordescription0 in attackVectors {
                try attackVectorsContainer.encode(attackvectordescription0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackVectorDescription?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[ShieldClientTypes.AttackVectorDescription]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [ShieldClientTypes.AttackVectorDescription]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
    }
}

extension ShieldClientTypes {
    /// Summarizes all DDoS attacks for a specified time period.
    public struct AttackSummary: Swift.Equatable {
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The list of attacks for a specified time period.
        public var attackVectors: [ShieldClientTypes.AttackVectorDescription]?
        /// The end time of the attack, in Unix time in seconds.
        public var endTime: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The start time of the attack, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?

        public init(
            attackId: Swift.String? = nil,
            attackVectors: [ShieldClientTypes.AttackVectorDescription]? = nil,
            endTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.attackId = attackId
            self.attackVectors = attackVectors
            self.endTime = endTime
            self.resourceArn = resourceArn
            self.startTime = startTime
        }
    }

}

extension ShieldClientTypes.AttackVectorDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorType = self.vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
    }
}

extension ShieldClientTypes {
    /// Describes the attack.
    public struct AttackVectorDescription: Swift.Equatable {
        /// The attack type. Valid values:
        ///
        /// * UDP_TRAFFIC
        ///
        /// * UDP_FRAGMENT
        ///
        /// * GENERIC_UDP_REFLECTION
        ///
        /// * DNS_REFLECTION
        ///
        /// * NTP_REFLECTION
        ///
        /// * CHARGEN_REFLECTION
        ///
        /// * SSDP_REFLECTION
        ///
        /// * PORT_MAPPER
        ///
        /// * RIP_REFLECTION
        ///
        /// * SNMP_REFLECTION
        ///
        /// * MSSQL_REFLECTION
        ///
        /// * NET_BIOS_REFLECTION
        ///
        /// * SYN_FLOOD
        ///
        /// * ACK_FLOOD
        ///
        /// * REQUEST_FLOOD
        ///
        /// * HTTP_REFLECTION
        ///
        /// * UDS_REFLECTION
        ///
        /// * MEMCACHED_REFLECTION
        /// This member is required.
        public var vectorType: Swift.String?

        public init(
            vectorType: Swift.String? = nil
        )
        {
            self.vectorType = vectorType
        }
    }

}

extension ShieldClientTypes.AttackVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitsPerSecond = "BitsPerSecond"
        case packetsPerSecond = "PacketsPerSecond"
        case requestsPerSecond = "RequestsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitsPerSecond = self.bitsPerSecond {
            try encodeContainer.encode(bitsPerSecond, forKey: .bitsPerSecond)
        }
        if let packetsPerSecond = self.packetsPerSecond {
            try encodeContainer.encode(packetsPerSecond, forKey: .packetsPerSecond)
        }
        if let requestsPerSecond = self.requestsPerSecond {
            try encodeContainer.encode(requestsPerSecond, forKey: .requestsPerSecond)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bitsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .bitsPerSecond)
        bitsPerSecond = bitsPerSecondDecoded
        let packetsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .packetsPerSecond)
        packetsPerSecond = packetsPerSecondDecoded
        let requestsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .requestsPerSecond)
        requestsPerSecond = requestsPerSecondDecoded
    }
}

extension ShieldClientTypes {
    /// Information about the volume of attacks during the time period, included in an [AttackStatisticsDataItem]. If the accompanying AttackCount in the statistics object is zero, this setting might be empty.
    public struct AttackVolume: Swift.Equatable {
        /// A statistics object that uses bits per second as the unit. This is included for network level attacks.
        public var bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses packets per second as the unit. This is included for network level attacks.
        public var packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses requests per second as the unit. This is included for application level attacks, and is only available for accounts that are subscribed to Shield Advanced.
        public var requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics?

        public init(
            bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil
        )
        {
            self.bitsPerSecond = bitsPerSecond
            self.packetsPerSecond = packetsPerSecond
            self.requestsPerSecond = requestsPerSecond
        }
    }

}

extension ShieldClientTypes.AttackVolumeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max) ?? 0.0
        max = maxDecoded
    }
}

extension ShieldClientTypes {
    /// Statistics objects for the various data types in [AttackVolume].
    public struct AttackVolumeStatistics: Swift.Equatable {
        /// The maximum attack volume observed for the given unit.
        /// This member is required.
        public var max: Swift.Double

        public init(
            max: Swift.Double = 0.0
        )
        {
            self.max = max
        }
    }

}

extension ShieldClientTypes {
    public enum AutoRenew: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRenew] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoRenew(rawValue: rawValue) ?? AutoRenew.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.BlockAction: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ShieldClientTypes {
    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. This is only used in the context of the ResponseAction setting. JSON specification: "Block": {}
    public struct BlockAction: Swift.Equatable {

        public init() { }
    }

}

extension ShieldClientTypes.Contributor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .value) ?? 0
        value = valueDecoded
    }
}

extension ShieldClientTypes {
    /// A contributor to the attack and their contribution.
    public struct Contributor: Swift.Equatable {
        /// The name of the contributor. The type of name that you'll find here depends on the AttackPropertyIdentifier setting in the AttackProperty where this contributor is defined. For example, if the AttackPropertyIdentifier is SOURCE_COUNTRY, the Name could be United States.
        public var name: Swift.String?
        /// The contribution of this contributor expressed in [Protection] units. For example 10,000.
        public var value: Swift.Int

        public init(
            name: Swift.String? = nil,
            value: Swift.Int = 0
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ShieldClientTypes.CountAction: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ShieldClientTypes {
    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. This is only used in the context of the ResponseAction setting. JSON specification: "Count": {}
    public struct CountAction: Swift.Equatable {

        public init() { }
    }

}

extension CreateProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = self.aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for resourcearn0 in members {
                try membersContainer.encode(resourcearn0)
            }
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProtectionGroupInput: Swift.Equatable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?
    /// One or more tag key-value pairs for the protection group.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct CreateProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    let pattern: ShieldClientTypes.ProtectionGroupPattern?
    let resourceType: ShieldClientTypes.ProtectedResourceType?
    let members: [Swift.String]?
    let tags: [ShieldClientTypes.Tag]?
}

extension CreateProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateProtectionGroupOutput: Swift.Equatable {

    public init() { }
}

enum CreateProtectionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitsExceededException": return try await LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProtectionInput: Swift.Equatable {
    /// Friendly name for the Protection you are creating.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN (Amazon Resource Name) of the resource to be protected. The ARN should be in one of the following formats:
    ///
    /// * For an Application Load Balancer: arn:aws:elasticloadbalancing:region:account-id:loadbalancer/app/load-balancer-name/load-balancer-id
    ///
    /// * For an Elastic Load Balancer (Classic Load Balancer): arn:aws:elasticloadbalancing:region:account-id:loadbalancer/load-balancer-name
    ///
    /// * For an Amazon CloudFront distribution: arn:aws:cloudfront::account-id:distribution/distribution-id
    ///
    /// * For an Global Accelerator standard accelerator: arn:aws:globalaccelerator::account-id:accelerator/accelerator-id
    ///
    /// * For Amazon Route 53: arn:aws:route53:::hostedzone/hosted-zone-id
    ///
    /// * For an Elastic IP address: arn:aws:ec2:region:account-id:eip-allocation/allocation-id
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag key-value pairs for the [Protection] object that is created.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateProtectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let resourceArn: Swift.String?
    let tags: [ShieldClientTypes.Tag]?
}

extension CreateProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProtectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.protectionId = output.protectionId
        } else {
            self.protectionId = nil
        }
    }
}

public struct CreateProtectionOutput: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object that is created.
    public var protectionId: Swift.String?

    public init(
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct CreateProtectionOutputBody: Swift.Equatable {
    let protectionId: Swift.String?
}

extension CreateProtectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

enum CreateProtectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitsExceededException": return try await LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension CreateSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct CreateSubscriptionInputBody: Swift.Equatable {
}

extension CreateSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum CreateSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension DeleteProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtectionGroupInput: Swift.Equatable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DeleteProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
}

extension DeleteProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DeleteProtectionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProtectionGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProtectionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = self.protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension DeleteProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtectionInput: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object to be deleted.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct DeleteProtectionInputBody: Swift.Equatable {
    let protectionId: Swift.String?
}

extension DeleteProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

extension DeleteProtectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProtectionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProtectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct DeleteSubscriptionInputBody: Swift.Equatable {
}

extension DeleteSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LockedSubscriptionException": return try await LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAttackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = self.attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
    }
}

extension DescribeAttackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAttackInput: Swift.Equatable {
    /// The unique identifier (ID) for the attack.
    /// This member is required.
    public var attackId: Swift.String?

    public init(
        attackId: Swift.String? = nil
    )
    {
        self.attackId = attackId
    }
}

struct DescribeAttackInputBody: Swift.Equatable {
    let attackId: Swift.String?
}

extension DescribeAttackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
    }
}

extension DescribeAttackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAttackOutputBody = try responseDecoder.decode(responseBody: data)
            self.attack = output.attack
        } else {
            self.attack = nil
        }
    }
}

public struct DescribeAttackOutput: Swift.Equatable {
    /// The attack that you requested.
    public var attack: ShieldClientTypes.AttackDetail?

    public init(
        attack: ShieldClientTypes.AttackDetail? = nil
    )
    {
        self.attack = attack
    }
}

struct DescribeAttackOutputBody: Swift.Equatable {
    let attack: ShieldClientTypes.AttackDetail?
}

extension DescribeAttackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attack = "Attack"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackDetail.self, forKey: .attack)
        attack = attackDecoded
    }
}

enum DescribeAttackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAttackStatisticsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAttackStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAttackStatisticsInput: Swift.Equatable {

    public init() { }
}

struct DescribeAttackStatisticsInputBody: Swift.Equatable {
}

extension DescribeAttackStatisticsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAttackStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAttackStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataItems = output.dataItems
            self.timeRange = output.timeRange
        } else {
            self.dataItems = nil
            self.timeRange = nil
        }
    }
}

public struct DescribeAttackStatisticsOutput: Swift.Equatable {
    /// The data that describes the attacks detected during the time period.
    /// This member is required.
    public var dataItems: [ShieldClientTypes.AttackStatisticsDataItem]?
    /// The time range of the attack.
    /// This member is required.
    public var timeRange: ShieldClientTypes.TimeRange?

    public init(
        dataItems: [ShieldClientTypes.AttackStatisticsDataItem]? = nil,
        timeRange: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.dataItems = dataItems
        self.timeRange = timeRange
    }
}

struct DescribeAttackStatisticsOutputBody: Swift.Equatable {
    let timeRange: ShieldClientTypes.TimeRange?
    let dataItems: [ShieldClientTypes.AttackStatisticsDataItem]?
}

extension DescribeAttackStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataItems = "DataItems"
        case timeRange = "TimeRange"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let dataItemsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackStatisticsDataItem?].self, forKey: .dataItems)
        var dataItemsDecoded0:[ShieldClientTypes.AttackStatisticsDataItem]? = nil
        if let dataItemsContainer = dataItemsContainer {
            dataItemsDecoded0 = [ShieldClientTypes.AttackStatisticsDataItem]()
            for structure0 in dataItemsContainer {
                if let structure0 = structure0 {
                    dataItemsDecoded0?.append(structure0)
                }
            }
        }
        dataItems = dataItemsDecoded0
    }
}

enum DescribeAttackStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDRTAccessInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeDRTAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDRTAccessInput: Swift.Equatable {

    public init() { }
}

struct DescribeDRTAccessInputBody: Swift.Equatable {
}

extension DescribeDRTAccessInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDRTAccessOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDRTAccessOutputBody = try responseDecoder.decode(responseBody: data)
            self.logBucketList = output.logBucketList
            self.roleArn = output.roleArn
        } else {
            self.logBucketList = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeDRTAccessOutput: Swift.Equatable {
    /// The list of Amazon S3 buckets accessed by the SRT.
    public var logBucketList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the role the SRT used to access your Amazon Web Services account.
    public var roleArn: Swift.String?

    public init(
        logBucketList: [Swift.String]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logBucketList = logBucketList
        self.roleArn = roleArn
    }
}

struct DescribeDRTAccessOutputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let logBucketList: [Swift.String]?
}

extension DescribeDRTAccessOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucketList = "LogBucketList"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logBucketListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logBucketList)
        var logBucketListDecoded0:[Swift.String]? = nil
        if let logBucketListContainer = logBucketListContainer {
            logBucketListDecoded0 = [Swift.String]()
            for string0 in logBucketListContainer {
                if let string0 = string0 {
                    logBucketListDecoded0?.append(string0)
                }
            }
        }
        logBucketList = logBucketListDecoded0
    }
}

enum DescribeDRTAccessOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEmergencyContactSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeEmergencyContactSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEmergencyContactSettingsInput: Swift.Equatable {

    public init() { }
}

struct DescribeEmergencyContactSettingsInputBody: Swift.Equatable {
}

extension DescribeEmergencyContactSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEmergencyContactSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEmergencyContactSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.emergencyContactList = output.emergencyContactList
        } else {
            self.emergencyContactList = nil
        }
    }
}

public struct DescribeEmergencyContactSettingsOutput: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct DescribeEmergencyContactSettingsOutputBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension DescribeEmergencyContactSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

enum DescribeEmergencyContactSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension DescribeProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProtectionGroupInput: Swift.Equatable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DescribeProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
}

extension DescribeProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DescribeProtectionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProtectionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.protectionGroup = output.protectionGroup
        } else {
            self.protectionGroup = nil
        }
    }
}

public struct DescribeProtectionGroupOutput: Swift.Equatable {
    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    /// This member is required.
    public var protectionGroup: ShieldClientTypes.ProtectionGroup?

    public init(
        protectionGroup: ShieldClientTypes.ProtectionGroup? = nil
    )
    {
        self.protectionGroup = protectionGroup
    }
}

struct DescribeProtectionGroupOutputBody: Swift.Equatable {
    let protectionGroup: ShieldClientTypes.ProtectionGroup?
}

extension DescribeProtectionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroup = "ProtectionGroup"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroup.self, forKey: .protectionGroup)
        protectionGroup = protectionGroupDecoded
    }
}

enum DescribeProtectionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = self.protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DescribeProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProtectionInput: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object to describe. You must provide either the ResourceArn of the protected resource or the ProtectionID of the protection, but not both.
    public var protectionId: Swift.String?
    /// The ARN (Amazon Resource Name) of the protected Amazon Web Services resource. You must provide either the ResourceArn of the protected resource or the ProtectionID of the protection, but not both.
    public var resourceArn: Swift.String?

    public init(
        protectionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectionInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let resourceArn: Swift.String?
}

extension DescribeProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeProtectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProtectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.protection = output.protection
        } else {
            self.protection = nil
        }
    }
}

public struct DescribeProtectionOutput: Swift.Equatable {
    /// The [Protection] that you requested.
    public var protection: ShieldClientTypes.Protection?

    public init(
        protection: ShieldClientTypes.Protection? = nil
    )
    {
        self.protection = protection
    }
}

struct DescribeProtectionOutputBody: Swift.Equatable {
    let protection: ShieldClientTypes.Protection?
}

extension DescribeProtectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protection = "Protection"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Protection.self, forKey: .protection)
        protection = protectionDecoded
    }
}

enum DescribeProtectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSubscriptionInput: Swift.Equatable {

    public init() { }
}

struct DescribeSubscriptionInputBody: Swift.Equatable {
}

extension DescribeSubscriptionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSubscriptionOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct DescribeSubscriptionOutput: Swift.Equatable {
    /// The Shield Advanced subscription details for an account.
    public var subscription: ShieldClientTypes.Subscription?

    public init(
        subscription: ShieldClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct DescribeSubscriptionOutputBody: Swift.Equatable {
    let subscription: ShieldClientTypes.Subscription?
}

extension DescribeSubscriptionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscription = "Subscription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

enum DescribeSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DisableApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the protected resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DisableApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DisableApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DisableApplicationLayerAutomaticResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableApplicationLayerAutomaticResponseOutput: Swift.Equatable {

    public init() { }
}

enum DisableApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableProactiveEngagementInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisableProactiveEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableProactiveEngagementInput: Swift.Equatable {

    public init() { }
}

struct DisableProactiveEngagementInputBody: Swift.Equatable {
}

extension DisableProactiveEngagementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableProactiveEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableProactiveEngagementOutput: Swift.Equatable {

    public init() { }
}

enum DisableProactiveEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateDRTLogBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = self.logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

extension DisassociateDRTLogBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDRTLogBucketInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init(
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct DisassociateDRTLogBucketInputBody: Swift.Equatable {
    let logBucket: Swift.String?
}

extension DisassociateDRTLogBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension DisassociateDRTLogBucketOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDRTLogBucketOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDRTLogBucketOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedForDependencyException": return try await AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoAssociatedRoleException": return try await NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateDRTRoleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateDRTRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDRTRoleInput: Swift.Equatable {

    public init() { }
}

struct DisassociateDRTRoleInputBody: Swift.Equatable {
}

extension DisassociateDRTRoleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateDRTRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateDRTRoleOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateDRTRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateHealthCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = self.healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = self.protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension DisassociateHealthCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateHealthCheckInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the health check that is associated with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to remove the health check association from.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct DisassociateHealthCheckInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let healthCheckArn: Swift.String?
}

extension DisassociateHealthCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension DisassociateHealthCheckOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateHealthCheckOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateHealthCheckOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShieldClientTypes.EmergencyContact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactNotes = "ContactNotes"
        case emailAddress = "EmailAddress"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactNotes = self.contactNotes {
            try encodeContainer.encode(contactNotes, forKey: .contactNotes)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let contactNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactNotes)
        contactNotes = contactNotesDecoded
    }
}

extension ShieldClientTypes {
    /// Contact information that the SRT can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public struct EmergencyContact: Swift.Equatable {
        /// Additional notes regarding the contact.
        public var contactNotes: Swift.String?
        /// The email address for the contact.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The phone number for the contact.
        public var phoneNumber: Swift.String?

        public init(
            contactNotes: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.contactNotes = contactNotes
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }

}

extension EnableApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension EnableApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the protected resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

struct EnableApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let action: ShieldClientTypes.ResponseAction?
}

extension EnableApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension EnableApplicationLayerAutomaticResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableApplicationLayerAutomaticResponseOutput: Swift.Equatable {

    public init() { }
}

enum EnableApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitsExceededException": return try await LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableProactiveEngagementInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EnableProactiveEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableProactiveEngagementInput: Swift.Equatable {

    public init() { }
}

struct EnableProactiveEngagementInputBody: Swift.Equatable {
}

extension EnableProactiveEngagementInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableProactiveEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableProactiveEngagementOutput: Swift.Equatable {

    public init() { }
}

enum EnableProactiveEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionStateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSubscriptionStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSubscriptionStateInput: Swift.Equatable {

    public init() { }
}

struct GetSubscriptionStateInputBody: Swift.Equatable {
}

extension GetSubscriptionStateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionStateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionStateOutputBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionState = output.subscriptionState
        } else {
            self.subscriptionState = nil
        }
    }
}

public struct GetSubscriptionStateOutput: Swift.Equatable {
    /// The status of the subscription.
    /// This member is required.
    public var subscriptionState: ShieldClientTypes.SubscriptionState?

    public init(
        subscriptionState: ShieldClientTypes.SubscriptionState? = nil
    )
    {
        self.subscriptionState = subscriptionState
    }
}

struct GetSubscriptionStateOutputBody: Swift.Equatable {
    let subscriptionState: ShieldClientTypes.SubscriptionState?
}

extension GetSubscriptionStateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionState = "SubscriptionState"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionStateDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubscriptionState.self, forKey: .subscriptionState)
        subscriptionState = subscriptionStateDecoded
    }
}

enum GetSubscriptionStateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShieldClientTypes.InclusionProtectionFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionNames = "ProtectionNames"
        case resourceArns = "ResourceArns"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionNames = protectionNames {
            var protectionNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protectionNames)
            for protectionname0 in protectionNames {
                try protectionNamesContainer.encode(protectionname0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for protectedresourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(protectedresourcetype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let protectionNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protectionNames)
        var protectionNamesDecoded0:[Swift.String]? = nil
        if let protectionNamesContainer = protectionNamesContainer {
            protectionNamesDecoded0 = [Swift.String]()
            for string0 in protectionNamesContainer {
                if let string0 = string0 {
                    protectionNamesDecoded0?.append(string0)
                }
            }
        }
        protectionNames = protectionNamesDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectedResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ShieldClientTypes.ProtectedResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ShieldClientTypes.ProtectedResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
    }
}

extension ShieldClientTypes {
    /// Narrows the set of protections that the call retrieves. You can retrieve a single protection by providing its name or the ARN (Amazon Resource Name) of its protected resource. You can also retrieve all protections for a specific resource type. You can provide up to one criteria per filter type. Shield Advanced returns protections that exactly match all of the filter criteria that you provide.
    public struct InclusionProtectionFilters: Swift.Equatable {
        /// The name of the protection that you want to retrieve.
        public var protectionNames: [Swift.String]?
        /// The ARN (Amazon Resource Name) of the resource whose protection you want to retrieve.
        public var resourceArns: [Swift.String]?
        /// The type of protected resource whose protections you want to retrieve.
        public var resourceTypes: [ShieldClientTypes.ProtectedResourceType]?

        public init(
            protectionNames: [Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTypes: [ShieldClientTypes.ProtectedResourceType]? = nil
        )
        {
            self.protectionNames = protectionNames
            self.resourceArns = resourceArns
            self.resourceTypes = resourceTypes
        }
    }

}

extension ShieldClientTypes.InclusionProtectionGroupFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregations = "Aggregations"
        case patterns = "Patterns"
        case protectionGroupIds = "ProtectionGroupIds"
        case resourceTypes = "ResourceTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregations = aggregations {
            var aggregationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregations)
            for protectiongroupaggregation0 in aggregations {
                try aggregationsContainer.encode(protectiongroupaggregation0.rawValue)
            }
        }
        if let patterns = patterns {
            var patternsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .patterns)
            for protectiongrouppattern0 in patterns {
                try patternsContainer.encode(protectiongrouppattern0.rawValue)
            }
        }
        if let protectionGroupIds = protectionGroupIds {
            var protectionGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protectionGroupIds)
            for protectiongroupid0 in protectionGroupIds {
                try protectionGroupIdsContainer.encode(protectiongroupid0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for protectedresourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(protectedresourcetype0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .protectionGroupIds)
        var protectionGroupIdsDecoded0:[Swift.String]? = nil
        if let protectionGroupIdsContainer = protectionGroupIdsContainer {
            protectionGroupIdsDecoded0 = [Swift.String]()
            for string0 in protectionGroupIdsContainer {
                if let string0 = string0 {
                    protectionGroupIdsDecoded0?.append(string0)
                }
            }
        }
        protectionGroupIds = protectionGroupIdsDecoded0
        let patternsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectionGroupPattern?].self, forKey: .patterns)
        var patternsDecoded0:[ShieldClientTypes.ProtectionGroupPattern]? = nil
        if let patternsContainer = patternsContainer {
            patternsDecoded0 = [ShieldClientTypes.ProtectionGroupPattern]()
            for enum0 in patternsContainer {
                if let enum0 = enum0 {
                    patternsDecoded0?.append(enum0)
                }
            }
        }
        patterns = patternsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectedResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[ShieldClientTypes.ProtectedResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [ShieldClientTypes.ProtectedResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let aggregationsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectionGroupAggregation?].self, forKey: .aggregations)
        var aggregationsDecoded0:[ShieldClientTypes.ProtectionGroupAggregation]? = nil
        if let aggregationsContainer = aggregationsContainer {
            aggregationsDecoded0 = [ShieldClientTypes.ProtectionGroupAggregation]()
            for enum0 in aggregationsContainer {
                if let enum0 = enum0 {
                    aggregationsDecoded0?.append(enum0)
                }
            }
        }
        aggregations = aggregationsDecoded0
    }
}

extension ShieldClientTypes {
    /// Narrows the set of protection groups that the call retrieves. You can retrieve a single protection group by its name and you can retrieve all protection groups that are configured with a specific pattern, aggregation, or resource type. You can provide up to one criteria per filter type. Shield Advanced returns the protection groups that exactly match all of the search criteria that you provide.
    public struct InclusionProtectionGroupFilters: Swift.Equatable {
        /// The aggregation setting of the protection groups that you want to retrieve.
        public var aggregations: [ShieldClientTypes.ProtectionGroupAggregation]?
        /// The pattern specification of the protection groups that you want to retrieve.
        public var patterns: [ShieldClientTypes.ProtectionGroupPattern]?
        /// The ID of the protection group that you want to retrieve.
        public var protectionGroupIds: [Swift.String]?
        /// The resource type configuration of the protection groups that you want to retrieve. In the protection group configuration, you specify the resource type when you set the group's Pattern to BY_RESOURCE_TYPE.
        public var resourceTypes: [ShieldClientTypes.ProtectedResourceType]?

        public init(
            aggregations: [ShieldClientTypes.ProtectionGroupAggregation]? = nil,
            patterns: [ShieldClientTypes.ProtectionGroupPattern]? = nil,
            protectionGroupIds: [Swift.String]? = nil,
            resourceTypes: [ShieldClientTypes.ProtectedResourceType]? = nil
        )
        {
            self.aggregations = aggregations
            self.patterns = patterns
            self.protectionGroupIds = protectionGroupIds
            self.resourceTypes = resourceTypes
        }
    }

}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that a problem occurred with the service infrastructure. You can retry the request.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the operation would not cause any change to occur.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the NextToken specified in the request is invalid. Submit the request using the NextToken value that was returned in the prior response.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the parameters passed to the API are invalid. If available, this exception includes details in additional properties.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Fields that caused the exception.
        public internal(set) var fields: [ShieldClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Additional information about the exception.
        public internal(set) var reason: ShieldClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [ShieldClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ShieldClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ShieldClientTypes.ValidationExceptionReason?
    let fields: [ShieldClientTypes.ValidationExceptionField]?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ShieldClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ShieldClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension InvalidResourceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the resource is invalid. You might not have access to the resource, or the resource might not exist.
public struct InvalidResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.Limit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .max) ?? 0
        max = maxDecoded
    }
}

extension ShieldClientTypes {
    /// Specifies how many protections of a given type you can create.
    public struct Limit: Swift.Equatable {
        /// The maximum number of protections that can be created for the specified Type.
        public var max: Swift.Int
        /// The type of protection.
        public var type: Swift.String?

        public init(
            max: Swift.Int = 0,
            type: Swift.String? = nil
        )
        {
            self.max = max
            self.type = type
        }
    }

}

extension LimitsExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.limit = output.limit
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.limit = 0
            self.properties.type = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the operation would exceed a limit.
public struct LimitsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The threshold that would be exceeded.
        public internal(set) var limit: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
        /// The type of limit that would be exceeded.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitsExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.type = type
    }
}

struct LimitsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
    let limit: Swift.Int
}

extension LimitsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case type = "Type"
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit) ?? 0
        limit = limitDecoded
    }
}

extension ListAttacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearn0 in resourceArns {
                try resourceArnsContainer.encode(resourcearn0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

extension ListAttacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttacksInput: Swift.Equatable {
    /// The end of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var endTime: ShieldClientTypes.TimeRange?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The ARNs (Amazon Resource Names) of the resources that were attacked. If you leave this blank, all applicable resources for this account will be included.
    public var resourceArns: [Swift.String]?
    /// The start of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var startTime: ShieldClientTypes.TimeRange?

    public init(
        endTime: ShieldClientTypes.TimeRange? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        startTime: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArns = resourceArns
        self.startTime = startTime
    }
}

struct ListAttacksInputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let startTime: ShieldClientTypes.TimeRange?
    let endTime: ShieldClientTypes.TimeRange?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAttacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttacksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAttacksOutputBody = try responseDecoder.decode(responseBody: data)
            self.attackSummaries = output.attackSummaries
            self.nextToken = output.nextToken
        } else {
            self.attackSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttacksOutput: Swift.Equatable {
    /// The attack information for the specified time range.
    public var attackSummaries: [ShieldClientTypes.AttackSummary]?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?

    public init(
        attackSummaries: [ShieldClientTypes.AttackSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attackSummaries = attackSummaries
        self.nextToken = nextToken
    }
}

struct ListAttacksOutputBody: Swift.Equatable {
    let attackSummaries: [ShieldClientTypes.AttackSummary]?
    let nextToken: Swift.String?
}

extension ListAttacksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackSummaries = "AttackSummaries"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackSummariesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackSummary?].self, forKey: .attackSummaries)
        var attackSummariesDecoded0:[ShieldClientTypes.AttackSummary]? = nil
        if let attackSummariesContainer = attackSummariesContainer {
            attackSummariesDecoded0 = [ShieldClientTypes.AttackSummary]()
            for structure0 in attackSummariesContainer {
                if let structure0 = structure0 {
                    attackSummariesDecoded0?.append(structure0)
                }
            }
        }
        attackSummaries = attackSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAttacksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProtectionGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inclusionFilters = "InclusionFilters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inclusionFilters = self.inclusionFilters {
            try encodeContainer.encode(inclusionFilters, forKey: .inclusionFilters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtectionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtectionGroupsInput: Swift.Equatable {
    /// Narrows the set of protection groups that the call retrieves. You can retrieve a single protection group by its name and you can retrieve all protection groups that are configured with specific pattern or aggregation settings. You can provide up to one criteria per filter type. Shield Advanced returns the protection groups that exactly match all of the search criteria that you provide.
    public var inclusionFilters: ShieldClientTypes.InclusionProtectionGroupFilters?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init(
        inclusionFilters: ShieldClientTypes.InclusionProtectionGroupFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inclusionFilters = inclusionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let inclusionFilters: ShieldClientTypes.InclusionProtectionGroupFilters?
}

extension ListProtectionGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inclusionFilters = "InclusionFilters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let inclusionFiltersDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.InclusionProtectionGroupFilters.self, forKey: .inclusionFilters)
        inclusionFilters = inclusionFiltersDecoded
    }
}

extension ListProtectionGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProtectionGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protectionGroups = output.protectionGroups
        } else {
            self.nextToken = nil
            self.protectionGroups = nil
        }
    }
}

public struct ListProtectionGroupsOutput: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    ///
    /// This member is required.
    public var protectionGroups: [ShieldClientTypes.ProtectionGroup]?

    public init(
        nextToken: Swift.String? = nil,
        protectionGroups: [ShieldClientTypes.ProtectionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectionGroups = protectionGroups
    }
}

struct ListProtectionGroupsOutputBody: Swift.Equatable {
    let protectionGroups: [ShieldClientTypes.ProtectionGroup]?
    let nextToken: Swift.String?
}

extension ListProtectionGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protectionGroups = "ProtectionGroups"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectionGroup?].self, forKey: .protectionGroups)
        var protectionGroupsDecoded0:[ShieldClientTypes.ProtectionGroup]? = nil
        if let protectionGroupsContainer = protectionGroupsContainer {
            protectionGroupsDecoded0 = [ShieldClientTypes.ProtectionGroup]()
            for structure0 in protectionGroupsContainer {
                if let structure0 = structure0 {
                    protectionGroupsDecoded0?.append(structure0)
                }
            }
        }
        protectionGroups = protectionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProtectionGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProtectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inclusionFilters = "InclusionFilters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inclusionFilters = self.inclusionFilters {
            try encodeContainer.encode(inclusionFilters, forKey: .inclusionFilters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtectionsInput: Swift.Equatable {
    /// Narrows the set of protections that the call retrieves. You can retrieve a single protection by providing its name or the ARN (Amazon Resource Name) of its protected resource. You can also retrieve all protections for a specific resource type. You can provide up to one criteria per filter type. Shield Advanced returns protections that exactly match all of the filter criteria that you provide.
    public var inclusionFilters: ShieldClientTypes.InclusionProtectionFilters?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init(
        inclusionFilters: ShieldClientTypes.InclusionProtectionFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inclusionFilters = inclusionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let inclusionFilters: ShieldClientTypes.InclusionProtectionFilters?
}

extension ListProtectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inclusionFilters = "InclusionFilters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let inclusionFiltersDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.InclusionProtectionFilters.self, forKey: .inclusionFilters)
        inclusionFilters = inclusionFiltersDecoded
    }
}

extension ListProtectionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProtectionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protections = output.protections
        } else {
            self.nextToken = nil
            self.protections = nil
        }
    }
}

public struct ListProtectionsOutput: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The array of enabled [Protection] objects.
    public var protections: [ShieldClientTypes.Protection]?

    public init(
        nextToken: Swift.String? = nil,
        protections: [ShieldClientTypes.Protection]? = nil
    )
    {
        self.nextToken = nextToken
        self.protections = protections
    }
}

struct ListProtectionsOutputBody: Swift.Equatable {
    let protections: [ShieldClientTypes.Protection]?
    let nextToken: Swift.String?
}

extension ListProtectionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protections = "Protections"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Protection?].self, forKey: .protections)
        var protectionsDecoded0:[ShieldClientTypes.Protection]? = nil
        if let protectionsContainer = protectionsContainer {
            protectionsDecoded0 = [ShieldClientTypes.Protection]()
            for structure0 in protectionsContainer {
                if let structure0 = structure0 {
                    protectionsDecoded0?.append(structure0)
                }
            }
        }
        protections = protectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProtectionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourcesInProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension ListResourcesInProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInProtectionGroupInput: Swift.Equatable {
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        protectionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.protectionGroupId = protectionGroupId
    }
}

struct ListResourcesInProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourcesInProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesInProtectionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourcesInProtectionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceArns = output.resourceArns
        } else {
            self.nextToken = nil
            self.resourceArns = nil
        }
    }
}

public struct ListResourcesInProtectionGroupOutput: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of the resources that are included in the protection group.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArns = resourceArns
    }
}

struct ListResourcesInProtectionGroupOutputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListResourcesInProtectionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourcesInProtectionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidPaginationTokenException": return try await InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ShieldClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension LockedSubscriptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LockedSubscriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are trying to update a subscription that has not yet completed the 1-year commitment. You can change the AutoRenew parameter during the last 30 days of your subscription. This exception indicates that you are attempting to change AutoRenew prior to that period.
public struct LockedSubscriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LockedSubscriptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LockedSubscriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LockedSubscriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.Mitigation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mitigationName = "MitigationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mitigationName = self.mitigationName {
            try encodeContainer.encode(mitigationName, forKey: .mitigationName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mitigationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mitigationName)
        mitigationName = mitigationNameDecoded
    }
}

extension ShieldClientTypes {
    /// The mitigation applied to a DDoS attack.
    public struct Mitigation: Swift.Equatable {
        /// The name of the mitigation taken for this attack.
        public var mitigationName: Swift.String?

        public init(
            mitigationName: Swift.String? = nil
        )
        {
            self.mitigationName = mitigationName
        }
    }

}

extension NoAssociatedRoleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoAssociatedRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The ARN of the role that you specified does not exist.
public struct NoAssociatedRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAssociatedRoleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoAssociatedRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAssociatedRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptimisticLockException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OptimisticLockExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that indicates that the resource state has been modified by another client. Retrieve the resource and then retry your request.
public struct OptimisticLockException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OptimisticLockException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OptimisticLockExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptimisticLockExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes {
    public enum ProactiveEngagementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProactiveEngagementStatus] {
            return [
                .disabled,
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProactiveEngagementStatus(rawValue: rawValue) ?? ProactiveEngagementStatus.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes {
    public enum ProtectedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationLoadBalancer
        case classicLoadBalancer
        case cloudfrontDistribution
        case elasticIpAllocation
        case globalAccelerator
        case route53HostedZone
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedResourceType] {
            return [
                .applicationLoadBalancer,
                .classicLoadBalancer,
                .cloudfrontDistribution,
                .elasticIpAllocation,
                .globalAccelerator,
                .route53HostedZone,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationLoadBalancer: return "APPLICATION_LOAD_BALANCER"
            case .classicLoadBalancer: return "CLASSIC_LOAD_BALANCER"
            case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
            case .elasticIpAllocation: return "ELASTIC_IP_ALLOCATION"
            case .globalAccelerator: return "GLOBAL_ACCELERATOR"
            case .route53HostedZone: return "ROUTE_53_HOSTED_ZONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectedResourceType(rawValue: rawValue) ?? ProtectedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.Protection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationLayerAutomaticResponseConfiguration = "ApplicationLayerAutomaticResponseConfiguration"
        case healthCheckIds = "HealthCheckIds"
        case id = "Id"
        case name = "Name"
        case protectionArn = "ProtectionArn"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationLayerAutomaticResponseConfiguration = self.applicationLayerAutomaticResponseConfiguration {
            try encodeContainer.encode(applicationLayerAutomaticResponseConfiguration, forKey: .applicationLayerAutomaticResponseConfiguration)
        }
        if let healthCheckIds = healthCheckIds {
            var healthCheckIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .healthCheckIds)
            for healthcheckid0 in healthCheckIds {
                try healthCheckIdsContainer.encode(healthcheckid0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protectionArn = self.protectionArn {
            try encodeContainer.encode(protectionArn, forKey: .protectionArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let healthCheckIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .healthCheckIds)
        var healthCheckIdsDecoded0:[Swift.String]? = nil
        if let healthCheckIdsContainer = healthCheckIdsContainer {
            healthCheckIdsDecoded0 = [Swift.String]()
            for string0 in healthCheckIdsContainer {
                if let string0 = string0 {
                    healthCheckIdsDecoded0?.append(string0)
                }
            }
        }
        healthCheckIds = healthCheckIdsDecoded0
        let protectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionArn)
        protectionArn = protectionArnDecoded
        let applicationLayerAutomaticResponseConfigurationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration.self, forKey: .applicationLayerAutomaticResponseConfiguration)
        applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfigurationDecoded
    }
}

extension ShieldClientTypes {
    /// An object that represents a resource that is under DDoS protection.
    public struct Protection: Swift.Equatable {
        /// The automatic application layer DDoS mitigation settings for the protection. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
        public var applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration?
        /// The unique identifier (ID) for the Route 53 health check that's associated with the protection.
        public var healthCheckIds: [Swift.String]?
        /// The unique identifier (ID) of the protection.
        public var id: Swift.String?
        /// The name of the protection. For example, My CloudFront distributions.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) of the protection.
        public var protectionArn: Swift.String?
        /// The ARN (Amazon Resource Name) of the Amazon Web Services resource that is protected.
        public var resourceArn: Swift.String?

        public init(
            applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration? = nil,
            healthCheckIds: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            protectionArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfiguration
            self.healthCheckIds = healthCheckIds
            self.id = id
            self.name = name
            self.protectionArn = protectionArn
            self.resourceArn = resourceArn
        }
    }

}

extension ShieldClientTypes.ProtectionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupArn = "ProtectionGroupArn"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = self.aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for resourcearn0 in members {
                try membersContainer.encode(resourcearn0)
            }
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupArn = self.protectionGroupArn {
            try encodeContainer.encode(protectionGroupArn, forKey: .protectionGroupArn)
        }
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let protectionGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupArn)
        protectionGroupArn = protectionGroupArnDecoded
    }
}

extension ShieldClientTypes {
    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    public struct ProtectionGroup: Swift.Equatable {
        /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
        ///
        /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
        ///
        /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
        ///
        /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
        /// This member is required.
        public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
        /// The ARNs (Amazon Resource Names) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
        /// This member is required.
        public var members: [Swift.String]?
        /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource ARNs (Amazon Resource Names), or include all resources of a specified resource type.
        /// This member is required.
        public var pattern: ShieldClientTypes.ProtectionGroupPattern?
        /// The ARN (Amazon Resource Name) of the protection group.
        public var protectionGroupArn: Swift.String?
        /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
        /// This member is required.
        public var protectionGroupId: Swift.String?
        /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
        public var resourceType: ShieldClientTypes.ProtectedResourceType?

        public init(
            aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
            members: [Swift.String]? = nil,
            pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
            protectionGroupArn: Swift.String? = nil,
            protectionGroupId: Swift.String? = nil,
            resourceType: ShieldClientTypes.ProtectedResourceType? = nil
        )
        {
            self.aggregation = aggregation
            self.members = members
            self.pattern = pattern
            self.protectionGroupArn = protectionGroupArn
            self.protectionGroupId = protectionGroupId
            self.resourceType = resourceType
        }
    }

}

extension ShieldClientTypes {
    public enum ProtectionGroupAggregation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case max
        case mean
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupAggregation] {
            return [
                .max,
                .mean,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .max: return "MAX"
            case .mean: return "MEAN"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectionGroupAggregation(rawValue: rawValue) ?? ProtectionGroupAggregation.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.ProtectionGroupArbitraryPatternLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxMembers = "MaxMembers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxMembers != 0 {
            try encodeContainer.encode(maxMembers, forKey: .maxMembers)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxMembersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxMembers) ?? 0
        maxMembers = maxMembersDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings on protection groups with arbitrary pattern type.
    public struct ProtectionGroupArbitraryPatternLimits: Swift.Equatable {
        /// The maximum number of resources you can specify for a single arbitrary pattern in a protection group.
        /// This member is required.
        public var maxMembers: Swift.Int

        public init(
            maxMembers: Swift.Int = 0
        )
        {
            self.maxMembers = maxMembers
        }
    }

}

extension ShieldClientTypes.ProtectionGroupLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxProtectionGroups = "MaxProtectionGroups"
        case patternTypeLimits = "PatternTypeLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxProtectionGroups != 0 {
            try encodeContainer.encode(maxProtectionGroups, forKey: .maxProtectionGroups)
        }
        if let patternTypeLimits = self.patternTypeLimits {
            try encodeContainer.encode(patternTypeLimits, forKey: .patternTypeLimits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxProtectionGroupsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxProtectionGroups) ?? 0
        maxProtectionGroups = maxProtectionGroupsDecoded
        let patternTypeLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPatternTypeLimits.self, forKey: .patternTypeLimits)
        patternTypeLimits = patternTypeLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings on protection groups for your subscription.
    public struct ProtectionGroupLimits: Swift.Equatable {
        /// The maximum number of protection groups that you can have at one time.
        /// This member is required.
        public var maxProtectionGroups: Swift.Int
        /// Limits settings by pattern type in the protection groups for your subscription.
        /// This member is required.
        public var patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits?

        public init(
            maxProtectionGroups: Swift.Int = 0,
            patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits? = nil
        )
        {
            self.maxProtectionGroups = maxProtectionGroups
            self.patternTypeLimits = patternTypeLimits
        }
    }

}

extension ShieldClientTypes {
    public enum ProtectionGroupPattern: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case arbitrary
        case byResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupPattern] {
            return [
                .all,
                .arbitrary,
                .byResourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .arbitrary: return "ARBITRARY"
            case .byResourceType: return "BY_RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectionGroupPattern(rawValue: rawValue) ?? ProtectionGroupPattern.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.ProtectionGroupPatternTypeLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arbitraryPatternLimits = "ArbitraryPatternLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arbitraryPatternLimits = self.arbitraryPatternLimits {
            try encodeContainer.encode(arbitraryPatternLimits, forKey: .arbitraryPatternLimits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arbitraryPatternLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupArbitraryPatternLimits.self, forKey: .arbitraryPatternLimits)
        arbitraryPatternLimits = arbitraryPatternLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings by pattern type in the protection groups for your subscription.
    public struct ProtectionGroupPatternTypeLimits: Swift.Equatable {
        /// Limits settings on protection groups with arbitrary pattern type.
        /// This member is required.
        public var arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits?

        public init(
            arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits? = nil
        )
        {
            self.arbitraryPatternLimits = arbitraryPatternLimits
        }
    }

}

extension ShieldClientTypes.ProtectionLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectedResourceTypeLimits = "ProtectedResourceTypeLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectedResourceTypeLimits = protectedResourceTypeLimits {
            var protectedResourceTypeLimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protectedResourceTypeLimits)
            for limit0 in protectedResourceTypeLimits {
                try protectedResourceTypeLimitsContainer.encode(limit0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedResourceTypeLimitsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Limit?].self, forKey: .protectedResourceTypeLimits)
        var protectedResourceTypeLimitsDecoded0:[ShieldClientTypes.Limit]? = nil
        if let protectedResourceTypeLimitsContainer = protectedResourceTypeLimitsContainer {
            protectedResourceTypeLimitsDecoded0 = [ShieldClientTypes.Limit]()
            for structure0 in protectedResourceTypeLimitsContainer {
                if let structure0 = structure0 {
                    protectedResourceTypeLimitsDecoded0?.append(structure0)
                }
            }
        }
        protectedResourceTypeLimits = protectedResourceTypeLimitsDecoded0
    }
}

extension ShieldClientTypes {
    /// Limits settings on protections for your subscription.
    public struct ProtectionLimits: Swift.Equatable {
        /// The maximum number of resource types that you can specify in a protection.
        /// This member is required.
        public var protectedResourceTypeLimits: [ShieldClientTypes.Limit]?

        public init(
            protectedResourceTypeLimits: [ShieldClientTypes.Limit]? = nil
        )
        {
            self.protectedResourceTypeLimits = protectedResourceTypeLimits
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception indicating the specified resource already exists. If available, this exception includes details in additional properties.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource that already exists.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception indicating the specified resource does not exist. If available, this exception includes details in additional properties.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ShieldClientTypes.ResponseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case block = "Block"
        case count = "Count"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let block = self.block {
            try encodeContainer.encode(block, forKey: .block)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.BlockAction.self, forKey: .block)
        block = blockDecoded
        let countDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.CountAction.self, forKey: .count)
        count = countDecoded
    }
}

extension ShieldClientTypes {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    public struct ResponseAction: Swift.Equatable {
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. You must specify exactly one action, either Block or Count.
        public var block: ShieldClientTypes.BlockAction?
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. You must specify exactly one action, either Block or Count.
        public var count: ShieldClientTypes.CountAction?

        public init(
            block: ShieldClientTypes.BlockAction? = nil,
            count: ShieldClientTypes.CountAction? = nil
        )
        {
            self.block = block
            self.count = count
        }
    }

}

extension ShieldClientTypes.SubResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackVectors = "AttackVectors"
        case counters = "Counters"
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for summarizedattackvector0 in attackVectors {
                try attackVectorsContainer.encode(summarizedattackvector0)
            }
        }
        if let counters = counters {
            var countersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .counters)
            for summarizedcounter0 in counters {
                try countersContainer.encode(summarizedcounter0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedAttackVector?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[ShieldClientTypes.SummarizedAttackVector]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [ShieldClientTypes.SummarizedAttackVector]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
        let countersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .counters)
        var countersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let countersContainer = countersContainer {
            countersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in countersContainer {
                if let structure0 = structure0 {
                    countersDecoded0?.append(structure0)
                }
            }
        }
        counters = countersDecoded0
    }
}

extension ShieldClientTypes {
    /// The attack information for the specified SubResource.
    public struct SubResourceSummary: Swift.Equatable {
        /// The list of attack types and associated counters.
        public var attackVectors: [ShieldClientTypes.SummarizedAttackVector]?
        /// The counters that describe the details of the attack.
        public var counters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the SubResource.
        public var id: Swift.String?
        /// The SubResource type.
        public var type: ShieldClientTypes.SubResourceType?

        public init(
            attackVectors: [ShieldClientTypes.SummarizedAttackVector]? = nil,
            counters: [ShieldClientTypes.SummarizedCounter]? = nil,
            id: Swift.String? = nil,
            type: ShieldClientTypes.SubResourceType? = nil
        )
        {
            self.attackVectors = attackVectors
            self.counters = counters
            self.id = id
            self.type = type
        }
    }

}

extension ShieldClientTypes {
    public enum SubResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ip
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [SubResourceType] {
            return [
                .ip,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ip: return "IP"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubResourceType(rawValue: rawValue) ?? SubResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
        case endTime = "EndTime"
        case limits = "Limits"
        case proactiveEngagementStatus = "ProactiveEngagementStatus"
        case startTime = "StartTime"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionLimits = "SubscriptionLimits"
        case timeCommitmentInSeconds = "TimeCommitmentInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = self.autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let limits = limits {
            var limitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .limits)
            for limit0 in limits {
                try limitsContainer.encode(limit0)
            }
        }
        if let proactiveEngagementStatus = self.proactiveEngagementStatus {
            try encodeContainer.encode(proactiveEngagementStatus.rawValue, forKey: .proactiveEngagementStatus)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let subscriptionArn = self.subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionLimits = self.subscriptionLimits {
            try encodeContainer.encode(subscriptionLimits, forKey: .subscriptionLimits)
        }
        if timeCommitmentInSeconds != 0 {
            try encodeContainer.encode(timeCommitmentInSeconds, forKey: .timeCommitmentInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let timeCommitmentInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeCommitmentInSeconds) ?? 0
        timeCommitmentInSeconds = timeCommitmentInSecondsDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let limitsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Limit?].self, forKey: .limits)
        var limitsDecoded0:[ShieldClientTypes.Limit]? = nil
        if let limitsContainer = limitsContainer {
            limitsDecoded0 = [ShieldClientTypes.Limit]()
            for structure0 in limitsContainer {
                if let structure0 = structure0 {
                    limitsDecoded0?.append(structure0)
                }
            }
        }
        limits = limitsDecoded0
        let proactiveEngagementStatusDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProactiveEngagementStatus.self, forKey: .proactiveEngagementStatus)
        proactiveEngagementStatus = proactiveEngagementStatusDecoded
        let subscriptionLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubscriptionLimits.self, forKey: .subscriptionLimits)
        subscriptionLimits = subscriptionLimitsDecoded
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension ShieldClientTypes {
    /// Information about the Shield Advanced subscription for an account.
    public struct Subscription: Swift.Equatable {
        /// If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. When you initally create a subscription, AutoRenew is set to ENABLED. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
        public var autoRenew: ShieldClientTypes.AutoRenew?
        /// The date and time your subscription will end.
        public var endTime: ClientRuntime.Date?
        /// Specifies how many protections of a given type you can create.
        public var limits: [ShieldClientTypes.Limit]?
        /// If ENABLED, the Shield Response Team (SRT) will use email and phone to notify contacts about escalations to the SRT and to initiate proactive customer support. If PENDING, you have requested proactive engagement and the request is pending. The status changes to ENABLED when your request is fully processed. If DISABLED, the SRT will not proactively notify contacts about escalations or to initiate proactive customer support.
        public var proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus?
        /// The start time of the subscription, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) of the subscription.
        public var subscriptionArn: Swift.String?
        /// Limits settings for your subscription.
        /// This member is required.
        public var subscriptionLimits: ShieldClientTypes.SubscriptionLimits?
        /// The length, in seconds, of the Shield Advanced subscription for the account.
        public var timeCommitmentInSeconds: Swift.Int

        public init(
            autoRenew: ShieldClientTypes.AutoRenew? = nil,
            endTime: ClientRuntime.Date? = nil,
            limits: [ShieldClientTypes.Limit]? = nil,
            proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus? = nil,
            startTime: ClientRuntime.Date? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionLimits: ShieldClientTypes.SubscriptionLimits? = nil,
            timeCommitmentInSeconds: Swift.Int = 0
        )
        {
            self.autoRenew = autoRenew
            self.endTime = endTime
            self.limits = limits
            self.proactiveEngagementStatus = proactiveEngagementStatus
            self.startTime = startTime
            self.subscriptionArn = subscriptionArn
            self.subscriptionLimits = subscriptionLimits
            self.timeCommitmentInSeconds = timeCommitmentInSeconds
        }
    }

}

extension ShieldClientTypes.SubscriptionLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupLimits = "ProtectionGroupLimits"
        case protectionLimits = "ProtectionLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupLimits = self.protectionGroupLimits {
            try encodeContainer.encode(protectionGroupLimits, forKey: .protectionGroupLimits)
        }
        if let protectionLimits = self.protectionLimits {
            try encodeContainer.encode(protectionLimits, forKey: .protectionLimits)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionLimits.self, forKey: .protectionLimits)
        protectionLimits = protectionLimitsDecoded
        let protectionGroupLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupLimits.self, forKey: .protectionGroupLimits)
        protectionGroupLimits = protectionGroupLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings for your subscription.
    public struct SubscriptionLimits: Swift.Equatable {
        /// Limits settings on protection groups for your subscription.
        /// This member is required.
        public var protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits?
        /// Limits settings on protections for your subscription.
        /// This member is required.
        public var protectionLimits: ShieldClientTypes.ProtectionLimits?

        public init(
            protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits? = nil,
            protectionLimits: ShieldClientTypes.ProtectionLimits? = nil
        )
        {
            self.protectionGroupLimits = protectionGroupLimits
            self.protectionLimits = protectionLimits
        }
    }

}

extension ShieldClientTypes {
    public enum SubscriptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionState(rawValue: rawValue) ?? SubscriptionState.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.SummarizedAttackVector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorCounters = "VectorCounters"
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorCounters = vectorCounters {
            var vectorCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vectorCounters)
            for summarizedcounter0 in vectorCounters {
                try vectorCountersContainer.encode(summarizedcounter0)
            }
        }
        if let vectorType = self.vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
        let vectorCountersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .vectorCounters)
        var vectorCountersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let vectorCountersContainer = vectorCountersContainer {
            vectorCountersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in vectorCountersContainer {
                if let structure0 = structure0 {
                    vectorCountersDecoded0?.append(structure0)
                }
            }
        }
        vectorCounters = vectorCountersDecoded0
    }
}

extension ShieldClientTypes {
    /// A summary of information about the attack.
    public struct SummarizedAttackVector: Swift.Equatable {
        /// The list of counters that describe the details of the attack.
        public var vectorCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The attack type, for example, SNMP reflection or SYN flood.
        /// This member is required.
        public var vectorType: Swift.String?

        public init(
            vectorCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            vectorType: Swift.String? = nil
        )
        {
            self.vectorCounters = vectorCounters
            self.vectorType = vectorType
        }
    }

}

extension ShieldClientTypes.SummarizedCounter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average = "Average"
        case max = "Max"
        case n = "N"
        case name = "Name"
        case sum = "Sum"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if average != 0.0 {
            try encodeContainer.encode(average, forKey: .average)
        }
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if n != 0 {
            try encodeContainer.encode(n, forKey: .n)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if sum != 0.0 {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .max) ?? 0.0
        max = maxDecoded
        let averageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .average) ?? 0.0
        average = averageDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum) ?? 0.0
        sum = sumDecoded
        let nDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .n) ?? 0
        n = nDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ShieldClientTypes {
    /// The counter that describes a DDoS attack.
    public struct SummarizedCounter: Swift.Equatable {
        /// The average value of the counter for a specified time period.
        public var average: Swift.Double
        /// The maximum value of the counter for a specified time period.
        public var max: Swift.Double
        /// The number of counters for a specified time period.
        public var n: Swift.Int
        /// The counter name.
        public var name: Swift.String?
        /// The total of counter values for a specified time period.
        public var sum: Swift.Double
        /// The unit of the counters.
        public var unit: Swift.String?

        public init(
            average: Swift.Double = 0.0,
            max: Swift.Double = 0.0,
            n: Swift.Int = 0,
            name: Swift.String? = nil,
            sum: Swift.Double = 0.0,
            unit: Swift.String? = nil
        )
        {
            self.average = average
            self.max = max
            self.n = n
            self.name = name
            self.sum = sum
            self.unit = unit
        }
    }

}

extension ShieldClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ShieldClientTypes {
    /// A tag associated with an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to modify or add to the resource.
    /// This member is required.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ShieldClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShieldClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromInclusive = "FromInclusive"
        case toExclusive = "ToExclusive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromInclusive = self.fromInclusive {
            try encodeContainer.encodeTimestamp(fromInclusive, format: .epochSeconds, forKey: .fromInclusive)
        }
        if let toExclusive = self.toExclusive {
            try encodeContainer.encodeTimestamp(toExclusive, format: .epochSeconds, forKey: .toExclusive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromInclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .fromInclusive)
        fromInclusive = fromInclusiveDecoded
        let toExclusiveDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .toExclusive)
        toExclusive = toExclusiveDecoded
    }
}

extension ShieldClientTypes {
    /// The time range.
    public struct TimeRange: Swift.Equatable {
        /// The start time, in Unix time in seconds.
        public var fromInclusive: ClientRuntime.Date?
        /// The end time, in Unix time in seconds.
        public var toExclusive: ClientRuntime.Date?

        public init(
            fromInclusive: ClientRuntime.Date? = nil,
            toExclusive: ClientRuntime.Date? = nil
        )
        {
            self.fromInclusive = fromInclusive
            self.toExclusive = toExclusive
        }
    }

}

extension ShieldClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bytes
        case packets
        case requests
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .bits,
                .bytes,
                .packets,
                .requests,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "BITS"
            case .bytes: return "BYTES"
            case .packets: return "PACKETS"
            case .requests: return "REQUESTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceException": return try await InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension UpdateApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

struct UpdateApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let action: ShieldClientTypes.ResponseAction?
}

extension UpdateApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateApplicationLayerAutomaticResponseOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationLayerAutomaticResponseOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidOperationException": return try await InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEmergencyContactSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontact0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontact0)
            }
        }
    }
}

extension UpdateEmergencyContactSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEmergencyContactSettingsInput: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support. If you have proactive engagement enabled, the contact list must include at least one phone number.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct UpdateEmergencyContactSettingsInputBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension UpdateEmergencyContactSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension UpdateEmergencyContactSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEmergencyContactSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEmergencyContactSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = self.aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for resourcearn0 in members {
                try membersContainer.encode(resourcearn0)
            }
        }
        if let pattern = self.pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = self.protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension UpdateProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProtectionGroupInput: Swift.Equatable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?

    public init(
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
    }
}

struct UpdateProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    let pattern: ShieldClientTypes.ProtectionGroupPattern?
    let resourceType: ShieldClientTypes.ProtectedResourceType?
    let members: [Swift.String]?
}

extension UpdateProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension UpdateProtectionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProtectionGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProtectionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = self.autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
    }
}

extension UpdateSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSubscriptionInput: Swift.Equatable {
    /// When you initally create a subscription, AutoRenew is set to ENABLED. If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
    public var autoRenew: ShieldClientTypes.AutoRenew?

    public init(
        autoRenew: ShieldClientTypes.AutoRenew? = nil
    )
    {
        self.autoRenew = autoRenew
    }
}

struct UpdateSubscriptionInputBody: Swift.Equatable {
    let autoRenew: ShieldClientTypes.AutoRenew?
}

extension UpdateSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoRenewDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
    }
}

extension UpdateSubscriptionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSubscriptionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSubscriptionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LockedSubscriptionException": return try await LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OptimisticLockException": return try await OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ShieldClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes {
    /// Provides information about a particular parameter passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the parameter failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension ShieldClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
