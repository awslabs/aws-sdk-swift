// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAttacksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttacksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttacksOutputResponse`
extension ShieldClient {
    public func listAttacksPaginated(input: ListAttacksInput) -> ClientRuntime.PaginatorSequence<ListAttacksInput, ListAttacksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttacksInput, ListAttacksOutputResponse>(input: input, inputKey: \ListAttacksInput.nextToken, outputKey: \ListAttacksOutputResponse.nextToken, paginationFunction: self.listAttacks(input:))
    }
}

extension ListAttacksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttacksInput {
        return ListAttacksInput(
            endTime: self.endTime,
            maxResults: self.maxResults,
            nextToken: token,
            resourceArns: self.resourceArns,
            startTime: self.startTime
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttacksPaginated`
/// to access the nested member `[ShieldClientTypes.AttackSummary]`
/// - Returns: `[ShieldClientTypes.AttackSummary]`
extension PaginatorSequence where Input == ListAttacksInput, Output == ListAttacksOutputResponse {
    public func attackSummaries() async throws -> [ShieldClientTypes.AttackSummary] {
        return try await self.asyncCompactMap { item in item.attackSummaries }
    }
}

/// Paginate over `[ListProtectionGroupsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProtectionGroupsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProtectionGroupsOutputResponse`
extension ShieldClient {
    public func listProtectionGroupsPaginated(input: ListProtectionGroupsInput) -> ClientRuntime.PaginatorSequence<ListProtectionGroupsInput, ListProtectionGroupsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProtectionGroupsInput, ListProtectionGroupsOutputResponse>(input: input, inputKey: \ListProtectionGroupsInput.nextToken, outputKey: \ListProtectionGroupsOutputResponse.nextToken, paginationFunction: self.listProtectionGroups(input:))
    }
}

extension ListProtectionGroupsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectionGroupsInput {
        return ListProtectionGroupsInput(
            inclusionFilters: self.inclusionFilters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// Paginate over `[ListProtectionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListProtectionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListProtectionsOutputResponse`
extension ShieldClient {
    public func listProtectionsPaginated(input: ListProtectionsInput) -> ClientRuntime.PaginatorSequence<ListProtectionsInput, ListProtectionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListProtectionsInput, ListProtectionsOutputResponse>(input: input, inputKey: \ListProtectionsInput.nextToken, outputKey: \ListProtectionsOutputResponse.nextToken, paginationFunction: self.listProtections(input:))
    }
}

extension ListProtectionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProtectionsInput {
        return ListProtectionsInput(
            inclusionFilters: self.inclusionFilters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listProtectionsPaginated`
/// to access the nested member `[ShieldClientTypes.Protection]`
/// - Returns: `[ShieldClientTypes.Protection]`
extension PaginatorSequence where Input == ListProtectionsInput, Output == ListProtectionsOutputResponse {
    public func protections() async throws -> [ShieldClientTypes.Protection] {
        return try await self.asyncCompactMap { item in item.protections }
    }
}

/// Paginate over `[ListResourcesInProtectionGroupOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListResourcesInProtectionGroupInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListResourcesInProtectionGroupOutputResponse`
extension ShieldClient {
    public func listResourcesInProtectionGroupPaginated(input: ListResourcesInProtectionGroupInput) -> ClientRuntime.PaginatorSequence<ListResourcesInProtectionGroupInput, ListResourcesInProtectionGroupOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListResourcesInProtectionGroupInput, ListResourcesInProtectionGroupOutputResponse>(input: input, inputKey: \ListResourcesInProtectionGroupInput.nextToken, outputKey: \ListResourcesInProtectionGroupOutputResponse.nextToken, paginationFunction: self.listResourcesInProtectionGroup(input:))
    }
}

extension ListResourcesInProtectionGroupInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListResourcesInProtectionGroupInput {
        return ListResourcesInProtectionGroupInput(
            maxResults: self.maxResults,
            nextToken: token,
            protectionGroupId: self.protectionGroupId
        )}
}
