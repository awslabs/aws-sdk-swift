//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Exception that indicates the specified AttackId does not exist, or the requester does not have the appropriate permissions to access the AttackId.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// In order to grant the necessary access to the Shield Response Team (SRT) the user submitting the request must have the iam:PassRole permission. This error indicates the user did not have the appropriate permissions. For more information, see [Granting a User Permissions to Pass a Role to an Amazon Web Services Service](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html).
public struct AccessDeniedForDependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedForDependencyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ShieldClientTypes {

    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. This is only used in the context of the ResponseAction setting. JSON specification: "Block": {}
    public struct BlockAction: Swift.Sendable {

        public init() { }
    }
}

extension ShieldClientTypes {

    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. This is only used in the context of the ResponseAction setting. JSON specification: "Count": {}
    public struct CountAction: Swift.Sendable {

        public init() { }
    }
}

extension ShieldClientTypes {

    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    public struct ResponseAction: Swift.Sendable {
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. You must specify exactly one action, either Block or Count.
        public var block: ShieldClientTypes.BlockAction?
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. You must specify exactly one action, either Block or Count.
        public var count: ShieldClientTypes.CountAction?

        public init(
            block: ShieldClientTypes.BlockAction? = nil,
            count: ShieldClientTypes.CountAction? = nil
        )
        {
            self.block = block
            self.count = count
        }
    }
}

extension ShieldClientTypes {

    public enum ApplicationLayerAutomaticResponseStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLayerAutomaticResponseStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    /// The automatic application layer DDoS mitigation settings for a [Protection]. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
    public struct ApplicationLayerAutomaticResponseConfiguration: Swift.Sendable {
        /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
        /// This member is required.
        public var action: ShieldClientTypes.ResponseAction?
        /// Indicates whether automatic application layer DDoS mitigation is enabled for the protection.
        /// This member is required.
        public var status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus?

        public init(
            action: ShieldClientTypes.ResponseAction? = nil,
            status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus? = nil
        )
        {
            self.action = action
            self.status = status
        }
    }
}

/// Exception that indicates that a problem occurred with the service infrastructure. You can retry the request.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception that indicates that the operation would not cause any change to occur.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ShieldClientTypes {

    /// Provides information about a particular parameter passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The message describing why the parameter failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension ShieldClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception that indicates that the parameters passed to the API are invalid. If available, this exception includes details in additional properties.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Fields that caused the exception.
        public internal(set) var fields: [ShieldClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Additional information about the exception.
        public internal(set) var reason: ShieldClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [ShieldClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ShieldClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// Exception that indicates that the operation would exceed a limit.
public struct LimitsExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The threshold that would be exceeded.
        public internal(set) var limit: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
        /// The type of limit that would be exceeded.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitsExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.limit = limit
        self.properties.message = message
        self.properties.type = type
    }
}

/// The ARN of the role that you specified does not exist.
public struct NoAssociatedRoleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoAssociatedRoleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception that indicates that the resource state has been modified by another client. Retrieve the resource and then retry your request.
public struct OptimisticLockException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OptimisticLockException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exception indicating the specified resource does not exist. If available, this exception includes details in additional properties.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// Type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

public struct AssociateDRTLogBucketInput: Swift.Sendable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init(
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

public struct AssociateDRTLogBucketOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateDRTRoleInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the role the SRT will use to access your Amazon Web Services account. Prior to making the AssociateDRTRole request, you must attach the [AWSShieldDRTAccessPolicy](https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy) managed policy to this role. For more information see [Attaching and Detaching IAM Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

public struct AssociateDRTRoleOutput: Swift.Sendable {

    public init() { }
}

/// Exception that indicates that the resource is invalid. You might not have access to the resource, or the resource might not exist.
public struct InvalidResourceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateHealthCheckInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the health check to associate with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to add the health check association to.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

public struct AssociateHealthCheckOutput: Swift.Sendable {

    public init() { }
}

extension ShieldClientTypes {

    /// Contact information that the SRT can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public struct EmergencyContact: Swift.Sendable {
        /// Additional notes regarding the contact.
        public var contactNotes: Swift.String?
        /// The email address for the contact.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The phone number for the contact.
        public var phoneNumber: Swift.String?

        public init(
            contactNotes: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.contactNotes = contactNotes
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }
}

public struct AssociateProactiveEngagementDetailsInput: Swift.Sendable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you for escalations to the SRT and to initiate proactive customer support. To enable proactive engagement, the contact list must include at least one phone number. The contacts that you provide here replace any contacts that were already defined. If you already have contacts defined and want to use them, retrieve the list using DescribeEmergencyContactSettings and then provide it here.
    /// This member is required.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

public struct AssociateProactiveEngagementDetailsOutput: Swift.Sendable {

    public init() { }
}

extension ShieldClientTypes {

    /// The counter that describes a DDoS attack.
    public struct SummarizedCounter: Swift.Sendable {
        /// The average value of the counter for a specified time period.
        public var average: Swift.Double
        /// The maximum value of the counter for a specified time period.
        public var max: Swift.Double
        /// The number of counters for a specified time period.
        public var n: Swift.Int
        /// The counter name.
        public var name: Swift.String?
        /// The total of counter values for a specified time period.
        public var sum: Swift.Double
        /// The unit of the counters.
        public var unit: Swift.String?

        public init(
            average: Swift.Double = 0.0,
            max: Swift.Double = 0.0,
            n: Swift.Int = 0,
            name: Swift.String? = nil,
            sum: Swift.Double = 0.0,
            unit: Swift.String? = nil
        )
        {
            self.average = average
            self.max = max
            self.n = n
            self.name = name
            self.sum = sum
            self.unit = unit
        }
    }
}

extension ShieldClientTypes {

    public enum AttackLayer: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackLayer] {
            return [
                .application,
                .network
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .network: return "NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    public enum AttackPropertyIdentifier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case destinationUrl
        case referrer
        case sourceAsn
        case sourceCountry
        case sourceIpAddress
        case sourceUserAgent
        case wordpressPingbackReflector
        case wordpressPingbackSource
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackPropertyIdentifier] {
            return [
                .destinationUrl,
                .referrer,
                .sourceAsn,
                .sourceCountry,
                .sourceIpAddress,
                .sourceUserAgent,
                .wordpressPingbackReflector,
                .wordpressPingbackSource
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .destinationUrl: return "DESTINATION_URL"
            case .referrer: return "REFERRER"
            case .sourceAsn: return "SOURCE_ASN"
            case .sourceCountry: return "SOURCE_COUNTRY"
            case .sourceIpAddress: return "SOURCE_IP_ADDRESS"
            case .sourceUserAgent: return "SOURCE_USER_AGENT"
            case .wordpressPingbackReflector: return "WORDPRESS_PINGBACK_REFLECTOR"
            case .wordpressPingbackSource: return "WORDPRESS_PINGBACK_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    /// A contributor to the attack and their contribution.
    public struct Contributor: Swift.Sendable {
        /// The name of the contributor. The type of name that you'll find here depends on the AttackPropertyIdentifier setting in the AttackProperty where this contributor is defined. For example, if the AttackPropertyIdentifier is SOURCE_COUNTRY, the Name could be United States.
        public var name: Swift.String?
        /// The contribution of this contributor expressed in [Protection] units. For example 10,000.
        public var value: Swift.Int

        public init(
            name: Swift.String? = nil,
            value: Swift.Int = 0
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension ShieldClientTypes {

    public enum Unit: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bits
        case bytes
        case packets
        case requests
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .bits,
                .bytes,
                .packets,
                .requests
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bits: return "BITS"
            case .bytes: return "BYTES"
            case .packets: return "PACKETS"
            case .requests: return "REQUESTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    /// Details of a Shield event. This is provided as part of an [AttackDetail].
    public struct AttackProperty: Swift.Sendable {
        /// The type of Shield event that was observed. NETWORK indicates layer 3 and layer 4 events and APPLICATION indicates layer 7 events. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackLayer: ShieldClientTypes.AttackLayer?
        /// Defines the Shield event property information that is provided. The WORDPRESS_PINGBACK_REFLECTOR and WORDPRESS_PINGBACK_SOURCE values are valid only for WordPress reflective pingback events.
        public var attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier?
        /// Contributor objects for the top five contributors to a Shield event. A contributor is a source of traffic that Shield Advanced identifies as responsible for some or all of an event.
        public var topContributors: [ShieldClientTypes.Contributor]?
        /// The total contributions made to this Shield event by all contributors.
        public var total: Swift.Int
        /// The unit used for the ContributorValue property.
        public var unit: ShieldClientTypes.Unit?

        public init(
            attackLayer: ShieldClientTypes.AttackLayer? = nil,
            attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier? = nil,
            topContributors: [ShieldClientTypes.Contributor]? = nil,
            total: Swift.Int = 0,
            unit: ShieldClientTypes.Unit? = nil
        )
        {
            self.attackLayer = attackLayer
            self.attackPropertyIdentifier = attackPropertyIdentifier
            self.topContributors = topContributors
            self.total = total
            self.unit = unit
        }
    }
}

extension ShieldClientTypes {

    /// The mitigation applied to a DDoS attack.
    public struct Mitigation: Swift.Sendable {
        /// The name of the mitigation taken for this attack.
        public var mitigationName: Swift.String?

        public init(
            mitigationName: Swift.String? = nil
        )
        {
            self.mitigationName = mitigationName
        }
    }
}

extension ShieldClientTypes {

    /// A summary of information about the attack.
    public struct SummarizedAttackVector: Swift.Sendable {
        /// The list of counters that describe the details of the attack.
        public var vectorCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The attack type, for example, SNMP reflection or SYN flood.
        /// This member is required.
        public var vectorType: Swift.String?

        public init(
            vectorCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            vectorType: Swift.String? = nil
        )
        {
            self.vectorCounters = vectorCounters
            self.vectorType = vectorType
        }
    }
}

extension ShieldClientTypes {

    public enum SubResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ip
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [SubResourceType] {
            return [
                .ip,
                .url
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ip: return "IP"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    /// The attack information for the specified SubResource.
    public struct SubResourceSummary: Swift.Sendable {
        /// The list of attack types and associated counters.
        public var attackVectors: [ShieldClientTypes.SummarizedAttackVector]?
        /// The counters that describe the details of the attack.
        public var counters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the SubResource.
        public var id: Swift.String?
        /// The SubResource type.
        public var type: ShieldClientTypes.SubResourceType?

        public init(
            attackVectors: [ShieldClientTypes.SummarizedAttackVector]? = nil,
            counters: [ShieldClientTypes.SummarizedCounter]? = nil,
            id: Swift.String? = nil,
            type: ShieldClientTypes.SubResourceType? = nil
        )
        {
            self.attackVectors = attackVectors
            self.counters = counters
            self.id = id
            self.type = type
        }
    }
}

extension ShieldClientTypes {

    /// The details of a DDoS attack.
    public struct AttackDetail: Swift.Sendable {
        /// List of counters that describe the attack for the specified time period.
        public var attackCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The array of objects that provide details of the Shield event. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackProperties: [ShieldClientTypes.AttackProperty]?
        /// The time the attack ended, in Unix time in seconds.
        public var endTime: Foundation.Date?
        /// List of mitigation actions taken for the attack.
        public var mitigations: [ShieldClientTypes.Mitigation]?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The time the attack started, in Unix time in seconds.
        public var startTime: Foundation.Date?
        /// If applicable, additional detail about the resource being attacked, for example, IP address or URL.
        public var subResources: [ShieldClientTypes.SubResourceSummary]?

        public init(
            attackCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            attackId: Swift.String? = nil,
            attackProperties: [ShieldClientTypes.AttackProperty]? = nil,
            endTime: Foundation.Date? = nil,
            mitigations: [ShieldClientTypes.Mitigation]? = nil,
            resourceArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            subResources: [ShieldClientTypes.SubResourceSummary]? = nil
        )
        {
            self.attackCounters = attackCounters
            self.attackId = attackId
            self.attackProperties = attackProperties
            self.endTime = endTime
            self.mitigations = mitigations
            self.resourceArn = resourceArn
            self.startTime = startTime
            self.subResources = subResources
        }
    }
}

extension ShieldClientTypes {

    /// Statistics objects for the various data types in [AttackVolume].
    public struct AttackVolumeStatistics: Swift.Sendable {
        /// The maximum attack volume observed for the given unit.
        /// This member is required.
        public var max: Swift.Double

        public init(
            max: Swift.Double = 0.0
        )
        {
            self.max = max
        }
    }
}

extension ShieldClientTypes {

    /// Information about the volume of attacks during the time period, included in an [AttackStatisticsDataItem]. If the accompanying AttackCount in the statistics object is zero, this setting might be empty.
    public struct AttackVolume: Swift.Sendable {
        /// A statistics object that uses bits per second as the unit. This is included for network level attacks.
        public var bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses packets per second as the unit. This is included for network level attacks.
        public var packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses requests per second as the unit. This is included for application level attacks, and is only available for accounts that are subscribed to Shield Advanced.
        public var requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics?

        public init(
            bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil
        )
        {
            self.bitsPerSecond = bitsPerSecond
            self.packetsPerSecond = packetsPerSecond
            self.requestsPerSecond = requestsPerSecond
        }
    }
}

extension ShieldClientTypes {

    /// A single attack statistics data record. This is returned by [DescribeAttackStatistics] along with a time range indicating the time period that the attack statistics apply to.
    public struct AttackStatisticsDataItem: Swift.Sendable {
        /// The number of attacks detected during the time period. This is always present, but might be zero.
        /// This member is required.
        public var attackCount: Swift.Int
        /// Information about the volume of attacks during the time period. If the accompanying AttackCount is zero, this setting might be empty.
        public var attackVolume: ShieldClientTypes.AttackVolume?

        public init(
            attackCount: Swift.Int = 0,
            attackVolume: ShieldClientTypes.AttackVolume? = nil
        )
        {
            self.attackCount = attackCount
            self.attackVolume = attackVolume
        }
    }
}

extension ShieldClientTypes {

    /// Describes the attack.
    public struct AttackVectorDescription: Swift.Sendable {
        /// The attack type. Valid values:
        ///
        /// * UDP_TRAFFIC
        ///
        /// * UDP_FRAGMENT
        ///
        /// * GENERIC_UDP_REFLECTION
        ///
        /// * DNS_REFLECTION
        ///
        /// * NTP_REFLECTION
        ///
        /// * CHARGEN_REFLECTION
        ///
        /// * SSDP_REFLECTION
        ///
        /// * PORT_MAPPER
        ///
        /// * RIP_REFLECTION
        ///
        /// * SNMP_REFLECTION
        ///
        /// * MSSQL_REFLECTION
        ///
        /// * NET_BIOS_REFLECTION
        ///
        /// * SYN_FLOOD
        ///
        /// * ACK_FLOOD
        ///
        /// * REQUEST_FLOOD
        ///
        /// * HTTP_REFLECTION
        ///
        /// * UDS_REFLECTION
        ///
        /// * MEMCACHED_REFLECTION
        /// This member is required.
        public var vectorType: Swift.String?

        public init(
            vectorType: Swift.String? = nil
        )
        {
            self.vectorType = vectorType
        }
    }
}

extension ShieldClientTypes {

    /// Summarizes all DDoS attacks for a specified time period.
    public struct AttackSummary: Swift.Sendable {
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The list of attacks for a specified time period.
        public var attackVectors: [ShieldClientTypes.AttackVectorDescription]?
        /// The end time of the attack, in Unix time in seconds.
        public var endTime: Foundation.Date?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The start time of the attack, in Unix time in seconds.
        public var startTime: Foundation.Date?

        public init(
            attackId: Swift.String? = nil,
            attackVectors: [ShieldClientTypes.AttackVectorDescription]? = nil,
            endTime: Foundation.Date? = nil,
            resourceArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.attackId = attackId
            self.attackVectors = attackVectors
            self.endTime = endTime
            self.resourceArn = resourceArn
            self.startTime = startTime
        }
    }
}

extension ShieldClientTypes {

    public enum AutoRenew: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRenew] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Exception indicating the specified resource already exists. If available, this exception includes details in additional properties.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource that already exists.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

extension ShieldClientTypes {

    /// A tag associated with an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.
    public struct Tag: Swift.Sendable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateProtectionInput: Swift.Sendable {
    /// Friendly name for the Protection you are creating.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN (Amazon Resource Name) of the resource to be protected. The ARN should be in one of the following formats:
    ///
    /// * For an Application Load Balancer: arn:aws:elasticloadbalancing:region:account-id:loadbalancer/app/load-balancer-name/load-balancer-id
    ///
    /// * For an Elastic Load Balancer (Classic Load Balancer): arn:aws:elasticloadbalancing:region:account-id:loadbalancer/load-balancer-name
    ///
    /// * For an Amazon CloudFront distribution: arn:aws:cloudfront::account-id:distribution/distribution-id
    ///
    /// * For an Global Accelerator standard accelerator: arn:aws:globalaccelerator::account-id:accelerator/accelerator-id
    ///
    /// * For Amazon Route 53: arn:aws:route53:::hostedzone/hosted-zone-id
    ///
    /// * For an Elastic IP address: arn:aws:ec2:region:account-id:eip-allocation/allocation-id
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag key-value pairs for the [Protection] object that is created.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct CreateProtectionOutput: Swift.Sendable {
    /// The unique identifier (ID) for the [Protection] object that is created.
    public var protectionId: Swift.String?

    public init(
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

extension ShieldClientTypes {

    public enum ProtectionGroupAggregation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case max
        case mean
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupAggregation] {
            return [
                .max,
                .mean,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .max: return "MAX"
            case .mean: return "MEAN"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    public enum ProtectionGroupPattern: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case arbitrary
        case byResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupPattern] {
            return [
                .all,
                .arbitrary,
                .byResourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .arbitrary: return "ARBITRARY"
            case .byResourceType: return "BY_RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    public enum ProtectedResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applicationLoadBalancer
        case classicLoadBalancer
        case cloudfrontDistribution
        case elasticIpAllocation
        case globalAccelerator
        case route53HostedZone
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedResourceType] {
            return [
                .applicationLoadBalancer,
                .classicLoadBalancer,
                .cloudfrontDistribution,
                .elasticIpAllocation,
                .globalAccelerator,
                .route53HostedZone
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applicationLoadBalancer: return "APPLICATION_LOAD_BALANCER"
            case .classicLoadBalancer: return "CLASSIC_LOAD_BALANCER"
            case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
            case .elasticIpAllocation: return "ELASTIC_IP_ALLOCATION"
            case .globalAccelerator: return "GLOBAL_ACCELERATOR"
            case .route53HostedZone: return "ROUTE_53_HOSTED_ZONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProtectionGroupInput: Swift.Sendable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?
    /// One or more tag key-value pairs for the protection group.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
        self.tags = tags
    }
}

public struct CreateProtectionGroupOutput: Swift.Sendable {

    public init() { }
}

public struct CreateSubscriptionInput: Swift.Sendable {

    public init() { }
}

public struct CreateSubscriptionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProtectionInput: Swift.Sendable {
    /// The unique identifier (ID) for the [Protection] object to be deleted.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

public struct DeleteProtectionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProtectionGroupInput: Swift.Sendable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

public struct DeleteProtectionGroupOutput: Swift.Sendable {

    public init() { }
}

/// You are trying to update a subscription that has not yet completed the 1-year commitment. You can change the AutoRenew parameter during the last 30 days of your subscription. This exception indicates that you are attempting to change AutoRenew prior to that period.
public struct LockedSubscriptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LockedSubscriptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionInput: Swift.Sendable {

    public init() { }
}

@available(*, deprecated)
public struct DeleteSubscriptionOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeAttackInput: Swift.Sendable {
    /// The unique identifier (ID) for the attack.
    /// This member is required.
    public var attackId: Swift.String?

    public init(
        attackId: Swift.String? = nil
    )
    {
        self.attackId = attackId
    }
}

public struct DescribeAttackOutput: Swift.Sendable {
    /// The attack that you requested.
    public var attack: ShieldClientTypes.AttackDetail?

    public init(
        attack: ShieldClientTypes.AttackDetail? = nil
    )
    {
        self.attack = attack
    }
}

public struct DescribeAttackStatisticsInput: Swift.Sendable {

    public init() { }
}

extension ShieldClientTypes {

    /// The time range.
    public struct TimeRange: Swift.Sendable {
        /// The start time, in Unix time in seconds.
        public var fromInclusive: Foundation.Date?
        /// The end time, in Unix time in seconds.
        public var toExclusive: Foundation.Date?

        public init(
            fromInclusive: Foundation.Date? = nil,
            toExclusive: Foundation.Date? = nil
        )
        {
            self.fromInclusive = fromInclusive
            self.toExclusive = toExclusive
        }
    }
}

public struct DescribeAttackStatisticsOutput: Swift.Sendable {
    /// The data that describes the attacks detected during the time period.
    /// This member is required.
    public var dataItems: [ShieldClientTypes.AttackStatisticsDataItem]?
    /// The time range of the attack.
    /// This member is required.
    public var timeRange: ShieldClientTypes.TimeRange?

    public init(
        dataItems: [ShieldClientTypes.AttackStatisticsDataItem]? = nil,
        timeRange: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.dataItems = dataItems
        self.timeRange = timeRange
    }
}

public struct DescribeDRTAccessInput: Swift.Sendable {

    public init() { }
}

public struct DescribeDRTAccessOutput: Swift.Sendable {
    /// The list of Amazon S3 buckets accessed by the SRT.
    public var logBucketList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the role the SRT used to access your Amazon Web Services account.
    public var roleArn: Swift.String?

    public init(
        logBucketList: [Swift.String]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logBucketList = logBucketList
        self.roleArn = roleArn
    }
}

public struct DescribeEmergencyContactSettingsInput: Swift.Sendable {

    public init() { }
}

public struct DescribeEmergencyContactSettingsOutput: Swift.Sendable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

public struct DescribeProtectionInput: Swift.Sendable {
    /// The unique identifier (ID) for the [Protection] object to describe. You must provide either the ResourceArn of the protected resource or the ProtectionID of the protection, but not both.
    public var protectionId: Swift.String?
    /// The ARN (Amazon Resource Name) of the protected Amazon Web Services resource. You must provide either the ResourceArn of the protected resource or the ProtectionID of the protection, but not both.
    public var resourceArn: Swift.String?

    public init(
        protectionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
        self.resourceArn = resourceArn
    }
}

extension ShieldClientTypes {

    /// An object that represents a resource that is under DDoS protection.
    public struct Protection: Swift.Sendable {
        /// The automatic application layer DDoS mitigation settings for the protection. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
        public var applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration?
        /// The unique identifier (ID) for the Route 53 health check that's associated with the protection.
        public var healthCheckIds: [Swift.String]?
        /// The unique identifier (ID) of the protection.
        public var id: Swift.String?
        /// The name of the protection. For example, My CloudFront distributions.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) of the protection.
        public var protectionArn: Swift.String?
        /// The ARN (Amazon Resource Name) of the Amazon Web Services resource that is protected.
        public var resourceArn: Swift.String?

        public init(
            applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration? = nil,
            healthCheckIds: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            protectionArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfiguration
            self.healthCheckIds = healthCheckIds
            self.id = id
            self.name = name
            self.protectionArn = protectionArn
            self.resourceArn = resourceArn
        }
    }
}

public struct DescribeProtectionOutput: Swift.Sendable {
    /// The [Protection] that you requested.
    public var protection: ShieldClientTypes.Protection?

    public init(
        protection: ShieldClientTypes.Protection? = nil
    )
    {
        self.protection = protection
    }
}

public struct DescribeProtectionGroupInput: Swift.Sendable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

extension ShieldClientTypes {

    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    public struct ProtectionGroup: Swift.Sendable {
        /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
        ///
        /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
        ///
        /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
        ///
        /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
        /// This member is required.
        public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
        /// The ARNs (Amazon Resource Names) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
        /// This member is required.
        public var members: [Swift.String]?
        /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource ARNs (Amazon Resource Names), or include all resources of a specified resource type.
        /// This member is required.
        public var pattern: ShieldClientTypes.ProtectionGroupPattern?
        /// The ARN (Amazon Resource Name) of the protection group.
        public var protectionGroupArn: Swift.String?
        /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
        /// This member is required.
        public var protectionGroupId: Swift.String?
        /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
        public var resourceType: ShieldClientTypes.ProtectedResourceType?

        public init(
            aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
            members: [Swift.String]? = nil,
            pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
            protectionGroupArn: Swift.String? = nil,
            protectionGroupId: Swift.String? = nil,
            resourceType: ShieldClientTypes.ProtectedResourceType? = nil
        )
        {
            self.aggregation = aggregation
            self.members = members
            self.pattern = pattern
            self.protectionGroupArn = protectionGroupArn
            self.protectionGroupId = protectionGroupId
            self.resourceType = resourceType
        }
    }
}

public struct DescribeProtectionGroupOutput: Swift.Sendable {
    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    /// This member is required.
    public var protectionGroup: ShieldClientTypes.ProtectionGroup?

    public init(
        protectionGroup: ShieldClientTypes.ProtectionGroup? = nil
    )
    {
        self.protectionGroup = protectionGroup
    }
}

public struct DescribeSubscriptionInput: Swift.Sendable {

    public init() { }
}

extension ShieldClientTypes {

    /// Specifies how many protections of a given type you can create.
    public struct Limit: Swift.Sendable {
        /// The maximum number of protections that can be created for the specified Type.
        public var max: Swift.Int
        /// The type of protection.
        public var type: Swift.String?

        public init(
            max: Swift.Int = 0,
            type: Swift.String? = nil
        )
        {
            self.max = max
            self.type = type
        }
    }
}

extension ShieldClientTypes {

    public enum ProactiveEngagementStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProactiveEngagementStatus] {
            return [
                .disabled,
                .enabled,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ShieldClientTypes {

    /// Limits settings on protection groups with arbitrary pattern type.
    public struct ProtectionGroupArbitraryPatternLimits: Swift.Sendable {
        /// The maximum number of resources you can specify for a single arbitrary pattern in a protection group.
        /// This member is required.
        public var maxMembers: Swift.Int

        public init(
            maxMembers: Swift.Int = 0
        )
        {
            self.maxMembers = maxMembers
        }
    }
}

extension ShieldClientTypes {

    /// Limits settings by pattern type in the protection groups for your subscription.
    public struct ProtectionGroupPatternTypeLimits: Swift.Sendable {
        /// Limits settings on protection groups with arbitrary pattern type.
        /// This member is required.
        public var arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits?

        public init(
            arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits? = nil
        )
        {
            self.arbitraryPatternLimits = arbitraryPatternLimits
        }
    }
}

extension ShieldClientTypes {

    /// Limits settings on protection groups for your subscription.
    public struct ProtectionGroupLimits: Swift.Sendable {
        /// The maximum number of protection groups that you can have at one time.
        /// This member is required.
        public var maxProtectionGroups: Swift.Int
        /// Limits settings by pattern type in the protection groups for your subscription.
        /// This member is required.
        public var patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits?

        public init(
            maxProtectionGroups: Swift.Int = 0,
            patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits? = nil
        )
        {
            self.maxProtectionGroups = maxProtectionGroups
            self.patternTypeLimits = patternTypeLimits
        }
    }
}

extension ShieldClientTypes {

    /// Limits settings on protections for your subscription.
    public struct ProtectionLimits: Swift.Sendable {
        /// The maximum number of resource types that you can specify in a protection.
        /// This member is required.
        public var protectedResourceTypeLimits: [ShieldClientTypes.Limit]?

        public init(
            protectedResourceTypeLimits: [ShieldClientTypes.Limit]? = nil
        )
        {
            self.protectedResourceTypeLimits = protectedResourceTypeLimits
        }
    }
}

extension ShieldClientTypes {

    /// Limits settings for your subscription.
    public struct SubscriptionLimits: Swift.Sendable {
        /// Limits settings on protection groups for your subscription.
        /// This member is required.
        public var protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits?
        /// Limits settings on protections for your subscription.
        /// This member is required.
        public var protectionLimits: ShieldClientTypes.ProtectionLimits?

        public init(
            protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits? = nil,
            protectionLimits: ShieldClientTypes.ProtectionLimits? = nil
        )
        {
            self.protectionGroupLimits = protectionGroupLimits
            self.protectionLimits = protectionLimits
        }
    }
}

extension ShieldClientTypes {

    /// Information about the Shield Advanced subscription for an account.
    public struct Subscription: Swift.Sendable {
        /// If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. When you initally create a subscription, AutoRenew is set to ENABLED. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
        public var autoRenew: ShieldClientTypes.AutoRenew?
        /// The date and time your subscription will end.
        public var endTime: Foundation.Date?
        /// Specifies how many protections of a given type you can create.
        public var limits: [ShieldClientTypes.Limit]?
        /// If ENABLED, the Shield Response Team (SRT) will use email and phone to notify contacts about escalations to the SRT and to initiate proactive customer support. If PENDING, you have requested proactive engagement and the request is pending. The status changes to ENABLED when your request is fully processed. If DISABLED, the SRT will not proactively notify contacts about escalations or to initiate proactive customer support.
        public var proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus?
        /// The start time of the subscription, in Unix time in seconds.
        public var startTime: Foundation.Date?
        /// The ARN (Amazon Resource Name) of the subscription.
        public var subscriptionArn: Swift.String?
        /// Limits settings for your subscription.
        /// This member is required.
        public var subscriptionLimits: ShieldClientTypes.SubscriptionLimits?
        /// The length, in seconds, of the Shield Advanced subscription for the account.
        public var timeCommitmentInSeconds: Swift.Int

        public init(
            autoRenew: ShieldClientTypes.AutoRenew? = nil,
            endTime: Foundation.Date? = nil,
            limits: [ShieldClientTypes.Limit]? = nil,
            proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus? = nil,
            startTime: Foundation.Date? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionLimits: ShieldClientTypes.SubscriptionLimits? = nil,
            timeCommitmentInSeconds: Swift.Int = 0
        )
        {
            self.autoRenew = autoRenew
            self.endTime = endTime
            self.limits = limits
            self.proactiveEngagementStatus = proactiveEngagementStatus
            self.startTime = startTime
            self.subscriptionArn = subscriptionArn
            self.subscriptionLimits = subscriptionLimits
            self.timeCommitmentInSeconds = timeCommitmentInSeconds
        }
    }
}

public struct DescribeSubscriptionOutput: Swift.Sendable {
    /// The Shield Advanced subscription details for an account.
    public var subscription: ShieldClientTypes.Subscription?

    public init(
        subscription: ShieldClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

public struct DisableApplicationLayerAutomaticResponseInput: Swift.Sendable {
    /// The ARN (Amazon Resource Name) of the protected resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct DisableApplicationLayerAutomaticResponseOutput: Swift.Sendable {

    public init() { }
}

public struct DisableProactiveEngagementInput: Swift.Sendable {

    public init() { }
}

public struct DisableProactiveEngagementOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateDRTLogBucketInput: Swift.Sendable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init(
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

public struct DisassociateDRTLogBucketOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateDRTRoleInput: Swift.Sendable {

    public init() { }
}

public struct DisassociateDRTRoleOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateHealthCheckInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the health check that is associated with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to remove the health check association from.
    /// This member is required.
    public var protectionId: Swift.String?

    public init(
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

public struct DisassociateHealthCheckOutput: Swift.Sendable {

    public init() { }
}

public struct EnableApplicationLayerAutomaticResponseInput: Swift.Sendable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the protected resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

public struct EnableApplicationLayerAutomaticResponseOutput: Swift.Sendable {

    public init() { }
}

public struct EnableProactiveEngagementInput: Swift.Sendable {

    public init() { }
}

public struct EnableProactiveEngagementOutput: Swift.Sendable {

    public init() { }
}

public struct GetSubscriptionStateInput: Swift.Sendable {

    public init() { }
}

extension ShieldClientTypes {

    public enum SubscriptionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionState] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSubscriptionStateOutput: Swift.Sendable {
    /// The status of the subscription.
    /// This member is required.
    public var subscriptionState: ShieldClientTypes.SubscriptionState?

    public init(
        subscriptionState: ShieldClientTypes.SubscriptionState? = nil
    )
    {
        self.subscriptionState = subscriptionState
    }
}

public struct ListAttacksInput: Swift.Sendable {
    /// The end of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var endTime: ShieldClientTypes.TimeRange?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The ARNs (Amazon Resource Names) of the resources that were attacked. If you leave this blank, all applicable resources for this account will be included.
    public var resourceArns: [Swift.String]?
    /// The start of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var startTime: ShieldClientTypes.TimeRange?

    public init(
        endTime: ShieldClientTypes.TimeRange? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        startTime: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArns = resourceArns
        self.startTime = startTime
    }
}

public struct ListAttacksOutput: Swift.Sendable {
    /// The attack information for the specified time range.
    public var attackSummaries: [ShieldClientTypes.AttackSummary]?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?

    public init(
        attackSummaries: [ShieldClientTypes.AttackSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attackSummaries = attackSummaries
        self.nextToken = nextToken
    }
}

/// Exception that indicates that the NextToken specified in the request is invalid. Submit the request using the NextToken value that was returned in the prior response.
public struct InvalidPaginationTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ShieldClientTypes {

    /// Narrows the set of protection groups that the call retrieves. You can retrieve a single protection group by its name and you can retrieve all protection groups that are configured with a specific pattern, aggregation, or resource type. You can provide up to one criteria per filter type. Shield Advanced returns the protection groups that exactly match all of the search criteria that you provide.
    public struct InclusionProtectionGroupFilters: Swift.Sendable {
        /// The aggregation setting of the protection groups that you want to retrieve.
        public var aggregations: [ShieldClientTypes.ProtectionGroupAggregation]?
        /// The pattern specification of the protection groups that you want to retrieve.
        public var patterns: [ShieldClientTypes.ProtectionGroupPattern]?
        /// The ID of the protection group that you want to retrieve.
        public var protectionGroupIds: [Swift.String]?
        /// The resource type configuration of the protection groups that you want to retrieve. In the protection group configuration, you specify the resource type when you set the group's Pattern to BY_RESOURCE_TYPE.
        public var resourceTypes: [ShieldClientTypes.ProtectedResourceType]?

        public init(
            aggregations: [ShieldClientTypes.ProtectionGroupAggregation]? = nil,
            patterns: [ShieldClientTypes.ProtectionGroupPattern]? = nil,
            protectionGroupIds: [Swift.String]? = nil,
            resourceTypes: [ShieldClientTypes.ProtectedResourceType]? = nil
        )
        {
            self.aggregations = aggregations
            self.patterns = patterns
            self.protectionGroupIds = protectionGroupIds
            self.resourceTypes = resourceTypes
        }
    }
}

public struct ListProtectionGroupsInput: Swift.Sendable {
    /// Narrows the set of protection groups that the call retrieves. You can retrieve a single protection group by its name and you can retrieve all protection groups that are configured with specific pattern or aggregation settings. You can provide up to one criteria per filter type. Shield Advanced returns the protection groups that exactly match all of the search criteria that you provide.
    public var inclusionFilters: ShieldClientTypes.InclusionProtectionGroupFilters?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init(
        inclusionFilters: ShieldClientTypes.InclusionProtectionGroupFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inclusionFilters = inclusionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListProtectionGroupsOutput: Swift.Sendable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    ///
    /// This member is required.
    public var protectionGroups: [ShieldClientTypes.ProtectionGroup]?

    public init(
        nextToken: Swift.String? = nil,
        protectionGroups: [ShieldClientTypes.ProtectionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectionGroups = protectionGroups
    }
}

extension ShieldClientTypes {

    /// Narrows the set of protections that the call retrieves. You can retrieve a single protection by providing its name or the ARN (Amazon Resource Name) of its protected resource. You can also retrieve all protections for a specific resource type. You can provide up to one criteria per filter type. Shield Advanced returns protections that exactly match all of the filter criteria that you provide.
    public struct InclusionProtectionFilters: Swift.Sendable {
        /// The name of the protection that you want to retrieve.
        public var protectionNames: [Swift.String]?
        /// The ARN (Amazon Resource Name) of the resource whose protection you want to retrieve.
        public var resourceArns: [Swift.String]?
        /// The type of protected resource whose protections you want to retrieve.
        public var resourceTypes: [ShieldClientTypes.ProtectedResourceType]?

        public init(
            protectionNames: [Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceTypes: [ShieldClientTypes.ProtectedResourceType]? = nil
        )
        {
            self.protectionNames = protectionNames
            self.resourceArns = resourceArns
            self.resourceTypes = resourceTypes
        }
    }
}

public struct ListProtectionsInput: Swift.Sendable {
    /// Narrows the set of protections that the call retrieves. You can retrieve a single protection by providing its name or the ARN (Amazon Resource Name) of its protected resource. You can also retrieve all protections for a specific resource type. You can provide up to one criteria per filter type. Shield Advanced returns protections that exactly match all of the filter criteria that you provide.
    public var inclusionFilters: ShieldClientTypes.InclusionProtectionFilters?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init(
        inclusionFilters: ShieldClientTypes.InclusionProtectionFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.inclusionFilters = inclusionFilters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListProtectionsOutput: Swift.Sendable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The array of enabled [Protection] objects.
    public var protections: [ShieldClientTypes.Protection]?

    public init(
        nextToken: Swift.String? = nil,
        protections: [ShieldClientTypes.Protection]? = nil
    )
    {
        self.nextToken = nextToken
        self.protections = protections
    }
}

public struct ListResourcesInProtectionGroupInput: Swift.Sendable {
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        protectionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.protectionGroupId = protectionGroupId
    }
}

public struct ListResourcesInProtectionGroupOutput: Swift.Sendable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of the resources that are included in the protection group.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArns = resourceArns
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to modify or add to the resource.
    /// This member is required.
    public var tags: [ShieldClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateApplicationLayerAutomaticResponseInput: Swift.Sendable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

public struct UpdateApplicationLayerAutomaticResponseOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateEmergencyContactSettingsInput: Swift.Sendable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support. If you have proactive engagement enabled, the contact list must include at least one phone number.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init(
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

public struct UpdateEmergencyContactSettingsOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateProtectionGroupInput: Swift.Sendable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?

    public init(
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
    }
}

public struct UpdateProtectionGroupOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateSubscriptionInput: Swift.Sendable {
    /// When you initally create a subscription, AutoRenew is set to ENABLED. If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
    public var autoRenew: ShieldClientTypes.AutoRenew?

    public init(
        autoRenew: ShieldClientTypes.AutoRenew? = nil
    )
    {
        self.autoRenew = autoRenew
    }
}

public struct UpdateSubscriptionOutput: Swift.Sendable {

    public init() { }
}

extension AssociateDRTLogBucketInput {

    static func urlPathProvider(_ value: AssociateDRTLogBucketInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDRTRoleInput {

    static func urlPathProvider(_ value: AssociateDRTRoleInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateHealthCheckInput {

    static func urlPathProvider(_ value: AssociateHealthCheckInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateProactiveEngagementDetailsInput {

    static func urlPathProvider(_ value: AssociateProactiveEngagementDetailsInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProtectionInput {

    static func urlPathProvider(_ value: CreateProtectionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProtectionGroupInput {

    static func urlPathProvider(_ value: CreateProtectionGroupInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSubscriptionInput {

    static func urlPathProvider(_ value: CreateSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProtectionInput {

    static func urlPathProvider(_ value: DeleteProtectionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProtectionGroupInput {

    static func urlPathProvider(_ value: DeleteProtectionGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSubscriptionInput {

    static func urlPathProvider(_ value: DeleteSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAttackInput {

    static func urlPathProvider(_ value: DescribeAttackInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAttackStatisticsInput {

    static func urlPathProvider(_ value: DescribeAttackStatisticsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDRTAccessInput {

    static func urlPathProvider(_ value: DescribeDRTAccessInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEmergencyContactSettingsInput {

    static func urlPathProvider(_ value: DescribeEmergencyContactSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProtectionInput {

    static func urlPathProvider(_ value: DescribeProtectionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeProtectionGroupInput {

    static func urlPathProvider(_ value: DescribeProtectionGroupInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSubscriptionInput {

    static func urlPathProvider(_ value: DescribeSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension DisableApplicationLayerAutomaticResponseInput {

    static func urlPathProvider(_ value: DisableApplicationLayerAutomaticResponseInput) -> Swift.String? {
        return "/"
    }
}

extension DisableProactiveEngagementInput {

    static func urlPathProvider(_ value: DisableProactiveEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateDRTLogBucketInput {

    static func urlPathProvider(_ value: DisassociateDRTLogBucketInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateDRTRoleInput {

    static func urlPathProvider(_ value: DisassociateDRTRoleInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateHealthCheckInput {

    static func urlPathProvider(_ value: DisassociateHealthCheckInput) -> Swift.String? {
        return "/"
    }
}

extension EnableApplicationLayerAutomaticResponseInput {

    static func urlPathProvider(_ value: EnableApplicationLayerAutomaticResponseInput) -> Swift.String? {
        return "/"
    }
}

extension EnableProactiveEngagementInput {

    static func urlPathProvider(_ value: EnableProactiveEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension GetSubscriptionStateInput {

    static func urlPathProvider(_ value: GetSubscriptionStateInput) -> Swift.String? {
        return "/"
    }
}

extension ListAttacksInput {

    static func urlPathProvider(_ value: ListAttacksInput) -> Swift.String? {
        return "/"
    }
}

extension ListProtectionGroupsInput {

    static func urlPathProvider(_ value: ListProtectionGroupsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProtectionsInput {

    static func urlPathProvider(_ value: ListProtectionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourcesInProtectionGroupInput {

    static func urlPathProvider(_ value: ListResourcesInProtectionGroupInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationLayerAutomaticResponseInput {

    static func urlPathProvider(_ value: UpdateApplicationLayerAutomaticResponseInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEmergencyContactSettingsInput {

    static func urlPathProvider(_ value: UpdateEmergencyContactSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProtectionGroupInput {

    static func urlPathProvider(_ value: UpdateProtectionGroupInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSubscriptionInput {

    static func urlPathProvider(_ value: UpdateSubscriptionInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateDRTLogBucketInput {

    static func write(value: AssociateDRTLogBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogBucket"].write(value.logBucket)
    }
}

extension AssociateDRTRoleInput {

    static func write(value: AssociateDRTRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension AssociateHealthCheckInput {

    static func write(value: AssociateHealthCheckInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthCheckArn"].write(value.healthCheckArn)
        try writer["ProtectionId"].write(value.protectionId)
    }
}

extension AssociateProactiveEngagementDetailsInput {

    static func write(value: AssociateProactiveEngagementDetailsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmergencyContactList"].writeList(value.emergencyContactList, memberWritingClosure: ShieldClientTypes.EmergencyContact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProtectionInput {

    static func write(value: CreateProtectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ShieldClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProtectionGroupInput {

    static func write(value: CreateProtectionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["Members"].writeList(value.members, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Pattern"].write(value.pattern)
        try writer["ProtectionGroupId"].write(value.protectionGroupId)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ShieldClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSubscriptionInput {

    static func write(value: CreateSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteProtectionInput {

    static func write(value: DeleteProtectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectionId"].write(value.protectionId)
    }
}

extension DeleteProtectionGroupInput {

    static func write(value: DeleteProtectionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectionGroupId"].write(value.protectionGroupId)
    }
}

extension DeleteSubscriptionInput {

    static func write(value: DeleteSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeAttackInput {

    static func write(value: DescribeAttackInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AttackId"].write(value.attackId)
    }
}

extension DescribeAttackStatisticsInput {

    static func write(value: DescribeAttackStatisticsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeDRTAccessInput {

    static func write(value: DescribeDRTAccessInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeEmergencyContactSettingsInput {

    static func write(value: DescribeEmergencyContactSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DescribeProtectionInput {

    static func write(value: DescribeProtectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectionId"].write(value.protectionId)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DescribeProtectionGroupInput {

    static func write(value: DescribeProtectionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectionGroupId"].write(value.protectionGroupId)
    }
}

extension DescribeSubscriptionInput {

    static func write(value: DescribeSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisableApplicationLayerAutomaticResponseInput {

    static func write(value: DisableApplicationLayerAutomaticResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension DisableProactiveEngagementInput {

    static func write(value: DisableProactiveEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateDRTLogBucketInput {

    static func write(value: DisassociateDRTLogBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LogBucket"].write(value.logBucket)
    }
}

extension DisassociateDRTRoleInput {

    static func write(value: DisassociateDRTRoleInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateHealthCheckInput {

    static func write(value: DisassociateHealthCheckInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthCheckArn"].write(value.healthCheckArn)
        try writer["ProtectionId"].write(value.protectionId)
    }
}

extension EnableApplicationLayerAutomaticResponseInput {

    static func write(value: EnableApplicationLayerAutomaticResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: ShieldClientTypes.ResponseAction.write(value:to:))
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension EnableProactiveEngagementInput {

    static func write(value: EnableProactiveEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetSubscriptionStateInput {

    static func write(value: GetSubscriptionStateInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListAttacksInput {

    static func write(value: ListAttacksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].write(value.endTime, with: ShieldClientTypes.TimeRange.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartTime"].write(value.startTime, with: ShieldClientTypes.TimeRange.write(value:to:))
    }
}

extension ListProtectionGroupsInput {

    static func write(value: ListProtectionGroupsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InclusionFilters"].write(value.inclusionFilters, with: ShieldClientTypes.InclusionProtectionGroupFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListProtectionsInput {

    static func write(value: ListProtectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InclusionFilters"].write(value.inclusionFilters, with: ShieldClientTypes.InclusionProtectionFilters.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListResourcesInProtectionGroupInput {

    static func write(value: ListResourcesInProtectionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProtectionGroupId"].write(value.protectionGroupId)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ShieldClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationLayerAutomaticResponseInput {

    static func write(value: UpdateApplicationLayerAutomaticResponseInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Action"].write(value.action, with: ShieldClientTypes.ResponseAction.write(value:to:))
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension UpdateEmergencyContactSettingsInput {

    static func write(value: UpdateEmergencyContactSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EmergencyContactList"].writeList(value.emergencyContactList, memberWritingClosure: ShieldClientTypes.EmergencyContact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateProtectionGroupInput {

    static func write(value: UpdateProtectionGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregation"].write(value.aggregation)
        try writer["Members"].writeList(value.members, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Pattern"].write(value.pattern)
        try writer["ProtectionGroupId"].write(value.protectionGroupId)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension UpdateSubscriptionInput {

    static func write(value: UpdateSubscriptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoRenew"].write(value.autoRenew)
    }
}

extension AssociateDRTLogBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDRTLogBucketOutput {
        return AssociateDRTLogBucketOutput()
    }
}

extension AssociateDRTRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateDRTRoleOutput {
        return AssociateDRTRoleOutput()
    }
}

extension AssociateHealthCheckOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateHealthCheckOutput {
        return AssociateHealthCheckOutput()
    }
}

extension AssociateProactiveEngagementDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateProactiveEngagementDetailsOutput {
        return AssociateProactiveEngagementDetailsOutput()
    }
}

extension CreateProtectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProtectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProtectionOutput()
        value.protectionId = try reader["ProtectionId"].readIfPresent()
        return value
    }
}

extension CreateProtectionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProtectionGroupOutput {
        return CreateProtectionGroupOutput()
    }
}

extension CreateSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionOutput {
        return CreateSubscriptionOutput()
    }
}

extension DeleteProtectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProtectionOutput {
        return DeleteProtectionOutput()
    }
}

extension DeleteProtectionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProtectionGroupOutput {
        return DeleteProtectionGroupOutput()
    }
}

extension DeleteSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriptionOutput {
        return DeleteSubscriptionOutput()
    }
}

extension DescribeAttackOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAttackOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAttackOutput()
        value.attack = try reader["Attack"].readIfPresent(with: ShieldClientTypes.AttackDetail.read(from:))
        return value
    }
}

extension DescribeAttackStatisticsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAttackStatisticsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAttackStatisticsOutput()
        value.dataItems = try reader["DataItems"].readListIfPresent(memberReadingClosure: ShieldClientTypes.AttackStatisticsDataItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeRange = try reader["TimeRange"].readIfPresent(with: ShieldClientTypes.TimeRange.read(from:))
        return value
    }
}

extension DescribeDRTAccessOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDRTAccessOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDRTAccessOutput()
        value.logBucketList = try reader["LogBucketList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension DescribeEmergencyContactSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEmergencyContactSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEmergencyContactSettingsOutput()
        value.emergencyContactList = try reader["EmergencyContactList"].readListIfPresent(memberReadingClosure: ShieldClientTypes.EmergencyContact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeProtectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProtectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProtectionOutput()
        value.protection = try reader["Protection"].readIfPresent(with: ShieldClientTypes.Protection.read(from:))
        return value
    }
}

extension DescribeProtectionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProtectionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProtectionGroupOutput()
        value.protectionGroup = try reader["ProtectionGroup"].readIfPresent(with: ShieldClientTypes.ProtectionGroup.read(from:))
        return value
    }
}

extension DescribeSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSubscriptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSubscriptionOutput()
        value.subscription = try reader["Subscription"].readIfPresent(with: ShieldClientTypes.Subscription.read(from:))
        return value
    }
}

extension DisableApplicationLayerAutomaticResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableApplicationLayerAutomaticResponseOutput {
        return DisableApplicationLayerAutomaticResponseOutput()
    }
}

extension DisableProactiveEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableProactiveEngagementOutput {
        return DisableProactiveEngagementOutput()
    }
}

extension DisassociateDRTLogBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDRTLogBucketOutput {
        return DisassociateDRTLogBucketOutput()
    }
}

extension DisassociateDRTRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateDRTRoleOutput {
        return DisassociateDRTRoleOutput()
    }
}

extension DisassociateHealthCheckOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateHealthCheckOutput {
        return DisassociateHealthCheckOutput()
    }
}

extension EnableApplicationLayerAutomaticResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableApplicationLayerAutomaticResponseOutput {
        return EnableApplicationLayerAutomaticResponseOutput()
    }
}

extension EnableProactiveEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableProactiveEngagementOutput {
        return EnableProactiveEngagementOutput()
    }
}

extension GetSubscriptionStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionStateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionStateOutput()
        value.subscriptionState = try reader["SubscriptionState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListAttacksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAttacksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAttacksOutput()
        value.attackSummaries = try reader["AttackSummaries"].readListIfPresent(memberReadingClosure: ShieldClientTypes.AttackSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListProtectionGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtectionGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtectionGroupsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.protectionGroups = try reader["ProtectionGroups"].readListIfPresent(memberReadingClosure: ShieldClientTypes.ProtectionGroup.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListProtectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtectionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.protections = try reader["Protections"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Protection.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourcesInProtectionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourcesInProtectionGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourcesInProtectionGroupOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceArns = try reader["ResourceArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationLayerAutomaticResponseOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationLayerAutomaticResponseOutput {
        return UpdateApplicationLayerAutomaticResponseOutput()
    }
}

extension UpdateEmergencyContactSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEmergencyContactSettingsOutput {
        return UpdateEmergencyContactSettingsOutput()
    }
}

extension UpdateProtectionGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProtectionGroupOutput {
        return UpdateProtectionGroupOutput()
    }
}

extension UpdateSubscriptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionOutput {
        return UpdateSubscriptionOutput()
    }
}

enum AssociateDRTLogBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedForDependencyException": return try AccessDeniedForDependencyException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitsExceededException": return try LimitsExceededException.makeError(baseError: baseError)
            case "NoAssociatedRoleException": return try NoAssociatedRoleException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateDRTRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedForDependencyException": return try AccessDeniedForDependencyException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateHealthCheckOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "LimitsExceededException": return try LimitsExceededException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateProactiveEngagementDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProtectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "LimitsExceededException": return try LimitsExceededException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProtectionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitsExceededException": return try LimitsExceededException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProtectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProtectionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "LockedSubscriptionException": return try LockedSubscriptionException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAttackOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAttackStatisticsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDRTAccessOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEmergencyContactSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProtectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProtectionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableApplicationLayerAutomaticResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableProactiveEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDRTLogBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedForDependencyException": return try AccessDeniedForDependencyException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "NoAssociatedRoleException": return try NoAssociatedRoleException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateDRTRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateHealthCheckOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableApplicationLayerAutomaticResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitsExceededException": return try LimitsExceededException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableProactiveEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAttacksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtectionGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourcesInProtectionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidPaginationTokenException": return try InvalidPaginationTokenException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "InvalidResourceException": return try InvalidResourceException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationLayerAutomaticResponseOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEmergencyContactSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProtectionGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LockedSubscriptionException": return try LockedSubscriptionException.makeError(baseError: baseError)
            case "OptimisticLockException": return try OptimisticLockException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOperationException {
        let reader = baseError.errorBodyReader
        var value = InvalidOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedForDependencyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedForDependencyException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedForDependencyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.fields = try reader["fields"].readListIfPresent(memberReadingClosure: ShieldClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoAssociatedRoleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoAssociatedRoleException {
        let reader = baseError.errorBodyReader
        var value = NoAssociatedRoleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OptimisticLockException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OptimisticLockException {
        let reader = baseError.errorBodyReader
        var value = OptimisticLockException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitsExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitsExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitsExceededException()
        value.properties.limit = try reader["Limit"].readIfPresent() ?? 0
        value.properties.type = try reader["Type"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidResourceException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LockedSubscriptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LockedSubscriptionException {
        let reader = baseError.errorBodyReader
        var value = LockedSubscriptionException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidPaginationTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidPaginationTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidPaginationTokenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ShieldClientTypes.AttackDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackDetail()
        value.attackId = try reader["AttackId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.subResources = try reader["SubResources"].readListIfPresent(memberReadingClosure: ShieldClientTypes.SubResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.attackCounters = try reader["AttackCounters"].readListIfPresent(memberReadingClosure: ShieldClientTypes.SummarizedCounter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.attackProperties = try reader["AttackProperties"].readListIfPresent(memberReadingClosure: ShieldClientTypes.AttackProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mitigations = try reader["Mitigations"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Mitigation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ShieldClientTypes.Mitigation {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Mitigation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Mitigation()
        value.mitigationName = try reader["MitigationName"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.AttackProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackProperty()
        value.attackLayer = try reader["AttackLayer"].readIfPresent()
        value.attackPropertyIdentifier = try reader["AttackPropertyIdentifier"].readIfPresent()
        value.topContributors = try reader["TopContributors"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Contributor.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unit = try reader["Unit"].readIfPresent()
        value.total = try reader["Total"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.Contributor {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Contributor {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Contributor()
        value.name = try reader["Name"].readIfPresent()
        value.value = try reader["Value"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.SummarizedCounter {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.SummarizedCounter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.SummarizedCounter()
        value.name = try reader["Name"].readIfPresent()
        value.max = try reader["Max"].readIfPresent() ?? 0
        value.average = try reader["Average"].readIfPresent() ?? 0
        value.sum = try reader["Sum"].readIfPresent() ?? 0
        value.n = try reader["N"].readIfPresent() ?? 0
        value.unit = try reader["Unit"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.SubResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.SubResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.SubResourceSummary()
        value.type = try reader["Type"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.attackVectors = try reader["AttackVectors"].readListIfPresent(memberReadingClosure: ShieldClientTypes.SummarizedAttackVector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.counters = try reader["Counters"].readListIfPresent(memberReadingClosure: ShieldClientTypes.SummarizedCounter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ShieldClientTypes.SummarizedAttackVector {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.SummarizedAttackVector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.SummarizedAttackVector()
        value.vectorType = try reader["VectorType"].readIfPresent() ?? ""
        value.vectorCounters = try reader["VectorCounters"].readListIfPresent(memberReadingClosure: ShieldClientTypes.SummarizedCounter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ShieldClientTypes.TimeRange {

    static func write(value: ShieldClientTypes.TimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FromInclusive"].writeTimestamp(value.fromInclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["ToExclusive"].writeTimestamp(value.toExclusive, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.TimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.TimeRange()
        value.fromInclusive = try reader["FromInclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.toExclusive = try reader["ToExclusive"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ShieldClientTypes.AttackStatisticsDataItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackStatisticsDataItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackStatisticsDataItem()
        value.attackVolume = try reader["AttackVolume"].readIfPresent(with: ShieldClientTypes.AttackVolume.read(from:))
        value.attackCount = try reader["AttackCount"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.AttackVolume {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackVolume {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackVolume()
        value.bitsPerSecond = try reader["BitsPerSecond"].readIfPresent(with: ShieldClientTypes.AttackVolumeStatistics.read(from:))
        value.packetsPerSecond = try reader["PacketsPerSecond"].readIfPresent(with: ShieldClientTypes.AttackVolumeStatistics.read(from:))
        value.requestsPerSecond = try reader["RequestsPerSecond"].readIfPresent(with: ShieldClientTypes.AttackVolumeStatistics.read(from:))
        return value
    }
}

extension ShieldClientTypes.AttackVolumeStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackVolumeStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackVolumeStatistics()
        value.max = try reader["Max"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.EmergencyContact {

    static func write(value: ShieldClientTypes.EmergencyContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactNotes"].write(value.contactNotes)
        try writer["EmailAddress"].write(value.emailAddress)
        try writer["PhoneNumber"].write(value.phoneNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.EmergencyContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.EmergencyContact()
        value.emailAddress = try reader["EmailAddress"].readIfPresent() ?? ""
        value.phoneNumber = try reader["PhoneNumber"].readIfPresent()
        value.contactNotes = try reader["ContactNotes"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.Protection {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Protection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Protection()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.healthCheckIds = try reader["HealthCheckIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.protectionArn = try reader["ProtectionArn"].readIfPresent()
        value.applicationLayerAutomaticResponseConfiguration = try reader["ApplicationLayerAutomaticResponseConfiguration"].readIfPresent(with: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration.read(from:))
        return value
    }
}

extension ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.action = try reader["Action"].readIfPresent(with: ShieldClientTypes.ResponseAction.read(from:))
        return value
    }
}

extension ShieldClientTypes.ResponseAction {

    static func write(value: ShieldClientTypes.ResponseAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Block"].write(value.block, with: ShieldClientTypes.BlockAction.write(value:to:))
        try writer["Count"].write(value.count, with: ShieldClientTypes.CountAction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ResponseAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ResponseAction()
        value.block = try reader["Block"].readIfPresent(with: ShieldClientTypes.BlockAction.read(from:))
        value.count = try reader["Count"].readIfPresent(with: ShieldClientTypes.CountAction.read(from:))
        return value
    }
}

extension ShieldClientTypes.CountAction {

    static func write(value: ShieldClientTypes.CountAction?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.CountAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ShieldClientTypes.CountAction()
    }
}

extension ShieldClientTypes.BlockAction {

    static func write(value: ShieldClientTypes.BlockAction?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.BlockAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return ShieldClientTypes.BlockAction()
    }
}

extension ShieldClientTypes.ProtectionGroup {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ProtectionGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ProtectionGroup()
        value.protectionGroupId = try reader["ProtectionGroupId"].readIfPresent() ?? ""
        value.aggregation = try reader["Aggregation"].readIfPresent() ?? .sdkUnknown("")
        value.pattern = try reader["Pattern"].readIfPresent() ?? .sdkUnknown("")
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.members = try reader["Members"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.protectionGroupArn = try reader["ProtectionGroupArn"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.Subscription {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Subscription()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timeCommitmentInSeconds = try reader["TimeCommitmentInSeconds"].readIfPresent() ?? 0
        value.autoRenew = try reader["AutoRenew"].readIfPresent()
        value.limits = try reader["Limits"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Limit.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.proactiveEngagementStatus = try reader["ProactiveEngagementStatus"].readIfPresent()
        value.subscriptionLimits = try reader["SubscriptionLimits"].readIfPresent(with: ShieldClientTypes.SubscriptionLimits.read(from:))
        value.subscriptionArn = try reader["SubscriptionArn"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.SubscriptionLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.SubscriptionLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.SubscriptionLimits()
        value.protectionLimits = try reader["ProtectionLimits"].readIfPresent(with: ShieldClientTypes.ProtectionLimits.read(from:))
        value.protectionGroupLimits = try reader["ProtectionGroupLimits"].readIfPresent(with: ShieldClientTypes.ProtectionGroupLimits.read(from:))
        return value
    }
}

extension ShieldClientTypes.ProtectionGroupLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ProtectionGroupLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ProtectionGroupLimits()
        value.maxProtectionGroups = try reader["MaxProtectionGroups"].readIfPresent() ?? 0
        value.patternTypeLimits = try reader["PatternTypeLimits"].readIfPresent(with: ShieldClientTypes.ProtectionGroupPatternTypeLimits.read(from:))
        return value
    }
}

extension ShieldClientTypes.ProtectionGroupPatternTypeLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ProtectionGroupPatternTypeLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ProtectionGroupPatternTypeLimits()
        value.arbitraryPatternLimits = try reader["ArbitraryPatternLimits"].readIfPresent(with: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits.read(from:))
        return value
    }
}

extension ShieldClientTypes.ProtectionGroupArbitraryPatternLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ProtectionGroupArbitraryPatternLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ProtectionGroupArbitraryPatternLimits()
        value.maxMembers = try reader["MaxMembers"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.ProtectionLimits {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ProtectionLimits {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ProtectionLimits()
        value.protectedResourceTypeLimits = try reader["ProtectedResourceTypeLimits"].readListIfPresent(memberReadingClosure: ShieldClientTypes.Limit.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ShieldClientTypes.Limit {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Limit {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Limit()
        value.type = try reader["Type"].readIfPresent()
        value.max = try reader["Max"].readIfPresent() ?? 0
        return value
    }
}

extension ShieldClientTypes.AttackSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackSummary()
        value.attackId = try reader["AttackId"].readIfPresent()
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.attackVectors = try reader["AttackVectors"].readListIfPresent(memberReadingClosure: ShieldClientTypes.AttackVectorDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ShieldClientTypes.AttackVectorDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.AttackVectorDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.AttackVectorDescription()
        value.vectorType = try reader["VectorType"].readIfPresent() ?? ""
        return value
    }
}

extension ShieldClientTypes.Tag {

    static func write(value: ShieldClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension ShieldClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> ShieldClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ShieldClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension ShieldClientTypes.InclusionProtectionGroupFilters {

    static func write(value: ShieldClientTypes.InclusionProtectionGroupFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Aggregations"].writeList(value.aggregations, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ShieldClientTypes.ProtectionGroupAggregation>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Patterns"].writeList(value.patterns, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ShieldClientTypes.ProtectionGroupPattern>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ProtectionGroupIds"].writeList(value.protectionGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ShieldClientTypes.ProtectedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ShieldClientTypes.InclusionProtectionFilters {

    static func write(value: ShieldClientTypes.InclusionProtectionFilters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ProtectionNames"].writeList(value.protectionNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceArns"].writeList(value.resourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTypes"].writeList(value.resourceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ShieldClientTypes.ProtectedResourceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ShieldClientTypes {}
