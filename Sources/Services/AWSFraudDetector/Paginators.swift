// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension FraudDetectorClient {
    /// Paginate over `[DescribeModelVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[DescribeModelVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `DescribeModelVersionsOutputResponse`
    public func describeModelVersionsPaginated(input: DescribeModelVersionsInput) -> ClientRuntime.PaginatorSequence<DescribeModelVersionsInput, DescribeModelVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<DescribeModelVersionsInput, DescribeModelVersionsOutputResponse>(input: input, inputKey: \DescribeModelVersionsInput.nextToken, outputKey: \DescribeModelVersionsOutputResponse.nextToken, paginationFunction: self.describeModelVersions(input:))
    }
}

extension DescribeModelVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> DescribeModelVersionsInput {
        return DescribeModelVersionsInput(
            maxResults: self.maxResults,
            modelId: self.modelId,
            modelType: self.modelType,
            modelVersionNumber: self.modelVersionNumber,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetBatchImportJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBatchImportJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBatchImportJobsOutputResponse`
    public func getBatchImportJobsPaginated(input: GetBatchImportJobsInput) -> ClientRuntime.PaginatorSequence<GetBatchImportJobsInput, GetBatchImportJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetBatchImportJobsInput, GetBatchImportJobsOutputResponse>(input: input, inputKey: \GetBatchImportJobsInput.nextToken, outputKey: \GetBatchImportJobsOutputResponse.nextToken, paginationFunction: self.getBatchImportJobs(input:))
    }
}

extension GetBatchImportJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBatchImportJobsInput {
        return GetBatchImportJobsInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetBatchPredictionJobsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetBatchPredictionJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetBatchPredictionJobsOutputResponse`
    public func getBatchPredictionJobsPaginated(input: GetBatchPredictionJobsInput) -> ClientRuntime.PaginatorSequence<GetBatchPredictionJobsInput, GetBatchPredictionJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetBatchPredictionJobsInput, GetBatchPredictionJobsOutputResponse>(input: input, inputKey: \GetBatchPredictionJobsInput.nextToken, outputKey: \GetBatchPredictionJobsOutputResponse.nextToken, paginationFunction: self.getBatchPredictionJobs(input:))
    }
}

extension GetBatchPredictionJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetBatchPredictionJobsInput {
        return GetBatchPredictionJobsInput(
            jobId: self.jobId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetDetectorsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetDetectorsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetDetectorsOutputResponse`
    public func getDetectorsPaginated(input: GetDetectorsInput) -> ClientRuntime.PaginatorSequence<GetDetectorsInput, GetDetectorsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetDetectorsInput, GetDetectorsOutputResponse>(input: input, inputKey: \GetDetectorsInput.nextToken, outputKey: \GetDetectorsOutputResponse.nextToken, paginationFunction: self.getDetectors(input:))
    }
}

extension GetDetectorsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetDetectorsInput {
        return GetDetectorsInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetEntityTypesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEntityTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEntityTypesOutputResponse`
    public func getEntityTypesPaginated(input: GetEntityTypesInput) -> ClientRuntime.PaginatorSequence<GetEntityTypesInput, GetEntityTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEntityTypesInput, GetEntityTypesOutputResponse>(input: input, inputKey: \GetEntityTypesInput.nextToken, outputKey: \GetEntityTypesOutputResponse.nextToken, paginationFunction: self.getEntityTypes(input:))
    }
}

extension GetEntityTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEntityTypesInput {
        return GetEntityTypesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetEventTypesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetEventTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetEventTypesOutputResponse`
    public func getEventTypesPaginated(input: GetEventTypesInput) -> ClientRuntime.PaginatorSequence<GetEventTypesInput, GetEventTypesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetEventTypesInput, GetEventTypesOutputResponse>(input: input, inputKey: \GetEventTypesInput.nextToken, outputKey: \GetEventTypesOutputResponse.nextToken, paginationFunction: self.getEventTypes(input:))
    }
}

extension GetEventTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetEventTypesInput {
        return GetEventTypesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetExternalModelsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetExternalModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetExternalModelsOutputResponse`
    public func getExternalModelsPaginated(input: GetExternalModelsInput) -> ClientRuntime.PaginatorSequence<GetExternalModelsInput, GetExternalModelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetExternalModelsInput, GetExternalModelsOutputResponse>(input: input, inputKey: \GetExternalModelsInput.nextToken, outputKey: \GetExternalModelsOutputResponse.nextToken, paginationFunction: self.getExternalModels(input:))
    }
}

extension GetExternalModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetExternalModelsInput {
        return GetExternalModelsInput(
            maxResults: self.maxResults,
            modelEndpoint: self.modelEndpoint,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetLabelsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetLabelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetLabelsOutputResponse`
    public func getLabelsPaginated(input: GetLabelsInput) -> ClientRuntime.PaginatorSequence<GetLabelsInput, GetLabelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetLabelsInput, GetLabelsOutputResponse>(input: input, inputKey: \GetLabelsInput.nextToken, outputKey: \GetLabelsOutputResponse.nextToken, paginationFunction: self.getLabels(input:))
    }
}

extension GetLabelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetLabelsInput {
        return GetLabelsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetListElementsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetListElementsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetListElementsOutputResponse`
    public func getListElementsPaginated(input: GetListElementsInput) -> ClientRuntime.PaginatorSequence<GetListElementsInput, GetListElementsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetListElementsInput, GetListElementsOutputResponse>(input: input, inputKey: \GetListElementsInput.nextToken, outputKey: \GetListElementsOutputResponse.nextToken, paginationFunction: self.getListElements(input:))
    }
}

extension GetListElementsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetListElementsInput {
        return GetListElementsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetListsMetadataOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetListsMetadataInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetListsMetadataOutputResponse`
    public func getListsMetadataPaginated(input: GetListsMetadataInput) -> ClientRuntime.PaginatorSequence<GetListsMetadataInput, GetListsMetadataOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetListsMetadataInput, GetListsMetadataOutputResponse>(input: input, inputKey: \GetListsMetadataInput.nextToken, outputKey: \GetListsMetadataOutputResponse.nextToken, paginationFunction: self.getListsMetadata(input:))
    }
}

extension GetListsMetadataInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetListsMetadataInput {
        return GetListsMetadataInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetModelsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetModelsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetModelsOutputResponse`
    public func getModelsPaginated(input: GetModelsInput) -> ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetModelsInput, GetModelsOutputResponse>(input: input, inputKey: \GetModelsInput.nextToken, outputKey: \GetModelsOutputResponse.nextToken, paginationFunction: self.getModels(input:))
    }
}

extension GetModelsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetModelsInput {
        return GetModelsInput(
            maxResults: self.maxResults,
            modelId: self.modelId,
            modelType: self.modelType,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetOutcomesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetOutcomesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetOutcomesOutputResponse`
    public func getOutcomesPaginated(input: GetOutcomesInput) -> ClientRuntime.PaginatorSequence<GetOutcomesInput, GetOutcomesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetOutcomesInput, GetOutcomesOutputResponse>(input: input, inputKey: \GetOutcomesInput.nextToken, outputKey: \GetOutcomesOutputResponse.nextToken, paginationFunction: self.getOutcomes(input:))
    }
}

extension GetOutcomesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOutcomesInput {
        return GetOutcomesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetRulesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetRulesOutputResponse`
    public func getRulesPaginated(input: GetRulesInput) -> ClientRuntime.PaginatorSequence<GetRulesInput, GetRulesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetRulesInput, GetRulesOutputResponse>(input: input, inputKey: \GetRulesInput.nextToken, outputKey: \GetRulesOutputResponse.nextToken, paginationFunction: self.getRules(input:))
    }
}

extension GetRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetRulesInput {
        return GetRulesInput(
            detectorId: self.detectorId,
            maxResults: self.maxResults,
            nextToken: token,
            ruleId: self.ruleId,
            ruleVersion: self.ruleVersion
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[GetVariablesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetVariablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetVariablesOutputResponse`
    public func getVariablesPaginated(input: GetVariablesInput) -> ClientRuntime.PaginatorSequence<GetVariablesInput, GetVariablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<GetVariablesInput, GetVariablesOutputResponse>(input: input, inputKey: \GetVariablesInput.nextToken, outputKey: \GetVariablesOutputResponse.nextToken, paginationFunction: self.getVariables(input:))
    }
}

extension GetVariablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetVariablesInput {
        return GetVariablesInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[ListEventPredictionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEventPredictionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEventPredictionsOutputResponse`
    public func listEventPredictionsPaginated(input: ListEventPredictionsInput) -> ClientRuntime.PaginatorSequence<ListEventPredictionsInput, ListEventPredictionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEventPredictionsInput, ListEventPredictionsOutputResponse>(input: input, inputKey: \ListEventPredictionsInput.nextToken, outputKey: \ListEventPredictionsOutputResponse.nextToken, paginationFunction: self.listEventPredictions(input:))
    }
}

extension ListEventPredictionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEventPredictionsInput {
        return ListEventPredictionsInput(
            detectorId: self.detectorId,
            detectorVersionId: self.detectorVersionId,
            eventId: self.eventId,
            eventType: self.eventType,
            maxResults: self.maxResults,
            nextToken: token,
            predictionTimeRange: self.predictionTimeRange
        )}
}
extension FraudDetectorClient {
    /// Paginate over `[ListTagsForResourceOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutputResponse`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutputResponse>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutputResponse.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            maxResults: self.maxResults,
            nextToken: token,
            resourceARN: self.resourceARN
        )}
}
