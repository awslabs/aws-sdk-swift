// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension FraudDetectorClientTypes.ATIMetricDataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adr
        case atodr
        case cr
        case threshold
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adr = self.adr {
            try encodeContainer.encode(adr, forKey: .adr)
        }
        if let atodr = self.atodr {
            try encodeContainer.encode(atodr, forKey: .atodr)
        }
        if let cr = self.cr {
            try encodeContainer.encode(cr, forKey: .cr)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let crDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .cr)
        cr = crDecoded
        let adrDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .adr)
        adr = adrDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
        let atodrDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .atodr)
        atodr = atodrDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model performance metrics data points.
    public struct ATIMetricDataPoint: Swift.Equatable {
        /// The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction.
        public var adr: Swift.Float?
        /// The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset.
        public var atodr: Swift.Float?
        /// The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations.
        public var cr: Swift.Float?
        /// The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?

        public init(
            adr: Swift.Float? = nil,
            atodr: Swift.Float? = nil,
            cr: Swift.Float? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.adr = adr
            self.atodr = atodr
            self.cr = cr
            self.threshold = threshold
        }
    }

}

extension FraudDetectorClientTypes.ATIModelPerformance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asi
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asi = self.asi {
            try encodeContainer.encode(asi, forKey: .asi)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asiDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .asi)
        asi = asiDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model performance score.
    public struct ATIModelPerformance: Swift.Equatable {
        /// The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0
        public var asi: Swift.Float?

        public init(
            asi: Swift.Float? = nil
        )
        {
            self.asi = asi
        }
    }

}

extension FraudDetectorClientTypes.ATITrainingMetricsValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDataPoints
        case modelPerformance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for atimetricdatapoint0 in metricDataPoints {
                try metricDataPointsContainer.encode(atimetricdatapoint0)
            }
        }
        if let modelPerformance = self.modelPerformance {
            try encodeContainer.encode(modelPerformance, forKey: .modelPerformance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDataPointsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ATIMetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[FraudDetectorClientTypes.ATIMetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [FraudDetectorClientTypes.ATIMetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
        let modelPerformanceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ATIModelPerformance.self, forKey: .modelPerformance)
        modelPerformance = modelPerformanceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model training metric details.
    public struct ATITrainingMetricsValue: Swift.Equatable {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.ATIMetricDataPoint]?
        /// The model's overall performance scores.
        public var modelPerformance: FraudDetectorClientTypes.ATIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.ATIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.ATIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating Amazon Fraud Detector does not have the needed permissions. This can occur if you submit a request, such as PutExternalModel, that specifies a role that is not in your account.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.AggregatedLogOddsMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedVariablesImportance
        case variableNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatedVariablesImportance = self.aggregatedVariablesImportance {
            try encodeContainer.encode(aggregatedVariablesImportance, forKey: .aggregatedVariablesImportance)
        }
        if let variableNames = variableNames {
            var variableNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableNames)
            for string0 in variableNames {
                try variableNamesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .variableNames)
        var variableNamesDecoded0:[Swift.String]? = nil
        if let variableNamesContainer = variableNamesContainer {
            variableNamesDecoded0 = [Swift.String]()
            for string0 in variableNamesContainer {
                if let string0 = string0 {
                    variableNamesDecoded0?.append(string0)
                }
            }
        }
        variableNames = variableNamesDecoded0
        let aggregatedVariablesImportanceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .aggregatedVariablesImportance)
        aggregatedVariablesImportance = aggregatedVariablesImportanceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The log odds metric details. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedLogOddsMetric: Swift.Equatable {
        /// The relative importance of the variables in the list to the other event variable.
        /// This member is required.
        public var aggregatedVariablesImportance: Swift.Float?
        /// The names of all the variables.
        /// This member is required.
        public var variableNames: [Swift.String]?

        public init(
            aggregatedVariablesImportance: Swift.Float? = nil,
            variableNames: [Swift.String]? = nil
        )
        {
            self.aggregatedVariablesImportance = aggregatedVariablesImportance
            self.variableNames = variableNames
        }
    }

}

extension FraudDetectorClientTypes.AggregatedVariablesImpactExplanation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventVariableNames
        case logOddsImpact
        case relativeImpact
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventVariableNames = eventVariableNames {
            var eventVariableNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariableNames)
            for string0 in eventVariableNames {
                try eventVariableNamesContainer.encode(string0)
            }
        }
        if let logOddsImpact = self.logOddsImpact {
            try encodeContainer.encode(logOddsImpact, forKey: .logOddsImpact)
        }
        if let relativeImpact = self.relativeImpact {
            try encodeContainer.encode(relativeImpact, forKey: .relativeImpact)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventVariableNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventVariableNames)
        var eventVariableNamesDecoded0:[Swift.String]? = nil
        if let eventVariableNamesContainer = eventVariableNamesContainer {
            eventVariableNamesDecoded0 = [Swift.String]()
            for string0 in eventVariableNamesContainer {
                if let string0 = string0 {
                    eventVariableNamesDecoded0?.append(string0)
                }
            }
        }
        eventVariableNames = eventVariableNamesDecoded0
        let relativeImpactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativeImpact)
        relativeImpact = relativeImpactDecoded
        let logOddsImpactDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .logOddsImpact)
        logOddsImpact = logOddsImpactDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The details of the impact of aggregated variables on the prediction score. Account Takeover Insights (ATI) model uses the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, the model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedVariablesImpactExplanation: Swift.Equatable {
        /// The names of all the event variables that were used to derive the aggregated variables.
        public var eventVariableNames: [Swift.String]?
        /// The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.
        ///
        /// * A positive value indicates that the variables drove the risk score up.
        ///
        /// * A negative value indicates that the variables drove the risk score down.
        public var logOddsImpact: Swift.Float?
        /// The relative impact of the aggregated variables in terms of magnitude on the prediction scores.
        public var relativeImpact: Swift.String?

        public init(
            eventVariableNames: [Swift.String]? = nil,
            logOddsImpact: Swift.Float? = nil,
            relativeImpact: Swift.String? = nil
        )
        {
            self.eventVariableNames = eventVariableNames
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }
    }

}

extension FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logOddsMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logOddsMetrics = logOddsMetrics {
            var logOddsMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logOddsMetrics)
            for aggregatedlogoddsmetric0 in logOddsMetrics {
                try logOddsMetricsContainer.encode(aggregatedlogoddsmetric0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logOddsMetricsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.AggregatedLogOddsMetric?].self, forKey: .logOddsMetrics)
        var logOddsMetricsDecoded0:[FraudDetectorClientTypes.AggregatedLogOddsMetric]? = nil
        if let logOddsMetricsContainer = logOddsMetricsContainer {
            logOddsMetricsDecoded0 = [FraudDetectorClientTypes.AggregatedLogOddsMetric]()
            for structure0 in logOddsMetricsContainer {
                if let structure0 = structure0 {
                    logOddsMetricsDecoded0?.append(structure0)
                }
            }
        }
        logOddsMetrics = logOddsMetricsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The details of the relative importance of the aggregated variables. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedVariablesImportanceMetrics: Swift.Equatable {
        /// List of variables' metrics.
        public var logOddsMetrics: [FraudDetectorClientTypes.AggregatedLogOddsMetric]?

        public init(
            logOddsMetrics: [FraudDetectorClientTypes.AggregatedLogOddsMetric]? = nil
        )
        {
            self.logOddsMetrics = logOddsMetrics
        }
    }

}

extension FraudDetectorClientTypes.AllowDenyList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case name
        case updatedTime
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedTime = self.updatedTime {
            try encodeContainer.encode(updatedTime, forKey: .updatedTime)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The metadata of a list.
    public struct AllowDenyList: Swift.Equatable {
        /// The ARN of the list.
        public var arn: Swift.String?
        /// The time the list was created.
        public var createdTime: Swift.String?
        /// The description of the list.
        public var description: Swift.String?
        /// The name of the list.
        /// This member is required.
        public var name: Swift.String?
        /// The time the list was last updated.
        public var updatedTime: Swift.String?
        /// The variable type of the list.
        public var variableType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedTime: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.updatedTime = updatedTime
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes {
    public enum AsyncJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case cancelInProgress
        case complete
        case failed
        case inProgress
        case inProgressInitializing
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncJobStatus] {
            return [
                .canceled,
                .cancelInProgress,
                .complete,
                .failed,
                .inProgress,
                .inProgressInitializing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInitializing: return "IN_PROGRESS_INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AsyncJobStatus(rawValue: rawValue) ?? AsyncJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.BatchCreateVariableError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch create variable API.
    public struct BatchCreateVariableError: Swift.Equatable {
        /// The error code.
        public var code: Swift.Int
        /// The error message.
        public var message: Swift.String?
        /// The name.
        public var name: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

extension BatchCreateVariableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case variableEntries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let variableEntries = variableEntries {
            var variableEntriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableEntries)
            for variableentry0 in variableEntries {
                try variableEntriesContainer.encode(variableentry0)
            }
        }
    }
}

extension BatchCreateVariableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchCreateVariableInput: Swift.Equatable {
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The list of variables for the batch create variable request.
    /// This member is required.
    public var variableEntries: [FraudDetectorClientTypes.VariableEntry]?

    public init(
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableEntries: [FraudDetectorClientTypes.VariableEntry]? = nil
    )
    {
        self.tags = tags
        self.variableEntries = variableEntries
    }
}

struct BatchCreateVariableInputBody: Swift.Equatable {
    let variableEntries: [FraudDetectorClientTypes.VariableEntry]?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension BatchCreateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case variableEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableEntriesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.VariableEntry?].self, forKey: .variableEntries)
        var variableEntriesDecoded0:[FraudDetectorClientTypes.VariableEntry]? = nil
        if let variableEntriesContainer = variableEntriesContainer {
            variableEntriesDecoded0 = [FraudDetectorClientTypes.VariableEntry]()
            for structure0 in variableEntriesContainer {
                if let structure0 = structure0 {
                    variableEntriesDecoded0?.append(structure0)
                }
            }
        }
        variableEntries = variableEntriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension BatchCreateVariableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateVariableOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchCreateVariableOutput: Swift.Equatable {
    /// Provides the errors for the BatchCreateVariable request.
    public var errors: [FraudDetectorClientTypes.BatchCreateVariableError]?

    public init(
        errors: [FraudDetectorClientTypes.BatchCreateVariableError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchCreateVariableOutputBody: Swift.Equatable {
    let errors: [FraudDetectorClientTypes.BatchCreateVariableError]?
}

extension BatchCreateVariableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchCreateVariableError?].self, forKey: .errors)
        var errorsDecoded0:[FraudDetectorClientTypes.BatchCreateVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [FraudDetectorClientTypes.BatchCreateVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchCreateVariableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes.BatchGetVariableError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if code != 0 {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch get variable API.
    public struct BatchGetVariableError: Swift.Equatable {
        /// The error code.
        public var code: Swift.Int
        /// The error message.
        public var message: Swift.String?
        /// The error name.
        public var name: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

extension BatchGetVariableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for string0 in names {
                try namesContainer.encode(string0)
            }
        }
    }
}

extension BatchGetVariableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetVariableInput: Swift.Equatable {
    /// The list of variable names to get.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

struct BatchGetVariableInputBody: Swift.Equatable {
    let names: [Swift.String]?
}

extension BatchGetVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetVariableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetVariableOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.variables = output.variables
        } else {
            self.errors = nil
            self.variables = nil
        }
    }
}

public struct BatchGetVariableOutput: Swift.Equatable {
    /// The errors from the request.
    public var errors: [FraudDetectorClientTypes.BatchGetVariableError]?
    /// The returned variables.
    public var variables: [FraudDetectorClientTypes.Variable]?

    public init(
        errors: [FraudDetectorClientTypes.BatchGetVariableError]? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.errors = errors
        self.variables = variables
    }
}

struct BatchGetVariableOutputBody: Swift.Equatable {
    let variables: [FraudDetectorClientTypes.Variable]?
    let errors: [FraudDetectorClientTypes.BatchGetVariableError]?
}

extension BatchGetVariableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case variables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[FraudDetectorClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [FraudDetectorClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchGetVariableError?].self, forKey: .errors)
        var errorsDecoded0:[FraudDetectorClientTypes.BatchGetVariableError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [FraudDetectorClientTypes.BatchGetVariableError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetVariableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes.BatchImport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case completionTime
        case eventTypeName
        case failedRecordsCount
        case failureReason
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case processedRecordsCount
        case startTime
        case status
        case totalRecordsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encode(completionTime, forKey: .completionTime)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let failedRecordsCount = self.failedRecordsCount {
            try encodeContainer.encode(failedRecordsCount, forKey: .failedRecordsCount)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = self.inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputPath = self.outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let processedRecordsCount = self.processedRecordsCount {
            try encodeContainer.encode(processedRecordsCount, forKey: .processedRecordsCount)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalRecordsCount = self.totalRecordsCount {
            try encodeContainer.encode(totalRecordsCount, forKey: .totalRecordsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.AsyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let failedRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedRecordsCount)
        failedRecordsCount = failedRecordsCountDecoded
        let totalRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsCount)
        totalRecordsCount = totalRecordsCountDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The batch import job details.
    public struct BatchImport: Swift.Equatable {
        /// The ARN of the batch import job.
        public var arn: Swift.String?
        /// Timestamp of when batch import job completed.
        public var completionTime: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// The number of records that failed to import.
        public var failedRecordsCount: Swift.Int?
        /// The reason batch import job failed.
        public var failureReason: Swift.String?
        /// The ARN of the IAM role to use for this job request.
        public var iamRoleArn: Swift.String?
        /// The Amazon S3 location of your data file for batch import.
        public var inputPath: Swift.String?
        /// The ID of the batch import job.
        public var jobId: Swift.String?
        /// The Amazon S3 location of your output file.
        public var outputPath: Swift.String?
        /// The number of records processed by batch import job.
        public var processedRecordsCount: Swift.Int?
        /// Timestamp of when the batch import job started.
        public var startTime: Swift.String?
        /// The status of the batch import job.
        public var status: FraudDetectorClientTypes.AsyncJobStatus?
        /// The total number of records in the batch import job.
        public var totalRecordsCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            completionTime: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            failedRecordsCount: Swift.Int? = nil,
            failureReason: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            jobId: Swift.String? = nil,
            outputPath: Swift.String? = nil,
            processedRecordsCount: Swift.Int? = nil,
            startTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.AsyncJobStatus? = nil,
            totalRecordsCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.completionTime = completionTime
            self.eventTypeName = eventTypeName
            self.failedRecordsCount = failedRecordsCount
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }
    }

}

extension FraudDetectorClientTypes.BatchPrediction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case completionTime
        case detectorName
        case detectorVersion
        case eventTypeName
        case failureReason
        case iamRoleArn
        case inputPath
        case jobId
        case lastHeartbeatTime
        case outputPath
        case processedRecordsCount
        case startTime
        case status
        case totalRecordsCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let completionTime = self.completionTime {
            try encodeContainer.encode(completionTime, forKey: .completionTime)
        }
        if let detectorName = self.detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = self.detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = self.inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let lastHeartbeatTime = self.lastHeartbeatTime {
            try encodeContainer.encode(lastHeartbeatTime, forKey: .lastHeartbeatTime)
        }
        if let outputPath = self.outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let processedRecordsCount = self.processedRecordsCount {
            try encodeContainer.encode(processedRecordsCount, forKey: .processedRecordsCount)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let totalRecordsCount = self.totalRecordsCount {
            try encodeContainer.encode(totalRecordsCount, forKey: .totalRecordsCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.AsyncJobStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let lastHeartbeatTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastHeartbeatTime)
        lastHeartbeatTime = lastHeartbeatTimeDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let processedRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .processedRecordsCount)
        processedRecordsCount = processedRecordsCountDecoded
        let totalRecordsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalRecordsCount)
        totalRecordsCount = totalRecordsCountDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The batch prediction details.
    public struct BatchPrediction: Swift.Equatable {
        /// The ARN of batch prediction job.
        public var arn: Swift.String?
        /// Timestamp of when the batch prediction job completed.
        public var completionTime: Swift.String?
        /// The name of the detector.
        public var detectorName: Swift.String?
        /// The detector version.
        public var detectorVersion: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// The reason a batch prediction job failed.
        public var failureReason: Swift.String?
        /// The ARN of the IAM role to use for this job request.
        public var iamRoleArn: Swift.String?
        /// The Amazon S3 location of your training file.
        public var inputPath: Swift.String?
        /// The job ID for the batch prediction.
        public var jobId: Swift.String?
        /// Timestamp of most recent heartbeat indicating the batch prediction job was making progress.
        public var lastHeartbeatTime: Swift.String?
        /// The Amazon S3 location of your output file.
        public var outputPath: Swift.String?
        /// The number of records processed by the batch prediction job.
        public var processedRecordsCount: Swift.Int?
        /// Timestamp of when the batch prediction job started.
        public var startTime: Swift.String?
        /// The batch prediction status.
        public var status: FraudDetectorClientTypes.AsyncJobStatus?
        /// The total number of records in the batch prediction job.
        public var totalRecordsCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            completionTime: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorVersion: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            jobId: Swift.String? = nil,
            lastHeartbeatTime: Swift.String? = nil,
            outputPath: Swift.String? = nil,
            processedRecordsCount: Swift.Int? = nil,
            startTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.AsyncJobStatus? = nil,
            totalRecordsCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.completionTime = completionTime
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.lastHeartbeatTime = lastHeartbeatTime
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }
    }

}

extension CancelBatchImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension CancelBatchImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelBatchImportJobInput: Swift.Equatable {
    /// The ID of an in-progress batch import job to cancel. Amazon Fraud Detector will throw an error if the batch import job is in FAILED, CANCELED, or COMPLETED state.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelBatchImportJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CancelBatchImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelBatchImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelBatchImportJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelBatchImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CancelBatchPredictionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension CancelBatchPredictionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CancelBatchPredictionJobInput: Swift.Equatable {
    /// The ID of the batch prediction job to cancel.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelBatchPredictionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CancelBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelBatchPredictionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CancelBatchPredictionJobOutput: Swift.Equatable {

    public init() { }
}

enum CancelBatchPredictionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating there was a conflict during a delete operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBatchImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = self.inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputPath = self.outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchImportJobInput: Swift.Equatable {
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The ARN of the IAM role created for Amazon S3 bucket that holds your data file. The IAM role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see [User policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-policies-s3.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The URI that points to the Amazon S3 location of your data file.
    /// This member is required.
    public var inputPath: Swift.String?
    /// The ID of the batch import job. The ID cannot be of a past job, unless the job exists in CREATE_FAILED state.
    /// This member is required.
    public var jobId: Swift.String?
    /// The URI that points to the Amazon S3 location for storing your results.
    /// This member is required.
    public var outputPath: Swift.String?
    /// A collection of key-value pairs associated with this request.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        eventTypeName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        inputPath: Swift.String? = nil,
        jobId: Swift.String? = nil,
        outputPath: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

struct CreateBatchImportJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let inputPath: Swift.String?
    let outputPath: Swift.String?
    let eventTypeName: Swift.String?
    let iamRoleArn: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateBatchImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateBatchImportJobOutput: Swift.Equatable {

    public init() { }
}

enum CreateBatchImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBatchPredictionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorName = self.detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorVersion = self.detectorVersion {
            try encodeContainer.encode(detectorVersion, forKey: .detectorVersion)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let iamRoleArn = self.iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let inputPath = self.inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputPath = self.outputPath {
            try encodeContainer.encode(outputPath, forKey: .outputPath)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateBatchPredictionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBatchPredictionJobInput: Swift.Equatable {
    /// The name of the detector.
    /// This member is required.
    public var detectorName: Swift.String?
    /// The detector version.
    public var detectorVersion: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The ARN of the IAM role to use for this job request. The IAM Role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see [User policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-policies-s3.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The Amazon S3 location of your training file.
    /// This member is required.
    public var inputPath: Swift.String?
    /// The ID of the batch prediction job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The Amazon S3 location of your output file.
    /// This member is required.
    public var outputPath: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        detectorName: Swift.String? = nil,
        detectorVersion: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        inputPath: Swift.String? = nil,
        jobId: Swift.String? = nil,
        outputPath: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.detectorName = detectorName
        self.detectorVersion = detectorVersion
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

struct CreateBatchPredictionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let inputPath: Swift.String?
    let outputPath: Swift.String?
    let eventTypeName: Swift.String?
    let detectorName: Swift.String?
    let detectorVersion: Swift.String?
    let iamRoleArn: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorName
        case detectorVersion
        case eventTypeName
        case iamRoleArn
        case inputPath
        case jobId
        case outputPath
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let outputPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputPath)
        outputPath = outputPathDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let detectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersion)
        detectorVersion = detectorVersionDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBatchPredictionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateBatchPredictionJobOutput: Swift.Equatable {

    public init() { }
}

enum CreateBatchPredictionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDetectorVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for string0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(string0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for modelversion0 in modelVersions {
                try modelVersionsContainer.encode(modelversion0)
            }
        }
        if let ruleExecutionMode = self.ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDetectorVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDetectorVersionInput: Swift.Equatable {
    /// The description of the detector version.
    public var description: Swift.String?
    /// The ID of the detector under which you want to create a new version.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The Amazon Sagemaker model endpoints to include in the detector version.
    public var externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode for the rules included in the detector version. You can define and edit the rule mode at the detector version level, when it is in draft status. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. The default behavior is FIRST_MATCHED.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public var rules: [FraudDetectorClientTypes.Rule]?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.tags = tags
    }
}

struct CreateDetectorVersionInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let description: Swift.String?
    let externalModelEndpoints: [Swift.String]?
    let rules: [FraudDetectorClientTypes.Rule]?
    let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDetectorVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.status = output.status
        } else {
            self.detectorId = nil
            self.detectorVersionId = nil
            self.status = nil
        }
    }
}

public struct CreateDetectorVersionOutput: Swift.Equatable {
    /// The ID for the created version's parent detector.
    public var detectorId: Swift.String?
    /// The ID for the created detector.
    public var detectorVersionId: Swift.String?
    /// The status of the detector version.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct CreateDetectorVersionOutputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let status: FraudDetectorClientTypes.DetectorVersionStatus?
}

extension CreateDetectorVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateDetectorVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case elements
        case name
        case tags
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for elements0 in elements {
                try elementsContainer.encode(elements0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

extension CreateListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateListInput: Swift.Equatable {
    /// The description of the list.
    public var description: Swift.String?
    /// The names of the elements, if providing. You can also create an empty list and add elements later using the [UpdateList](https://docs.aws.amazon.com/frauddetector/latest/api/API_Updatelist.html) API.
    public var elements: [Swift.String]?
    /// The name of the list.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of the key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The variable type of the list. You can only assign the variable type with String data type. For more information, see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
    public var variableType: Swift.String?

    public init(
        description: Swift.String? = nil,
        elements: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.description = description
        self.elements = elements
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

struct CreateListInputBody: Swift.Equatable {
    let name: Swift.String?
    let elements: [Swift.String]?
    let variableType: Swift.String?
    let description: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case elements
        case name
        case tags
        case variableType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let elementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .elements)
        var elementsDecoded0:[Swift.String]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [Swift.String]()
            for string0 in elementsContainer {
                if let string0 = string0 {
                    elementsDecoded0?.append(string0)
                }
            }
        }
        elements = elementsDecoded0
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateListOutput: Swift.Equatable {

    public init() { }
}

enum CreateListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateModelInput: Swift.Equatable {
    /// The model description.
    public var description: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.eventTypeName = eventTypeName
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct CreateModelInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let description: Swift.String?
    let eventTypeName: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case eventTypeName
        case modelId
        case modelType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateModelOutput: Swift.Equatable {

    public init() { }
}

enum CreateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateModelVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case ingestedEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = self.externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let ingestedEventsDetail = self.ingestedEventsDetail {
            try encodeContainer.encode(ingestedEventsDetail, forKey: .ingestedEventsDetail)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trainingDataSchema = self.trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = self.trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
    }
}

extension CreateModelVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateModelVersionInput: Swift.Equatable {
    /// Details of the external events data used for model version training. Required if trainingDataSource is EXTERNAL_EVENTS.
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// Details of the ingested events data used for model version training. Required if trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The training data schema.
    /// This member is required.
    public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source location in Amazon S3.
    /// This member is required.
    public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init(
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct CreateModelVersionInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
    let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    let ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case ingestedEventsDetail
        case modelId
        case modelType
        case tags
        case trainingDataSchema
        case trainingDataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let ingestedEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventsDetail.self, forKey: .ingestedEventsDetail)
        ingestedEventsDetail = ingestedEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateModelVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct CreateModelVersionOutput: Swift.Equatable {
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version created.
    public var modelVersionNumber: Swift.String?
    /// The model version status.
    public var status: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct CreateModelVersionOutputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
    let status: Swift.String?
}

extension CreateModelVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum CreateModelVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), tags: \(Swift.String(describing: tags)), expression: \"CONTENT_REDACTED\")"}
}

extension CreateRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for string0 in outcomes {
                try outcomesContainer.encode(string0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRuleInput: Swift.Equatable {
    /// The rule description.
    public var description: Swift.String?
    /// The detector ID for the rule's parent detector.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The rule expression.
    /// This member is required.
    public var expression: Swift.String?
    /// The language of the rule.
    /// This member is required.
    public var language: FraudDetectorClientTypes.Language?
    /// The outcome or outcomes returned when the rule expression matches.
    /// This member is required.
    public var outcomes: [Swift.String]?
    /// The rule ID.
    /// This member is required.
    public var ruleId: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        ruleId: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.ruleId = ruleId
        self.tags = tags
    }
}

struct CreateRuleInputBody: Swift.Equatable {
    let ruleId: Swift.String?
    let detectorId: Swift.String?
    let description: Swift.String?
    let expression: Swift.String?
    let language: FraudDetectorClientTypes.Language?
    let outcomes: [Swift.String]?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case expression
        case language
        case outcomes
        case ruleId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct CreateRuleOutput: Swift.Equatable {
    /// The created rule.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct CreateRuleOutputBody: Swift.Equatable {
    let rule: FraudDetectorClientTypes.Rule?
}

extension CreateRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

enum CreateRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateVariableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

extension CreateVariableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVariableInput: Swift.Equatable {
    /// The source of the data.
    /// This member is required.
    public var dataSource: FraudDetectorClientTypes.DataSource?
    /// The data type of the variable.
    /// This member is required.
    public var dataType: FraudDetectorClientTypes.DataType?
    /// The default value for the variable when no value is received.
    /// This member is required.
    public var defaultValue: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The variable type. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types). Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
    public var variableType: Swift.String?

    public init(
        dataSource: FraudDetectorClientTypes.DataSource? = nil,
        dataType: FraudDetectorClientTypes.DataType? = nil,
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

struct CreateVariableInputBody: Swift.Equatable {
    let name: Swift.String?
    let dataType: FraudDetectorClientTypes.DataType?
    let dataSource: FraudDetectorClientTypes.DataSource?
    let defaultValue: Swift.String?
    let description: Swift.String?
    let variableType: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension CreateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case tags
        case variableType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVariableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateVariableOutput: Swift.Equatable {

    public init() { }
}

enum CreateVariableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case event
        case externalModelScore
        case modelScore
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .event,
                .externalModelScore,
                .modelScore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .externalModelScore: return "EXTERNAL_MODEL_SCORE"
            case .modelScore: return "MODEL_SCORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum DataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case datetime
        case float
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .boolean,
                .datetime,
                .float,
                .integer,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataType(rawValue: rawValue) ?? DataType.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.DataValidationMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldLevelMessages
        case fileLevelMessages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldLevelMessages = fieldLevelMessages {
            var fieldLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldLevelMessages)
            for fieldvalidationmessage0 in fieldLevelMessages {
                try fieldLevelMessagesContainer.encode(fieldvalidationmessage0)
            }
        }
        if let fileLevelMessages = fileLevelMessages {
            var fileLevelMessagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileLevelMessages)
            for filevalidationmessage0 in fileLevelMessages {
                try fileLevelMessagesContainer.encode(filevalidationmessage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileLevelMessagesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.FileValidationMessage?].self, forKey: .fileLevelMessages)
        var fileLevelMessagesDecoded0:[FraudDetectorClientTypes.FileValidationMessage]? = nil
        if let fileLevelMessagesContainer = fileLevelMessagesContainer {
            fileLevelMessagesDecoded0 = [FraudDetectorClientTypes.FileValidationMessage]()
            for structure0 in fileLevelMessagesContainer {
                if let structure0 = structure0 {
                    fileLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fileLevelMessages = fileLevelMessagesDecoded0
        let fieldLevelMessagesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.FieldValidationMessage?].self, forKey: .fieldLevelMessages)
        var fieldLevelMessagesDecoded0:[FraudDetectorClientTypes.FieldValidationMessage]? = nil
        if let fieldLevelMessagesContainer = fieldLevelMessagesContainer {
            fieldLevelMessagesDecoded0 = [FraudDetectorClientTypes.FieldValidationMessage]()
            for structure0 in fieldLevelMessagesContainer {
                if let structure0 = structure0 {
                    fieldLevelMessagesDecoded0?.append(structure0)
                }
            }
        }
        fieldLevelMessages = fieldLevelMessagesDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The model training data validation metrics.
    public struct DataValidationMetrics: Swift.Equatable {
        /// The field-specific model training validation messages.
        public var fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]?
        /// The file-specific model training data validation messages.
        public var fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]?

        public init(
            fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]? = nil,
            fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]? = nil
        )
        {
            self.fieldLevelMessages = fieldLevelMessages
            self.fileLevelMessages = fileLevelMessages
        }
    }

}

extension DeleteBatchImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DeleteBatchImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBatchImportJobInput: Swift.Equatable {
    /// The ID of the batch import job to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DeleteBatchImportJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DeleteBatchImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeleteBatchImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBatchImportJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBatchImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBatchPredictionJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

extension DeleteBatchPredictionJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBatchPredictionJobInput: Swift.Equatable {
    /// The ID of the batch prediction job to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DeleteBatchPredictionJobInputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension DeleteBatchPredictionJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DeleteBatchPredictionJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteBatchPredictionJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBatchPredictionJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
    }
}

extension DeleteDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDetectorInput: Swift.Equatable {
    /// The ID of the detector to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Swift.Equatable {
    let detectorId: Swift.String?
}

extension DeleteDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
    }
}

extension DeleteDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDetectorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDetectorVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

extension DeleteDetectorVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDetectorVersionInput: Swift.Equatable {
    /// The ID of the parent detector for the detector version to delete.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The ID of the detector version to delete.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct DeleteDetectorVersionInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
}

extension DeleteDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension DeleteDetectorVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDetectorVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDetectorVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEntityTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEntityTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEntityTypeInput: Swift.Equatable {
    /// The name of the entity type to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEntityTypeInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEntityTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEntityTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEntityTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEntityTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAuditHistory
        case eventId
        case eventTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAuditHistory = self.deleteAuditHistory {
            try encodeContainer.encode(deleteAuditHistory, forKey: .deleteAuditHistory)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

extension DeleteEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventInput: Swift.Equatable {
    /// Specifies whether or not to delete any predictions associated with the event. If set to True,
    public var deleteAuditHistory: Swift.Bool?
    /// The ID of the event to delete.
    /// This member is required.
    public var eventId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        deleteAuditHistory: Swift.Bool? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil
    )
    {
        self.deleteAuditHistory = deleteAuditHistory
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

struct DeleteEventInputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let deleteAuditHistory: Swift.Bool?
}

extension DeleteEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAuditHistory
        case eventId
        case eventTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let deleteAuditHistoryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAuditHistory)
        deleteAuditHistory = deleteAuditHistoryDecoded
    }
}

extension DeleteEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteEventTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventTypeInput: Swift.Equatable {
    /// The name of the event type to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventTypeInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteEventTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEventTypeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEventTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEventsByEventTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

extension DeleteEventsByEventTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEventsByEventTypeInput: Swift.Equatable {
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
    }
}

struct DeleteEventsByEventTypeInputBody: Swift.Equatable {
    let eventTypeName: Swift.String?
}

extension DeleteEventsByEventTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
    }
}

extension DeleteEventsByEventTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteEventsByEventTypeOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTypeName = output.eventTypeName
            self.eventsDeletionStatus = output.eventsDeletionStatus
        } else {
            self.eventTypeName = nil
            self.eventsDeletionStatus = nil
        }
    }
}

public struct DeleteEventsByEventTypeOutput: Swift.Equatable {
    /// Name of event type for which to delete the events.
    public var eventTypeName: Swift.String?
    /// The status of the delete request.
    public var eventsDeletionStatus: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil,
        eventsDeletionStatus: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.eventsDeletionStatus = eventsDeletionStatus
    }
}

struct DeleteEventsByEventTypeOutputBody: Swift.Equatable {
    let eventTypeName: Swift.String?
    let eventsDeletionStatus: Swift.String?
}

extension DeleteEventsByEventTypeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
        case eventsDeletionStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let eventsDeletionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventsDeletionStatus)
        eventsDeletionStatus = eventsDeletionStatusDecoded
    }
}

enum DeleteEventsByEventTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteExternalModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
    }
}

extension DeleteExternalModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteExternalModelInput: Swift.Equatable {
    /// The endpoint of the Amazon Sagemaker model to delete.
    /// This member is required.
    public var modelEndpoint: Swift.String?

    public init(
        modelEndpoint: Swift.String? = nil
    )
    {
        self.modelEndpoint = modelEndpoint
    }
}

struct DeleteExternalModelInputBody: Swift.Equatable {
    let modelEndpoint: Swift.String?
}

extension DeleteExternalModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
    }
}

extension DeleteExternalModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteExternalModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteExternalModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLabelInput: Swift.Equatable {
    /// The name of the label to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLabelInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteLabelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLabelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLabelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteListInput: Swift.Equatable {
    /// The name of the list to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteListInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteListOutput: Swift.Equatable {

    public init() { }
}

enum DeleteListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

extension DeleteModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteModelInput: Swift.Equatable {
    /// The model ID of the model to delete.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type of the model to delete.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct DeleteModelInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
}

extension DeleteModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
    }
}

extension DeleteModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteModelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteModelVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

extension DeleteModelVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteModelVersionInput: Swift.Equatable {
    /// The model ID of the model version to delete.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type of the model version to delete.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version to delete.
    /// This member is required.
    public var modelVersionNumber: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct DeleteModelVersionInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
}

extension DeleteModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension DeleteModelVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteModelVersionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteModelVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteOutcomeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteOutcomeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteOutcomeInput: Swift.Equatable {
    /// The name of the outcome to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteOutcomeInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteOutcomeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteOutcomeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteOutcomeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteOutcomeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

extension DeleteRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRuleInput: Swift.Equatable {
    /// A rule.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct DeleteRuleInputBody: Swift.Equatable {
    let rule: FraudDetectorClientTypes.Rule?
}

extension DeleteRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

extension DeleteRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteVariableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteVariableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVariableInput: Swift.Equatable {
    /// The name of the variable to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteVariableInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteVariableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteVariableOutput: Swift.Equatable {

    public init() { }
}

enum DeleteVariableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDetectorInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous response.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDetectorInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.detectorId = output.detectorId
            self.detectorVersionSummaries = output.detectorVersionSummaries
            self.nextToken = output.nextToken
        } else {
            self.arn = nil
            self.detectorId = nil
            self.detectorVersionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDetectorOutput: Swift.Equatable {
    /// The detector ARN.
    public var arn: Swift.String?
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The status and description for each detector version.
    public var detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]?
    /// The next token to be used for subsequent requests.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.detectorId = detectorId
        self.detectorVersionSummaries = detectorVersionSummaries
        self.nextToken = nextToken
    }
}

struct DescribeDetectorOutputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]?
    let nextToken: Swift.String?
    let arn: Swift.String?
}

extension DescribeDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case detectorId
        case detectorVersionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionSummariesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.DetectorVersionSummary?].self, forKey: .detectorVersionSummaries)
        var detectorVersionSummariesDecoded0:[FraudDetectorClientTypes.DetectorVersionSummary]? = nil
        if let detectorVersionSummariesContainer = detectorVersionSummariesContainer {
            detectorVersionSummariesDecoded0 = [FraudDetectorClientTypes.DetectorVersionSummary]()
            for structure0 in detectorVersionSummariesContainer {
                if let structure0 = structure0 {
                    detectorVersionSummariesDecoded0?.append(structure0)
                }
            }
        }
        detectorVersionSummaries = detectorVersionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum DescribeDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeModelVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeModelVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeModelVersionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public var modelVersionNumber: Swift.String?
    /// The next token from the previous results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelVersionNumber: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeModelVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case modelVersionNumber
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeModelVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeModelVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelVersionDetails = output.modelVersionDetails
            self.nextToken = output.nextToken
        } else {
            self.modelVersionDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeModelVersionsOutput: Swift.Equatable {
    /// The model version details.
    public var modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]?
    /// The next token.
    public var nextToken: Swift.String?

    public init(
        modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelVersionDetails = modelVersionDetails
        self.nextToken = nextToken
    }
}

struct DescribeModelVersionsOutputBody: Swift.Equatable {
    let modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]?
    let nextToken: Swift.String?
}

extension DescribeModelVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelVersionDetails
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDetailsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersionDetail?].self, forKey: .modelVersionDetails)
        var modelVersionDetailsDecoded0:[FraudDetectorClientTypes.ModelVersionDetail]? = nil
        if let modelVersionDetailsContainer = modelVersionDetailsContainer {
            modelVersionDetailsDecoded0 = [FraudDetectorClientTypes.ModelVersionDetail]()
            for structure0 in modelVersionDetailsContainer {
                if let structure0 = structure0 {
                    modelVersionDetailsDecoded0?.append(structure0)
                }
            }
        }
        modelVersionDetails = modelVersionDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeModelVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes.Detector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case eventTypeName
        case lastUpdatedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The detector.
    public struct Detector: Swift.Equatable {
        /// The detector ARN.
        public var arn: Swift.String?
        /// Timestamp of when the detector was created.
        public var createdTime: Swift.String?
        /// The detector description.
        public var description: Swift.String?
        /// The detector ID.
        public var detectorId: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// Timestamp of when the detector was last updated.
        public var lastUpdatedTime: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

extension FraudDetectorClientTypes {
    public enum DetectorVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case draft
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorVersionStatus] {
            return [
                .active,
                .draft,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorVersionStatus(rawValue: rawValue) ?? DetectorVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.DetectorVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorVersionId
        case lastUpdatedTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The summary of the detector version.
    public struct DetectorVersionSummary: Swift.Equatable {
        /// The detector version description.
        public var description: Swift.String?
        /// The detector version ID.
        public var detectorVersionId: Swift.String?
        /// Timestamp of when the detector version was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The detector version status.
        public var status: FraudDetectorClientTypes.DetectorVersionStatus?

        public init(
            description: Swift.String? = nil,
            detectorVersionId: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
        )
        {
            self.description = description
            self.detectorVersionId = detectorVersionId
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
        }
    }

}

extension FraudDetectorClientTypes.Entity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId
        case entityType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = self.entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let entityType = self.entityType {
            try encodeContainer.encode(entityType, forKey: .entityType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension FraudDetectorClientTypes.Entity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension FraudDetectorClientTypes {
    /// The entity details.
    public struct Entity: Swift.Equatable {
        /// The entity ID. If you do not know the entityId, you can pass unknown, which is areserved string literal.
        /// This member is required.
        public var entityId: Swift.String?
        /// The entity type.
        /// This member is required.
        public var entityType: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityType = entityType
        }
    }

}

extension FraudDetectorClientTypes.EntityType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The entity type details.
    public struct EntityType: Swift.Equatable {
        /// The entity type ARN.
        public var arn: Swift.String?
        /// Timestamp of when the entity type was created.
        public var createdTime: Swift.String?
        /// The entity type description.
        public var description: Swift.String?
        /// Timestamp of when the entity type was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The entity type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.EvaluatedExternalModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputVariables
        case modelEndpoint
        case outputVariables
        case useEventVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputVariables = inputVariables {
            var inputVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .inputVariables)
            for (dictKey0, mapOfStrings0) in inputVariables {
                try inputVariablesContainer.encode(mapOfStrings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let outputVariables = outputVariables {
            var outputVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputVariables)
            for (dictKey0, mapOfStrings0) in outputVariables {
                try outputVariablesContainer.encode(mapOfStrings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useEventVariables = self.useEventVariables {
            try encodeContainer.encode(useEventVariables, forKey: .useEventVariables)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let useEventVariablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEventVariables)
        useEventVariables = useEventVariablesDecoded
        let inputVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .inputVariables)
        var inputVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let inputVariablesContainer = inputVariablesContainer {
            inputVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in inputVariablesContainer {
                if let string0 = string0 {
                    inputVariablesDecoded0?[key0] = string0
                }
            }
        }
        inputVariables = inputVariablesDecoded0
        let outputVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .outputVariables)
        var outputVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let outputVariablesContainer = outputVariablesContainer {
            outputVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in outputVariablesContainer {
                if let string0 = string0 {
                    outputVariablesDecoded0?[key0] = string0
                }
            }
        }
        outputVariables = outputVariablesDecoded0
    }
}

extension FraudDetectorClientTypes.EvaluatedExternalModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluatedExternalModel(modelEndpoint: \(Swift.String(describing: modelEndpoint)), useEventVariables: \(Swift.String(describing: useEventVariables)), inputVariables: \"CONTENT_REDACTED\", outputVariables: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// The details of the external (Amazon Sagemaker) model evaluated for generating predictions.
    public struct EvaluatedExternalModel: Swift.Equatable {
        /// Input variables use for generating predictions.
        public var inputVariables: [Swift.String:Swift.String]?
        /// The endpoint of the external (Amazon Sagemaker) model.
        public var modelEndpoint: Swift.String?
        /// Output variables.
        public var outputVariables: [Swift.String:Swift.String]?
        /// Indicates whether event variables were used to generate predictions.
        public var useEventVariables: Swift.Bool?

        public init(
            inputVariables: [Swift.String:Swift.String]? = nil,
            modelEndpoint: Swift.String? = nil,
            outputVariables: [Swift.String:Swift.String]? = nil,
            useEventVariables: Swift.Bool? = nil
        )
        {
            self.inputVariables = inputVariables
            self.modelEndpoint = modelEndpoint
            self.outputVariables = outputVariables
            self.useEventVariables = useEventVariables
        }
    }

}

extension FraudDetectorClientTypes.EvaluatedModelVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluations
        case modelId
        case modelType
        case modelVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluations = evaluations {
            var evaluationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evaluations)
            for modelversionevaluation0 in evaluations {
                try evaluationsContainer.encode(modelversionevaluation0)
            }
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType, forKey: .modelType)
        }
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let evaluationsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersionEvaluation?].self, forKey: .evaluations)
        var evaluationsDecoded0:[FraudDetectorClientTypes.ModelVersionEvaluation]? = nil
        if let evaluationsContainer = evaluationsContainer {
            evaluationsDecoded0 = [FraudDetectorClientTypes.ModelVersionEvaluation]()
            for structure0 in evaluationsContainer {
                if let structure0 = structure0 {
                    evaluationsDecoded0?.append(structure0)
                }
            }
        }
        evaluations = evaluationsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The model version evaluated for generating prediction.
    public struct EvaluatedModelVersion: Swift.Equatable {
        /// Evaluations generated for the model version.
        public var evaluations: [FraudDetectorClientTypes.ModelVersionEvaluation]?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type. Valid values: ONLINE_FRAUD_INSIGHTS | TRANSACTION_FRAUD_INSIGHTS
        public var modelType: Swift.String?
        /// The model version.
        public var modelVersion: Swift.String?

        public init(
            evaluations: [FraudDetectorClientTypes.ModelVersionEvaluation]? = nil,
            modelId: Swift.String? = nil,
            modelType: Swift.String? = nil,
            modelVersion: Swift.String? = nil
        )
        {
            self.evaluations = evaluations
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersion = modelVersion
        }
    }

}

extension FraudDetectorClientTypes.EvaluatedRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluated
        case expression
        case expressionWithValues
        case matched
        case outcomes
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluated = self.evaluated {
            try encodeContainer.encode(evaluated, forKey: .evaluated)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionWithValues = self.expressionWithValues {
            try encodeContainer.encode(expressionWithValues, forKey: .expressionWithValues)
        }
        if let matched = self.matched {
            try encodeContainer.encode(matched, forKey: .matched)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for string0 in outcomes {
                try outcomesContainer.encode(string0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionWithValuesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expressionWithValues)
        expressionWithValues = expressionWithValuesDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let evaluatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .evaluated)
        evaluated = evaluatedDecoded
        let matchedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .matched)
        matched = matchedDecoded
    }
}

extension FraudDetectorClientTypes.EvaluatedRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluatedRule(evaluated: \(Swift.String(describing: evaluated)), matched: \(Swift.String(describing: matched)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)), expression: \"CONTENT_REDACTED\", expressionWithValues: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// The details of the rule used for evaluating variable values.
    public struct EvaluatedRule: Swift.Equatable {
        /// Indicates whether the rule was evaluated.
        public var evaluated: Swift.Bool?
        /// The rule expression.
        public var expression: Swift.String?
        /// The rule expression value.
        public var expressionWithValues: Swift.String?
        /// Indicates whether the rule matched.
        public var matched: Swift.Bool?
        /// The rule outcome.
        public var outcomes: [Swift.String]?
        /// The rule ID.
        public var ruleId: Swift.String?
        /// The rule version.
        public var ruleVersion: Swift.String?

        public init(
            evaluated: Swift.Bool? = nil,
            expression: Swift.String? = nil,
            expressionWithValues: Swift.String? = nil,
            matched: Swift.Bool? = nil,
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.evaluated = evaluated
            self.expression = expression
            self.expressionWithValues = expressionWithValues
            self.matched = matched
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentLabel
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case labelTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentLabel = self.currentLabel {
            try encodeContainer.encode(currentLabel, forKey: .currentLabel)
        }
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for entity0 in entities {
                try entitiesContainer.encode(entity0)
            }
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = self.eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventVariables)
            for (dictKey0, eventAttributeMap0) in eventVariables {
                try eventVariablesContainer.encode(eventAttributeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let labelTimestamp = self.labelTimestamp {
            try encodeContainer.encode(labelTimestamp, forKey: .labelTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in eventVariablesContainer {
                if let attributevalue0 = attributevalue0 {
                    eventVariablesDecoded0?[key0] = attributevalue0
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let currentLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentLabel)
        currentLabel = currentLabelDecoded
        let labelTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTimestamp)
        labelTimestamp = labelTimestampDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[FraudDetectorClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [FraudDetectorClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The event details.
    public struct Event: Swift.Equatable {
        /// The label associated with the event.
        public var currentLabel: Swift.String?
        /// The event entities.
        public var entities: [FraudDetectorClientTypes.Entity]?
        /// The event ID.
        public var eventId: Swift.String?
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public var eventTimestamp: Swift.String?
        /// The event type.
        public var eventTypeName: Swift.String?
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public var eventVariables: [Swift.String:Swift.String]?
        /// The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.
        public var labelTimestamp: Swift.String?

        public init(
            currentLabel: Swift.String? = nil,
            entities: [FraudDetectorClientTypes.Entity]? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            eventVariables: [Swift.String:Swift.String]? = nil,
            labelTimestamp: Swift.String? = nil
        )
        {
            self.currentLabel = currentLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }
    }

}

extension FraudDetectorClientTypes {
    public enum EventIngestion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventIngestion] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventIngestion(rawValue: rawValue) ?? EventIngestion.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.EventOrchestration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventBridgeEnabled
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBridgeEnabled = self.eventBridgeEnabled {
            try encodeContainer.encode(eventBridgeEnabled, forKey: .eventBridgeEnabled)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBridgeEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .eventBridgeEnabled)
        eventBridgeEnabled = eventBridgeEnabledDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The event orchestration status.
    public struct EventOrchestration: Swift.Equatable {
        /// Specifies if event orchestration is enabled through Amazon EventBridge.
        /// This member is required.
        public var eventBridgeEnabled: Swift.Bool?

        public init(
            eventBridgeEnabled: Swift.Bool? = nil
        )
        {
            self.eventBridgeEnabled = eventBridgeEnabled
        }
    }

}

extension FraudDetectorClientTypes.EventPredictionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case eventId
        case eventTimestamp
        case eventTypeName
        case predictionTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = self.eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let predictionTimestamp = self.predictionTimestamp {
            try encodeContainer.encode(predictionTimestamp, forKey: .predictionTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let predictionTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionTimestamp)
        predictionTimestamp = predictionTimestampDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Information about the summary of an event prediction.
    public struct EventPredictionSummary: Swift.Equatable {
        /// The detector ID.
        public var detectorId: Swift.String?
        /// The detector version ID.
        public var detectorVersionId: Swift.String?
        /// The event ID.
        public var eventId: Swift.String?
        /// The timestamp of the event.
        public var eventTimestamp: Swift.String?
        /// The event type.
        public var eventTypeName: Swift.String?
        /// The timestamp when the prediction was generated.
        public var predictionTimestamp: Swift.String?

        public init(
            detectorId: Swift.String? = nil,
            detectorVersionId: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            predictionTimestamp: Swift.String? = nil
        )
        {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }
    }

}

extension FraudDetectorClientTypes.EventType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case entityTypes
        case eventIngestion
        case eventOrchestration
        case eventVariables
        case ingestedEventStatistics
        case labels
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for string0 in entityTypes {
                try entityTypesContainer.encode(string0)
            }
        }
        if let eventIngestion = self.eventIngestion {
            try encodeContainer.encode(eventIngestion.rawValue, forKey: .eventIngestion)
        }
        if let eventOrchestration = self.eventOrchestration {
            try encodeContainer.encode(eventOrchestration, forKey: .eventOrchestration)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for string0 in eventVariables {
                try eventVariablesContainer.encode(string0)
            }
        }
        if let ingestedEventStatistics = self.ingestedEventStatistics {
            try encodeContainer.encode(ingestedEventStatistics, forKey: .ingestedEventStatistics)
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for string0 in labels {
                try labelsContainer.encode(string0)
            }
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[Swift.String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [Swift.String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let eventIngestionDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.EventIngestion.self, forKey: .eventIngestion)
        eventIngestion = eventIngestionDecoded
        let ingestedEventStatisticsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventStatistics.self, forKey: .ingestedEventStatistics)
        ingestedEventStatistics = ingestedEventStatisticsDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let eventOrchestrationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.EventOrchestration.self, forKey: .eventOrchestration)
        eventOrchestration = eventOrchestrationDecoded
    }
}

extension FraudDetectorClientTypes.EventType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension FraudDetectorClientTypes {
    /// The event type details.
    public struct EventType: Swift.Equatable {
        /// The entity type ARN.
        public var arn: Swift.String?
        /// Timestamp of when the event type was created.
        public var createdTime: Swift.String?
        /// The event type description.
        public var description: Swift.String?
        /// The event type entity types.
        public var entityTypes: [Swift.String]?
        /// If Enabled, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as INGESTED_EVENTS, to train your model and improve fraud predictions.
        public var eventIngestion: FraudDetectorClientTypes.EventIngestion?
        /// The event orchestration status.
        public var eventOrchestration: FraudDetectorClientTypes.EventOrchestration?
        /// The event type event variables.
        public var eventVariables: [Swift.String]?
        /// Data about the stored events.
        public var ingestedEventStatistics: FraudDetectorClientTypes.IngestedEventStatistics?
        /// The event type labels.
        public var labels: [Swift.String]?
        /// Timestamp of when the event type was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The event type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            entityTypes: [Swift.String]? = nil,
            eventIngestion: FraudDetectorClientTypes.EventIngestion? = nil,
            eventOrchestration: FraudDetectorClientTypes.EventOrchestration? = nil,
            eventVariables: [Swift.String]? = nil,
            ingestedEventStatistics: FraudDetectorClientTypes.IngestedEventStatistics? = nil,
            labels: [Swift.String]? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventOrchestration = eventOrchestration
            self.eventVariables = eventVariables
            self.ingestedEventStatistics = ingestedEventStatistics
            self.labels = labels
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.EventVariableSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case source
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension FraudDetectorClientTypes.EventVariableSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventVariableSummary(name: \"CONTENT_REDACTED\", source: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// Information about the summary of an event variable that was evaluated for generating prediction.
    public struct EventVariableSummary: Swift.Equatable {
        /// The event variable name.
        public var name: Swift.String?
        /// The event variable source.
        public var source: Swift.String?
        /// The value of the event variable.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.source = source
            self.value = value
        }
    }

}

extension FraudDetectorClientTypes.ExternalEventsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAccessRoleArn
        case dataLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAccessRoleArn = self.dataAccessRoleArn {
            try encodeContainer.encode(dataAccessRoleArn, forKey: .dataAccessRoleArn)
        }
        if let dataLocation = self.dataLocation {
            try encodeContainer.encode(dataLocation, forKey: .dataLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataLocationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataLocation)
        dataLocation = dataLocationDecoded
        let dataAccessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataAccessRoleArn)
        dataAccessRoleArn = dataAccessRoleArnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Details for the external events data used for model version training.
    public struct ExternalEventsDetail: Swift.Equatable {
        /// The ARN of the role that provides Amazon Fraud Detector access to the data location.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The Amazon S3 bucket location for the data.
        /// This member is required.
        public var dataLocation: Swift.String?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            dataLocation: Swift.String? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.dataLocation = dataLocation
        }
    }

}

extension FraudDetectorClientTypes.ExternalModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case lastUpdatedTime
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let inputConfiguration = self.inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = self.invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = self.modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = self.modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = self.outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model.
    public struct ExternalModel: Swift.Equatable {
        /// The model ARN.
        public var arn: Swift.String?
        /// Timestamp of when the model was last created.
        public var createdTime: Swift.String?
        /// The input configuration.
        public var inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
        /// The role used to invoke the model.
        public var invokeModelEndpointRoleArn: Swift.String?
        /// Timestamp of when the model was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The Amazon SageMaker model endpoints.
        public var modelEndpoint: Swift.String?
        /// The Amazon Fraud Detector status for the external model endpoint
        public var modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
        /// The source of the model.
        public var modelSource: FraudDetectorClientTypes.ModelSource?
        /// The output configuration.
        public var outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
            invokeModelEndpointRoleArn: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelEndpoint: Swift.String? = nil,
            modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
            modelSource: FraudDetectorClientTypes.ModelSource? = nil,
            outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.lastUpdatedTime = lastUpdatedTime
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
        }
    }

}

extension FraudDetectorClientTypes.ExternalModelOutputs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalModel
        case outputs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalModel = self.externalModel {
            try encodeContainer.encode(externalModel, forKey: .externalModel)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputs)
            for (dictKey0, externalModelPredictionMap0) in outputs {
                try outputsContainer.encode(externalModelPredictionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalModelDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalModelSummary.self, forKey: .externalModel)
        externalModel = externalModelDecoded
        let outputsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .outputs)
        var outputsDecoded0: [Swift.String:Swift.String]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in outputsContainer {
                if let string0 = string0 {
                    outputsDecoded0?[key0] = string0
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The fraud prediction scores from Amazon SageMaker model.
    public struct ExternalModelOutputs: Swift.Equatable {
        /// The Amazon SageMaker model.
        public var externalModel: FraudDetectorClientTypes.ExternalModelSummary?
        /// The fraud prediction scores from Amazon SageMaker model.
        public var outputs: [Swift.String:Swift.String]?

        public init(
            externalModel: FraudDetectorClientTypes.ExternalModelSummary? = nil,
            outputs: [Swift.String:Swift.String]? = nil
        )
        {
            self.externalModel = externalModel
            self.outputs = outputs
        }
    }

}

extension FraudDetectorClientTypes.ExternalModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelEndpoint
        case modelSource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelSource = self.modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model.
    public struct ExternalModelSummary: Swift.Equatable {
        /// The endpoint of the Amazon SageMaker model.
        public var modelEndpoint: Swift.String?
        /// The source of the model.
        public var modelSource: FraudDetectorClientTypes.ModelSource?

        public init(
            modelEndpoint: Swift.String? = nil,
            modelSource: FraudDetectorClientTypes.ModelSource? = nil
        )
        {
            self.modelEndpoint = modelEndpoint
            self.modelSource = modelSource
        }
    }

}

extension FraudDetectorClientTypes.FieldValidationMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case fieldName
        case identifier
        case title
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let identifier = self.identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let identifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identifier)
        identifier = identifierDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FieldValidationMessage: Swift.Equatable {
        /// The message content.
        public var content: Swift.String?
        /// The field name.
        public var fieldName: Swift.String?
        /// The message ID.
        public var identifier: Swift.String?
        /// The message title.
        public var title: Swift.String?
        /// The message type.
        public var type: Swift.String?

        public init(
            content: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.fieldName = fieldName
            self.identifier = identifier
            self.title = title
            self.type = type
        }
    }

}

extension FraudDetectorClientTypes.FileValidationMessage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case title
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FileValidationMessage: Swift.Equatable {
        /// The message content.
        public var content: Swift.String?
        /// The message title.
        public var title: Swift.String?
        /// The message type.
        public var type: Swift.String?

        public init(
            content: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.title = title
            self.type = type
        }
    }

}

extension FraudDetectorClientTypes.FilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FraudDetectorClientTypes {
    /// A conditional statement for filtering a list of past predictions.
    public struct FilterCondition: Swift.Equatable {
        /// A statement containing a resource property and a value to specify filter condition.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension GetBatchImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetBatchImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetBatchImportJobsInput: Swift.Equatable {
    /// The ID of the batch import job to get.
    public var jobId: Swift.String?
    /// The maximum number of objects to return for request.
    public var maxResults: Swift.Int?
    /// The next token from the previous request.
    public var nextToken: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetBatchImportJobsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetBatchImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetBatchImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBatchImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchImports = output.batchImports
            self.nextToken = output.nextToken
        } else {
            self.batchImports = nil
            self.nextToken = nil
        }
    }
}

public struct GetBatchImportJobsOutput: Swift.Equatable {
    /// An array containing the details of each batch import job.
    public var batchImports: [FraudDetectorClientTypes.BatchImport]?
    /// The next token for the subsequent resquest.
    public var nextToken: Swift.String?

    public init(
        batchImports: [FraudDetectorClientTypes.BatchImport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchImports = batchImports
        self.nextToken = nextToken
    }
}

struct GetBatchImportJobsOutputBody: Swift.Equatable {
    let batchImports: [FraudDetectorClientTypes.BatchImport]?
    let nextToken: Swift.String?
}

extension GetBatchImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchImports
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchImportsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchImport?].self, forKey: .batchImports)
        var batchImportsDecoded0:[FraudDetectorClientTypes.BatchImport]? = nil
        if let batchImportsContainer = batchImportsContainer {
            batchImportsDecoded0 = [FraudDetectorClientTypes.BatchImport]()
            for structure0 in batchImportsContainer {
                if let structure0 = structure0 {
                    batchImportsDecoded0?.append(structure0)
                }
            }
        }
        batchImports = batchImportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetBatchImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBatchPredictionJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetBatchPredictionJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetBatchPredictionJobsInput: Swift.Equatable {
    /// The batch prediction job for which to get the details.
    public var jobId: Swift.String?
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous request.
    public var nextToken: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsInputBody: Swift.Equatable {
    let jobId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetBatchPredictionJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetBatchPredictionJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBatchPredictionJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.batchPredictions = output.batchPredictions
            self.nextToken = output.nextToken
        } else {
            self.batchPredictions = nil
            self.nextToken = nil
        }
    }
}

public struct GetBatchPredictionJobsOutput: Swift.Equatable {
    /// An array containing the details of each batch prediction job.
    public var batchPredictions: [FraudDetectorClientTypes.BatchPrediction]?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        batchPredictions: [FraudDetectorClientTypes.BatchPrediction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchPredictions = batchPredictions
        self.nextToken = nextToken
    }
}

struct GetBatchPredictionJobsOutputBody: Swift.Equatable {
    let batchPredictions: [FraudDetectorClientTypes.BatchPrediction]?
    let nextToken: Swift.String?
}

extension GetBatchPredictionJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchPredictions
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchPredictionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.BatchPrediction?].self, forKey: .batchPredictions)
        var batchPredictionsDecoded0:[FraudDetectorClientTypes.BatchPrediction]? = nil
        if let batchPredictionsContainer = batchPredictionsContainer {
            batchPredictionsDecoded0 = [FraudDetectorClientTypes.BatchPrediction]()
            for structure0 in batchPredictionsContainer {
                if let structure0 = structure0 {
                    batchPredictionsDecoded0?.append(structure0)
                }
            }
        }
        batchPredictions = batchPredictionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetBatchPredictionJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeleteEventsByEventTypeStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

extension GetDeleteEventsByEventTypeStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeleteEventsByEventTypeStatusInput: Swift.Equatable {
    /// Name of event type for which to get the deletion status.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
    }
}

struct GetDeleteEventsByEventTypeStatusInputBody: Swift.Equatable {
    let eventTypeName: Swift.String?
}

extension GetDeleteEventsByEventTypeStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
    }
}

extension GetDeleteEventsByEventTypeStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeleteEventsByEventTypeStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTypeName = output.eventTypeName
            self.eventsDeletionStatus = output.eventsDeletionStatus
        } else {
            self.eventTypeName = nil
            self.eventsDeletionStatus = nil
        }
    }
}

public struct GetDeleteEventsByEventTypeStatusOutput: Swift.Equatable {
    /// The event type name.
    public var eventTypeName: Swift.String?
    /// The deletion status.
    public var eventsDeletionStatus: FraudDetectorClientTypes.AsyncJobStatus?

    public init(
        eventTypeName: Swift.String? = nil,
        eventsDeletionStatus: FraudDetectorClientTypes.AsyncJobStatus? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.eventsDeletionStatus = eventsDeletionStatus
    }
}

struct GetDeleteEventsByEventTypeStatusOutputBody: Swift.Equatable {
    let eventTypeName: Swift.String?
    let eventsDeletionStatus: FraudDetectorClientTypes.AsyncJobStatus?
}

extension GetDeleteEventsByEventTypeStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeName
        case eventsDeletionStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let eventsDeletionStatusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.AsyncJobStatus.self, forKey: .eventsDeletionStatus)
        eventsDeletionStatus = eventsDeletionStatusDecoded
    }
}

enum GetDeleteEventsByEventTypeStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDetectorVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

extension GetDetectorVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDetectorVersionInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct GetDetectorVersionInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
}

extension GetDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
    }
}

extension GetDetectorVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDetectorVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.createdTime = output.createdTime
            self.description = output.description
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.externalModelEndpoints = output.externalModelEndpoints
            self.lastUpdatedTime = output.lastUpdatedTime
            self.modelVersions = output.modelVersions
            self.ruleExecutionMode = output.ruleExecutionMode
            self.rules = output.rules
            self.status = output.status
        } else {
            self.arn = nil
            self.createdTime = nil
            self.description = nil
            self.detectorId = nil
            self.detectorVersionId = nil
            self.externalModelEndpoints = nil
            self.lastUpdatedTime = nil
            self.modelVersions = nil
            self.ruleExecutionMode = nil
            self.rules = nil
            self.status = nil
        }
    }
}

public struct GetDetectorVersionOutput: Swift.Equatable {
    /// The detector version ARN.
    public var arn: Swift.String?
    /// The timestamp when the detector version was created.
    public var createdTime: Swift.String?
    /// The detector version description.
    public var description: Swift.String?
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints included in the detector version.
    public var externalModelEndpoints: [Swift.String]?
    /// The timestamp when the detector version was last updated.
    public var lastUpdatedTime: Swift.String?
    /// The model versions included in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The execution mode of the rule in the dectector FIRST_MATCHED indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. ALL_MATCHED indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules included in the detector version.
    public var rules: [FraudDetectorClientTypes.Rule]?
    /// The status of the detector version.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        arn: Swift.String? = nil,
        createdTime: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        lastUpdatedTime: Swift.String? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.lastUpdatedTime = lastUpdatedTime
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.status = status
    }
}

struct GetDetectorVersionOutputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let description: Swift.String?
    let externalModelEndpoints: [Swift.String]?
    let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    let rules: [FraudDetectorClientTypes.Rule]?
    let status: FraudDetectorClientTypes.DetectorVersionStatus?
    let lastUpdatedTime: Swift.String?
    let createdTime: Swift.String?
    let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    let arn: Swift.String?
}

extension GetDetectorVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case lastUpdatedTime
        case modelVersions
        case ruleExecutionMode
        case rules
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum GetDetectorVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDetectorsInput: Swift.Equatable {
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDetectorsInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetDetectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDetectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectors = output.detectors
            self.nextToken = output.nextToken
        } else {
            self.detectors = nil
            self.nextToken = nil
        }
    }
}

public struct GetDetectorsOutput: Swift.Equatable {
    /// The detectors.
    public var detectors: [FraudDetectorClientTypes.Detector]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        detectors: [FraudDetectorClientTypes.Detector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectors = detectors
        self.nextToken = nextToken
    }
}

struct GetDetectorsOutputBody: Swift.Equatable {
    let detectors: [FraudDetectorClientTypes.Detector]?
    let nextToken: Swift.String?
}

extension GetDetectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectors
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Detector?].self, forKey: .detectors)
        var detectorsDecoded0:[FraudDetectorClientTypes.Detector]? = nil
        if let detectorsContainer = detectorsContainer {
            detectorsDecoded0 = [FraudDetectorClientTypes.Detector]()
            for structure0 in detectorsContainer {
                if let structure0 = structure0 {
                    detectorsDecoded0?.append(structure0)
                }
            }
        }
        detectors = detectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetDetectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEntityTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetEntityTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEntityTypesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEntityTypesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetEntityTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEntityTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEntityTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entityTypes = output.entityTypes
            self.nextToken = output.nextToken
        } else {
            self.entityTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEntityTypesOutput: Swift.Equatable {
    /// An array of entity types.
    public var entityTypes: [FraudDetectorClientTypes.EntityType]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        entityTypes: [FraudDetectorClientTypes.EntityType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.nextToken = nextToken
    }
}

struct GetEntityTypesOutputBody: Swift.Equatable {
    let entityTypes: [FraudDetectorClientTypes.EntityType]?
    let nextToken: Swift.String?
}

extension GetEntityTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityTypes
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityTypesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EntityType?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[FraudDetectorClientTypes.EntityType]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [FraudDetectorClientTypes.EntityType]()
            for structure0 in entityTypesContainer {
                if let structure0 = structure0 {
                    entityTypesDecoded0?.append(structure0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEntityTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case eventTypeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
    }
}

extension GetEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventInput: Swift.Equatable {
    /// The ID of the event to retrieve.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type of the event to retrieve.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

struct GetEventInputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
}

extension GetEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
        case eventTypeName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
    }
}

extension GetEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventOutputBody = try responseDecoder.decode(responseBody: data)
            self.event = output.event
        } else {
            self.event = nil
        }
    }
}

public struct GetEventOutput: Swift.Equatable {
    /// The details of the event.
    public var event: FraudDetectorClientTypes.Event?

    public init(
        event: FraudDetectorClientTypes.Event? = nil
    )
    {
        self.event = event
    }
}

struct GetEventOutputBody: Swift.Equatable {
    let event: FraudDetectorClientTypes.Event?
}

extension GetEventOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Event.self, forKey: .event)
        event = eventDecoded
    }
}

enum GetEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventPredictionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventPredictionInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), entities: \(Swift.String(describing: entities)), eventId: \(Swift.String(describing: eventId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventTypeName: \(Swift.String(describing: eventTypeName)), eventVariables: \(Swift.String(describing: eventVariables)), externalModelEndpointDataBlobs: \"CONTENT_REDACTED\")"}
}

extension GetEventPredictionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for entity0 in entities {
                try entitiesContainer.encode(entity0)
            }
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = self.eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventVariables)
            for (dictKey0, eventVariableMap0) in eventVariables {
                try eventVariablesContainer.encode(eventVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let externalModelEndpointDataBlobs = externalModelEndpointDataBlobs {
            var externalModelEndpointDataBlobsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .externalModelEndpointDataBlobs)
            for (dictKey0, externalModelEndpointDataBlobMap0) in externalModelEndpointDataBlobs {
                try externalModelEndpointDataBlobsContainer.encode(externalModelEndpointDataBlobMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension GetEventPredictionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventPredictionInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."
    /// This member is required.
    public var entities: [FraudDetectorClientTypes.Entity]?
    /// The unique ID used to identify the event.
    /// This member is required.
    public var eventId: Swift.String?
    /// Timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var eventTimestamp: Swift.String?
    /// The event type associated with the detector specified for the prediction.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation. You must provide at least one eventVariable To ensure most accurate fraud prediction and to simplify your data preparation, Amazon Fraud Detector will replace all missing variables or values as follows: For Amazon Fraud Detector trained models: If a null value is provided explicitly for a variable or if a variable is missing, model will replace the null value or the missing variable (no variable name in the eventVariables map) with calculated default mean/medians for numeric variables and with special values for categorical variables. For imported SageMaker models: If a null value is provided explicitly for a variable, the model and rules will use null as the value. If a variable is not provided (no variable name in the eventVariables map), model and rules will use the default value that is provided for the variable.
    /// This member is required.
    public var eventVariables: [Swift.String:Swift.String]?
    /// The Amazon SageMaker model endpoint input data blobs.
    public var externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        entities: [FraudDetectorClientTypes.Entity]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [Swift.String:Swift.String]? = nil,
        externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
    }
}

struct GetEventPredictionInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let entities: [FraudDetectorClientTypes.Entity]?
    let eventTimestamp: Swift.String?
    let eventVariables: [Swift.String:Swift.String]?
    let externalModelEndpointDataBlobs: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]?
}

extension GetEventPredictionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case externalModelEndpointDataBlobs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[FraudDetectorClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [FraudDetectorClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variablevalue0) in eventVariablesContainer {
                if let variablevalue0 = variablevalue0 {
                    eventVariablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let externalModelEndpointDataBlobsContainer = try containerValues.decodeIfPresent([Swift.String: FraudDetectorClientTypes.ModelEndpointDataBlob?].self, forKey: .externalModelEndpointDataBlobs)
        var externalModelEndpointDataBlobsDecoded0: [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]? = nil
        if let externalModelEndpointDataBlobsContainer = externalModelEndpointDataBlobsContainer {
            externalModelEndpointDataBlobsDecoded0 = [Swift.String:FraudDetectorClientTypes.ModelEndpointDataBlob]()
            for (key0, modelendpointdatablob0) in externalModelEndpointDataBlobsContainer {
                if let modelendpointdatablob0 = modelendpointdatablob0 {
                    externalModelEndpointDataBlobsDecoded0?[key0] = modelendpointdatablob0
                }
            }
        }
        externalModelEndpointDataBlobs = externalModelEndpointDataBlobsDecoded0
    }
}

extension GetEventPredictionMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case eventId
        case eventTypeName
        case predictionTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let predictionTimestamp = self.predictionTimestamp {
            try encodeContainer.encode(predictionTimestamp, forKey: .predictionTimestamp)
        }
    }
}

extension GetEventPredictionMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventPredictionMetadataInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The event ID.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type associated with the detector specified for the prediction.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The timestamp that defines when the prediction was generated. The timestamp must be specified using ISO 8601 standard in UTC. We recommend calling [ListEventPredictions](https://docs.aws.amazon.com/frauddetector/latest/api/API_ListEventPredictions.html) first, and using the predictionTimestamp value in the response to provide an accurate prediction timestamp value.
    /// This member is required.
    public var predictionTimestamp: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        predictionTimestamp: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.eventId = eventId
        self.eventTypeName = eventTypeName
        self.predictionTimestamp = predictionTimestamp
    }
}

struct GetEventPredictionMetadataInputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let predictionTimestamp: Swift.String?
}

extension GetEventPredictionMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case eventId
        case eventTypeName
        case predictionTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let predictionTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionTimestamp)
        predictionTimestamp = predictionTimestampDecoded
    }
}

extension GetEventPredictionMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventPredictionMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
            self.detectorVersionId = output.detectorVersionId
            self.detectorVersionStatus = output.detectorVersionStatus
            self.entityId = output.entityId
            self.entityType = output.entityType
            self.evaluatedExternalModels = output.evaluatedExternalModels
            self.evaluatedModelVersions = output.evaluatedModelVersions
            self.eventId = output.eventId
            self.eventTimestamp = output.eventTimestamp
            self.eventTypeName = output.eventTypeName
            self.eventVariables = output.eventVariables
            self.outcomes = output.outcomes
            self.predictionTimestamp = output.predictionTimestamp
            self.ruleExecutionMode = output.ruleExecutionMode
            self.rules = output.rules
        } else {
            self.detectorId = nil
            self.detectorVersionId = nil
            self.detectorVersionStatus = nil
            self.entityId = nil
            self.entityType = nil
            self.evaluatedExternalModels = nil
            self.evaluatedModelVersions = nil
            self.eventId = nil
            self.eventTimestamp = nil
            self.eventTypeName = nil
            self.eventVariables = nil
            self.outcomes = nil
            self.predictionTimestamp = nil
            self.ruleExecutionMode = nil
            self.rules = nil
        }
    }
}

public struct GetEventPredictionMetadataOutput: Swift.Equatable {
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The status of the detector version.
    public var detectorVersionStatus: Swift.String?
    /// The entity ID.
    public var entityId: Swift.String?
    /// The entity type.
    public var entityType: Swift.String?
    /// External (Amazon SageMaker) models that were evaluated for generating predictions.
    public var evaluatedExternalModels: [FraudDetectorClientTypes.EvaluatedExternalModel]?
    /// Model versions that were evaluated for generating predictions.
    public var evaluatedModelVersions: [FraudDetectorClientTypes.EvaluatedModelVersion]?
    /// The event ID.
    public var eventId: Swift.String?
    /// The timestamp for when the prediction was generated for the associated event ID.
    public var eventTimestamp: Swift.String?
    /// The event type associated with the detector specified for this prediction.
    public var eventTypeName: Swift.String?
    /// A list of event variables that influenced the prediction scores.
    public var eventVariables: [FraudDetectorClientTypes.EventVariableSummary]?
    /// The outcomes of the matched rule, based on the rule execution mode.
    public var outcomes: [Swift.String]?
    /// The timestamp that defines when the prediction was generated.
    public var predictionTimestamp: Swift.String?
    /// The execution mode of the rule used for evaluating variable values.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// List of rules associated with the detector version that were used for evaluating variable values.
    public var rules: [FraudDetectorClientTypes.EvaluatedRule]?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        detectorVersionStatus: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: Swift.String? = nil,
        evaluatedExternalModels: [FraudDetectorClientTypes.EvaluatedExternalModel]? = nil,
        evaluatedModelVersions: [FraudDetectorClientTypes.EvaluatedModelVersion]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [FraudDetectorClientTypes.EventVariableSummary]? = nil,
        outcomes: [Swift.String]? = nil,
        predictionTimestamp: Swift.String? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.EvaluatedRule]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.detectorVersionStatus = detectorVersionStatus
        self.entityId = entityId
        self.entityType = entityType
        self.evaluatedExternalModels = evaluatedExternalModels
        self.evaluatedModelVersions = evaluatedModelVersions
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.outcomes = outcomes
        self.predictionTimestamp = predictionTimestamp
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

struct GetEventPredictionMetadataOutputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let entityId: Swift.String?
    let entityType: Swift.String?
    let eventTimestamp: Swift.String?
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let detectorVersionStatus: Swift.String?
    let eventVariables: [FraudDetectorClientTypes.EventVariableSummary]?
    let rules: [FraudDetectorClientTypes.EvaluatedRule]?
    let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    let outcomes: [Swift.String]?
    let evaluatedModelVersions: [FraudDetectorClientTypes.EvaluatedModelVersion]?
    let evaluatedExternalModels: [FraudDetectorClientTypes.EvaluatedExternalModel]?
    let predictionTimestamp: Swift.String?
}

extension GetEventPredictionMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case detectorVersionStatus
        case entityId
        case entityType
        case evaluatedExternalModels
        case evaluatedModelVersions
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case outcomes
        case predictionTimestamp
        case ruleExecutionMode
        case rules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let entityTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityType)
        entityType = entityTypeDecoded
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let detectorVersionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionStatus)
        detectorVersionStatus = detectorVersionStatusDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EventVariableSummary?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[FraudDetectorClientTypes.EventVariableSummary]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [FraudDetectorClientTypes.EventVariableSummary]()
            for structure0 in eventVariablesContainer {
                if let structure0 = structure0 {
                    eventVariablesDecoded0?.append(structure0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EvaluatedRule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.EvaluatedRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.EvaluatedRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let evaluatedModelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EvaluatedModelVersion?].self, forKey: .evaluatedModelVersions)
        var evaluatedModelVersionsDecoded0:[FraudDetectorClientTypes.EvaluatedModelVersion]? = nil
        if let evaluatedModelVersionsContainer = evaluatedModelVersionsContainer {
            evaluatedModelVersionsDecoded0 = [FraudDetectorClientTypes.EvaluatedModelVersion]()
            for structure0 in evaluatedModelVersionsContainer {
                if let structure0 = structure0 {
                    evaluatedModelVersionsDecoded0?.append(structure0)
                }
            }
        }
        evaluatedModelVersions = evaluatedModelVersionsDecoded0
        let evaluatedExternalModelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EvaluatedExternalModel?].self, forKey: .evaluatedExternalModels)
        var evaluatedExternalModelsDecoded0:[FraudDetectorClientTypes.EvaluatedExternalModel]? = nil
        if let evaluatedExternalModelsContainer = evaluatedExternalModelsContainer {
            evaluatedExternalModelsDecoded0 = [FraudDetectorClientTypes.EvaluatedExternalModel]()
            for structure0 in evaluatedExternalModelsContainer {
                if let structure0 = structure0 {
                    evaluatedExternalModelsDecoded0?.append(structure0)
                }
            }
        }
        evaluatedExternalModels = evaluatedExternalModelsDecoded0
        let predictionTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .predictionTimestamp)
        predictionTimestamp = predictionTimestampDecoded
    }
}

enum GetEventPredictionMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventPredictionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventPredictionOutputBody = try responseDecoder.decode(responseBody: data)
            self.externalModelOutputs = output.externalModelOutputs
            self.modelScores = output.modelScores
            self.ruleResults = output.ruleResults
        } else {
            self.externalModelOutputs = nil
            self.modelScores = nil
            self.ruleResults = nil
        }
    }
}

public struct GetEventPredictionOutput: Swift.Equatable {
    /// The model scores for Amazon SageMaker models.
    public var externalModelOutputs: [FraudDetectorClientTypes.ExternalModelOutputs]?
    /// The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.
    public var modelScores: [FraudDetectorClientTypes.ModelScores]?
    /// The results from the rules.
    public var ruleResults: [FraudDetectorClientTypes.RuleResult]?

    public init(
        externalModelOutputs: [FraudDetectorClientTypes.ExternalModelOutputs]? = nil,
        modelScores: [FraudDetectorClientTypes.ModelScores]? = nil,
        ruleResults: [FraudDetectorClientTypes.RuleResult]? = nil
    )
    {
        self.externalModelOutputs = externalModelOutputs
        self.modelScores = modelScores
        self.ruleResults = ruleResults
    }
}

struct GetEventPredictionOutputBody: Swift.Equatable {
    let modelScores: [FraudDetectorClientTypes.ModelScores]?
    let ruleResults: [FraudDetectorClientTypes.RuleResult]?
    let externalModelOutputs: [FraudDetectorClientTypes.ExternalModelOutputs]?
}

extension GetEventPredictionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalModelOutputs
        case modelScores
        case ruleResults
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelScoresContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelScores?].self, forKey: .modelScores)
        var modelScoresDecoded0:[FraudDetectorClientTypes.ModelScores]? = nil
        if let modelScoresContainer = modelScoresContainer {
            modelScoresDecoded0 = [FraudDetectorClientTypes.ModelScores]()
            for structure0 in modelScoresContainer {
                if let structure0 = structure0 {
                    modelScoresDecoded0?.append(structure0)
                }
            }
        }
        modelScores = modelScoresDecoded0
        let ruleResultsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.RuleResult?].self, forKey: .ruleResults)
        var ruleResultsDecoded0:[FraudDetectorClientTypes.RuleResult]? = nil
        if let ruleResultsContainer = ruleResultsContainer {
            ruleResultsDecoded0 = [FraudDetectorClientTypes.RuleResult]()
            for structure0 in ruleResultsContainer {
                if let structure0 = structure0 {
                    ruleResultsDecoded0?.append(structure0)
                }
            }
        }
        ruleResults = ruleResultsDecoded0
        let externalModelOutputsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ExternalModelOutputs?].self, forKey: .externalModelOutputs)
        var externalModelOutputsDecoded0:[FraudDetectorClientTypes.ExternalModelOutputs]? = nil
        if let externalModelOutputsContainer = externalModelOutputsContainer {
            externalModelOutputsDecoded0 = [FraudDetectorClientTypes.ExternalModelOutputs]()
            for structure0 in externalModelOutputsContainer {
                if let structure0 = structure0 {
                    externalModelOutputsDecoded0?.append(structure0)
                }
            }
        }
        externalModelOutputs = externalModelOutputsDecoded0
    }
}

enum GetEventPredictionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceUnavailableException": return try await ResourceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEventTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetEventTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetEventTypesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetEventTypesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetEventTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetEventTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEventTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct GetEventTypesOutput: Swift.Equatable {
    /// An array of event types.
    public var eventTypes: [FraudDetectorClientTypes.EventType]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        eventTypes: [FraudDetectorClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct GetEventTypesOutputBody: Swift.Equatable {
    let eventTypes: [FraudDetectorClientTypes.EventType]?
    let nextToken: Swift.String?
}

extension GetEventTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypes
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[FraudDetectorClientTypes.EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [FraudDetectorClientTypes.EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetEventTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExternalModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetExternalModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetExternalModelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The Amazon SageMaker model endpoint.
    public var modelEndpoint: Swift.String?
    /// The next page token for the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelEndpoint: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelEndpoint = modelEndpoint
        self.nextToken = nextToken
    }
}

struct GetExternalModelsInputBody: Swift.Equatable {
    let modelEndpoint: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetExternalModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelEndpoint
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetExternalModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExternalModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.externalModels = output.externalModels
            self.nextToken = output.nextToken
        } else {
            self.externalModels = nil
            self.nextToken = nil
        }
    }
}

public struct GetExternalModelsOutput: Swift.Equatable {
    /// Gets the Amazon SageMaker models.
    public var externalModels: [FraudDetectorClientTypes.ExternalModel]?
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        externalModels: [FraudDetectorClientTypes.ExternalModel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.externalModels = externalModels
        self.nextToken = nextToken
    }
}

struct GetExternalModelsOutputBody: Swift.Equatable {
    let externalModels: [FraudDetectorClientTypes.ExternalModel]?
    let nextToken: Swift.String?
}

extension GetExternalModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalModels
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalModelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ExternalModel?].self, forKey: .externalModels)
        var externalModelsDecoded0:[FraudDetectorClientTypes.ExternalModel]? = nil
        if let externalModelsContainer = externalModelsContainer {
            externalModelsDecoded0 = [FraudDetectorClientTypes.ExternalModel]()
            for structure0 in externalModelsContainer {
                if let structure0 = structure0 {
                    externalModelsDecoded0?.append(structure0)
                }
            }
        }
        externalModels = externalModelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetExternalModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKMSEncryptionKeyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetKMSEncryptionKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetKMSEncryptionKeyInput: Swift.Equatable {

    public init() { }
}

struct GetKMSEncryptionKeyInputBody: Swift.Equatable {
}

extension GetKMSEncryptionKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKMSEncryptionKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKMSEncryptionKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.kmsKey = output.kmsKey
        } else {
            self.kmsKey = nil
        }
    }
}

public struct GetKMSEncryptionKeyOutput: Swift.Equatable {
    /// The KMS encryption key.
    public var kmsKey: FraudDetectorClientTypes.KMSKey?

    public init(
        kmsKey: FraudDetectorClientTypes.KMSKey? = nil
    )
    {
        self.kmsKey = kmsKey
    }
}

struct GetKMSEncryptionKeyOutputBody: Swift.Equatable {
    let kmsKey: FraudDetectorClientTypes.KMSKey?
}

extension GetKMSEncryptionKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.KMSKey.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

enum GetKMSEncryptionKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLabelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetLabelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLabelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the label or labels to get.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetLabelsInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetLabelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetLabelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLabelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.labels = output.labels
            self.nextToken = output.nextToken
        } else {
            self.labels = nil
            self.nextToken = nil
        }
    }
}

public struct GetLabelsOutput: Swift.Equatable {
    /// An array of labels.
    public var labels: [FraudDetectorClientTypes.Label]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        labels: [FraudDetectorClientTypes.Label]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.labels = labels
        self.nextToken = nextToken
    }
}

struct GetLabelsOutputBody: Swift.Equatable {
    let labels: [FraudDetectorClientTypes.Label]?
    let nextToken: Swift.String?
}

extension GetLabelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labels
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Label?].self, forKey: .labels)
        var labelsDecoded0:[FraudDetectorClientTypes.Label]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [FraudDetectorClientTypes.Label]()
            for structure0 in labelsContainer {
                if let structure0 = structure0 {
                    labelsDecoded0?.append(structure0)
                }
            }
        }
        labels = labelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetLabelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetListElementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetListElementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetListElementsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the list.
    /// This member is required.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetListElementsInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetListElementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetListElementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetListElementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.elements = output.elements
            self.nextToken = output.nextToken
        } else {
            self.elements = nil
            self.nextToken = nil
        }
    }
}

public struct GetListElementsOutput: Swift.Equatable {
    /// The list elements.
    public var elements: [Swift.String]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        elements: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.elements = elements
        self.nextToken = nextToken
    }
}

struct GetListElementsOutputBody: Swift.Equatable {
    let elements: [Swift.String]?
    let nextToken: Swift.String?
}

extension GetListElementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case elements
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .elements)
        var elementsDecoded0:[Swift.String]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [Swift.String]()
            for string0 in elementsContainer {
                if let string0 = string0 {
                    elementsDecoded0?.append(string0)
                }
            }
        }
        elements = elementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetListElementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetListsMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetListsMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetListsMetadataInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the list.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetListsMetadataInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetListsMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetListsMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetListsMetadataOutputBody = try responseDecoder.decode(responseBody: data)
            self.lists = output.lists
            self.nextToken = output.nextToken
        } else {
            self.lists = nil
            self.nextToken = nil
        }
    }
}

public struct GetListsMetadataOutput: Swift.Equatable {
    /// The metadata of the specified list or all lists under the account.
    public var lists: [FraudDetectorClientTypes.AllowDenyList]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        lists: [FraudDetectorClientTypes.AllowDenyList]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lists = lists
        self.nextToken = nextToken
    }
}

struct GetListsMetadataOutputBody: Swift.Equatable {
    let lists: [FraudDetectorClientTypes.AllowDenyList]?
    let nextToken: Swift.String?
}

extension GetListsMetadataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lists
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.AllowDenyList?].self, forKey: .lists)
        var listsDecoded0:[FraudDetectorClientTypes.AllowDenyList]? = nil
        if let listsContainer = listsContainer {
            listsDecoded0 = [FraudDetectorClientTypes.AllowDenyList]()
            for structure0 in listsContainer {
                if let structure0 = structure0 {
                    listsDecoded0?.append(structure0)
                }
            }
        }
        lists = listsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetListsMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }
}

extension GetModelVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetModelVersionInput: Swift.Equatable {
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public var modelVersionNumber: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

struct GetModelVersionInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
}

extension GetModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
    }
}

extension GetModelVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.externalEventsDetail = output.externalEventsDetail
            self.ingestedEventsDetail = output.ingestedEventsDetail
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
            self.trainingDataSchema = output.trainingDataSchema
            self.trainingDataSource = output.trainingDataSource
        } else {
            self.arn = nil
            self.externalEventsDetail = nil
            self.ingestedEventsDetail = nil
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
            self.trainingDataSchema = nil
            self.trainingDataSource = nil
        }
    }
}

public struct GetModelVersionOutput: Swift.Equatable {
    /// The model version ARN.
    public var arn: Swift.String?
    /// The details of the external events data used for training the model version. This will be populated if the trainingDataSource is EXTERNAL_EVENTS
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The details of the ingested events data used for training the model version. This will be populated if the trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public var modelVersionNumber: Swift.String?
    /// The model version status. Possible values are:
    ///
    /// * TRAINING_IN_PROGRESS
    ///
    /// * TRAINING_COMPLETE
    ///
    /// * ACTIVATE_REQUESTED
    ///
    /// * ACTIVATE_IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * INACTIVATE_REQUESTED
    ///
    /// * INACTIVATE_IN_PROGRESS
    ///
    /// * INACTIVE
    ///
    /// * ERROR
    public var status: Swift.String?
    /// The training data schema.
    public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source.
    public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init(
        arn: Swift.String? = nil,
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.arn = arn
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

struct GetModelVersionOutputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
    let trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
    let trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    let ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    let status: Swift.String?
    let arn: Swift.String?
}

extension GetModelVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case externalEventsDetail
        case ingestedEventsDetail
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let ingestedEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventsDetail.self, forKey: .ingestedEventsDetail)
        ingestedEventsDetail = ingestedEventsDetailDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

enum GetModelVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetModelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetModelsInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.nextToken = nextToken
    }
}

struct GetModelsInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetModelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case modelId
        case modelType
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct GetModelsOutput: Swift.Equatable {
    /// The array of models.
    public var models: [FraudDetectorClientTypes.Model]?
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        models: [FraudDetectorClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct GetModelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let models: [FraudDetectorClientTypes.Model]?
}

extension GetModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case models
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let modelsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Model?].self, forKey: .models)
        var modelsDecoded0:[FraudDetectorClientTypes.Model]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [FraudDetectorClientTypes.Model]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
    }
}

enum GetModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetOutcomesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetOutcomesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetOutcomesInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the outcome or outcomes to get.
    public var name: Swift.String?
    /// The next page token for the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetOutcomesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetOutcomesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetOutcomesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOutcomesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.outcomes = output.outcomes
        } else {
            self.nextToken = nil
            self.outcomes = nil
        }
    }
}

public struct GetOutcomesOutput: Swift.Equatable {
    /// The next page token for subsequent requests.
    public var nextToken: Swift.String?
    /// The outcomes.
    public var outcomes: [FraudDetectorClientTypes.Outcome]?

    public init(
        nextToken: Swift.String? = nil,
        outcomes: [FraudDetectorClientTypes.Outcome]? = nil
    )
    {
        self.nextToken = nextToken
        self.outcomes = outcomes
    }
}

struct GetOutcomesOutputBody: Swift.Equatable {
    let outcomes: [FraudDetectorClientTypes.Outcome]?
    let nextToken: Swift.String?
}

extension GetOutcomesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case outcomes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outcomesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Outcome?].self, forKey: .outcomes)
        var outcomesDecoded0:[FraudDetectorClientTypes.Outcome]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [FraudDetectorClientTypes.Outcome]()
            for structure0 in outcomesContainer {
                if let structure0 = structure0 {
                    outcomesDecoded0?.append(structure0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetOutcomesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }
}

extension GetRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRulesInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of rules to return for the request.
    public var maxResults: Swift.Int?
    /// The next page token.
    public var nextToken: Swift.String?
    /// The rule ID.
    public var ruleId: Swift.String?
    /// The rule version.
    public var ruleVersion: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleId: Swift.String? = nil,
        ruleVersion: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

struct GetRulesInputBody: Swift.Equatable {
    let ruleId: Swift.String?
    let detectorId: Swift.String?
    let ruleVersion: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case maxResults
        case nextToken
        case ruleId
        case ruleVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.ruleDetails = output.ruleDetails
        } else {
            self.nextToken = nil
            self.ruleDetails = nil
        }
    }
}

public struct GetRulesOutput: Swift.Equatable {
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The details of the requested rule.
    public var ruleDetails: [FraudDetectorClientTypes.RuleDetail]?

    public init(
        nextToken: Swift.String? = nil,
        ruleDetails: [FraudDetectorClientTypes.RuleDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleDetails = ruleDetails
    }
}

struct GetRulesOutputBody: Swift.Equatable {
    let ruleDetails: [FraudDetectorClientTypes.RuleDetail]?
    let nextToken: Swift.String?
}

extension GetRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case ruleDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDetailsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.RuleDetail?].self, forKey: .ruleDetails)
        var ruleDetailsDecoded0:[FraudDetectorClientTypes.RuleDetail]? = nil
        if let ruleDetailsContainer = ruleDetailsContainer {
            ruleDetailsDecoded0 = [FraudDetectorClientTypes.RuleDetail]()
            for structure0 in ruleDetailsContainer {
                if let structure0 = structure0 {
                    ruleDetailsDecoded0?.append(structure0)
                }
            }
        }
        ruleDetails = ruleDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetVariablesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetVariablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetVariablesInput: Swift.Equatable {
    /// The max size per page determined for the get variable request.
    public var maxResults: Swift.Int?
    /// The name of the variable.
    public var name: Swift.String?
    /// The next page token of the get variable request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct GetVariablesInputBody: Swift.Equatable {
    let name: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetVariablesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case name
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetVariablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetVariablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variables = output.variables
        } else {
            self.nextToken = nil
            self.variables = nil
        }
    }
}

public struct GetVariablesOutput: Swift.Equatable {
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The names of the variables returned.
    public var variables: [FraudDetectorClientTypes.Variable]?

    public init(
        nextToken: Swift.String? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.nextToken = nextToken
        self.variables = variables
    }
}

struct GetVariablesOutputBody: Swift.Equatable {
    let variables: [FraudDetectorClientTypes.Variable]?
    let nextToken: Swift.String?
}

extension GetVariablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Variable?].self, forKey: .variables)
        var variablesDecoded0:[FraudDetectorClientTypes.Variable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [FraudDetectorClientTypes.Variable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetVariablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes.IngestedEventStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDataSizeInBytes
        case lastUpdatedTime
        case leastRecentEvent
        case mostRecentEvent
        case numberOfEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDataSizeInBytes = self.eventDataSizeInBytes {
            try encodeContainer.encode(eventDataSizeInBytes, forKey: .eventDataSizeInBytes)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let leastRecentEvent = self.leastRecentEvent {
            try encodeContainer.encode(leastRecentEvent, forKey: .leastRecentEvent)
        }
        if let mostRecentEvent = self.mostRecentEvent {
            try encodeContainer.encode(mostRecentEvent, forKey: .mostRecentEvent)
        }
        if let numberOfEvents = self.numberOfEvents {
            try encodeContainer.encode(numberOfEvents, forKey: .numberOfEvents)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfEventsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfEvents)
        numberOfEvents = numberOfEventsDecoded
        let eventDataSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .eventDataSizeInBytes)
        eventDataSizeInBytes = eventDataSizeInBytesDecoded
        let leastRecentEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .leastRecentEvent)
        leastRecentEvent = leastRecentEventDecoded
        let mostRecentEventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mostRecentEvent)
        mostRecentEvent = mostRecentEventDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Data about the stored events.
    public struct IngestedEventStatistics: Swift.Equatable {
        /// The total size of the stored events.
        public var eventDataSizeInBytes: Swift.Int?
        /// Timestamp of when the stored event was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The oldest stored event.
        public var leastRecentEvent: Swift.String?
        /// The newest stored event.
        public var mostRecentEvent: Swift.String?
        /// The number of stored events.
        public var numberOfEvents: Swift.Int?

        public init(
            eventDataSizeInBytes: Swift.Int? = nil,
            lastUpdatedTime: Swift.String? = nil,
            leastRecentEvent: Swift.String? = nil,
            mostRecentEvent: Swift.String? = nil,
            numberOfEvents: Swift.Int? = nil
        )
        {
            self.eventDataSizeInBytes = eventDataSizeInBytes
            self.lastUpdatedTime = lastUpdatedTime
            self.leastRecentEvent = leastRecentEvent
            self.mostRecentEvent = mostRecentEvent
            self.numberOfEvents = numberOfEvents
        }
    }

}

extension FraudDetectorClientTypes.IngestedEventsDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingestedEventsTimeWindow
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingestedEventsTimeWindow = self.ingestedEventsTimeWindow {
            try encodeContainer.encode(ingestedEventsTimeWindow, forKey: .ingestedEventsTimeWindow)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ingestedEventsTimeWindowDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventsTimeWindow.self, forKey: .ingestedEventsTimeWindow)
        ingestedEventsTimeWindow = ingestedEventsTimeWindowDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The details of the ingested event.
    public struct IngestedEventsDetail: Swift.Equatable {
        /// The start and stop time of the ingested events.
        /// This member is required.
        public var ingestedEventsTimeWindow: FraudDetectorClientTypes.IngestedEventsTimeWindow?

        public init(
            ingestedEventsTimeWindow: FraudDetectorClientTypes.IngestedEventsTimeWindow? = nil
        )
        {
            self.ingestedEventsTimeWindow = ingestedEventsTimeWindow
        }
    }

}

extension FraudDetectorClientTypes.IngestedEventsTimeWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The start and stop time of the ingested events.
    public struct IngestedEventsTimeWindow: Swift.Equatable {
        /// Timestamp of the final ingested event.
        /// This member is required.
        public var endTime: Swift.String?
        /// Timestamp of the first ingensted event.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.KMSKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = self.kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The KMS key details.
    public struct KMSKey: Swift.Equatable {
        /// The encryption key ARN.
        public var kmsEncryptionKeyArn: Swift.String?

        public init(
            kmsEncryptionKeyArn: Swift.String? = nil
        )
        {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }
    }

}

extension FraudDetectorClientTypes.Label: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The label details.
    public struct Label: Swift.Equatable {
        /// The label ARN.
        public var arn: Swift.String?
        /// Timestamp of when the event type was created.
        public var createdTime: Swift.String?
        /// The label description.
        public var description: Swift.String?
        /// Timestamp of when the label was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The label name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.LabelSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelMapper
        case unlabeledEventsTreatment
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelMapper = labelMapper {
            var labelMapperContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .labelMapper)
            for (dictKey0, labelMapper0) in labelMapper {
                var labelMapper0Container = labelMapperContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for string1 in labelMapper0 {
                    try labelMapper0Container.encode(string1)
                }
            }
        }
        if let unlabeledEventsTreatment = self.unlabeledEventsTreatment {
            try encodeContainer.encode(unlabeledEventsTreatment.rawValue, forKey: .unlabeledEventsTreatment)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let labelMapperContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .labelMapper)
        var labelMapperDecoded0: [Swift.String:[Swift.String]]? = nil
        if let labelMapperContainer = labelMapperContainer {
            labelMapperDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, listofstrings0) in labelMapperContainer {
                var listofstrings0Decoded0: [Swift.String]? = nil
                if let listofstrings0 = listofstrings0 {
                    listofstrings0Decoded0 = [Swift.String]()
                    for string1 in listofstrings0 {
                        if let string1 = string1 {
                            listofstrings0Decoded0?.append(string1)
                        }
                    }
                }
                labelMapperDecoded0?[key0] = listofstrings0Decoded0
            }
        }
        labelMapper = labelMapperDecoded0
        let unlabeledEventsTreatmentDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.UnlabeledEventsTreatment.self, forKey: .unlabeledEventsTreatment)
        unlabeledEventsTreatment = unlabeledEventsTreatmentDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The label schema.
    public struct LabelSchema: Swift.Equatable {
        /// The label mapper maps the Amazon Fraud Detector supported model classification labels (FRAUD, LEGIT) to the appropriate event type labels. For example, if "FRAUD" and "LEGIT" are Amazon Fraud Detector supported labels, this mapper could be: {"FRAUD" => ["0"], "LEGIT" => ["1"]} or {"FRAUD" => ["false"], "LEGIT" => ["true"]} or {"FRAUD" => ["fraud", "abuse"], "LEGIT" => ["legit", "safe"]}. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
        public var labelMapper: [Swift.String:[Swift.String]]?
        /// The action to take for unlabeled events.
        ///
        /// * Use IGNORE if you want the unlabeled events to be ignored. This is recommended when the majority of the events in the dataset are labeled.
        ///
        /// * Use FRAUD if you want to categorize all unlabeled events as Fraud. This is recommended when most of the events in your dataset are fraudulent.
        ///
        /// * Use LEGIT if you want to categorize all unlabeled events as Legit. This is recommended when most of the events in your dataset are legitimate.
        ///
        /// * Use AUTO if you want Amazon Fraud Detector to decide how to use the unlabeled data. This is recommended when there is significant unlabeled events in the dataset.
        ///
        ///
        /// By default, Amazon Fraud Detector ignores the unlabeled data.
        public var unlabeledEventsTreatment: FraudDetectorClientTypes.UnlabeledEventsTreatment?

        public init(
            labelMapper: [Swift.String:[Swift.String]]? = nil,
            unlabeledEventsTreatment: FraudDetectorClientTypes.UnlabeledEventsTreatment? = nil
        )
        {
            self.labelMapper = labelMapper
            self.unlabeledEventsTreatment = unlabeledEventsTreatment
        }
    }

}

extension FraudDetectorClientTypes {
    public enum Language: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case detectorpl
        case sdkUnknown(Swift.String)

        public static var allCases: [Language] {
            return [
                .detectorpl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .detectorpl: return "DETECTORPL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Language(rawValue: rawValue) ?? Language.sdkUnknown(rawValue)
        }
    }
}

extension ListEventPredictionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case eventId
        case eventType
        case maxResults
        case nextToken
        case predictionTimeRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let predictionTimeRange = self.predictionTimeRange {
            try encodeContainer.encode(predictionTimeRange, forKey: .predictionTimeRange)
        }
    }
}

extension ListEventPredictionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEventPredictionsInput: Swift.Equatable {
    /// The detector ID.
    public var detectorId: FraudDetectorClientTypes.FilterCondition?
    /// The detector version ID.
    public var detectorVersionId: FraudDetectorClientTypes.FilterCondition?
    /// The event ID.
    public var eventId: FraudDetectorClientTypes.FilterCondition?
    /// The event type associated with the detector.
    public var eventType: FraudDetectorClientTypes.FilterCondition?
    /// The maximum number of predictions to return for the request.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The time period for when the predictions were generated.
    public var predictionTimeRange: FraudDetectorClientTypes.PredictionTimeRange?

    public init(
        detectorId: FraudDetectorClientTypes.FilterCondition? = nil,
        detectorVersionId: FraudDetectorClientTypes.FilterCondition? = nil,
        eventId: FraudDetectorClientTypes.FilterCondition? = nil,
        eventType: FraudDetectorClientTypes.FilterCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        predictionTimeRange: FraudDetectorClientTypes.PredictionTimeRange? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.eventId = eventId
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.predictionTimeRange = predictionTimeRange
    }
}

struct ListEventPredictionsInputBody: Swift.Equatable {
    let eventId: FraudDetectorClientTypes.FilterCondition?
    let eventType: FraudDetectorClientTypes.FilterCondition?
    let detectorId: FraudDetectorClientTypes.FilterCondition?
    let detectorVersionId: FraudDetectorClientTypes.FilterCondition?
    let predictionTimeRange: FraudDetectorClientTypes.PredictionTimeRange?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEventPredictionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case eventId
        case eventType
        case maxResults
        case nextToken
        case predictionTimeRange
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.FilterCondition.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.FilterCondition.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.FilterCondition.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.FilterCondition.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let predictionTimeRangeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.PredictionTimeRange.self, forKey: .predictionTimeRange)
        predictionTimeRange = predictionTimeRangeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventPredictionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEventPredictionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventPredictionSummaries = output.eventPredictionSummaries
            self.nextToken = output.nextToken
        } else {
            self.eventPredictionSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventPredictionsOutput: Swift.Equatable {
    /// The summary of the past predictions.
    public var eventPredictionSummaries: [FraudDetectorClientTypes.EventPredictionSummary]?
    /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        eventPredictionSummaries: [FraudDetectorClientTypes.EventPredictionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventPredictionSummaries = eventPredictionSummaries
        self.nextToken = nextToken
    }
}

struct ListEventPredictionsOutputBody: Swift.Equatable {
    let eventPredictionSummaries: [FraudDetectorClientTypes.EventPredictionSummary]?
    let nextToken: Swift.String?
}

extension ListEventPredictionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventPredictionSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventPredictionSummariesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.EventPredictionSummary?].self, forKey: .eventPredictionSummaries)
        var eventPredictionSummariesDecoded0:[FraudDetectorClientTypes.EventPredictionSummary]? = nil
        if let eventPredictionSummariesContainer = eventPredictionSummariesContainer {
            eventPredictionSummariesDecoded0 = [FraudDetectorClientTypes.EventPredictionSummary]()
            for structure0 in eventPredictionSummariesContainer {
                if let structure0 = structure0 {
                    eventPredictionSummariesDecoded0?.append(structure0)
                }
            }
        }
        eventPredictionSummaries = eventPredictionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEventPredictionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous results.
    public var nextToken: Swift.String?
    /// The ARN that specifies the resource whose tags you want to list.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceARN
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The next token for subsequent requests.
    public var nextToken: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [FraudDetectorClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum ListUpdateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ListUpdateMode] {
            return [
                .append,
                .remove,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListUpdateMode(rawValue: rawValue) ?? ListUpdateMode.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.LogOddsMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case variableImportance
        case variableName
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variableImportance = self.variableImportance {
            try encodeContainer.encode(variableImportance, forKey: .variableImportance)
        }
        if let variableName = self.variableName {
            try encodeContainer.encode(variableName, forKey: .variableName)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableName)
        variableName = variableNameDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let variableImportanceDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .variableImportance)
        variableImportance = variableImportanceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The log odds metric details.
    public struct LogOddsMetric: Swift.Equatable {
        /// The relative importance of the variable. For more information, see [Model variable importance](https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html).
        /// This member is required.
        public var variableImportance: Swift.Float?
        /// The name of the variable.
        /// This member is required.
        public var variableName: Swift.String?
        /// The type of variable.
        /// This member is required.
        public var variableType: Swift.String?

        public init(
            variableImportance: Swift.Float? = nil,
            variableName: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.variableImportance = variableImportance
            self.variableName = variableName
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.MetricDataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fpr
        case precision
        case threshold
        case tpr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fpr = self.fpr {
            try encodeContainer.encode(fpr, forKey: .fpr)
        }
        if let precision = self.precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let tpr = self.tpr {
            try encodeContainer.encode(tpr, forKey: .tpr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .fpr)
        fpr = fprDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
        let tprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .tpr)
        tpr = tprDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Model performance metrics data points.
    public struct MetricDataPoint: Swift.Equatable {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes.Model: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case eventTypeName
        case lastUpdatedTime
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The model.
    public struct Model: Swift.Equatable {
        /// The ARN of the model.
        public var arn: Swift.String?
        /// Timestamp of when the model was created.
        public var createdTime: Swift.String?
        /// The model description.
        public var description: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// Timestamp of last time the model was updated.
        public var lastUpdatedTime: Swift.String?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
        }
    }

}

extension FraudDetectorClientTypes.ModelEndpointDataBlob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byteBuffer
        case contentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let byteBuffer = self.byteBuffer {
            try encodeContainer.encode(byteBuffer.base64EncodedString(), forKey: .byteBuffer)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let byteBufferDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .byteBuffer)
        byteBuffer = byteBufferDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// A pre-formed Amazon SageMaker model input you can include if your detector version includes an imported Amazon SageMaker model endpoint with pass-through input configuration.
    public struct ModelEndpointDataBlob: Swift.Equatable {
        /// The byte buffer of the Amazon SageMaker model endpoint input data blob.
        public var byteBuffer: ClientRuntime.Data?
        /// The content type of the Amazon SageMaker model endpoint input data blob.
        public var contentType: Swift.String?

        public init(
            byteBuffer: ClientRuntime.Data? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.byteBuffer = byteBuffer
            self.contentType = contentType
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case dissociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelEndpointStatus] {
            return [
                .associated,
                .dissociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .dissociated: return "DISSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelEndpointStatus(rawValue: rawValue) ?? ModelEndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelInputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvInputTemplate
        case eventTypeName
        case format
        case jsonInputTemplate
        case useEventVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvInputTemplate = self.csvInputTemplate {
            try encodeContainer.encode(csvInputTemplate, forKey: .csvInputTemplate)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonInputTemplate = self.jsonInputTemplate {
            try encodeContainer.encode(jsonInputTemplate, forKey: .jsonInputTemplate)
        }
        if let useEventVariables = self.useEventVariables {
            try encodeContainer.encode(useEventVariables, forKey: .useEventVariables)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputDataFormat.self, forKey: .format)
        format = formatDecoded
        let useEventVariablesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useEventVariables)
        useEventVariables = useEventVariablesDecoded
        let jsonInputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonInputTemplate)
        jsonInputTemplate = jsonInputTemplateDecoded
        let csvInputTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .csvInputTemplate)
        csvInputTemplate = csvInputTemplateDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model input configuration.
    public struct ModelInputConfiguration: Swift.Equatable {
        /// Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker.
        public var csvInputTemplate: Swift.String?
        /// The event type name.
        public var eventTypeName: Swift.String?
        /// The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.
        public var format: FraudDetectorClientTypes.ModelInputDataFormat?
        /// Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker.
        public var jsonInputTemplate: Swift.String?
        /// The event variables.
        /// This member is required.
        public var useEventVariables: Swift.Bool?

        public init(
            csvInputTemplate: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            format: FraudDetectorClientTypes.ModelInputDataFormat? = nil,
            jsonInputTemplate: Swift.String? = nil,
            useEventVariables: Swift.Bool? = nil
        )
        {
            self.csvInputTemplate = csvInputTemplate
            self.eventTypeName = eventTypeName
            self.format = format
            self.jsonInputTemplate = jsonInputTemplate
            self.useEventVariables = useEventVariables
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelInputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInputDataFormat] {
            return [
                .csv,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .json: return "APPLICATION_JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelInputDataFormat(rawValue: rawValue) ?? ModelInputDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelOutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csvIndexToVariableMap
        case format
        case jsonKeyToVariableMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csvIndexToVariableMap = csvIndexToVariableMap {
            var csvIndexToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .csvIndexToVariableMap)
            for (dictKey0, csvIndexToVariableMap0) in csvIndexToVariableMap {
                try csvIndexToVariableMapContainer.encode(csvIndexToVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let jsonKeyToVariableMap = jsonKeyToVariableMap {
            var jsonKeyToVariableMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .jsonKeyToVariableMap)
            for (dictKey0, jsonKeyToVariableMap0) in jsonKeyToVariableMap {
                try jsonKeyToVariableMapContainer.encode(jsonKeyToVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputDataFormat.self, forKey: .format)
        format = formatDecoded
        let jsonKeyToVariableMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .jsonKeyToVariableMap)
        var jsonKeyToVariableMapDecoded0: [Swift.String:Swift.String]? = nil
        if let jsonKeyToVariableMapContainer = jsonKeyToVariableMapContainer {
            jsonKeyToVariableMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in jsonKeyToVariableMapContainer {
                if let string0 = string0 {
                    jsonKeyToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        jsonKeyToVariableMap = jsonKeyToVariableMapDecoded0
        let csvIndexToVariableMapContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .csvIndexToVariableMap)
        var csvIndexToVariableMapDecoded0: [Swift.String:Swift.String]? = nil
        if let csvIndexToVariableMapContainer = csvIndexToVariableMapContainer {
            csvIndexToVariableMapDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in csvIndexToVariableMapContainer {
                if let string0 = string0 {
                    csvIndexToVariableMapDecoded0?[key0] = string0
                }
            }
        }
        csvIndexToVariableMap = csvIndexToVariableMapDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// Provides the Amazon Sagemaker model output configuration.
    public struct ModelOutputConfiguration: Swift.Equatable {
        /// A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables.
        public var csvIndexToVariableMap: [Swift.String:Swift.String]?
        /// The format of the model output configuration.
        /// This member is required.
        public var format: FraudDetectorClientTypes.ModelOutputDataFormat?
        /// A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables.
        public var jsonKeyToVariableMap: [Swift.String:Swift.String]?

        public init(
            csvIndexToVariableMap: [Swift.String:Swift.String]? = nil,
            format: FraudDetectorClientTypes.ModelOutputDataFormat? = nil,
            jsonKeyToVariableMap: [Swift.String:Swift.String]? = nil
        )
        {
            self.csvIndexToVariableMap = csvIndexToVariableMap
            self.format = format
            self.jsonKeyToVariableMap = jsonKeyToVariableMap
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelOutputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case jsonlines
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelOutputDataFormat] {
            return [
                .csv,
                .jsonlines,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .jsonlines: return "APPLICATION_JSONLINES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelOutputDataFormat(rawValue: rawValue) ?? ModelOutputDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelScores: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelVersion
        case scores
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelVersion = self.modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let scores = scores {
            var scoresContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .scores)
            for (dictKey0, modelPredictionMap0) in scores {
                try scoresContainer.encode(modelPredictionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelVersion.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let scoresContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Float?].self, forKey: .scores)
        var scoresDecoded0: [Swift.String:Swift.Float]? = nil
        if let scoresContainer = scoresContainer {
            scoresDecoded0 = [Swift.String:Swift.Float]()
            for (key0, float0) in scoresContainer {
                if let float0 = float0 {
                    scoresDecoded0?[key0] = float0
                }
            }
        }
        scores = scoresDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The fraud prediction scores.
    public struct ModelScores: Swift.Equatable {
        /// The model version.
        public var modelVersion: FraudDetectorClientTypes.ModelVersion?
        /// The model's fraud prediction scores.
        public var scores: [Swift.String:Swift.Float]?

        public init(
            modelVersion: FraudDetectorClientTypes.ModelVersion? = nil,
            scores: [Swift.String:Swift.Float]? = nil
        )
        {
            self.modelVersion = modelVersion
            self.scores = scores
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelSource] {
            return [
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelSource(rawValue: rawValue) ?? ModelSource.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes {
    public enum ModelTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountTakeoverInsights
        case onlineFraudInsights
        case transactionFraudInsights
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelTypeEnum] {
            return [
                .accountTakeoverInsights,
                .onlineFraudInsights,
                .transactionFraudInsights,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountTakeoverInsights: return "ACCOUNT_TAKEOVER_INSIGHTS"
            case .onlineFraudInsights: return "ONLINE_FRAUD_INSIGHTS"
            case .transactionFraudInsights: return "TRANSACTION_FRAUD_INSIGHTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelTypeEnum(rawValue: rawValue) ?? ModelTypeEnum.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.ModelVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case modelId
        case modelType
        case modelVersionNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The model version.
    public struct ModelVersion: Swift.Equatable {
        /// The model version ARN.
        public var arn: Swift.String?
        /// The model ID.
        /// This member is required.
        public var modelId: Swift.String?
        /// The model type.
        /// This member is required.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        /// This member is required.
        public var modelVersionNumber: Swift.String?

        public init(
            arn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil
        )
        {
            self.arn = arn
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }
    }

}

extension FraudDetectorClientTypes.ModelVersionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case externalEventsDetail
        case ingestedEventsDetail
        case lastUpdatedTime
        case modelId
        case modelType
        case modelVersionNumber
        case status
        case trainingDataSchema
        case trainingDataSource
        case trainingResult
        case trainingResultV2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let externalEventsDetail = self.externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let ingestedEventsDetail = self.ingestedEventsDetail {
            try encodeContainer.encode(ingestedEventsDetail, forKey: .ingestedEventsDetail)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trainingDataSchema = self.trainingDataSchema {
            try encodeContainer.encode(trainingDataSchema, forKey: .trainingDataSchema)
        }
        if let trainingDataSource = self.trainingDataSource {
            try encodeContainer.encode(trainingDataSource.rawValue, forKey: .trainingDataSource)
        }
        if let trainingResult = self.trainingResult {
            try encodeContainer.encode(trainingResult, forKey: .trainingResult)
        }
        if let trainingResultV2 = self.trainingResultV2 {
            try encodeContainer.encode(trainingResultV2, forKey: .trainingResultV2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let trainingDataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSourceEnum.self, forKey: .trainingDataSource)
        trainingDataSource = trainingDataSourceDecoded
        let trainingDataSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingDataSchema.self, forKey: .trainingDataSchema)
        trainingDataSchema = trainingDataSchemaDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let ingestedEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventsDetail.self, forKey: .ingestedEventsDetail)
        ingestedEventsDetail = ingestedEventsDetailDecoded
        let trainingResultDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingResult.self, forKey: .trainingResult)
        trainingResult = trainingResultDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let trainingResultV2Decoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingResultV2.self, forKey: .trainingResultV2)
        trainingResultV2 = trainingResultV2Decoded
    }
}

extension FraudDetectorClientTypes {
    /// The details of the model version.
    public struct ModelVersionDetail: Swift.Equatable {
        /// The model version ARN.
        public var arn: Swift.String?
        /// The timestamp when the model was created.
        public var createdTime: Swift.String?
        /// The external events data details. This will be populated if the trainingDataSource for the model version is specified as EXTERNAL_EVENTS.
        public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
        /// The ingested events data details. This will be populated if the trainingDataSource for the model version is specified as INGESTED_EVENTS.
        public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
        /// The timestamp when the model was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        public var modelVersionNumber: Swift.String?
        /// The status of the model version.
        public var status: Swift.String?
        /// The training data schema.
        public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
        /// The model version training data source.
        public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
        /// The training results.
        public var trainingResult: FraudDetectorClientTypes.TrainingResult?
        /// The training result details. The details include the relative importance of the variables.
        public var trainingResultV2: FraudDetectorClientTypes.TrainingResultV2?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
            ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
            trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil,
            trainingResult: FraudDetectorClientTypes.TrainingResult? = nil,
            trainingResultV2: FraudDetectorClientTypes.TrainingResultV2? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
            self.trainingResult = trainingResult
            self.trainingResultV2 = trainingResultV2
        }
    }

}

extension FraudDetectorClientTypes.ModelVersionEvaluation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case evaluationScore
        case outputVariableName
        case predictionExplanations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationScore = self.evaluationScore {
            try encodeContainer.encode(evaluationScore, forKey: .evaluationScore)
        }
        if let outputVariableName = self.outputVariableName {
            try encodeContainer.encode(outputVariableName, forKey: .outputVariableName)
        }
        if let predictionExplanations = self.predictionExplanations {
            try encodeContainer.encode(predictionExplanations, forKey: .predictionExplanations)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputVariableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputVariableName)
        outputVariableName = outputVariableNameDecoded
        let evaluationScoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .evaluationScore)
        evaluationScore = evaluationScoreDecoded
        let predictionExplanationsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.PredictionExplanations.self, forKey: .predictionExplanations)
        predictionExplanations = predictionExplanationsDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The model version evalutions.
    public struct ModelVersionEvaluation: Swift.Equatable {
        /// The evaluation score generated for the model version.
        public var evaluationScore: Swift.String?
        /// The output variable name.
        public var outputVariableName: Swift.String?
        /// The prediction explanations generated for the model version.
        public var predictionExplanations: FraudDetectorClientTypes.PredictionExplanations?

        public init(
            evaluationScore: Swift.String? = nil,
            outputVariableName: Swift.String? = nil,
            predictionExplanations: FraudDetectorClientTypes.PredictionExplanations? = nil
        )
        {
            self.evaluationScore = evaluationScore
            self.outputVariableName = outputVariableName
            self.predictionExplanations = predictionExplanations
        }
    }

}

extension FraudDetectorClientTypes {
    public enum ModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case trainingCancelled
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelVersionStatus] {
            return [
                .active,
                .inactive,
                .trainingCancelled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .trainingCancelled: return "TRAINING_CANCELLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelVersionStatus(rawValue: rawValue) ?? ModelVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.OFIMetricDataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fpr
        case precision
        case threshold
        case tpr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fpr = self.fpr {
            try encodeContainer.encode(fpr, forKey: .fpr)
        }
        if let precision = self.precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let tpr = self.tpr {
            try encodeContainer.encode(tpr, forKey: .tpr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .fpr)
        fpr = fprDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
        let tprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .tpr)
        tpr = tprDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model performance metrics data points.
    public struct OFIMetricDataPoint: Swift.Equatable {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes.OFIModelPerformance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auc
        case uncertaintyRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auc = self.auc {
            try encodeContainer.encode(auc, forKey: .auc)
        }
        if let uncertaintyRange = self.uncertaintyRange {
            try encodeContainer.encode(uncertaintyRange, forKey: .uncertaintyRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aucDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .auc)
        auc = aucDecoded
        let uncertaintyRangeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.UncertaintyRange.self, forKey: .uncertaintyRange)
        uncertaintyRange = uncertaintyRangeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model performance score.
    public struct OFIModelPerformance: Swift.Equatable {
        /// The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public var auc: Swift.Float?
        /// Indicates the range of area under curve (auc) expected from the OFI model. A range greater than 0.1 indicates higher model uncertainity.
        public var uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange?

        public init(
            auc: Swift.Float? = nil,
            uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange? = nil
        )
        {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }
    }

}

extension FraudDetectorClientTypes.OFITrainingMetricsValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDataPoints
        case modelPerformance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for ofimetricdatapoint0 in metricDataPoints {
                try metricDataPointsContainer.encode(ofimetricdatapoint0)
            }
        }
        if let modelPerformance = self.modelPerformance {
            try encodeContainer.encode(modelPerformance, forKey: .modelPerformance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDataPointsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.OFIMetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[FraudDetectorClientTypes.OFIMetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [FraudDetectorClientTypes.OFIMetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
        let modelPerformanceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.OFIModelPerformance.self, forKey: .modelPerformance)
        modelPerformance = modelPerformanceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model training metric details.
    public struct OFITrainingMetricsValue: Swift.Equatable {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.OFIMetricDataPoint]?
        /// The model's overall performance score.
        public var modelPerformance: FraudDetectorClientTypes.OFIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.OFIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.OFIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

extension FraudDetectorClientTypes.Outcome: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case lastUpdatedTime
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The outcome.
    public struct Outcome: Swift.Equatable {
        /// The outcome ARN.
        public var arn: Swift.String?
        /// The timestamp when the outcome was created.
        public var createdTime: Swift.String?
        /// The outcome description.
        public var description: Swift.String?
        /// The timestamp when the outcome was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The outcome name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.PredictionExplanations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedVariablesImpactExplanations
        case variableImpactExplanations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatedVariablesImpactExplanations = aggregatedVariablesImpactExplanations {
            var aggregatedVariablesImpactExplanationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregatedVariablesImpactExplanations)
            for aggregatedvariablesimpactexplanation0 in aggregatedVariablesImpactExplanations {
                try aggregatedVariablesImpactExplanationsContainer.encode(aggregatedvariablesimpactexplanation0)
            }
        }
        if let variableImpactExplanations = variableImpactExplanations {
            var variableImpactExplanationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variableImpactExplanations)
            for variableimpactexplanation0 in variableImpactExplanations {
                try variableImpactExplanationsContainer.encode(variableimpactexplanation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variableImpactExplanationsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.VariableImpactExplanation?].self, forKey: .variableImpactExplanations)
        var variableImpactExplanationsDecoded0:[FraudDetectorClientTypes.VariableImpactExplanation]? = nil
        if let variableImpactExplanationsContainer = variableImpactExplanationsContainer {
            variableImpactExplanationsDecoded0 = [FraudDetectorClientTypes.VariableImpactExplanation]()
            for structure0 in variableImpactExplanationsContainer {
                if let structure0 = structure0 {
                    variableImpactExplanationsDecoded0?.append(structure0)
                }
            }
        }
        variableImpactExplanations = variableImpactExplanationsDecoded0
        let aggregatedVariablesImpactExplanationsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.AggregatedVariablesImpactExplanation?].self, forKey: .aggregatedVariablesImpactExplanations)
        var aggregatedVariablesImpactExplanationsDecoded0:[FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]? = nil
        if let aggregatedVariablesImpactExplanationsContainer = aggregatedVariablesImpactExplanationsContainer {
            aggregatedVariablesImpactExplanationsDecoded0 = [FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]()
            for structure0 in aggregatedVariablesImpactExplanationsContainer {
                if let structure0 = structure0 {
                    aggregatedVariablesImpactExplanationsDecoded0?.append(structure0)
                }
            }
        }
        aggregatedVariablesImpactExplanations = aggregatedVariablesImpactExplanationsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The prediction explanations that provide insight into how each event variable impacted the model version's fraud prediction score.
    public struct PredictionExplanations: Swift.Equatable {
        /// The details of the aggregated variables impact on the prediction score. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
        public var aggregatedVariablesImpactExplanations: [FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]?
        /// The details of the event variable's impact on the prediction score.
        public var variableImpactExplanations: [FraudDetectorClientTypes.VariableImpactExplanation]?

        public init(
            aggregatedVariablesImpactExplanations: [FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]? = nil,
            variableImpactExplanations: [FraudDetectorClientTypes.VariableImpactExplanation]? = nil
        )
        {
            self.aggregatedVariablesImpactExplanations = aggregatedVariablesImpactExplanations
            self.variableImpactExplanations = variableImpactExplanations
        }
    }

}

extension FraudDetectorClientTypes.PredictionTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The time period for when the predictions were generated.
    public struct PredictionTimeRange: Swift.Equatable {
        /// The end time of the time period for when the predictions were generated.
        /// This member is required.
        public var endTime: Swift.String?
        /// The start time of the time period for when the predictions were generated.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension PutDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutDetectorInput: Swift.Equatable {
    /// The description of the detector.
    public var description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.eventTypeName = eventTypeName
        self.tags = tags
    }
}

struct PutDetectorInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let description: Swift.String?
    let eventTypeName: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case eventTypeName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutDetectorOutput: Swift.Equatable {

    public init() { }
}

enum PutDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutEntityTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutEntityTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEntityTypeInput: Swift.Equatable {
    /// The description.
    public var description: Swift.String?
    /// The name of the entity type.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutEntityTypeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutEntityTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutEntityTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutEntityTypeOutput: Swift.Equatable {

    public init() { }
}

enum PutEntityTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutEventTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case entityTypes
        case eventIngestion
        case eventOrchestration
        case eventVariables
        case labels
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityTypes = entityTypes {
            var entityTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityTypes)
            for string0 in entityTypes {
                try entityTypesContainer.encode(string0)
            }
        }
        if let eventIngestion = self.eventIngestion {
            try encodeContainer.encode(eventIngestion.rawValue, forKey: .eventIngestion)
        }
        if let eventOrchestration = self.eventOrchestration {
            try encodeContainer.encode(eventOrchestration, forKey: .eventOrchestration)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventVariables)
            for string0 in eventVariables {
                try eventVariablesContainer.encode(string0)
            }
        }
        if let labels = labels {
            var labelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .labels)
            for string0 in labels {
                try labelsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutEventTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutEventTypeInput: Swift.Equatable {
    /// The description of the event type.
    public var description: Swift.String?
    /// The entity type for the event type. Example entity types: customer, merchant, account.
    /// This member is required.
    public var entityTypes: [Swift.String]?
    /// Specifies if ingestion is enabled or disabled.
    public var eventIngestion: FraudDetectorClientTypes.EventIngestion?
    /// Enables or disables event orchestration. If enabled, you can send event predictions to select AWS services for downstream processing of the events.
    public var eventOrchestration: FraudDetectorClientTypes.EventOrchestration?
    /// The event type variables.
    /// This member is required.
    public var eventVariables: [Swift.String]?
    /// The event type labels.
    public var labels: [Swift.String]?
    /// The name.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        entityTypes: [Swift.String]? = nil,
        eventIngestion: FraudDetectorClientTypes.EventIngestion? = nil,
        eventOrchestration: FraudDetectorClientTypes.EventOrchestration? = nil,
        eventVariables: [Swift.String]? = nil,
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.entityTypes = entityTypes
        self.eventIngestion = eventIngestion
        self.eventOrchestration = eventOrchestration
        self.eventVariables = eventVariables
        self.labels = labels
        self.name = name
        self.tags = tags
    }
}

struct PutEventTypeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let eventVariables: [Swift.String]?
    let labels: [Swift.String]?
    let entityTypes: [Swift.String]?
    let eventIngestion: FraudDetectorClientTypes.EventIngestion?
    let tags: [FraudDetectorClientTypes.Tag]?
    let eventOrchestration: FraudDetectorClientTypes.EventOrchestration?
}

extension PutEventTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case entityTypes
        case eventIngestion
        case eventOrchestration
        case eventVariables
        case labels
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0:[Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String]()
            for string0 in eventVariablesContainer {
                if let string0 = string0 {
                    eventVariablesDecoded0?.append(string0)
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let labelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .labels)
        var labelsDecoded0:[Swift.String]? = nil
        if let labelsContainer = labelsContainer {
            labelsDecoded0 = [Swift.String]()
            for string0 in labelsContainer {
                if let string0 = string0 {
                    labelsDecoded0?.append(string0)
                }
            }
        }
        labels = labelsDecoded0
        let entityTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityTypes)
        var entityTypesDecoded0:[Swift.String]? = nil
        if let entityTypesContainer = entityTypesContainer {
            entityTypesDecoded0 = [Swift.String]()
            for string0 in entityTypesContainer {
                if let string0 = string0 {
                    entityTypesDecoded0?.append(string0)
                }
            }
        }
        entityTypes = entityTypesDecoded0
        let eventIngestionDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.EventIngestion.self, forKey: .eventIngestion)
        eventIngestion = eventIngestionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let eventOrchestrationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.EventOrchestration.self, forKey: .eventOrchestration)
        eventOrchestration = eventOrchestrationDecoded
    }
}

extension PutEventTypeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutEventTypeOutput: Swift.Equatable {

    public init() { }
}

enum PutEventTypeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutExternalModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputConfiguration = self.inputConfiguration {
            try encodeContainer.encode(inputConfiguration, forKey: .inputConfiguration)
        }
        if let invokeModelEndpointRoleArn = self.invokeModelEndpointRoleArn {
            try encodeContainer.encode(invokeModelEndpointRoleArn, forKey: .invokeModelEndpointRoleArn)
        }
        if let modelEndpoint = self.modelEndpoint {
            try encodeContainer.encode(modelEndpoint, forKey: .modelEndpoint)
        }
        if let modelEndpointStatus = self.modelEndpointStatus {
            try encodeContainer.encode(modelEndpointStatus.rawValue, forKey: .modelEndpointStatus)
        }
        if let modelSource = self.modelSource {
            try encodeContainer.encode(modelSource.rawValue, forKey: .modelSource)
        }
        if let outputConfiguration = self.outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutExternalModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutExternalModelInput: Swift.Equatable {
    /// The model endpoint input configuration.
    /// This member is required.
    public var inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
    /// The IAM role used to invoke the model endpoint.
    /// This member is required.
    public var invokeModelEndpointRoleArn: Swift.String?
    /// The model endpoints name.
    /// This member is required.
    public var modelEndpoint: Swift.String?
    /// The model endpoints status in Amazon Fraud Detector.
    /// This member is required.
    public var modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
    /// The source of the model.
    /// This member is required.
    public var modelSource: FraudDetectorClientTypes.ModelSource?
    /// The model endpoint output configuration.
    /// This member is required.
    public var outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
        invokeModelEndpointRoleArn: Swift.String? = nil,
        modelEndpoint: Swift.String? = nil,
        modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
        modelSource: FraudDetectorClientTypes.ModelSource? = nil,
        outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
        self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
        self.modelEndpoint = modelEndpoint
        self.modelEndpointStatus = modelEndpointStatus
        self.modelSource = modelSource
        self.outputConfiguration = outputConfiguration
        self.tags = tags
    }
}

struct PutExternalModelInputBody: Swift.Equatable {
    let modelEndpoint: Swift.String?
    let modelSource: FraudDetectorClientTypes.ModelSource?
    let invokeModelEndpointRoleArn: Swift.String?
    let inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
    let outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?
    let modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutExternalModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputConfiguration
        case invokeModelEndpointRoleArn
        case modelEndpoint
        case modelEndpointStatus
        case modelSource
        case outputConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelEndpoint)
        modelEndpoint = modelEndpointDecoded
        let modelSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelSource.self, forKey: .modelSource)
        modelSource = modelSourceDecoded
        let invokeModelEndpointRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invokeModelEndpointRoleArn)
        invokeModelEndpointRoleArn = invokeModelEndpointRoleArnDecoded
        let inputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelInputConfiguration.self, forKey: .inputConfiguration)
        inputConfiguration = inputConfigurationDecoded
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let modelEndpointStatusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelEndpointStatus.self, forKey: .modelEndpointStatus)
        modelEndpointStatus = modelEndpointStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutExternalModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutExternalModelOutput: Swift.Equatable {

    public init() { }
}

enum PutExternalModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutKMSEncryptionKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsEncryptionKeyArn = self.kmsEncryptionKeyArn {
            try encodeContainer.encode(kmsEncryptionKeyArn, forKey: .kmsEncryptionKeyArn)
        }
    }
}

extension PutKMSEncryptionKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutKMSEncryptionKeyInput: Swift.Equatable {
    /// The KMS encryption key ARN. The KMS key must be single-Region key. Amazon Fraud Detector does not support multi-Region KMS key.
    /// This member is required.
    public var kmsEncryptionKeyArn: Swift.String?

    public init(
        kmsEncryptionKeyArn: Swift.String? = nil
    )
    {
        self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
    }
}

struct PutKMSEncryptionKeyInputBody: Swift.Equatable {
    let kmsEncryptionKeyArn: Swift.String?
}

extension PutKMSEncryptionKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsEncryptionKeyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsEncryptionKeyArn)
        kmsEncryptionKeyArn = kmsEncryptionKeyArnDecoded
    }
}

extension PutKMSEncryptionKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutKMSEncryptionKeyOutput: Swift.Equatable {

    public init() { }
}

enum PutKMSEncryptionKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLabelInput: Swift.Equatable {
    /// The label description.
    public var description: Swift.String?
    /// The label name.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutLabelInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutLabelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLabelOutput: Swift.Equatable {

    public init() { }
}

enum PutLabelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutOutcomeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension PutOutcomeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutOutcomeInput: Swift.Equatable {
    /// The outcome description.
    public var description: Swift.String?
    /// The name of the outcome.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct PutOutcomeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension PutOutcomeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutOutcomeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutOutcomeOutput: Swift.Equatable {

    public init() { }
}

enum PutOutcomeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating the specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating that the attached customer-owned (external) model threw an exception when Amazon Fraud Detector invoked the model.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.Rule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
    }
}

extension FraudDetectorClientTypes {
    /// A rule.
    public struct Rule: Swift.Equatable {
        /// The detector for which the rule is associated.
        /// This member is required.
        public var detectorId: Swift.String?
        /// The rule ID.
        /// This member is required.
        public var ruleId: Swift.String?
        /// The rule version.
        /// This member is required.
        public var ruleVersion: Swift.String?

        public init(
            detectorId: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.detectorId = detectorId
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes.RuleDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case description
        case detectorId
        case expression
        case language
        case lastUpdatedTime
        case outcomes
        case ruleId
        case ruleVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for string0 in outcomes {
                try outcomesContainer.encode(string0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let ruleVersion = self.ruleVersion {
            try encodeContainer.encode(ruleVersion, forKey: .ruleVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes.RuleDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleDetail(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), language: \(Swift.String(describing: language)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)), expression: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// The details of the rule.
    public struct RuleDetail: Swift.Equatable {
        /// The rule ARN.
        public var arn: Swift.String?
        /// The timestamp of when the rule was created.
        public var createdTime: Swift.String?
        /// The rule description.
        public var description: Swift.String?
        /// The detector for which the rule is associated.
        public var detectorId: Swift.String?
        /// The rule expression.
        public var expression: Swift.String?
        /// The rule language.
        public var language: FraudDetectorClientTypes.Language?
        /// Timestamp of the last time the rule was updated.
        public var lastUpdatedTime: Swift.String?
        /// The rule outcomes.
        public var outcomes: [Swift.String]?
        /// The rule ID.
        public var ruleId: Swift.String?
        /// The rule version.
        public var ruleVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            expression: Swift.String? = nil,
            language: FraudDetectorClientTypes.Language? = nil,
            lastUpdatedTime: Swift.String? = nil,
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.lastUpdatedTime = lastUpdatedTime
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes {
    public enum RuleExecutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allMatched
        case firstMatched
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleExecutionMode] {
            return [
                .allMatched,
                .firstMatched,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allMatched: return "ALL_MATCHED"
            case .firstMatched: return "FIRST_MATCHED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuleExecutionMode(rawValue: rawValue) ?? RuleExecutionMode.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.RuleResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outcomes
        case ruleId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for string0 in outcomes {
                try outcomesContainer.encode(string0)
            }
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The rule results.
    public struct RuleResult: Swift.Equatable {
        /// The outcomes of the matched rule, based on the rule execution mode.
        public var outcomes: [Swift.String]?
        /// The rule ID that was matched, based on the rule execution mode.
        public var ruleId: Swift.String?

        public init(
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.outcomes = outcomes
            self.ruleId = ruleId
        }
    }

}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedLabel
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case labelTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignedLabel = self.assignedLabel {
            try encodeContainer.encode(assignedLabel, forKey: .assignedLabel)
        }
        if let entities = entities {
            var entitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entities)
            for entity0 in entities {
                try entitiesContainer.encode(entity0)
            }
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTimestamp = self.eventTimestamp {
            try encodeContainer.encode(eventTimestamp, forKey: .eventTimestamp)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let eventVariables = eventVariables {
            var eventVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventVariables)
            for (dictKey0, eventVariableMap0) in eventVariables {
                try eventVariablesContainer.encode(eventVariableMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let labelTimestamp = self.labelTimestamp {
            try encodeContainer.encode(labelTimestamp, forKey: .labelTimestamp)
        }
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// The label to associate with the event. Required if specifying labelTimestamp.
    public var assignedLabel: Swift.String?
    /// An array of entities.
    /// This member is required.
    public var entities: [FraudDetectorClientTypes.Entity]?
    /// The event ID to upload.
    /// This member is required.
    public var eventId: Swift.String?
    /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var eventTimestamp: Swift.String?
    /// The event type name of the event.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
    /// This member is required.
    public var eventVariables: [Swift.String:Swift.String]?
    /// The timestamp associated with the label. Required if specifying assignedLabel.
    public var labelTimestamp: Swift.String?

    public init(
        assignedLabel: Swift.String? = nil,
        entities: [FraudDetectorClientTypes.Entity]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [Swift.String:Swift.String]? = nil,
        labelTimestamp: Swift.String? = nil
    )
    {
        self.assignedLabel = assignedLabel
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.labelTimestamp = labelTimestamp
    }
}

struct SendEventInputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let eventTimestamp: Swift.String?
    let eventVariables: [Swift.String:Swift.String]?
    let assignedLabel: Swift.String?
    let labelTimestamp: Swift.String?
    let entities: [FraudDetectorClientTypes.Entity]?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedLabel
        case entities
        case eventId
        case eventTimestamp
        case eventTypeName
        case eventVariables
        case labelTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let eventTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let eventVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventVariables)
        var eventVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let eventVariablesContainer = eventVariablesContainer {
            eventVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, variablevalue0) in eventVariablesContainer {
                if let variablevalue0 = variablevalue0 {
                    eventVariablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        eventVariables = eventVariablesDecoded0
        let assignedLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedLabel)
        assignedLabel = assignedLabelDecoded
        let labelTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTimestamp)
        labelTimestamp = labelTimestampDecoded
        let entitiesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Entity?].self, forKey: .entities)
        var entitiesDecoded0:[FraudDetectorClientTypes.Entity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [FraudDetectorClientTypes.Entity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension SendEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendEventOutput: Swift.Equatable {

    public init() { }
}

enum SendEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FraudDetectorClientTypes.TFIMetricDataPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fpr
        case precision
        case threshold
        case tpr
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fpr = self.fpr {
            try encodeContainer.encode(fpr, forKey: .fpr)
        }
        if let precision = self.precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let threshold = self.threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let tpr = self.tpr {
            try encodeContainer.encode(tpr, forKey: .tpr)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .fpr)
        fpr = fprDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .precision)
        precision = precisionDecoded
        let tprDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .tpr)
        tpr = tprDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .threshold)
        threshold = thresholdDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The performance metrics data points for Transaction Fraud Insights (TFI) model.
    public struct TFIMetricDataPoint: Swift.Equatable {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes.TFIModelPerformance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auc
        case uncertaintyRange
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auc = self.auc {
            try encodeContainer.encode(auc, forKey: .auc)
        }
        if let uncertaintyRange = self.uncertaintyRange {
            try encodeContainer.encode(uncertaintyRange, forKey: .uncertaintyRange)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aucDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .auc)
        auc = aucDecoded
        let uncertaintyRangeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.UncertaintyRange.self, forKey: .uncertaintyRange)
        uncertaintyRange = uncertaintyRangeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Transaction Fraud Insights (TFI) model performance score.
    public struct TFIModelPerformance: Swift.Equatable {
        /// The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public var auc: Swift.Float?
        /// Indicates the range of area under curve (auc) expected from the TFI model. A range greater than 0.1 indicates higher model uncertainity.
        public var uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange?

        public init(
            auc: Swift.Float? = nil,
            uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange? = nil
        )
        {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }
    }

}

extension FraudDetectorClientTypes.TFITrainingMetricsValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricDataPoints
        case modelPerformance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for tfimetricdatapoint0 in metricDataPoints {
                try metricDataPointsContainer.encode(tfimetricdatapoint0)
            }
        }
        if let modelPerformance = self.modelPerformance {
            try encodeContainer.encode(modelPerformance, forKey: .modelPerformance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDataPointsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.TFIMetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[FraudDetectorClientTypes.TFIMetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [FraudDetectorClientTypes.TFIMetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
        let modelPerformanceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TFIModelPerformance.self, forKey: .modelPerformance)
        modelPerformance = modelPerformanceDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The Transaction Fraud Insights (TFI) model training metric details.
    public struct TFITrainingMetricsValue: Swift.Equatable {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.TFIMetricDataPoint]?
        /// The model performance score.
        public var modelPerformance: FraudDetectorClientTypes.TFIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.TFIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.TFIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

extension FraudDetectorClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension FraudDetectorClientTypes {
    /// A key and value pair.
    public struct Tag: Swift.Equatable {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A value assigned to a tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to assign to the resource.
    /// This member is required.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating a throttling error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.TrainingDataSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case labelSchema
        case modelVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let labelSchema = self.labelSchema {
            try encodeContainer.encode(labelSchema, forKey: .labelSchema)
        }
        if let modelVariables = modelVariables {
            var modelVariablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVariables)
            for string0 in modelVariables {
                try modelVariablesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVariablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .modelVariables)
        var modelVariablesDecoded0:[Swift.String]? = nil
        if let modelVariablesContainer = modelVariablesContainer {
            modelVariablesDecoded0 = [Swift.String]()
            for string0 in modelVariablesContainer {
                if let string0 = string0 {
                    modelVariablesDecoded0?.append(string0)
                }
            }
        }
        modelVariables = modelVariablesDecoded0
        let labelSchemaDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.LabelSchema.self, forKey: .labelSchema)
        labelSchema = labelSchemaDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The training data schema.
    public struct TrainingDataSchema: Swift.Equatable {
        /// The label schema.
        public var labelSchema: FraudDetectorClientTypes.LabelSchema?
        /// The training data schema variables.
        /// This member is required.
        public var modelVariables: [Swift.String]?

        public init(
            labelSchema: FraudDetectorClientTypes.LabelSchema? = nil,
            modelVariables: [Swift.String]? = nil
        )
        {
            self.labelSchema = labelSchema
            self.modelVariables = modelVariables
        }
    }

}

extension FraudDetectorClientTypes {
    public enum TrainingDataSourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case externalEvents
        case ingestedEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingDataSourceEnum] {
            return [
                .externalEvents,
                .ingestedEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .externalEvents: return "EXTERNAL_EVENTS"
            case .ingestedEvents: return "INGESTED_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrainingDataSourceEnum(rawValue: rawValue) ?? TrainingDataSourceEnum.sdkUnknown(rawValue)
        }
    }
}

extension FraudDetectorClientTypes.TrainingMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auc
        case metricDataPoints
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auc = self.auc {
            try encodeContainer.encode(auc, forKey: .auc)
        }
        if let metricDataPoints = metricDataPoints {
            var metricDataPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricDataPoints)
            for metricdatapoint0 in metricDataPoints {
                try metricDataPointsContainer.encode(metricdatapoint0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aucDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .auc)
        auc = aucDecoded
        let metricDataPointsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.MetricDataPoint?].self, forKey: .metricDataPoints)
        var metricDataPointsDecoded0:[FraudDetectorClientTypes.MetricDataPoint]? = nil
        if let metricDataPointsContainer = metricDataPointsContainer {
            metricDataPointsDecoded0 = [FraudDetectorClientTypes.MetricDataPoint]()
            for structure0 in metricDataPointsContainer {
                if let structure0 = structure0 {
                    metricDataPointsDecoded0?.append(structure0)
                }
            }
        }
        metricDataPoints = metricDataPointsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The training metric details.
    public struct TrainingMetrics: Swift.Equatable {
        /// The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.
        public var auc: Swift.Float?
        /// The data points details.
        public var metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]?

        public init(
            auc: Swift.Float? = nil,
            metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]? = nil
        )
        {
            self.auc = auc
            self.metricDataPoints = metricDataPoints
        }
    }

}

extension FraudDetectorClientTypes.TrainingMetricsV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ati
        case ofi
        case tfi
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ati = self.ati {
            try encodeContainer.encode(ati, forKey: .ati)
        }
        if let ofi = self.ofi {
            try encodeContainer.encode(ofi, forKey: .ofi)
        }
        if let tfi = self.tfi {
            try encodeContainer.encode(tfi, forKey: .tfi)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ofiDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.OFITrainingMetricsValue.self, forKey: .ofi)
        ofi = ofiDecoded
        let tfiDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TFITrainingMetricsValue.self, forKey: .tfi)
        tfi = tfiDecoded
        let atiDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ATITrainingMetricsValue.self, forKey: .ati)
        ati = atiDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The training metrics details.
    public struct TrainingMetricsV2: Swift.Equatable {
        /// The Account Takeover Insights (ATI) model training metric details.
        public var ati: FraudDetectorClientTypes.ATITrainingMetricsValue?
        /// The Online Fraud Insights (OFI) model training metric details.
        public var ofi: FraudDetectorClientTypes.OFITrainingMetricsValue?
        /// The Transaction Fraud Insights (TFI) model training metric details.
        public var tfi: FraudDetectorClientTypes.TFITrainingMetricsValue?

        public init(
            ati: FraudDetectorClientTypes.ATITrainingMetricsValue? = nil,
            ofi: FraudDetectorClientTypes.OFITrainingMetricsValue? = nil,
            tfi: FraudDetectorClientTypes.TFITrainingMetricsValue? = nil
        )
        {
            self.ati = ati
            self.ofi = ofi
            self.tfi = tfi
        }
    }

}

extension FraudDetectorClientTypes.TrainingResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataValidationMetrics
        case trainingMetrics
        case variableImportanceMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataValidationMetrics = self.dataValidationMetrics {
            try encodeContainer.encode(dataValidationMetrics, forKey: .dataValidationMetrics)
        }
        if let trainingMetrics = self.trainingMetrics {
            try encodeContainer.encode(trainingMetrics, forKey: .trainingMetrics)
        }
        if let variableImportanceMetrics = self.variableImportanceMetrics {
            try encodeContainer.encode(variableImportanceMetrics, forKey: .variableImportanceMetrics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataValidationMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataValidationMetrics.self, forKey: .dataValidationMetrics)
        dataValidationMetrics = dataValidationMetricsDecoded
        let trainingMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingMetrics.self, forKey: .trainingMetrics)
        trainingMetrics = trainingMetricsDecoded
        let variableImportanceMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.VariableImportanceMetrics.self, forKey: .variableImportanceMetrics)
        variableImportanceMetrics = variableImportanceMetricsDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The training result details.
    public struct TrainingResult: Swift.Equatable {
        /// The validation metrics.
        public var dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics?
        /// The training metric details.
        public var trainingMetrics: FraudDetectorClientTypes.TrainingMetrics?
        /// The variable importance metrics.
        public var variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics?

        public init(
            dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics? = nil,
            trainingMetrics: FraudDetectorClientTypes.TrainingMetrics? = nil,
            variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics? = nil
        )
        {
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetrics = trainingMetrics
            self.variableImportanceMetrics = variableImportanceMetrics
        }
    }

}

extension FraudDetectorClientTypes.TrainingResultV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedVariablesImportanceMetrics
        case dataValidationMetrics
        case trainingMetricsV2
        case variableImportanceMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatedVariablesImportanceMetrics = self.aggregatedVariablesImportanceMetrics {
            try encodeContainer.encode(aggregatedVariablesImportanceMetrics, forKey: .aggregatedVariablesImportanceMetrics)
        }
        if let dataValidationMetrics = self.dataValidationMetrics {
            try encodeContainer.encode(dataValidationMetrics, forKey: .dataValidationMetrics)
        }
        if let trainingMetricsV2 = self.trainingMetricsV2 {
            try encodeContainer.encode(trainingMetricsV2, forKey: .trainingMetricsV2)
        }
        if let variableImportanceMetrics = self.variableImportanceMetrics {
            try encodeContainer.encode(variableImportanceMetrics, forKey: .variableImportanceMetrics)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataValidationMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataValidationMetrics.self, forKey: .dataValidationMetrics)
        dataValidationMetrics = dataValidationMetricsDecoded
        let trainingMetricsV2Decoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.TrainingMetricsV2.self, forKey: .trainingMetricsV2)
        trainingMetricsV2 = trainingMetricsV2Decoded
        let variableImportanceMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.VariableImportanceMetrics.self, forKey: .variableImportanceMetrics)
        variableImportanceMetrics = variableImportanceMetricsDecoded
        let aggregatedVariablesImportanceMetricsDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics.self, forKey: .aggregatedVariablesImportanceMetrics)
        aggregatedVariablesImportanceMetrics = aggregatedVariablesImportanceMetricsDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The training result details.
    public struct TrainingResultV2: Swift.Equatable {
        /// The variable importance metrics of the aggregated variables. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
        public var aggregatedVariablesImportanceMetrics: FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics?
        /// The model training data validation metrics.
        public var dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics?
        /// The training metric details.
        public var trainingMetricsV2: FraudDetectorClientTypes.TrainingMetricsV2?
        /// The variable importance metrics details.
        public var variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics?

        public init(
            aggregatedVariablesImportanceMetrics: FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics? = nil,
            dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics? = nil,
            trainingMetricsV2: FraudDetectorClientTypes.TrainingMetricsV2? = nil,
            variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics? = nil
        )
        {
            self.aggregatedVariablesImportanceMetrics = aggregatedVariablesImportanceMetrics
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetricsV2 = trainingMetricsV2
            self.variableImportanceMetrics = variableImportanceMetrics
        }
    }

}

extension FraudDetectorClientTypes.UncertaintyRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lowerBoundValue
        case upperBoundValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lowerBoundValue = self.lowerBoundValue {
            try encodeContainer.encode(lowerBoundValue, forKey: .lowerBoundValue)
        }
        if let upperBoundValue = self.upperBoundValue {
            try encodeContainer.encode(upperBoundValue, forKey: .upperBoundValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lowerBoundValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .lowerBoundValue)
        lowerBoundValue = lowerBoundValueDecoded
        let upperBoundValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .upperBoundValue)
        upperBoundValue = upperBoundValueDecoded
    }
}

extension FraudDetectorClientTypes {
    /// Range of area under curve (auc) expected from the model. A range greater than 0.1 indicates higher model uncertainity. A range is the difference between upper and lower bound of auc.
    public struct UncertaintyRange: Swift.Equatable {
        /// The lower bound value of the area under curve (auc).
        /// This member is required.
        public var lowerBoundValue: Swift.Float?
        /// The upper bound value of the area under curve (auc).
        /// This member is required.
        public var upperBoundValue: Swift.Float?

        public init(
            lowerBoundValue: Swift.Float? = nil,
            upperBoundValue: Swift.Float? = nil
        )
        {
            self.lowerBoundValue = lowerBoundValue
            self.upperBoundValue = upperBoundValue
        }
    }

}

extension FraudDetectorClientTypes {
    public enum UnlabeledEventsTreatment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case fraud
        case ignore
        case legit
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlabeledEventsTreatment] {
            return [
                .auto,
                .fraud,
                .ignore,
                .legit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .fraud: return "FRAUD"
            case .ignore: return "IGNORE"
            case .legit: return "LEGIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnlabeledEventsTreatment(rawValue: rawValue) ?? UnlabeledEventsTreatment.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource from which to remove the tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The resource ARN.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDetectorVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let externalModelEndpoints = externalModelEndpoints {
            var externalModelEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalModelEndpoints)
            for string0 in externalModelEndpoints {
                try externalModelEndpointsContainer.encode(string0)
            }
        }
        if let modelVersions = modelVersions {
            var modelVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .modelVersions)
            for modelversion0 in modelVersions {
                try modelVersionsContainer.encode(modelversion0)
            }
        }
        if let ruleExecutionMode = self.ruleExecutionMode {
            try encodeContainer.encode(ruleExecutionMode.rawValue, forKey: .ruleExecutionMode)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for rule0 in rules {
                try rulesContainer.encode(rule0)
            }
        }
    }
}

extension UpdateDetectorVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDetectorVersionInput: Swift.Equatable {
    /// The detector version description.
    public var description: Swift.String?
    /// The parent detector ID for the detector version you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints to include in the detector version.
    /// This member is required.
    public var externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode to add to the detector. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status. The default behavior is FIRST_MATCHED.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public var rules: [FraudDetectorClientTypes.Rule]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

struct UpdateDetectorVersionInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let externalModelEndpoints: [Swift.String]?
    let rules: [FraudDetectorClientTypes.Rule]?
    let description: Swift.String?
    let modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    let ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
}

extension UpdateDetectorVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
        case externalModelEndpoints
        case modelVersions
        case ruleExecutionMode
        case rules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let externalModelEndpointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .externalModelEndpoints)
        var externalModelEndpointsDecoded0:[Swift.String]? = nil
        if let externalModelEndpointsContainer = externalModelEndpointsContainer {
            externalModelEndpointsDecoded0 = [Swift.String]()
            for string0 in externalModelEndpointsContainer {
                if let string0 = string0 {
                    externalModelEndpointsDecoded0?.append(string0)
                }
            }
        }
        externalModelEndpoints = externalModelEndpointsDecoded0
        let rulesContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Rule?].self, forKey: .rules)
        var rulesDecoded0:[FraudDetectorClientTypes.Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [FraudDetectorClientTypes.Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let modelVersionsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.ModelVersion?].self, forKey: .modelVersions)
        var modelVersionsDecoded0:[FraudDetectorClientTypes.ModelVersion]? = nil
        if let modelVersionsContainer = modelVersionsContainer {
            modelVersionsDecoded0 = [FraudDetectorClientTypes.ModelVersion]()
            for structure0 in modelVersionsContainer {
                if let structure0 = structure0 {
                    modelVersionsDecoded0?.append(structure0)
                }
            }
        }
        modelVersions = modelVersionsDecoded0
        let ruleExecutionModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.RuleExecutionMode.self, forKey: .ruleExecutionMode)
        ruleExecutionMode = ruleExecutionModeDecoded
    }
}

extension UpdateDetectorVersionMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
    }
}

extension UpdateDetectorVersionMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDetectorVersionMetadataInput: Swift.Equatable {
    /// The description.
    /// This member is required.
    public var description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

struct UpdateDetectorVersionMetadataInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let description: Swift.String?
}

extension UpdateDetectorVersionMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case detectorId
        case detectorVersionId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateDetectorVersionMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDetectorVersionMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDetectorVersionMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDetectorVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDetectorVersionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDetectorVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDetectorVersionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorVersionId = self.detectorVersionId {
            try encodeContainer.encode(detectorVersionId, forKey: .detectorVersionId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateDetectorVersionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDetectorVersionStatusInput: Swift.Equatable {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The new status. The only supported values are ACTIVE and INACTIVE
    /// This member is required.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

struct UpdateDetectorVersionStatusInputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let detectorVersionId: Swift.String?
    let status: FraudDetectorClientTypes.DetectorVersionStatus?
}

extension UpdateDetectorVersionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId
        case detectorVersionId
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorVersionId)
        detectorVersionId = detectorVersionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DetectorVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateDetectorVersionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDetectorVersionStatusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDetectorVersionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEventLabelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedLabel
        case eventId
        case eventTypeName
        case labelTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignedLabel = self.assignedLabel {
            try encodeContainer.encode(assignedLabel, forKey: .assignedLabel)
        }
        if let eventId = self.eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTypeName = self.eventTypeName {
            try encodeContainer.encode(eventTypeName, forKey: .eventTypeName)
        }
        if let labelTimestamp = self.labelTimestamp {
            try encodeContainer.encode(labelTimestamp, forKey: .labelTimestamp)
        }
    }
}

extension UpdateEventLabelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEventLabelInput: Swift.Equatable {
    /// The new label to assign to the event.
    /// This member is required.
    public var assignedLabel: Swift.String?
    /// The ID of the event associated with the label to update.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type of the event associated with the label to update.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The timestamp associated with the label. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var labelTimestamp: Swift.String?

    public init(
        assignedLabel: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        labelTimestamp: Swift.String? = nil
    )
    {
        self.assignedLabel = assignedLabel
        self.eventId = eventId
        self.eventTypeName = eventTypeName
        self.labelTimestamp = labelTimestamp
    }
}

struct UpdateEventLabelInputBody: Swift.Equatable {
    let eventId: Swift.String?
    let eventTypeName: Swift.String?
    let assignedLabel: Swift.String?
    let labelTimestamp: Swift.String?
}

extension UpdateEventLabelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignedLabel
        case eventId
        case eventTypeName
        case labelTimestamp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTypeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeName)
        eventTypeName = eventTypeNameDecoded
        let assignedLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assignedLabel)
        assignedLabel = assignedLabelDecoded
        let labelTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .labelTimestamp)
        labelTimestamp = labelTimestampDecoded
    }
}

extension UpdateEventLabelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEventLabelOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEventLabelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateListInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case elements
        case name
        case updateMode
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let elements = elements {
            var elementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .elements)
            for elements0 in elements {
                try elementsContainer.encode(elements0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateMode = self.updateMode {
            try encodeContainer.encode(updateMode.rawValue, forKey: .updateMode)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

extension UpdateListInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateListInput: Swift.Equatable {
    /// The new description.
    public var description: Swift.String?
    /// One or more list elements to add or replace. If you are providing the elements, make sure to specify the updateMode to use. If you are deleting all elements from the list, use REPLACE for the updateMode and provide an empty list (0 elements).
    public var elements: [Swift.String]?
    /// The name of the list to update.
    /// This member is required.
    public var name: Swift.String?
    /// The update mode (type).
    ///
    /// * Use APPEND if you are adding elements to the list.
    ///
    /// * Use REPLACE if you replacing existing elements in the list.
    ///
    /// * Use REMOVE if you are removing elements from the list.
    public var updateMode: FraudDetectorClientTypes.ListUpdateMode?
    /// The variable type you want to assign to the list. You cannot update a variable type of a list that already has a variable type assigned to it. You can assign a variable type to a list only if the list does not already have a variable type.
    public var variableType: Swift.String?

    public init(
        description: Swift.String? = nil,
        elements: [Swift.String]? = nil,
        name: Swift.String? = nil,
        updateMode: FraudDetectorClientTypes.ListUpdateMode? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.description = description
        self.elements = elements
        self.name = name
        self.updateMode = updateMode
        self.variableType = variableType
    }
}

struct UpdateListInputBody: Swift.Equatable {
    let name: Swift.String?
    let elements: [Swift.String]?
    let description: Swift.String?
    let updateMode: FraudDetectorClientTypes.ListUpdateMode?
    let variableType: Swift.String?
}

extension UpdateListInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case elements
        case name
        case updateMode
        case variableType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let elementsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .elements)
        var elementsDecoded0:[Swift.String]? = nil
        if let elementsContainer = elementsContainer {
            elementsDecoded0 = [Swift.String]()
            for string0 in elementsContainer {
                if let string0 = string0 {
                    elementsDecoded0?.append(string0)
                }
            }
        }
        elements = elementsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let updateModeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ListUpdateMode.self, forKey: .updateMode)
        updateMode = updateModeDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension UpdateListOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateListOutput: Swift.Equatable {

    public init() { }
}

enum UpdateListOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelId
        case modelType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
    }
}

extension UpdateModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateModelInput: Swift.Equatable {
    /// The new model description.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init(
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.description = description
        self.modelId = modelId
        self.modelType = modelType
    }
}

struct UpdateModelInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let description: Swift.String?
}

extension UpdateModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case modelId
        case modelType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateModelOutput: Swift.Equatable {

    public init() { }
}

enum UpdateModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateModelVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case ingestedEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalEventsDetail = self.externalEventsDetail {
            try encodeContainer.encode(externalEventsDetail, forKey: .externalEventsDetail)
        }
        if let ingestedEventsDetail = self.ingestedEventsDetail {
            try encodeContainer.encode(ingestedEventsDetail, forKey: .ingestedEventsDetail)
        }
        if let majorVersionNumber = self.majorVersionNumber {
            try encodeContainer.encode(majorVersionNumber, forKey: .majorVersionNumber)
        }
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UpdateModelVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateModelVersionInput: Swift.Equatable {
    /// The details of the external events data used for training the model version. Required if trainingDataSource is EXTERNAL_EVENTS.
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The details of the ingested event used for training the model version. Required if your trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The major version number.
    /// This member is required.
    public var majorVersionNumber: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        majorVersionNumber: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.majorVersionNumber = majorVersionNumber
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

struct UpdateModelVersionInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let majorVersionNumber: Swift.String?
    let externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    let ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension UpdateModelVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalEventsDetail
        case ingestedEventsDetail
        case majorVersionNumber
        case modelId
        case modelType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let majorVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .majorVersionNumber)
        majorVersionNumber = majorVersionNumberDecoded
        let externalEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ExternalEventsDetail.self, forKey: .externalEventsDetail)
        externalEventsDetail = externalEventsDetailDecoded
        let ingestedEventsDetailDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.IngestedEventsDetail.self, forKey: .ingestedEventsDetail)
        ingestedEventsDetail = ingestedEventsDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateModelVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateModelVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.modelId = output.modelId
            self.modelType = output.modelType
            self.modelVersionNumber = output.modelVersionNumber
            self.status = output.status
        } else {
            self.modelId = nil
            self.modelType = nil
            self.modelVersionNumber = nil
            self.status = nil
        }
    }
}

public struct UpdateModelVersionOutput: Swift.Equatable {
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version updated.
    public var modelVersionNumber: Swift.String?
    /// The status of the updated model version.
    public var status: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionOutputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
    let status: Swift.String?
}

extension UpdateModelVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateModelVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateModelVersionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let modelId = self.modelId {
            try encodeContainer.encode(modelId, forKey: .modelId)
        }
        if let modelType = self.modelType {
            try encodeContainer.encode(modelType.rawValue, forKey: .modelType)
        }
        if let modelVersionNumber = self.modelVersionNumber {
            try encodeContainer.encode(modelVersionNumber, forKey: .modelVersionNumber)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateModelVersionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateModelVersionStatusInput: Swift.Equatable {
    /// The model ID of the model version to update.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public var modelVersionNumber: Swift.String?
    /// The model version status.
    /// This member is required.
    public var status: FraudDetectorClientTypes.ModelVersionStatus?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: FraudDetectorClientTypes.ModelVersionStatus? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

struct UpdateModelVersionStatusInputBody: Swift.Equatable {
    let modelId: Swift.String?
    let modelType: FraudDetectorClientTypes.ModelTypeEnum?
    let modelVersionNumber: Swift.String?
    let status: FraudDetectorClientTypes.ModelVersionStatus?
}

extension UpdateModelVersionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case modelId
        case modelType
        case modelVersionNumber
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelId)
        modelId = modelIdDecoded
        let modelTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelTypeEnum.self, forKey: .modelType)
        modelType = modelTypeDecoded
        let modelVersionNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelVersionNumber)
        modelVersionNumber = modelVersionNumberDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.ModelVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateModelVersionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateModelVersionStatusOutput: Swift.Equatable {

    public init() { }
}

enum UpdateModelVersionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRuleMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case rule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

extension UpdateRuleMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRuleMetadataInput: Swift.Equatable {
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule to update.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        description: Swift.String? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.description = description
        self.rule = rule
    }
}

struct UpdateRuleMetadataInputBody: Swift.Equatable {
    let rule: FraudDetectorClientTypes.Rule?
    let description: Swift.String?
}

extension UpdateRuleMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case rule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateRuleMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRuleMetadataOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRuleMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRuleVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleVersionInput(description: \(Swift.String(describing: description)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), rule: \(Swift.String(describing: rule)), tags: \(Swift.String(describing: tags)), expression: \"CONTENT_REDACTED\")"}
}

extension UpdateRuleVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let language = self.language {
            try encodeContainer.encode(language.rawValue, forKey: .language)
        }
        if let outcomes = outcomes {
            var outcomesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outcomes)
            for string0 in outcomes {
                try outcomesContainer.encode(string0)
            }
        }
        if let rule = self.rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UpdateRuleVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRuleVersionInput: Swift.Equatable {
    /// The description.
    public var description: Swift.String?
    /// The rule expression.
    /// This member is required.
    public var expression: Swift.String?
    /// The language.
    /// This member is required.
    public var language: FraudDetectorClientTypes.Language?
    /// The outcomes.
    /// This member is required.
    public var outcomes: [Swift.String]?
    /// The rule to update.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?
    /// The tags to assign to the rule version.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.rule = rule
        self.tags = tags
    }
}

struct UpdateRuleVersionInputBody: Swift.Equatable {
    let rule: FraudDetectorClientTypes.Rule?
    let description: Swift.String?
    let expression: Swift.String?
    let language: FraudDetectorClientTypes.Language?
    let outcomes: [Swift.String]?
    let tags: [FraudDetectorClientTypes.Tag]?
}

extension UpdateRuleVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case expression
        case language
        case outcomes
        case rule
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let languageDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Language.self, forKey: .language)
        language = languageDecoded
        let outcomesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outcomes)
        var outcomesDecoded0:[Swift.String]? = nil
        if let outcomesContainer = outcomesContainer {
            outcomesDecoded0 = [Swift.String]()
            for string0 in outcomesContainer {
                if let string0 = string0 {
                    outcomesDecoded0?.append(string0)
                }
            }
        }
        outcomes = outcomesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[FraudDetectorClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [FraudDetectorClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateRuleVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRuleVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.rule = output.rule
        } else {
            self.rule = nil
        }
    }
}

public struct UpdateRuleVersionOutput: Swift.Equatable {
    /// The new rule version that was created.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

struct UpdateRuleVersionOutputBody: Swift.Equatable {
    let rule: FraudDetectorClientTypes.Rule?
}

extension UpdateRuleVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.Rule.self, forKey: .rule)
        rule = ruleDecoded
    }
}

enum UpdateRuleVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateVariableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }
}

extension UpdateVariableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVariableInput: Swift.Equatable {
    /// The new default value of the variable.
    public var defaultValue: Swift.String?
    /// The new description.
    public var description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public var name: Swift.String?
    /// The variable type. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
    public var variableType: Swift.String?

    public init(
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.variableType = variableType
    }
}

struct UpdateVariableInputBody: Swift.Equatable {
    let name: Swift.String?
    let defaultValue: Swift.String?
    let description: Swift.String?
    let variableType: Swift.String?
}

extension UpdateVariableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case variableType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension UpdateVariableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateVariableOutput: Swift.Equatable {

    public init() { }
}

enum UpdateVariableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An exception indicating a specified value is not allowed.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FraudDetectorClientTypes.Variable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case dataSource
        case dataType
        case defaultValue
        case description
        case lastUpdatedTime
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encode(createdTime, forKey: .createdTime)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(FraudDetectorClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The variable.
    public struct Variable: Swift.Equatable {
        /// The ARN of the variable.
        public var arn: Swift.String?
        /// The time when the variable was created.
        public var createdTime: Swift.String?
        /// The data source of the variable.
        public var dataSource: FraudDetectorClientTypes.DataSource?
        /// The data type of the variable. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
        public var dataType: FraudDetectorClientTypes.DataType?
        /// The default value of the variable.
        public var defaultValue: Swift.String?
        /// The description of the variable.
        public var description: Swift.String?
        /// The time when variable was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The name of the variable.
        public var name: Swift.String?
        /// The variable type of the variable. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public var variableType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dataSource: FraudDetectorClientTypes.DataSource? = nil,
            dataType: FraudDetectorClientTypes.DataType? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.VariableEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case dataType
        case defaultValue
        case description
        case name
        case variableType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let variableType = self.variableType {
            try encodeContainer.encode(variableType, forKey: .variableType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let variableTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .variableType)
        variableType = variableTypeDecoded
    }
}

extension FraudDetectorClientTypes {
    /// A variable in the list of variables for the batch create variable request.
    public struct VariableEntry: Swift.Equatable {
        /// The data source of the variable.
        public var dataSource: Swift.String?
        /// The data type of the variable.
        public var dataType: Swift.String?
        /// The default value of the variable.
        public var defaultValue: Swift.String?
        /// The description of the variable.
        public var description: Swift.String?
        /// The name of the variable.
        public var name: Swift.String?
        /// The type of the variable. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types). Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public var variableType: Swift.String?

        public init(
            dataSource: Swift.String? = nil,
            dataType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes.VariableImpactExplanation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventVariableName
        case logOddsImpact
        case relativeImpact
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventVariableName = self.eventVariableName {
            try encodeContainer.encode(eventVariableName, forKey: .eventVariableName)
        }
        if let logOddsImpact = self.logOddsImpact {
            try encodeContainer.encode(logOddsImpact, forKey: .logOddsImpact)
        }
        if let relativeImpact = self.relativeImpact {
            try encodeContainer.encode(relativeImpact, forKey: .relativeImpact)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventVariableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventVariableName)
        eventVariableName = eventVariableNameDecoded
        let relativeImpactDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relativeImpact)
        relativeImpact = relativeImpactDecoded
        let logOddsImpactDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .logOddsImpact)
        logOddsImpact = logOddsImpactDecoded
    }
}

extension FraudDetectorClientTypes {
    /// The details of the event variable's impact on the prediction score.
    public struct VariableImpactExplanation: Swift.Equatable {
        /// The event variable name.
        public var eventVariableName: Swift.String?
        /// The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.
        ///
        /// * A positive value indicates that the variable drove the risk score up.
        ///
        /// * A negative value indicates that the variable drove the risk score down.
        public var logOddsImpact: Swift.Float?
        /// The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk.
        public var relativeImpact: Swift.String?

        public init(
            eventVariableName: Swift.String? = nil,
            logOddsImpact: Swift.Float? = nil,
            relativeImpact: Swift.String? = nil
        )
        {
            self.eventVariableName = eventVariableName
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }
    }

}

extension FraudDetectorClientTypes.VariableImportanceMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logOddsMetrics
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logOddsMetrics = logOddsMetrics {
            var logOddsMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logOddsMetrics)
            for logoddsmetric0 in logOddsMetrics {
                try logOddsMetricsContainer.encode(logoddsmetric0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logOddsMetricsContainer = try containerValues.decodeIfPresent([FraudDetectorClientTypes.LogOddsMetric?].self, forKey: .logOddsMetrics)
        var logOddsMetricsDecoded0:[FraudDetectorClientTypes.LogOddsMetric]? = nil
        if let logOddsMetricsContainer = logOddsMetricsContainer {
            logOddsMetricsDecoded0 = [FraudDetectorClientTypes.LogOddsMetric]()
            for structure0 in logOddsMetricsContainer {
                if let structure0 = structure0 {
                    logOddsMetricsDecoded0?.append(structure0)
                }
            }
        }
        logOddsMetrics = logOddsMetricsDecoded0
    }
}

extension FraudDetectorClientTypes {
    /// The variable importance metrics details.
    public struct VariableImportanceMetrics: Swift.Equatable {
        /// List of variable metrics.
        public var logOddsMetrics: [FraudDetectorClientTypes.LogOddsMetric]?

        public init(
            logOddsMetrics: [FraudDetectorClientTypes.LogOddsMetric]? = nil
        )
        {
            self.logOddsMetrics = logOddsMetrics
        }
    }

}
