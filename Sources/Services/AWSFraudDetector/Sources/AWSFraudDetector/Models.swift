//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

public struct GetKMSEncryptionKeyInput {

    public init() { }
}

/// An exception indicating Amazon Fraud Detector does not have the needed permissions. This can occur if you submit a request, such as PutExternalModel, that specifies a role that is not in your account.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FraudDetectorClientTypes {
    /// The log odds metric details. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedLogOddsMetric {
        /// The relative importance of the variables in the list to the other event variable.
        /// This member is required.
        public var aggregatedVariablesImportance: Swift.Float?
        /// The names of all the variables.
        /// This member is required.
        public var variableNames: [Swift.String]?

        public init(
            aggregatedVariablesImportance: Swift.Float? = nil,
            variableNames: [Swift.String]? = nil
        )
        {
            self.aggregatedVariablesImportance = aggregatedVariablesImportance
            self.variableNames = variableNames
        }
    }

}

extension FraudDetectorClientTypes {
    /// The details of the impact of aggregated variables on the prediction score. Account Takeover Insights (ATI) model uses the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, the model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedVariablesImpactExplanation {
        /// The names of all the event variables that were used to derive the aggregated variables.
        public var eventVariableNames: [Swift.String]?
        /// The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from -infinity to +infinity.
        ///
        /// * A positive value indicates that the variables drove the risk score up.
        ///
        /// * A negative value indicates that the variables drove the risk score down.
        public var logOddsImpact: Swift.Float?
        /// The relative impact of the aggregated variables in terms of magnitude on the prediction scores.
        public var relativeImpact: Swift.String?

        public init(
            eventVariableNames: [Swift.String]? = nil,
            logOddsImpact: Swift.Float? = nil,
            relativeImpact: Swift.String? = nil
        )
        {
            self.eventVariableNames = eventVariableNames
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }
    }

}

extension FraudDetectorClientTypes {
    /// The details of the relative importance of the aggregated variables. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
    public struct AggregatedVariablesImportanceMetrics {
        /// List of variables' metrics.
        public var logOddsMetrics: [FraudDetectorClientTypes.AggregatedLogOddsMetric]?

        public init(
            logOddsMetrics: [FraudDetectorClientTypes.AggregatedLogOddsMetric]? = nil
        )
        {
            self.logOddsMetrics = logOddsMetrics
        }
    }

}

extension FraudDetectorClientTypes {
    /// The metadata of a list.
    public struct AllowDenyList {
        /// The ARN of the list.
        public var arn: Swift.String?
        /// The time the list was created.
        public var createdTime: Swift.String?
        /// The description of the list.
        public var description: Swift.String?
        /// The name of the list.
        /// This member is required.
        public var name: Swift.String?
        /// The time the list was last updated.
        public var updatedTime: Swift.String?
        /// The variable type of the list.
        public var variableType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedTime: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.name = name
            self.updatedTime = updatedTime
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes {

    public enum AsyncJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case cancelInProgress
        case complete
        case failed
        case inProgress
        case inProgressInitializing
        case sdkUnknown(Swift.String)

        public static var allCases: [AsyncJobStatus] {
            return [
                .canceled,
                .cancelInProgress,
                .complete,
                .failed,
                .inProgress,
                .inProgressInitializing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .cancelInProgress: return "CANCEL_IN_PROGRESS"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInitializing: return "IN_PROGRESS_INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model performance metrics data points.
    public struct ATIMetricDataPoint {
        /// The anomaly discovery rate. This metric quantifies the percentage of anomalies that can be detected by the model at the selected score threshold. A lower score threshold increases the percentage of anomalies captured by the model, but would also require challenging a larger percentage of login events, leading to a higher customer friction.
        public var adr: Swift.Float?
        /// The account takeover discovery rate. This metric quantifies the percentage of account compromise events that can be detected by the model at the selected score threshold. This metric is only available if 50 or more entities with at-least one labeled account takeover event is present in the ingested dataset.
        public var atodr: Swift.Float?
        /// The challenge rate. This indicates the percentage of login events that the model recommends to challenge such as one-time password, multi-factor authentication, and investigations.
        public var cr: Swift.Float?
        /// The model's threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?

        public init(
            adr: Swift.Float? = nil,
            atodr: Swift.Float? = nil,
            cr: Swift.Float? = nil,
            threshold: Swift.Float? = nil
        )
        {
            self.adr = adr
            self.atodr = atodr
            self.cr = cr
            self.threshold = threshold
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model performance score.
    public struct ATIModelPerformance {
        /// The anomaly separation index (ASI) score. This metric summarizes the overall ability of the model to separate anomalous activities from the normal behavior. Depending on the business, a large fraction of these anomalous activities can be malicious and correspond to the account takeover attacks. A model with no separability power will have the lowest possible ASI score of 0.5, whereas the a model with a high separability power will have the highest possible ASI score of 1.0
        public var asi: Swift.Float?

        public init(
            asi: Swift.Float? = nil
        )
        {
            self.asi = asi
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Account Takeover Insights (ATI) model training metric details.
    public struct ATITrainingMetricsValue {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.ATIMetricDataPoint]?
        /// The model's overall performance scores.
        public var modelPerformance: FraudDetectorClientTypes.ATIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.ATIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.ATIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

/// An exception indicating an internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception indicating a throttling error.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An exception indicating a specified value is not allowed.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FraudDetectorClientTypes {
    /// A key and value pair.
    public struct Tag {
        /// A tag key.
        /// This member is required.
        public var key: Swift.String?
        /// A value assigned to a tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension FraudDetectorClientTypes {
    /// A variable in the list of variables for the batch create variable request.
    public struct VariableEntry {
        /// The data source of the variable.
        public var dataSource: Swift.String?
        /// The data type of the variable.
        public var dataType: Swift.String?
        /// The default value of the variable.
        public var defaultValue: Swift.String?
        /// The description of the variable.
        public var description: Swift.String?
        /// The name of the variable.
        public var name: Swift.String?
        /// The type of the variable. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types). Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public var variableType: Swift.String?

        public init(
            dataSource: Swift.String? = nil,
            dataType: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.variableType = variableType
        }
    }

}

public struct BatchCreateVariableInput {
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The list of variables for the batch create variable request.
    /// This member is required.
    public var variableEntries: [FraudDetectorClientTypes.VariableEntry]?

    public init(
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableEntries: [FraudDetectorClientTypes.VariableEntry]? = nil
    )
    {
        self.tags = tags
        self.variableEntries = variableEntries
    }
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch create variable API.
    public struct BatchCreateVariableError {
        /// The error code.
        public var code: Swift.Int
        /// The error message.
        public var message: Swift.String?
        /// The name.
        public var name: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

public struct BatchCreateVariableOutput {
    /// Provides the errors for the BatchCreateVariable request.
    public var errors: [FraudDetectorClientTypes.BatchCreateVariableError]?

    public init(
        errors: [FraudDetectorClientTypes.BatchCreateVariableError]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchGetVariableInput {
    /// The list of variable names to get.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        names: [Swift.String]? = nil
    )
    {
        self.names = names
    }
}

extension FraudDetectorClientTypes {
    /// Provides the error of the batch get variable API.
    public struct BatchGetVariableError {
        /// The error code.
        public var code: Swift.Int
        /// The error message.
        public var message: Swift.String?
        /// The error name.
        public var name: Swift.String?

        public init(
            code: Swift.Int = 0,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes {

    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case event
        case externalModelScore
        case modelScore
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .event,
                .externalModelScore,
                .modelScore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .event: return "EVENT"
            case .externalModelScore: return "EXTERNAL_MODEL_SCORE"
            case .modelScore: return "MODEL_SCORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {

    public enum DataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case datetime
        case float
        case integer
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DataType] {
            return [
                .boolean,
                .datetime,
                .float,
                .integer,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .datetime: return "DATETIME"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The variable.
    public struct Variable {
        /// The ARN of the variable.
        public var arn: Swift.String?
        /// The time when the variable was created.
        public var createdTime: Swift.String?
        /// The data source of the variable.
        public var dataSource: FraudDetectorClientTypes.DataSource?
        /// The data type of the variable. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
        public var dataType: FraudDetectorClientTypes.DataType?
        /// The default value of the variable.
        public var defaultValue: Swift.String?
        /// The description of the variable.
        public var description: Swift.String?
        /// The time when variable was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The name of the variable.
        public var name: Swift.String?
        /// The variable type of the variable. Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
        public var variableType: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            dataSource: FraudDetectorClientTypes.DataSource? = nil,
            dataType: FraudDetectorClientTypes.DataType? = nil,
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.dataSource = dataSource
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
            self.variableType = variableType
        }
    }

}

public struct BatchGetVariableOutput {
    /// The errors from the request.
    public var errors: [FraudDetectorClientTypes.BatchGetVariableError]?
    /// The returned variables.
    public var variables: [FraudDetectorClientTypes.Variable]?

    public init(
        errors: [FraudDetectorClientTypes.BatchGetVariableError]? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.errors = errors
        self.variables = variables
    }
}

/// An exception indicating the specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelBatchImportJobInput {
    /// The ID of an in-progress batch import job to cancel. Amazon Fraud Detector will throw an error if the batch import job is in FAILED, CANCELED, or COMPLETED state.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CancelBatchImportJobOutput {

    public init() { }
}

public struct CancelBatchPredictionJobInput {
    /// The ID of the batch prediction job to cancel.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct CancelBatchPredictionJobOutput {

    public init() { }
}

public struct CreateBatchImportJobInput {
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The ARN of the IAM role created for Amazon S3 bucket that holds your data file. The IAM role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see [User policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-policies-s3.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The URI that points to the Amazon S3 location of your data file.
    /// This member is required.
    public var inputPath: Swift.String?
    /// The ID of the batch import job. The ID cannot be of a past job, unless the job exists in CREATE_FAILED state.
    /// This member is required.
    public var jobId: Swift.String?
    /// The URI that points to the Amazon S3 location for storing your results.
    /// This member is required.
    public var outputPath: Swift.String?
    /// A collection of key-value pairs associated with this request.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        eventTypeName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        inputPath: Swift.String? = nil,
        jobId: Swift.String? = nil,
        outputPath: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

public struct CreateBatchImportJobOutput {

    public init() { }
}

public struct CreateBatchPredictionJobInput {
    /// The name of the detector.
    /// This member is required.
    public var detectorName: Swift.String?
    /// The detector version.
    public var detectorVersion: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The ARN of the IAM role to use for this job request. The IAM Role must have read permissions to your input S3 bucket and write permissions to your output S3 bucket. For more information about bucket permissions, see [User policy examples](https://docs.aws.amazon.com/AmazonS3/latest/userguide/example-policies-s3.html) in the Amazon S3 User Guide.
    /// This member is required.
    public var iamRoleArn: Swift.String?
    /// The Amazon S3 location of your training file.
    /// This member is required.
    public var inputPath: Swift.String?
    /// The ID of the batch prediction job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The Amazon S3 location of your output file.
    /// This member is required.
    public var outputPath: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        detectorName: Swift.String? = nil,
        detectorVersion: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        iamRoleArn: Swift.String? = nil,
        inputPath: Swift.String? = nil,
        jobId: Swift.String? = nil,
        outputPath: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.detectorName = detectorName
        self.detectorVersion = detectorVersion
        self.eventTypeName = eventTypeName
        self.iamRoleArn = iamRoleArn
        self.inputPath = inputPath
        self.jobId = jobId
        self.outputPath = outputPath
        self.tags = tags
    }
}

public struct CreateBatchPredictionJobOutput {

    public init() { }
}

extension FraudDetectorClientTypes {

    public enum ModelTypeEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountTakeoverInsights
        case onlineFraudInsights
        case transactionFraudInsights
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelTypeEnum] {
            return [
                .accountTakeoverInsights,
                .onlineFraudInsights,
                .transactionFraudInsights
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountTakeoverInsights: return "ACCOUNT_TAKEOVER_INSIGHTS"
            case .onlineFraudInsights: return "ONLINE_FRAUD_INSIGHTS"
            case .transactionFraudInsights: return "TRANSACTION_FRAUD_INSIGHTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The model version.
    public struct ModelVersion {
        /// The model version ARN.
        public var arn: Swift.String?
        /// The model ID.
        /// This member is required.
        public var modelId: Swift.String?
        /// The model type.
        /// This member is required.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        /// This member is required.
        public var modelVersionNumber: Swift.String?

        public init(
            arn: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil
        )
        {
            self.arn = arn
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
        }
    }

}

extension FraudDetectorClientTypes {

    public enum RuleExecutionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allMatched
        case firstMatched
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleExecutionMode] {
            return [
                .allMatched,
                .firstMatched
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allMatched: return "ALL_MATCHED"
            case .firstMatched: return "FIRST_MATCHED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// A rule.
    public struct Rule {
        /// The detector for which the rule is associated.
        /// This member is required.
        public var detectorId: Swift.String?
        /// The rule ID.
        /// This member is required.
        public var ruleId: Swift.String?
        /// The rule version.
        /// This member is required.
        public var ruleVersion: Swift.String?

        public init(
            detectorId: Swift.String? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.detectorId = detectorId
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

public struct CreateDetectorVersionInput {
    /// The description of the detector version.
    public var description: Swift.String?
    /// The ID of the detector under which you want to create a new version.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The Amazon Sagemaker model endpoints to include in the detector version.
    public var externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode for the rules included in the detector version. You can define and edit the rule mode at the detector version level, when it is in draft status. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. The default behavior is FIRST_MATCHED.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public var rules: [FraudDetectorClientTypes.Rule]?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.tags = tags
    }
}

extension FraudDetectorClientTypes {

    public enum DetectorVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case draft
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorVersionStatus] {
            return [
                .active,
                .draft,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .draft: return "DRAFT"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDetectorVersionOutput {
    /// The ID for the created version's parent detector.
    public var detectorId: Swift.String?
    /// The ID for the created detector.
    public var detectorVersionId: Swift.String?
    /// The status of the detector version.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

public struct CreateListInput {
    /// The description of the list.
    public var description: Swift.String?
    /// The names of the elements, if providing. You can also create an empty list and add elements later using the [UpdateList](https://docs.aws.amazon.com/frauddetector/latest/api/API_Updatelist.html) API.
    public var elements: [Swift.String]?
    /// The name of the list.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of the key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The variable type of the list. You can only assign the variable type with String data type. For more information, see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
    public var variableType: Swift.String?

    public init(
        description: Swift.String? = nil,
        elements: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.description = description
        self.elements = elements
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

extension CreateListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateListInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), variableType: \(Swift.String(describing: variableType)), elements: \"CONTENT_REDACTED\")"}
}

public struct CreateListOutput {

    public init() { }
}

public struct CreateModelInput {
    /// The model description.
    public var description: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.eventTypeName = eventTypeName
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

public struct CreateModelOutput {

    public init() { }
}

extension FraudDetectorClientTypes {
    /// Details for the external events data used for model version training.
    public struct ExternalEventsDetail {
        /// The ARN of the role that provides Amazon Fraud Detector access to the data location.
        /// This member is required.
        public var dataAccessRoleArn: Swift.String?
        /// The Amazon S3 bucket location for the data.
        /// This member is required.
        public var dataLocation: Swift.String?

        public init(
            dataAccessRoleArn: Swift.String? = nil,
            dataLocation: Swift.String? = nil
        )
        {
            self.dataAccessRoleArn = dataAccessRoleArn
            self.dataLocation = dataLocation
        }
    }

}

extension FraudDetectorClientTypes {
    /// The start and stop time of the ingested events.
    public struct IngestedEventsTimeWindow {
        /// Timestamp of the final ingested event.
        /// This member is required.
        public var endTime: Swift.String?
        /// Timestamp of the first ingensted event.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension FraudDetectorClientTypes {
    /// The details of the ingested event.
    public struct IngestedEventsDetail {
        /// The start and stop time of the ingested events.
        /// This member is required.
        public var ingestedEventsTimeWindow: FraudDetectorClientTypes.IngestedEventsTimeWindow?

        public init(
            ingestedEventsTimeWindow: FraudDetectorClientTypes.IngestedEventsTimeWindow? = nil
        )
        {
            self.ingestedEventsTimeWindow = ingestedEventsTimeWindow
        }
    }

}

extension FraudDetectorClientTypes {

    public enum UnlabeledEventsTreatment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case fraud
        case ignore
        case legit
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlabeledEventsTreatment] {
            return [
                .auto,
                .fraud,
                .ignore,
                .legit
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .fraud: return "FRAUD"
            case .ignore: return "IGNORE"
            case .legit: return "LEGIT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The label schema.
    public struct LabelSchema {
        /// The label mapper maps the Amazon Fraud Detector supported model classification labels (FRAUD, LEGIT) to the appropriate event type labels. For example, if "FRAUD" and "LEGIT" are Amazon Fraud Detector supported labels, this mapper could be: {"FRAUD" => ["0"], "LEGIT" => ["1"]} or {"FRAUD" => ["false"], "LEGIT" => ["true"]} or {"FRAUD" => ["fraud", "abuse"], "LEGIT" => ["legit", "safe"]}. The value part of the mapper is a list, because you may have multiple label variants from your event type for a single Amazon Fraud Detector label.
        public var labelMapper: [Swift.String: [Swift.String]]?
        /// The action to take for unlabeled events.
        ///
        /// * Use IGNORE if you want the unlabeled events to be ignored. This is recommended when the majority of the events in the dataset are labeled.
        ///
        /// * Use FRAUD if you want to categorize all unlabeled events as “Fraud”. This is recommended when most of the events in your dataset are fraudulent.
        ///
        /// * Use LEGIT if you want to categorize all unlabeled events as “Legit”. This is recommended when most of the events in your dataset are legitimate.
        ///
        /// * Use AUTO if you want Amazon Fraud Detector to decide how to use the unlabeled data. This is recommended when there is significant unlabeled events in the dataset.
        ///
        ///
        /// By default, Amazon Fraud Detector ignores the unlabeled data.
        public var unlabeledEventsTreatment: FraudDetectorClientTypes.UnlabeledEventsTreatment?

        public init(
            labelMapper: [Swift.String: [Swift.String]]? = nil,
            unlabeledEventsTreatment: FraudDetectorClientTypes.UnlabeledEventsTreatment? = nil
        )
        {
            self.labelMapper = labelMapper
            self.unlabeledEventsTreatment = unlabeledEventsTreatment
        }
    }

}

extension FraudDetectorClientTypes {
    /// The training data schema.
    public struct TrainingDataSchema {
        /// The label schema.
        public var labelSchema: FraudDetectorClientTypes.LabelSchema?
        /// The training data schema variables.
        /// This member is required.
        public var modelVariables: [Swift.String]?

        public init(
            labelSchema: FraudDetectorClientTypes.LabelSchema? = nil,
            modelVariables: [Swift.String]? = nil
        )
        {
            self.labelSchema = labelSchema
            self.modelVariables = modelVariables
        }
    }

}

extension FraudDetectorClientTypes {

    public enum TrainingDataSourceEnum: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalEvents
        case ingestedEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [TrainingDataSourceEnum] {
            return [
                .externalEvents,
                .ingestedEvents
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalEvents: return "EXTERNAL_EVENTS"
            case .ingestedEvents: return "INGESTED_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateModelVersionInput {
    /// Details of the external events data used for model version training. Required if trainingDataSource is EXTERNAL_EVENTS.
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// Details of the ingested events data used for model version training. Required if trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The training data schema.
    /// This member is required.
    public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source location in Amazon S3.
    /// This member is required.
    public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init(
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

public struct CreateModelVersionOutput {
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version created.
    public var modelVersionNumber: Swift.String?
    /// The model version status.
    public var status: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

extension FraudDetectorClientTypes {

    public enum Language: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case detectorpl
        case sdkUnknown(Swift.String)

        public static var allCases: [Language] {
            return [
                .detectorpl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .detectorpl: return "DETECTORPL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateRuleInput {
    /// The rule description.
    public var description: Swift.String?
    /// The detector ID for the rule's parent detector.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The rule expression.
    /// This member is required.
    public var expression: Swift.String?
    /// The language of the rule.
    /// This member is required.
    public var language: FraudDetectorClientTypes.Language?
    /// The outcome or outcomes returned when the rule expression matches.
    /// This member is required.
    public var outcomes: [Swift.String]?
    /// The rule ID.
    /// This member is required.
    public var ruleId: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        ruleId: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.ruleId = ruleId
        self.tags = tags
    }
}

extension CreateRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRuleInput(description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), tags: \(Swift.String(describing: tags)), expression: \"CONTENT_REDACTED\")"}
}

public struct CreateRuleOutput {
    /// The created rule.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

public struct CreateVariableInput {
    /// The source of the data.
    /// This member is required.
    public var dataSource: FraudDetectorClientTypes.DataSource?
    /// The data type of the variable.
    /// This member is required.
    public var dataType: FraudDetectorClientTypes.DataType?
    /// The default value for the variable when no value is received.
    /// This member is required.
    public var defaultValue: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?
    /// The variable type. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types). Valid Values: AUTH_CODE | AVS | BILLING_ADDRESS_L1 | BILLING_ADDRESS_L2 | BILLING_CITY | BILLING_COUNTRY | BILLING_NAME | BILLING_PHONE | BILLING_STATE | BILLING_ZIP | CARD_BIN | CATEGORICAL | CURRENCY_CODE | EMAIL_ADDRESS | FINGERPRINT | FRAUD_LABEL | FREE_FORM_TEXT | IP_ADDRESS | NUMERIC | ORDER_ID | PAYMENT_TYPE | PHONE_NUMBER | PRICE | PRODUCT_CATEGORY | SHIPPING_ADDRESS_L1 | SHIPPING_ADDRESS_L2 | SHIPPING_CITY | SHIPPING_COUNTRY | SHIPPING_NAME | SHIPPING_PHONE | SHIPPING_STATE | SHIPPING_ZIP | USERAGENT
    public var variableType: Swift.String?

    public init(
        dataSource: FraudDetectorClientTypes.DataSource? = nil,
        dataType: FraudDetectorClientTypes.DataType? = nil,
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.dataSource = dataSource
        self.dataType = dataType
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.tags = tags
        self.variableType = variableType
    }
}

public struct CreateVariableOutput {

    public init() { }
}

public struct DeleteBatchImportJobInput {
    /// The ID of the batch import job to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DeleteBatchImportJobOutput {

    public init() { }
}

public struct DeleteBatchPredictionJobInput {
    /// The ID of the batch prediction job to delete.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DeleteBatchPredictionJobOutput {

    public init() { }
}

/// An exception indicating there was a conflict during a delete operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteDetectorInput {
    /// The ID of the detector to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

public struct DeleteDetectorOutput {

    public init() { }
}

public struct DeleteDetectorVersionInput {
    /// The ID of the parent detector for the detector version to delete.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The ID of the detector version to delete.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

public struct DeleteDetectorVersionOutput {

    public init() { }
}

public struct DeleteEntityTypeInput {
    /// The name of the entity type to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteEntityTypeOutput {

    public init() { }
}

public struct DeleteEventInput {
    /// Specifies whether or not to delete any predictions associated with the event. If set to True,
    public var deleteAuditHistory: Swift.Bool?
    /// The ID of the event to delete.
    /// This member is required.
    public var eventId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        deleteAuditHistory: Swift.Bool? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil
    )
    {
        self.deleteAuditHistory = deleteAuditHistory
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

public struct DeleteEventOutput {

    public init() { }
}

public struct DeleteEventsByEventTypeInput {
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
    }
}

public struct DeleteEventsByEventTypeOutput {
    /// Name of event type for which to delete the events.
    public var eventTypeName: Swift.String?
    /// The status of the delete request.
    public var eventsDeletionStatus: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil,
        eventsDeletionStatus: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.eventsDeletionStatus = eventsDeletionStatus
    }
}

public struct DeleteEventTypeInput {
    /// The name of the event type to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteEventTypeOutput {

    public init() { }
}

public struct DeleteExternalModelInput {
    /// The endpoint of the Amazon Sagemaker model to delete.
    /// This member is required.
    public var modelEndpoint: Swift.String?

    public init(
        modelEndpoint: Swift.String? = nil
    )
    {
        self.modelEndpoint = modelEndpoint
    }
}

public struct DeleteExternalModelOutput {

    public init() { }
}

public struct DeleteLabelInput {
    /// The name of the label to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteLabelOutput {

    public init() { }
}

public struct DeleteListInput {
    /// The name of the list to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteListOutput {

    public init() { }
}

public struct DeleteModelInput {
    /// The model ID of the model to delete.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type of the model to delete.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
    }
}

public struct DeleteModelOutput {

    public init() { }
}

public struct DeleteModelVersionInput {
    /// The model ID of the model version to delete.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type of the model version to delete.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version to delete.
    /// This member is required.
    public var modelVersionNumber: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

public struct DeleteModelVersionOutput {

    public init() { }
}

public struct DeleteOutcomeInput {
    /// The name of the outcome to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteOutcomeOutput {

    public init() { }
}

public struct DeleteRuleInput {
    /// A rule.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

public struct DeleteRuleOutput {

    public init() { }
}

public struct DeleteVariableInput {
    /// The name of the variable to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DeleteVariableOutput {

    public init() { }
}

public struct DescribeDetectorInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous response.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The summary of the detector version.
    public struct DetectorVersionSummary {
        /// The detector version description.
        public var description: Swift.String?
        /// The detector version ID.
        public var detectorVersionId: Swift.String?
        /// Timestamp of when the detector version was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The detector version status.
        public var status: FraudDetectorClientTypes.DetectorVersionStatus?

        public init(
            description: Swift.String? = nil,
            detectorVersionId: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
        )
        {
            self.description = description
            self.detectorVersionId = detectorVersionId
            self.lastUpdatedTime = lastUpdatedTime
            self.status = status
        }
    }

}

public struct DescribeDetectorOutput {
    /// The detector ARN.
    public var arn: Swift.String?
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The status and description for each detector version.
    public var detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]?
    /// The next token to be used for subsequent requests.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionSummaries: [FraudDetectorClientTypes.DetectorVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.detectorId = detectorId
        self.detectorVersionSummaries = detectorVersionSummaries
        self.nextToken = nextToken
    }
}

public struct DescribeModelVersionsInput {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public var modelVersionNumber: Swift.String?
    /// The next token from the previous results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FieldValidationMessage {
        /// The message content.
        public var content: Swift.String?
        /// The field name.
        public var fieldName: Swift.String?
        /// The message ID.
        public var identifier: Swift.String?
        /// The message title.
        public var title: Swift.String?
        /// The message type.
        public var type: Swift.String?

        public init(
            content: Swift.String? = nil,
            fieldName: Swift.String? = nil,
            identifier: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.fieldName = fieldName
            self.identifier = identifier
            self.title = title
            self.type = type
        }
    }

}

extension FraudDetectorClientTypes {
    /// The message details.
    public struct FileValidationMessage {
        /// The message content.
        public var content: Swift.String?
        /// The message title.
        public var title: Swift.String?
        /// The message type.
        public var type: Swift.String?

        public init(
            content: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.content = content
            self.title = title
            self.type = type
        }
    }

}

extension FraudDetectorClientTypes {
    /// The model training data validation metrics.
    public struct DataValidationMetrics {
        /// The field-specific model training validation messages.
        public var fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]?
        /// The file-specific model training data validation messages.
        public var fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]?

        public init(
            fieldLevelMessages: [FraudDetectorClientTypes.FieldValidationMessage]? = nil,
            fileLevelMessages: [FraudDetectorClientTypes.FileValidationMessage]? = nil
        )
        {
            self.fieldLevelMessages = fieldLevelMessages
            self.fileLevelMessages = fileLevelMessages
        }
    }

}

extension FraudDetectorClientTypes {
    /// Model performance metrics data points.
    public struct MetricDataPoint {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes {
    /// The training metric details.
    public struct TrainingMetrics {
        /// The area under the curve. This summarizes true positive rate (TPR) and false positive rate (FPR) across all possible model score thresholds. A model with no predictive power has an AUC of 0.5, whereas a perfect model has a score of 1.0.
        public var auc: Swift.Float?
        /// The data points details.
        public var metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]?

        public init(
            auc: Swift.Float? = nil,
            metricDataPoints: [FraudDetectorClientTypes.MetricDataPoint]? = nil
        )
        {
            self.auc = auc
            self.metricDataPoints = metricDataPoints
        }
    }

}

extension FraudDetectorClientTypes {
    /// The log odds metric details.
    public struct LogOddsMetric {
        /// The relative importance of the variable. For more information, see [Model variable importance](https://docs.aws.amazon.com/frauddetector/latest/ug/model-variable-importance.html).
        /// This member is required.
        public var variableImportance: Swift.Float?
        /// The name of the variable.
        /// This member is required.
        public var variableName: Swift.String?
        /// The type of variable.
        /// This member is required.
        public var variableType: Swift.String?

        public init(
            variableImportance: Swift.Float? = nil,
            variableName: Swift.String? = nil,
            variableType: Swift.String? = nil
        )
        {
            self.variableImportance = variableImportance
            self.variableName = variableName
            self.variableType = variableType
        }
    }

}

extension FraudDetectorClientTypes {
    /// The variable importance metrics details.
    public struct VariableImportanceMetrics {
        /// List of variable metrics.
        public var logOddsMetrics: [FraudDetectorClientTypes.LogOddsMetric]?

        public init(
            logOddsMetrics: [FraudDetectorClientTypes.LogOddsMetric]? = nil
        )
        {
            self.logOddsMetrics = logOddsMetrics
        }
    }

}

extension FraudDetectorClientTypes {
    /// The training result details.
    public struct TrainingResult {
        /// The validation metrics.
        public var dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics?
        /// The training metric details.
        public var trainingMetrics: FraudDetectorClientTypes.TrainingMetrics?
        /// The variable importance metrics.
        public var variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics?

        public init(
            dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics? = nil,
            trainingMetrics: FraudDetectorClientTypes.TrainingMetrics? = nil,
            variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics? = nil
        )
        {
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetrics = trainingMetrics
            self.variableImportanceMetrics = variableImportanceMetrics
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model performance metrics data points.
    public struct OFIMetricDataPoint {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes {
    /// Range of area under curve (auc) expected from the model. A range greater than 0.1 indicates higher model uncertainity. A range is the difference between upper and lower bound of auc.
    public struct UncertaintyRange {
        /// The lower bound value of the area under curve (auc).
        /// This member is required.
        public var lowerBoundValue: Swift.Float?
        /// The upper bound value of the area under curve (auc).
        /// This member is required.
        public var upperBoundValue: Swift.Float?

        public init(
            lowerBoundValue: Swift.Float? = nil,
            upperBoundValue: Swift.Float? = nil
        )
        {
            self.lowerBoundValue = lowerBoundValue
            self.upperBoundValue = upperBoundValue
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model performance score.
    public struct OFIModelPerformance {
        /// The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public var auc: Swift.Float?
        /// Indicates the range of area under curve (auc) expected from the OFI model. A range greater than 0.1 indicates higher model uncertainity.
        public var uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange?

        public init(
            auc: Swift.Float? = nil,
            uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange? = nil
        )
        {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Online Fraud Insights (OFI) model training metric details.
    public struct OFITrainingMetricsValue {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.OFIMetricDataPoint]?
        /// The model's overall performance score.
        public var modelPerformance: FraudDetectorClientTypes.OFIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.OFIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.OFIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

extension FraudDetectorClientTypes {
    /// The performance metrics data points for Transaction Fraud Insights (TFI) model.
    public struct TFIMetricDataPoint {
        /// The false positive rate. This is the percentage of total legitimate events that are incorrectly predicted as fraud.
        public var fpr: Swift.Float?
        /// The percentage of fraud events correctly predicted as fraudulent as compared to all events predicted as fraudulent.
        public var precision: Swift.Float?
        /// The model threshold that specifies an acceptable fraud capture rate. For example, a threshold of 500 means any model score 500 or above is labeled as fraud.
        public var threshold: Swift.Float?
        /// The true positive rate. This is the percentage of total fraud the model detects. Also known as capture rate.
        public var tpr: Swift.Float?

        public init(
            fpr: Swift.Float? = nil,
            precision: Swift.Float? = nil,
            threshold: Swift.Float? = nil,
            tpr: Swift.Float? = nil
        )
        {
            self.fpr = fpr
            self.precision = precision
            self.threshold = threshold
            self.tpr = tpr
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Transaction Fraud Insights (TFI) model performance score.
    public struct TFIModelPerformance {
        /// The area under the curve (auc). This summarizes the total positive rate (tpr) and false positive rate (FPR) across all possible model score thresholds.
        public var auc: Swift.Float?
        /// Indicates the range of area under curve (auc) expected from the TFI model. A range greater than 0.1 indicates higher model uncertainity.
        public var uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange?

        public init(
            auc: Swift.Float? = nil,
            uncertaintyRange: FraudDetectorClientTypes.UncertaintyRange? = nil
        )
        {
            self.auc = auc
            self.uncertaintyRange = uncertaintyRange
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Transaction Fraud Insights (TFI) model training metric details.
    public struct TFITrainingMetricsValue {
        /// The model's performance metrics data points.
        public var metricDataPoints: [FraudDetectorClientTypes.TFIMetricDataPoint]?
        /// The model performance score.
        public var modelPerformance: FraudDetectorClientTypes.TFIModelPerformance?

        public init(
            metricDataPoints: [FraudDetectorClientTypes.TFIMetricDataPoint]? = nil,
            modelPerformance: FraudDetectorClientTypes.TFIModelPerformance? = nil
        )
        {
            self.metricDataPoints = metricDataPoints
            self.modelPerformance = modelPerformance
        }
    }

}

extension FraudDetectorClientTypes {
    /// The training metrics details.
    public struct TrainingMetricsV2 {
        /// The Account Takeover Insights (ATI) model training metric details.
        public var ati: FraudDetectorClientTypes.ATITrainingMetricsValue?
        /// The Online Fraud Insights (OFI) model training metric details.
        public var ofi: FraudDetectorClientTypes.OFITrainingMetricsValue?
        /// The Transaction Fraud Insights (TFI) model training metric details.
        public var tfi: FraudDetectorClientTypes.TFITrainingMetricsValue?

        public init(
            ati: FraudDetectorClientTypes.ATITrainingMetricsValue? = nil,
            ofi: FraudDetectorClientTypes.OFITrainingMetricsValue? = nil,
            tfi: FraudDetectorClientTypes.TFITrainingMetricsValue? = nil
        )
        {
            self.ati = ati
            self.ofi = ofi
            self.tfi = tfi
        }
    }

}

extension FraudDetectorClientTypes {
    /// The training result details.
    public struct TrainingResultV2 {
        /// The variable importance metrics of the aggregated variables. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
        public var aggregatedVariablesImportanceMetrics: FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics?
        /// The model training data validation metrics.
        public var dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics?
        /// The training metric details.
        public var trainingMetricsV2: FraudDetectorClientTypes.TrainingMetricsV2?
        /// The variable importance metrics details.
        public var variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics?

        public init(
            aggregatedVariablesImportanceMetrics: FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics? = nil,
            dataValidationMetrics: FraudDetectorClientTypes.DataValidationMetrics? = nil,
            trainingMetricsV2: FraudDetectorClientTypes.TrainingMetricsV2? = nil,
            variableImportanceMetrics: FraudDetectorClientTypes.VariableImportanceMetrics? = nil
        )
        {
            self.aggregatedVariablesImportanceMetrics = aggregatedVariablesImportanceMetrics
            self.dataValidationMetrics = dataValidationMetrics
            self.trainingMetricsV2 = trainingMetricsV2
            self.variableImportanceMetrics = variableImportanceMetrics
        }
    }

}

extension FraudDetectorClientTypes {
    /// The details of the model version.
    public struct ModelVersionDetail {
        /// The model version ARN.
        public var arn: Swift.String?
        /// The timestamp when the model was created.
        public var createdTime: Swift.String?
        /// The external events data details. This will be populated if the trainingDataSource for the model version is specified as EXTERNAL_EVENTS.
        public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
        /// The ingested events data details. This will be populated if the trainingDataSource for the model version is specified as INGESTED_EVENTS.
        public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
        /// The timestamp when the model was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
        /// The model version number.
        public var modelVersionNumber: Swift.String?
        /// The status of the model version.
        public var status: Swift.String?
        /// The training data schema.
        public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
        /// The model version training data source.
        public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?
        /// The training results.
        public var trainingResult: FraudDetectorClientTypes.TrainingResult?
        /// The training result details. The details include the relative importance of the variables.
        public var trainingResultV2: FraudDetectorClientTypes.TrainingResultV2?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
            ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
            modelVersionNumber: Swift.String? = nil,
            status: Swift.String? = nil,
            trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
            trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil,
            trainingResult: FraudDetectorClientTypes.TrainingResult? = nil,
            trainingResultV2: FraudDetectorClientTypes.TrainingResultV2? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.externalEventsDetail = externalEventsDetail
            self.ingestedEventsDetail = ingestedEventsDetail
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersionNumber = modelVersionNumber
            self.status = status
            self.trainingDataSchema = trainingDataSchema
            self.trainingDataSource = trainingDataSource
            self.trainingResult = trainingResult
            self.trainingResultV2 = trainingResultV2
        }
    }

}

public struct DescribeModelVersionsOutput {
    /// The model version details.
    public var modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]?
    /// The next token.
    public var nextToken: Swift.String?

    public init(
        modelVersionDetails: [FraudDetectorClientTypes.ModelVersionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.modelVersionDetails = modelVersionDetails
        self.nextToken = nextToken
    }
}

public struct GetBatchImportJobsInput {
    /// The ID of the batch import job to get.
    public var jobId: Swift.String?
    /// The maximum number of objects to return for request.
    public var maxResults: Swift.Int?
    /// The next token from the previous request.
    public var nextToken: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The batch import job details.
    public struct BatchImport {
        /// The ARN of the batch import job.
        public var arn: Swift.String?
        /// Timestamp of when batch import job completed.
        public var completionTime: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// The number of records that failed to import.
        public var failedRecordsCount: Swift.Int?
        /// The reason batch import job failed.
        public var failureReason: Swift.String?
        /// The ARN of the IAM role to use for this job request.
        public var iamRoleArn: Swift.String?
        /// The Amazon S3 location of your data file for batch import.
        public var inputPath: Swift.String?
        /// The ID of the batch import job.
        public var jobId: Swift.String?
        /// The Amazon S3 location of your output file.
        public var outputPath: Swift.String?
        /// The number of records processed by batch import job.
        public var processedRecordsCount: Swift.Int?
        /// Timestamp of when the batch import job started.
        public var startTime: Swift.String?
        /// The status of the batch import job.
        public var status: FraudDetectorClientTypes.AsyncJobStatus?
        /// The total number of records in the batch import job.
        public var totalRecordsCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            completionTime: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            failedRecordsCount: Swift.Int? = nil,
            failureReason: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            jobId: Swift.String? = nil,
            outputPath: Swift.String? = nil,
            processedRecordsCount: Swift.Int? = nil,
            startTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.AsyncJobStatus? = nil,
            totalRecordsCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.completionTime = completionTime
            self.eventTypeName = eventTypeName
            self.failedRecordsCount = failedRecordsCount
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }
    }

}

public struct GetBatchImportJobsOutput {
    /// An array containing the details of each batch import job.
    public var batchImports: [FraudDetectorClientTypes.BatchImport]?
    /// The next token for the subsequent resquest.
    public var nextToken: Swift.String?

    public init(
        batchImports: [FraudDetectorClientTypes.BatchImport]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchImports = batchImports
        self.nextToken = nextToken
    }
}

public struct GetBatchPredictionJobsInput {
    /// The batch prediction job for which to get the details.
    public var jobId: Swift.String?
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous request.
    public var nextToken: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The batch prediction details.
    public struct BatchPrediction {
        /// The ARN of batch prediction job.
        public var arn: Swift.String?
        /// Timestamp of when the batch prediction job completed.
        public var completionTime: Swift.String?
        /// The name of the detector.
        public var detectorName: Swift.String?
        /// The detector version.
        public var detectorVersion: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// The reason a batch prediction job failed.
        public var failureReason: Swift.String?
        /// The ARN of the IAM role to use for this job request.
        public var iamRoleArn: Swift.String?
        /// The Amazon S3 location of your training file.
        public var inputPath: Swift.String?
        /// The job ID for the batch prediction.
        public var jobId: Swift.String?
        /// Timestamp of most recent heartbeat indicating the batch prediction job was making progress.
        public var lastHeartbeatTime: Swift.String?
        /// The Amazon S3 location of your output file.
        public var outputPath: Swift.String?
        /// The number of records processed by the batch prediction job.
        public var processedRecordsCount: Swift.Int?
        /// Timestamp of when the batch prediction job started.
        public var startTime: Swift.String?
        /// The batch prediction status.
        public var status: FraudDetectorClientTypes.AsyncJobStatus?
        /// The total number of records in the batch prediction job.
        public var totalRecordsCount: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            completionTime: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorVersion: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil,
            inputPath: Swift.String? = nil,
            jobId: Swift.String? = nil,
            lastHeartbeatTime: Swift.String? = nil,
            outputPath: Swift.String? = nil,
            processedRecordsCount: Swift.Int? = nil,
            startTime: Swift.String? = nil,
            status: FraudDetectorClientTypes.AsyncJobStatus? = nil,
            totalRecordsCount: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.completionTime = completionTime
            self.detectorName = detectorName
            self.detectorVersion = detectorVersion
            self.eventTypeName = eventTypeName
            self.failureReason = failureReason
            self.iamRoleArn = iamRoleArn
            self.inputPath = inputPath
            self.jobId = jobId
            self.lastHeartbeatTime = lastHeartbeatTime
            self.outputPath = outputPath
            self.processedRecordsCount = processedRecordsCount
            self.startTime = startTime
            self.status = status
            self.totalRecordsCount = totalRecordsCount
        }
    }

}

public struct GetBatchPredictionJobsOutput {
    /// An array containing the details of each batch prediction job.
    public var batchPredictions: [FraudDetectorClientTypes.BatchPrediction]?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        batchPredictions: [FraudDetectorClientTypes.BatchPrediction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.batchPredictions = batchPredictions
        self.nextToken = nextToken
    }
}

public struct GetDeleteEventsByEventTypeStatusInput {
    /// Name of event type for which to get the deletion status.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventTypeName = eventTypeName
    }
}

public struct GetDeleteEventsByEventTypeStatusOutput {
    /// The event type name.
    public var eventTypeName: Swift.String?
    /// The deletion status.
    public var eventsDeletionStatus: FraudDetectorClientTypes.AsyncJobStatus?

    public init(
        eventTypeName: Swift.String? = nil,
        eventsDeletionStatus: FraudDetectorClientTypes.AsyncJobStatus? = nil
    )
    {
        self.eventTypeName = eventTypeName
        self.eventsDeletionStatus = eventsDeletionStatus
    }
}

public struct GetDetectorsInput {
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The detector.
    public struct Detector {
        /// The detector ARN.
        public var arn: Swift.String?
        /// Timestamp of when the detector was created.
        public var createdTime: Swift.String?
        /// The detector description.
        public var description: Swift.String?
        /// The detector ID.
        public var detectorId: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// Timestamp of when the detector was last updated.
        public var lastUpdatedTime: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
        }
    }

}

public struct GetDetectorsOutput {
    /// The detectors.
    public var detectors: [FraudDetectorClientTypes.Detector]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        detectors: [FraudDetectorClientTypes.Detector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectors = detectors
        self.nextToken = nextToken
    }
}

public struct GetDetectorVersionInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

public struct GetDetectorVersionOutput {
    /// The detector version ARN.
    public var arn: Swift.String?
    /// The timestamp when the detector version was created.
    public var createdTime: Swift.String?
    /// The detector version description.
    public var description: Swift.String?
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints included in the detector version.
    public var externalModelEndpoints: [Swift.String]?
    /// The timestamp when the detector version was last updated.
    public var lastUpdatedTime: Swift.String?
    /// The model versions included in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The execution mode of the rule in the dectector FIRST_MATCHED indicates that Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. ALL_MATCHED indicates that Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules included in the detector version.
    public var rules: [FraudDetectorClientTypes.Rule]?
    /// The status of the detector version.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        arn: Swift.String? = nil,
        createdTime: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        lastUpdatedTime: Swift.String? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.arn = arn
        self.createdTime = createdTime
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.lastUpdatedTime = lastUpdatedTime
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
        self.status = status
    }
}

public struct GetEntityTypesInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The entity type details.
    public struct EntityType {
        /// The entity type ARN.
        public var arn: Swift.String?
        /// Timestamp of when the entity type was created.
        public var createdTime: Swift.String?
        /// The entity type description.
        public var description: Swift.String?
        /// Timestamp of when the entity type was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The entity type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

public struct GetEntityTypesOutput {
    /// An array of entity types.
    public var entityTypes: [FraudDetectorClientTypes.EntityType]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        entityTypes: [FraudDetectorClientTypes.EntityType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entityTypes = entityTypes
        self.nextToken = nextToken
    }
}

public struct GetEventInput {
    /// The ID of the event to retrieve.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type of the event to retrieve.
    /// This member is required.
    public var eventTypeName: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil
    )
    {
        self.eventId = eventId
        self.eventTypeName = eventTypeName
    }
}

extension FraudDetectorClientTypes {
    /// The entity details.
    public struct Entity {
        /// The entity ID. If you do not know the entityId, you can pass unknown, which is areserved string literal.
        /// This member is required.
        public var entityId: Swift.String?
        /// The entity type.
        /// This member is required.
        public var entityType: Swift.String?

        public init(
            entityId: Swift.String? = nil,
            entityType: Swift.String? = nil
        )
        {
            self.entityId = entityId
            self.entityType = entityType
        }
    }

}

extension FraudDetectorClientTypes.Entity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension FraudDetectorClientTypes {
    /// The event details.
    public struct Event {
        /// The label associated with the event.
        public var currentLabel: Swift.String?
        /// The event entities.
        public var entities: [FraudDetectorClientTypes.Entity]?
        /// The event ID.
        public var eventId: Swift.String?
        /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
        public var eventTimestamp: Swift.String?
        /// The event type.
        public var eventTypeName: Swift.String?
        /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
        public var eventVariables: [Swift.String: Swift.String]?
        /// The timestamp associated with the label to update. The timestamp must be specified using ISO 8601 standard in UTC.
        public var labelTimestamp: Swift.String?

        public init(
            currentLabel: Swift.String? = nil,
            entities: [FraudDetectorClientTypes.Entity]? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            eventVariables: [Swift.String: Swift.String]? = nil,
            labelTimestamp: Swift.String? = nil
        )
        {
            self.currentLabel = currentLabel
            self.entities = entities
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.eventVariables = eventVariables
            self.labelTimestamp = labelTimestamp
        }
    }

}

extension FraudDetectorClientTypes.Event: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Event(currentLabel: \(Swift.String(describing: currentLabel)), eventId: \(Swift.String(describing: eventId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventTypeName: \(Swift.String(describing: eventTypeName)), labelTimestamp: \(Swift.String(describing: labelTimestamp)), entities: \"CONTENT_REDACTED\", eventVariables: [keys: \(Swift.String(describing: eventVariables?.keys)), values: \"CONTENT_REDACTED\"])"}
}

public struct GetEventOutput {
    /// The details of the event.
    public var event: FraudDetectorClientTypes.Event?

    public init(
        event: FraudDetectorClientTypes.Event? = nil
    )
    {
        self.event = event
    }
}

/// An exception indicating that the attached customer-owned (external) model threw an exception when Amazon Fraud Detector invoked the model.
public struct ResourceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension FraudDetectorClientTypes {
    /// A pre-formed Amazon SageMaker model input you can include if your detector version includes an imported Amazon SageMaker model endpoint with pass-through input configuration.
    public struct ModelEndpointDataBlob {
        /// The byte buffer of the Amazon SageMaker model endpoint input data blob.
        public var byteBuffer: Foundation.Data?
        /// The content type of the Amazon SageMaker model endpoint input data blob.
        public var contentType: Swift.String?

        public init(
            byteBuffer: Foundation.Data? = nil,
            contentType: Swift.String? = nil
        )
        {
            self.byteBuffer = byteBuffer
            self.contentType = contentType
        }
    }

}

public struct GetEventPredictionInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The entity type (associated with the detector's event type) and specific entity ID representing who performed the event. If an entity id is not available, use "UNKNOWN."
    /// This member is required.
    public var entities: [FraudDetectorClientTypes.Entity]?
    /// The unique ID used to identify the event.
    /// This member is required.
    public var eventId: Swift.String?
    /// Timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var eventTimestamp: Swift.String?
    /// The event type associated with the detector specified for the prediction.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation. You must provide at least one eventVariable To ensure most accurate fraud prediction and to simplify your data preparation, Amazon Fraud Detector will replace all missing variables or values as follows: For Amazon Fraud Detector trained models: If a null value is provided explicitly for a variable or if a variable is missing, model will replace the null value or the missing variable (no variable name in the eventVariables map) with calculated default mean/medians for numeric variables and with special values for categorical variables. For imported SageMaker models: If a null value is provided explicitly for a variable, the model and rules will use “null” as the value. If a variable is not provided (no variable name in the eventVariables map), model and rules will use the default value that is provided for the variable.
    /// This member is required.
    public var eventVariables: [Swift.String: Swift.String]?
    /// The Amazon SageMaker model endpoint input data blobs.
    public var externalModelEndpointDataBlobs: [Swift.String: FraudDetectorClientTypes.ModelEndpointDataBlob]?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        entities: [FraudDetectorClientTypes.Entity]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [Swift.String: Swift.String]? = nil,
        externalModelEndpointDataBlobs: [Swift.String: FraudDetectorClientTypes.ModelEndpointDataBlob]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.externalModelEndpointDataBlobs = externalModelEndpointDataBlobs
    }
}

extension GetEventPredictionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventPredictionInput(detectorId: \(Swift.String(describing: detectorId)), detectorVersionId: \(Swift.String(describing: detectorVersionId)), eventId: \(Swift.String(describing: eventId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventTypeName: \(Swift.String(describing: eventTypeName)), entities: \"CONTENT_REDACTED\", eventVariables: [keys: \(Swift.String(describing: eventVariables?.keys)), values: \"CONTENT_REDACTED\"], externalModelEndpointDataBlobs: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {

    public enum ModelSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelSource] {
            return [
                .sagemaker
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model.
    public struct ExternalModelSummary {
        /// The endpoint of the Amazon SageMaker model.
        public var modelEndpoint: Swift.String?
        /// The source of the model.
        public var modelSource: FraudDetectorClientTypes.ModelSource?

        public init(
            modelEndpoint: Swift.String? = nil,
            modelSource: FraudDetectorClientTypes.ModelSource? = nil
        )
        {
            self.modelEndpoint = modelEndpoint
            self.modelSource = modelSource
        }
    }

}

extension FraudDetectorClientTypes {
    /// The fraud prediction scores from Amazon SageMaker model.
    public struct ExternalModelOutputs {
        /// The Amazon SageMaker model.
        public var externalModel: FraudDetectorClientTypes.ExternalModelSummary?
        /// The fraud prediction scores from Amazon SageMaker model.
        public var outputs: [Swift.String: Swift.String]?

        public init(
            externalModel: FraudDetectorClientTypes.ExternalModelSummary? = nil,
            outputs: [Swift.String: Swift.String]? = nil
        )
        {
            self.externalModel = externalModel
            self.outputs = outputs
        }
    }

}

extension FraudDetectorClientTypes {
    /// The fraud prediction scores.
    public struct ModelScores {
        /// The model version.
        public var modelVersion: FraudDetectorClientTypes.ModelVersion?
        /// The model's fraud prediction scores.
        public var scores: [Swift.String: Swift.Float]?

        public init(
            modelVersion: FraudDetectorClientTypes.ModelVersion? = nil,
            scores: [Swift.String: Swift.Float]? = nil
        )
        {
            self.modelVersion = modelVersion
            self.scores = scores
        }
    }

}

extension FraudDetectorClientTypes {
    /// The rule results.
    public struct RuleResult {
        /// The outcomes of the matched rule, based on the rule execution mode.
        public var outcomes: [Swift.String]?
        /// The rule ID that was matched, based on the rule execution mode.
        public var ruleId: Swift.String?

        public init(
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil
        )
        {
            self.outcomes = outcomes
            self.ruleId = ruleId
        }
    }

}

public struct GetEventPredictionOutput {
    /// The model scores for Amazon SageMaker models.
    public var externalModelOutputs: [FraudDetectorClientTypes.ExternalModelOutputs]?
    /// The model scores. Amazon Fraud Detector generates model scores between 0 and 1000, where 0 is low fraud risk and 1000 is high fraud risk. Model scores are directly related to the false positive rate (FPR). For example, a score of 600 corresponds to an estimated 10% false positive rate whereas a score of 900 corresponds to an estimated 2% false positive rate.
    public var modelScores: [FraudDetectorClientTypes.ModelScores]?
    /// The results from the rules.
    public var ruleResults: [FraudDetectorClientTypes.RuleResult]?

    public init(
        externalModelOutputs: [FraudDetectorClientTypes.ExternalModelOutputs]? = nil,
        modelScores: [FraudDetectorClientTypes.ModelScores]? = nil,
        ruleResults: [FraudDetectorClientTypes.RuleResult]? = nil
    )
    {
        self.externalModelOutputs = externalModelOutputs
        self.modelScores = modelScores
        self.ruleResults = ruleResults
    }
}

public struct GetEventPredictionMetadataInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The event ID.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type associated with the detector specified for the prediction.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The timestamp that defines when the prediction was generated. The timestamp must be specified using ISO 8601 standard in UTC. We recommend calling [ListEventPredictions](https://docs.aws.amazon.com/frauddetector/latest/api/API_ListEventPredictions.html) first, and using the predictionTimestamp value in the response to provide an accurate prediction timestamp value.
    /// This member is required.
    public var predictionTimestamp: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        predictionTimestamp: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.eventId = eventId
        self.eventTypeName = eventTypeName
        self.predictionTimestamp = predictionTimestamp
    }
}

extension FraudDetectorClientTypes {
    /// The details of the external (Amazon Sagemaker) model evaluated for generating predictions.
    public struct EvaluatedExternalModel {
        /// Input variables use for generating predictions.
        public var inputVariables: [Swift.String: Swift.String]?
        /// The endpoint of the external (Amazon Sagemaker) model.
        public var modelEndpoint: Swift.String?
        /// Output variables.
        public var outputVariables: [Swift.String: Swift.String]?
        /// Indicates whether event variables were used to generate predictions.
        public var useEventVariables: Swift.Bool?

        public init(
            inputVariables: [Swift.String: Swift.String]? = nil,
            modelEndpoint: Swift.String? = nil,
            outputVariables: [Swift.String: Swift.String]? = nil,
            useEventVariables: Swift.Bool? = nil
        )
        {
            self.inputVariables = inputVariables
            self.modelEndpoint = modelEndpoint
            self.outputVariables = outputVariables
            self.useEventVariables = useEventVariables
        }
    }

}

extension FraudDetectorClientTypes.EvaluatedExternalModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluatedExternalModel(modelEndpoint: \(Swift.String(describing: modelEndpoint)), useEventVariables: \(Swift.String(describing: useEventVariables)), inputVariables: \"CONTENT_REDACTED\", outputVariables: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// The details of the event variable's impact on the prediction score.
    public struct VariableImpactExplanation {
        /// The event variable name.
        public var eventVariableName: Swift.String?
        /// The raw, uninterpreted value represented as log-odds of the fraud. These values are usually between -10 to +10, but range from - infinity to + infinity.
        ///
        /// * A positive value indicates that the variable drove the risk score up.
        ///
        /// * A negative value indicates that the variable drove the risk score down.
        public var logOddsImpact: Swift.Float?
        /// The event variable's relative impact in terms of magnitude on the prediction scores. The relative impact values consist of a numerical rating (0-5, 5 being the highest) and direction (increased/decreased) impact of the fraud risk.
        public var relativeImpact: Swift.String?

        public init(
            eventVariableName: Swift.String? = nil,
            logOddsImpact: Swift.Float? = nil,
            relativeImpact: Swift.String? = nil
        )
        {
            self.eventVariableName = eventVariableName
            self.logOddsImpact = logOddsImpact
            self.relativeImpact = relativeImpact
        }
    }

}

extension FraudDetectorClientTypes {
    /// The prediction explanations that provide insight into how each event variable impacted the model version's fraud prediction score.
    public struct PredictionExplanations {
        /// The details of the aggregated variables impact on the prediction score. Account Takeover Insights (ATI) model uses event variables from the login data you provide to continuously calculate a set of variables (aggregated variables) based on historical events. For example, your ATI model might calculate the number of times an user has logged in using the same IP address. In this case, event variables used to derive the aggregated variables are IP address and user.
        public var aggregatedVariablesImpactExplanations: [FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]?
        /// The details of the event variable's impact on the prediction score.
        public var variableImpactExplanations: [FraudDetectorClientTypes.VariableImpactExplanation]?

        public init(
            aggregatedVariablesImpactExplanations: [FraudDetectorClientTypes.AggregatedVariablesImpactExplanation]? = nil,
            variableImpactExplanations: [FraudDetectorClientTypes.VariableImpactExplanation]? = nil
        )
        {
            self.aggregatedVariablesImpactExplanations = aggregatedVariablesImpactExplanations
            self.variableImpactExplanations = variableImpactExplanations
        }
    }

}

extension FraudDetectorClientTypes {
    /// The model version evalutions.
    public struct ModelVersionEvaluation {
        /// The evaluation score generated for the model version.
        public var evaluationScore: Swift.String?
        /// The output variable name.
        public var outputVariableName: Swift.String?
        /// The prediction explanations generated for the model version.
        public var predictionExplanations: FraudDetectorClientTypes.PredictionExplanations?

        public init(
            evaluationScore: Swift.String? = nil,
            outputVariableName: Swift.String? = nil,
            predictionExplanations: FraudDetectorClientTypes.PredictionExplanations? = nil
        )
        {
            self.evaluationScore = evaluationScore
            self.outputVariableName = outputVariableName
            self.predictionExplanations = predictionExplanations
        }
    }

}

extension FraudDetectorClientTypes {
    /// The model version evaluated for generating prediction.
    public struct EvaluatedModelVersion {
        /// Evaluations generated for the model version.
        public var evaluations: [FraudDetectorClientTypes.ModelVersionEvaluation]?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type. Valid values: ONLINE_FRAUD_INSIGHTS | TRANSACTION_FRAUD_INSIGHTS
        public var modelType: Swift.String?
        /// The model version.
        public var modelVersion: Swift.String?

        public init(
            evaluations: [FraudDetectorClientTypes.ModelVersionEvaluation]? = nil,
            modelId: Swift.String? = nil,
            modelType: Swift.String? = nil,
            modelVersion: Swift.String? = nil
        )
        {
            self.evaluations = evaluations
            self.modelId = modelId
            self.modelType = modelType
            self.modelVersion = modelVersion
        }
    }

}

extension FraudDetectorClientTypes {
    /// Information about the summary of an event variable that was evaluated for generating prediction.
    public struct EventVariableSummary {
        /// The event variable name.
        public var name: Swift.String?
        /// The event variable source.
        public var source: Swift.String?
        /// The value of the event variable.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            source: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.source = source
            self.value = value
        }
    }

}

extension FraudDetectorClientTypes.EventVariableSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EventVariableSummary(name: \"CONTENT_REDACTED\", source: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension FraudDetectorClientTypes {
    /// The details of the rule used for evaluating variable values.
    public struct EvaluatedRule {
        /// Indicates whether the rule was evaluated.
        public var evaluated: Swift.Bool?
        /// The rule expression.
        public var expression: Swift.String?
        /// The rule expression value.
        public var expressionWithValues: Swift.String?
        /// Indicates whether the rule matched.
        public var matched: Swift.Bool?
        /// The rule outcome.
        public var outcomes: [Swift.String]?
        /// The rule ID.
        public var ruleId: Swift.String?
        /// The rule version.
        public var ruleVersion: Swift.String?

        public init(
            evaluated: Swift.Bool? = nil,
            expression: Swift.String? = nil,
            expressionWithValues: Swift.String? = nil,
            matched: Swift.Bool? = nil,
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.evaluated = evaluated
            self.expression = expression
            self.expressionWithValues = expressionWithValues
            self.matched = matched
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes.EvaluatedRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EvaluatedRule(evaluated: \(Swift.String(describing: evaluated)), matched: \(Swift.String(describing: matched)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)), expression: \"CONTENT_REDACTED\", expressionWithValues: \"CONTENT_REDACTED\")"}
}

public struct GetEventPredictionMetadataOutput {
    /// The detector ID.
    public var detectorId: Swift.String?
    /// The detector version ID.
    public var detectorVersionId: Swift.String?
    /// The status of the detector version.
    public var detectorVersionStatus: Swift.String?
    /// The entity ID.
    public var entityId: Swift.String?
    /// The entity type.
    public var entityType: Swift.String?
    /// External (Amazon SageMaker) models that were evaluated for generating predictions.
    public var evaluatedExternalModels: [FraudDetectorClientTypes.EvaluatedExternalModel]?
    /// Model versions that were evaluated for generating predictions.
    public var evaluatedModelVersions: [FraudDetectorClientTypes.EvaluatedModelVersion]?
    /// The event ID.
    public var eventId: Swift.String?
    /// The timestamp for when the prediction was generated for the associated event ID.
    public var eventTimestamp: Swift.String?
    /// The event type associated with the detector specified for this prediction.
    public var eventTypeName: Swift.String?
    /// A list of event variables that influenced the prediction scores.
    public var eventVariables: [FraudDetectorClientTypes.EventVariableSummary]?
    /// The outcomes of the matched rule, based on the rule execution mode.
    public var outcomes: [Swift.String]?
    /// The timestamp that defines when the prediction was generated.
    public var predictionTimestamp: Swift.String?
    /// The execution mode of the rule used for evaluating variable values.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// List of rules associated with the detector version that were used for evaluating variable values.
    public var rules: [FraudDetectorClientTypes.EvaluatedRule]?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        detectorVersionStatus: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityType: Swift.String? = nil,
        evaluatedExternalModels: [FraudDetectorClientTypes.EvaluatedExternalModel]? = nil,
        evaluatedModelVersions: [FraudDetectorClientTypes.EvaluatedModelVersion]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [FraudDetectorClientTypes.EventVariableSummary]? = nil,
        outcomes: [Swift.String]? = nil,
        predictionTimestamp: Swift.String? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.EvaluatedRule]? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.detectorVersionStatus = detectorVersionStatus
        self.entityId = entityId
        self.entityType = entityType
        self.evaluatedExternalModels = evaluatedExternalModels
        self.evaluatedModelVersions = evaluatedModelVersions
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.outcomes = outcomes
        self.predictionTimestamp = predictionTimestamp
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

public struct GetEventTypesInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {

    public enum EventIngestion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EventIngestion] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The event orchestration status.
    public struct EventOrchestration {
        /// Specifies if event orchestration is enabled through Amazon EventBridge.
        /// This member is required.
        public var eventBridgeEnabled: Swift.Bool?

        public init(
            eventBridgeEnabled: Swift.Bool? = nil
        )
        {
            self.eventBridgeEnabled = eventBridgeEnabled
        }
    }

}

extension FraudDetectorClientTypes {
    /// Data about the stored events.
    public struct IngestedEventStatistics {
        /// The total size of the stored events.
        public var eventDataSizeInBytes: Swift.Int?
        /// Timestamp of when the stored event was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The oldest stored event.
        public var leastRecentEvent: Swift.String?
        /// The newest stored event.
        public var mostRecentEvent: Swift.String?
        /// The number of stored events.
        public var numberOfEvents: Swift.Int?

        public init(
            eventDataSizeInBytes: Swift.Int? = nil,
            lastUpdatedTime: Swift.String? = nil,
            leastRecentEvent: Swift.String? = nil,
            mostRecentEvent: Swift.String? = nil,
            numberOfEvents: Swift.Int? = nil
        )
        {
            self.eventDataSizeInBytes = eventDataSizeInBytes
            self.lastUpdatedTime = lastUpdatedTime
            self.leastRecentEvent = leastRecentEvent
            self.mostRecentEvent = mostRecentEvent
            self.numberOfEvents = numberOfEvents
        }
    }

}

extension FraudDetectorClientTypes {
    /// The event type details.
    public struct EventType {
        /// The entity type ARN.
        public var arn: Swift.String?
        /// Timestamp of when the event type was created.
        public var createdTime: Swift.String?
        /// The event type description.
        public var description: Swift.String?
        /// The event type entity types.
        public var entityTypes: [Swift.String]?
        /// If Enabled, Amazon Fraud Detector stores event data when you generate a prediction and uses that data to update calculated variables in near real-time. Amazon Fraud Detector uses this data, known as INGESTED_EVENTS, to train your model and improve fraud predictions.
        public var eventIngestion: FraudDetectorClientTypes.EventIngestion?
        /// The event orchestration status.
        public var eventOrchestration: FraudDetectorClientTypes.EventOrchestration?
        /// The event type event variables.
        public var eventVariables: [Swift.String]?
        /// Data about the stored events.
        public var ingestedEventStatistics: FraudDetectorClientTypes.IngestedEventStatistics?
        /// The event type labels.
        public var labels: [Swift.String]?
        /// Timestamp of when the event type was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The event type name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            entityTypes: [Swift.String]? = nil,
            eventIngestion: FraudDetectorClientTypes.EventIngestion? = nil,
            eventOrchestration: FraudDetectorClientTypes.EventOrchestration? = nil,
            eventVariables: [Swift.String]? = nil,
            ingestedEventStatistics: FraudDetectorClientTypes.IngestedEventStatistics? = nil,
            labels: [Swift.String]? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.entityTypes = entityTypes
            self.eventIngestion = eventIngestion
            self.eventOrchestration = eventOrchestration
            self.eventVariables = eventVariables
            self.ingestedEventStatistics = ingestedEventStatistics
            self.labels = labels
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

extension FraudDetectorClientTypes.EventType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetEventTypesOutput {
    /// An array of event types.
    public var eventTypes: [FraudDetectorClientTypes.EventType]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        eventTypes: [FraudDetectorClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

extension GetEventTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEventTypesOutput(nextToken: \(Swift.String(describing: nextToken)), eventTypes: \"CONTENT_REDACTED\")"}
}

public struct GetExternalModelsInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The Amazon SageMaker model endpoint.
    public var modelEndpoint: Swift.String?
    /// The next page token for the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelEndpoint: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelEndpoint = modelEndpoint
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {

    public enum ModelInputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelInputDataFormat] {
            return [
                .csv,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .json: return "APPLICATION_JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model input configuration.
    public struct ModelInputConfiguration {
        /// Template for constructing the CSV input-data sent to SageMaker. At event-evaluation, the placeholders for variable-names in the template will be replaced with the variable values before being sent to SageMaker.
        public var csvInputTemplate: Swift.String?
        /// The event type name.
        public var eventTypeName: Swift.String?
        /// The format of the model input configuration. The format differs depending on if it is passed through to SageMaker or constructed by Amazon Fraud Detector.
        public var format: FraudDetectorClientTypes.ModelInputDataFormat?
        /// Template for constructing the JSON input-data sent to SageMaker. At event-evaluation, the placeholders for variable names in the template will be replaced with the variable values before being sent to SageMaker.
        public var jsonInputTemplate: Swift.String?
        /// The event variables.
        /// This member is required.
        public var useEventVariables: Swift.Bool?

        public init(
            csvInputTemplate: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            format: FraudDetectorClientTypes.ModelInputDataFormat? = nil,
            jsonInputTemplate: Swift.String? = nil,
            useEventVariables: Swift.Bool? = nil
        )
        {
            self.csvInputTemplate = csvInputTemplate
            self.eventTypeName = eventTypeName
            self.format = format
            self.jsonInputTemplate = jsonInputTemplate
            self.useEventVariables = useEventVariables
        }
    }

}

extension FraudDetectorClientTypes {

    public enum ModelEndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case dissociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelEndpointStatus] {
            return [
                .associated,
                .dissociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .dissociated: return "DISSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {

    public enum ModelOutputDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case jsonlines
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelOutputDataFormat] {
            return [
                .csv,
                .jsonlines
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "TEXT_CSV"
            case .jsonlines: return "APPLICATION_JSONLINES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension FraudDetectorClientTypes {
    /// Provides the Amazon Sagemaker model output configuration.
    public struct ModelOutputConfiguration {
        /// A map of CSV index values in the SageMaker response to the Amazon Fraud Detector variables.
        public var csvIndexToVariableMap: [Swift.String: Swift.String]?
        /// The format of the model output configuration.
        /// This member is required.
        public var format: FraudDetectorClientTypes.ModelOutputDataFormat?
        /// A map of JSON keys in response from SageMaker to the Amazon Fraud Detector variables.
        public var jsonKeyToVariableMap: [Swift.String: Swift.String]?

        public init(
            csvIndexToVariableMap: [Swift.String: Swift.String]? = nil,
            format: FraudDetectorClientTypes.ModelOutputDataFormat? = nil,
            jsonKeyToVariableMap: [Swift.String: Swift.String]? = nil
        )
        {
            self.csvIndexToVariableMap = csvIndexToVariableMap
            self.format = format
            self.jsonKeyToVariableMap = jsonKeyToVariableMap
        }
    }

}

extension FraudDetectorClientTypes {
    /// The Amazon SageMaker model.
    public struct ExternalModel {
        /// The model ARN.
        public var arn: Swift.String?
        /// Timestamp of when the model was last created.
        public var createdTime: Swift.String?
        /// The input configuration.
        public var inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
        /// The role used to invoke the model.
        public var invokeModelEndpointRoleArn: Swift.String?
        /// Timestamp of when the model was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The Amazon SageMaker model endpoints.
        public var modelEndpoint: Swift.String?
        /// The Amazon Fraud Detector status for the external model endpoint
        public var modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
        /// The source of the model.
        public var modelSource: FraudDetectorClientTypes.ModelSource?
        /// The output configuration.
        public var outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
            invokeModelEndpointRoleArn: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelEndpoint: Swift.String? = nil,
            modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
            modelSource: FraudDetectorClientTypes.ModelSource? = nil,
            outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.inputConfiguration = inputConfiguration
            self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
            self.lastUpdatedTime = lastUpdatedTime
            self.modelEndpoint = modelEndpoint
            self.modelEndpointStatus = modelEndpointStatus
            self.modelSource = modelSource
            self.outputConfiguration = outputConfiguration
        }
    }

}

public struct GetExternalModelsOutput {
    /// Gets the Amazon SageMaker models.
    public var externalModels: [FraudDetectorClientTypes.ExternalModel]?
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        externalModels: [FraudDetectorClientTypes.ExternalModel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.externalModels = externalModels
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The KMS key details.
    public struct KMSKey {
        /// The encryption key ARN.
        public var kmsEncryptionKeyArn: Swift.String?

        public init(
            kmsEncryptionKeyArn: Swift.String? = nil
        )
        {
            self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
        }
    }

}

public struct GetKMSEncryptionKeyOutput {
    /// The KMS encryption key.
    public var kmsKey: FraudDetectorClientTypes.KMSKey?

    public init(
        kmsKey: FraudDetectorClientTypes.KMSKey? = nil
    )
    {
        self.kmsKey = kmsKey
    }
}

public struct GetLabelsInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the label or labels to get.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The label details.
    public struct Label {
        /// The label ARN.
        public var arn: Swift.String?
        /// Timestamp of when the event type was created.
        public var createdTime: Swift.String?
        /// The label description.
        public var description: Swift.String?
        /// Timestamp of when the label was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The label name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

public struct GetLabelsOutput {
    /// An array of labels.
    public var labels: [FraudDetectorClientTypes.Label]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        labels: [FraudDetectorClientTypes.Label]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.labels = labels
        self.nextToken = nextToken
    }
}

public struct GetListElementsInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the list.
    /// This member is required.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct GetListElementsOutput {
    /// The list elements.
    public var elements: [Swift.String]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        elements: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.elements = elements
        self.nextToken = nextToken
    }
}

extension GetListElementsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetListElementsOutput(nextToken: \(Swift.String(describing: nextToken)), elements: \"CONTENT_REDACTED\")"}
}

public struct GetListsMetadataInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the list.
    public var name: Swift.String?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct GetListsMetadataOutput {
    /// The metadata of the specified list or all lists under the account.
    public var lists: [FraudDetectorClientTypes.AllowDenyList]?
    /// The next page token.
    public var nextToken: Swift.String?

    public init(
        lists: [FraudDetectorClientTypes.AllowDenyList]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.lists = lists
        self.nextToken = nextToken
    }
}

public struct GetModelsInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The next token for the subsequent request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.modelId = modelId
        self.modelType = modelType
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The model.
    public struct Model {
        /// The ARN of the model.
        public var arn: Swift.String?
        /// Timestamp of when the model was created.
        public var createdTime: Swift.String?
        /// The model description.
        public var description: Swift.String?
        /// The name of the event type.
        public var eventTypeName: Swift.String?
        /// Timestamp of last time the model was updated.
        public var lastUpdatedTime: Swift.String?
        /// The model ID.
        public var modelId: Swift.String?
        /// The model type.
        public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            modelId: Swift.String? = nil,
            modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.eventTypeName = eventTypeName
            self.lastUpdatedTime = lastUpdatedTime
            self.modelId = modelId
            self.modelType = modelType
        }
    }

}

public struct GetModelsOutput {
    /// The array of models.
    public var models: [FraudDetectorClientTypes.Model]?
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?

    public init(
        models: [FraudDetectorClientTypes.Model]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

public struct GetModelVersionInput {
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public var modelVersionNumber: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
    }
}

public struct GetModelVersionOutput {
    /// The model version ARN.
    public var arn: Swift.String?
    /// The details of the external events data used for training the model version. This will be populated if the trainingDataSource is EXTERNAL_EVENTS
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The details of the ingested events data used for training the model version. This will be populated if the trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    public var modelVersionNumber: Swift.String?
    /// The model version status. Possible values are:
    ///
    /// * TRAINING_IN_PROGRESS
    ///
    /// * TRAINING_COMPLETE
    ///
    /// * ACTIVATE_REQUESTED
    ///
    /// * ACTIVATE_IN_PROGRESS
    ///
    /// * ACTIVE
    ///
    /// * INACTIVATE_REQUESTED
    ///
    /// * INACTIVATE_IN_PROGRESS
    ///
    /// * INACTIVE
    ///
    /// * ERROR
    public var status: Swift.String?
    /// The training data schema.
    public var trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema?
    /// The training data source.
    public var trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum?

    public init(
        arn: Swift.String? = nil,
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil,
        trainingDataSchema: FraudDetectorClientTypes.TrainingDataSchema? = nil,
        trainingDataSource: FraudDetectorClientTypes.TrainingDataSourceEnum? = nil
    )
    {
        self.arn = arn
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
        self.trainingDataSchema = trainingDataSchema
        self.trainingDataSource = trainingDataSource
    }
}

public struct GetOutcomesInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The name of the outcome or outcomes to get.
    public var name: Swift.String?
    /// The next page token for the request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

extension FraudDetectorClientTypes {
    /// The outcome.
    public struct Outcome {
        /// The outcome ARN.
        public var arn: Swift.String?
        /// The timestamp when the outcome was created.
        public var createdTime: Swift.String?
        /// The outcome description.
        public var description: Swift.String?
        /// The timestamp when the outcome was last updated.
        public var lastUpdatedTime: Swift.String?
        /// The outcome name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            lastUpdatedTime: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.lastUpdatedTime = lastUpdatedTime
            self.name = name
        }
    }

}

public struct GetOutcomesOutput {
    /// The next page token for subsequent requests.
    public var nextToken: Swift.String?
    /// The outcomes.
    public var outcomes: [FraudDetectorClientTypes.Outcome]?

    public init(
        nextToken: Swift.String? = nil,
        outcomes: [FraudDetectorClientTypes.Outcome]? = nil
    )
    {
        self.nextToken = nextToken
        self.outcomes = outcomes
    }
}

public struct GetRulesInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of rules to return for the request.
    public var maxResults: Swift.Int?
    /// The next page token.
    public var nextToken: Swift.String?
    /// The rule ID.
    public var ruleId: Swift.String?
    /// The rule version.
    public var ruleVersion: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ruleId: Swift.String? = nil,
        ruleVersion: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ruleId = ruleId
        self.ruleVersion = ruleVersion
    }
}

extension FraudDetectorClientTypes {
    /// The details of the rule.
    public struct RuleDetail {
        /// The rule ARN.
        public var arn: Swift.String?
        /// The timestamp of when the rule was created.
        public var createdTime: Swift.String?
        /// The rule description.
        public var description: Swift.String?
        /// The detector for which the rule is associated.
        public var detectorId: Swift.String?
        /// The rule expression.
        public var expression: Swift.String?
        /// The rule language.
        public var language: FraudDetectorClientTypes.Language?
        /// Timestamp of the last time the rule was updated.
        public var lastUpdatedTime: Swift.String?
        /// The rule outcomes.
        public var outcomes: [Swift.String]?
        /// The rule ID.
        public var ruleId: Swift.String?
        /// The rule version.
        public var ruleVersion: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Swift.String? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            expression: Swift.String? = nil,
            language: FraudDetectorClientTypes.Language? = nil,
            lastUpdatedTime: Swift.String? = nil,
            outcomes: [Swift.String]? = nil,
            ruleId: Swift.String? = nil,
            ruleVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.detectorId = detectorId
            self.expression = expression
            self.language = language
            self.lastUpdatedTime = lastUpdatedTime
            self.outcomes = outcomes
            self.ruleId = ruleId
            self.ruleVersion = ruleVersion
        }
    }

}

extension FraudDetectorClientTypes.RuleDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RuleDetail(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), detectorId: \(Swift.String(describing: detectorId)), language: \(Swift.String(describing: language)), lastUpdatedTime: \(Swift.String(describing: lastUpdatedTime)), outcomes: \(Swift.String(describing: outcomes)), ruleId: \(Swift.String(describing: ruleId)), ruleVersion: \(Swift.String(describing: ruleVersion)), expression: \"CONTENT_REDACTED\")"}
}

public struct GetRulesOutput {
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The details of the requested rule.
    public var ruleDetails: [FraudDetectorClientTypes.RuleDetail]?

    public init(
        nextToken: Swift.String? = nil,
        ruleDetails: [FraudDetectorClientTypes.RuleDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleDetails = ruleDetails
    }
}

public struct GetVariablesInput {
    /// The max size per page determined for the get variable request.
    public var maxResults: Swift.Int?
    /// The name of the variable.
    public var name: Swift.String?
    /// The next page token of the get variable request.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct GetVariablesOutput {
    /// The next page token to be used in subsequent requests.
    public var nextToken: Swift.String?
    /// The names of the variables returned.
    public var variables: [FraudDetectorClientTypes.Variable]?

    public init(
        nextToken: Swift.String? = nil,
        variables: [FraudDetectorClientTypes.Variable]? = nil
    )
    {
        self.nextToken = nextToken
        self.variables = variables
    }
}

extension FraudDetectorClientTypes {
    /// A conditional statement for filtering a list of past predictions.
    public struct FilterCondition {
        /// A statement containing a resource property and a value to specify filter condition.
        public var value: Swift.String?

        public init(
            value: Swift.String? = nil
        )
        {
            self.value = value
        }
    }

}

extension FraudDetectorClientTypes {
    /// The time period for when the predictions were generated.
    public struct PredictionTimeRange {
        /// The end time of the time period for when the predictions were generated.
        /// This member is required.
        public var endTime: Swift.String?
        /// The start time of the time period for when the predictions were generated.
        /// This member is required.
        public var startTime: Swift.String?

        public init(
            endTime: Swift.String? = nil,
            startTime: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct ListEventPredictionsInput {
    /// The detector ID.
    public var detectorId: FraudDetectorClientTypes.FilterCondition?
    /// The detector version ID.
    public var detectorVersionId: FraudDetectorClientTypes.FilterCondition?
    /// The event ID.
    public var eventId: FraudDetectorClientTypes.FilterCondition?
    /// The event type associated with the detector.
    public var eventType: FraudDetectorClientTypes.FilterCondition?
    /// The maximum number of predictions to return for the request.
    public var maxResults: Swift.Int?
    /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?
    /// The time period for when the predictions were generated.
    public var predictionTimeRange: FraudDetectorClientTypes.PredictionTimeRange?

    public init(
        detectorId: FraudDetectorClientTypes.FilterCondition? = nil,
        detectorVersionId: FraudDetectorClientTypes.FilterCondition? = nil,
        eventId: FraudDetectorClientTypes.FilterCondition? = nil,
        eventType: FraudDetectorClientTypes.FilterCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        predictionTimeRange: FraudDetectorClientTypes.PredictionTimeRange? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.eventId = eventId
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.predictionTimeRange = predictionTimeRange
    }
}

extension FraudDetectorClientTypes {
    /// Information about the summary of an event prediction.
    public struct EventPredictionSummary {
        /// The detector ID.
        public var detectorId: Swift.String?
        /// The detector version ID.
        public var detectorVersionId: Swift.String?
        /// The event ID.
        public var eventId: Swift.String?
        /// The timestamp of the event.
        public var eventTimestamp: Swift.String?
        /// The event type.
        public var eventTypeName: Swift.String?
        /// The timestamp when the prediction was generated.
        public var predictionTimestamp: Swift.String?

        public init(
            detectorId: Swift.String? = nil,
            detectorVersionId: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            predictionTimestamp: Swift.String? = nil
        )
        {
            self.detectorId = detectorId
            self.detectorVersionId = detectorVersionId
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventTypeName = eventTypeName
            self.predictionTimestamp = predictionTimestamp
        }
    }

}

public struct ListEventPredictionsOutput {
    /// The summary of the past predictions.
    public var eventPredictionSummaries: [FraudDetectorClientTypes.EventPredictionSummary]?
    /// Identifies the next page of results to return. Use the token to make the call again to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours.
    public var nextToken: Swift.String?

    public init(
        eventPredictionSummaries: [FraudDetectorClientTypes.EventPredictionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventPredictionSummaries = eventPredictionSummaries
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The maximum number of objects to return for the request.
    public var maxResults: Swift.Int?
    /// The next token from the previous results.
    public var nextToken: Swift.String?
    /// The ARN that specifies the resource whose tags you want to list.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The next token for subsequent requests.
    public var nextToken: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct PutDetectorInput {
    /// The description of the detector.
    public var description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the event type.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.eventTypeName = eventTypeName
        self.tags = tags
    }
}

public struct PutDetectorOutput {

    public init() { }
}

public struct PutEntityTypeInput {
    /// The description.
    public var description: Swift.String?
    /// The name of the entity type.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct PutEntityTypeOutput {

    public init() { }
}

public struct PutEventTypeInput {
    /// The description of the event type.
    public var description: Swift.String?
    /// The entity type for the event type. Example entity types: customer, merchant, account.
    /// This member is required.
    public var entityTypes: [Swift.String]?
    /// Specifies if ingestion is enabled or disabled.
    public var eventIngestion: FraudDetectorClientTypes.EventIngestion?
    /// Enables or disables event orchestration. If enabled, you can send event predictions to select AWS services for downstream processing of the events.
    public var eventOrchestration: FraudDetectorClientTypes.EventOrchestration?
    /// The event type variables.
    /// This member is required.
    public var eventVariables: [Swift.String]?
    /// The event type labels.
    public var labels: [Swift.String]?
    /// The name.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        entityTypes: [Swift.String]? = nil,
        eventIngestion: FraudDetectorClientTypes.EventIngestion? = nil,
        eventOrchestration: FraudDetectorClientTypes.EventOrchestration? = nil,
        eventVariables: [Swift.String]? = nil,
        labels: [Swift.String]? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.entityTypes = entityTypes
        self.eventIngestion = eventIngestion
        self.eventOrchestration = eventOrchestration
        self.eventVariables = eventVariables
        self.labels = labels
        self.name = name
        self.tags = tags
    }
}

public struct PutEventTypeOutput {

    public init() { }
}

public struct PutExternalModelInput {
    /// The model endpoint input configuration.
    /// This member is required.
    public var inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration?
    /// The IAM role used to invoke the model endpoint.
    /// This member is required.
    public var invokeModelEndpointRoleArn: Swift.String?
    /// The model endpoints name.
    /// This member is required.
    public var modelEndpoint: Swift.String?
    /// The model endpoint’s status in Amazon Fraud Detector.
    /// This member is required.
    public var modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus?
    /// The source of the model.
    /// This member is required.
    public var modelSource: FraudDetectorClientTypes.ModelSource?
    /// The model endpoint output configuration.
    /// This member is required.
    public var outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        inputConfiguration: FraudDetectorClientTypes.ModelInputConfiguration? = nil,
        invokeModelEndpointRoleArn: Swift.String? = nil,
        modelEndpoint: Swift.String? = nil,
        modelEndpointStatus: FraudDetectorClientTypes.ModelEndpointStatus? = nil,
        modelSource: FraudDetectorClientTypes.ModelSource? = nil,
        outputConfiguration: FraudDetectorClientTypes.ModelOutputConfiguration? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.inputConfiguration = inputConfiguration
        self.invokeModelEndpointRoleArn = invokeModelEndpointRoleArn
        self.modelEndpoint = modelEndpoint
        self.modelEndpointStatus = modelEndpointStatus
        self.modelSource = modelSource
        self.outputConfiguration = outputConfiguration
        self.tags = tags
    }
}

public struct PutExternalModelOutput {

    public init() { }
}

public struct PutKMSEncryptionKeyInput {
    /// The KMS encryption key ARN. The KMS key must be single-Region key. Amazon Fraud Detector does not support multi-Region KMS key.
    /// This member is required.
    public var kmsEncryptionKeyArn: Swift.String?

    public init(
        kmsEncryptionKeyArn: Swift.String? = nil
    )
    {
        self.kmsEncryptionKeyArn = kmsEncryptionKeyArn
    }
}

public struct PutKMSEncryptionKeyOutput {

    public init() { }
}

public struct PutLabelInput {
    /// The label description.
    public var description: Swift.String?
    /// The label name.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct PutLabelOutput {

    public init() { }
}

public struct PutOutcomeInput {
    /// The outcome description.
    public var description: Swift.String?
    /// The name of the outcome.
    /// This member is required.
    public var name: Swift.String?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct PutOutcomeOutput {

    public init() { }
}

public struct SendEventInput {
    /// The label to associate with the event. Required if specifying labelTimestamp.
    public var assignedLabel: Swift.String?
    /// An array of entities.
    /// This member is required.
    public var entities: [FraudDetectorClientTypes.Entity]?
    /// The event ID to upload.
    /// This member is required.
    public var eventId: Swift.String?
    /// The timestamp that defines when the event under evaluation occurred. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var eventTimestamp: Swift.String?
    /// The event type name of the event.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// Names of the event type's variables you defined in Amazon Fraud Detector to represent data elements and their corresponding values for the event you are sending for evaluation.
    /// This member is required.
    public var eventVariables: [Swift.String: Swift.String]?
    /// The timestamp associated with the label. Required if specifying assignedLabel.
    public var labelTimestamp: Swift.String?

    public init(
        assignedLabel: Swift.String? = nil,
        entities: [FraudDetectorClientTypes.Entity]? = nil,
        eventId: Swift.String? = nil,
        eventTimestamp: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        eventVariables: [Swift.String: Swift.String]? = nil,
        labelTimestamp: Swift.String? = nil
    )
    {
        self.assignedLabel = assignedLabel
        self.entities = entities
        self.eventId = eventId
        self.eventTimestamp = eventTimestamp
        self.eventTypeName = eventTypeName
        self.eventVariables = eventVariables
        self.labelTimestamp = labelTimestamp
    }
}

extension SendEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendEventInput(assignedLabel: \(Swift.String(describing: assignedLabel)), eventId: \(Swift.String(describing: eventId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventTypeName: \(Swift.String(describing: eventTypeName)), labelTimestamp: \(Swift.String(describing: labelTimestamp)), entities: \"CONTENT_REDACTED\", eventVariables: [keys: \(Swift.String(describing: eventVariables?.keys)), values: \"CONTENT_REDACTED\"])"}
}

public struct SendEventOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to assign to the resource.
    /// This member is required.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the resource from which to remove the tag.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The resource ARN.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateDetectorVersionInput {
    /// The detector version description.
    public var description: Swift.String?
    /// The parent detector ID for the detector version you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The Amazon SageMaker model endpoints to include in the detector version.
    /// This member is required.
    public var externalModelEndpoints: [Swift.String]?
    /// The model versions to include in the detector version.
    public var modelVersions: [FraudDetectorClientTypes.ModelVersion]?
    /// The rule execution mode to add to the detector. If you specify FIRST_MATCHED, Amazon Fraud Detector evaluates rules sequentially, first to last, stopping at the first matched rule. Amazon Fraud dectector then provides the outcomes for that single rule. If you specifiy ALL_MATCHED, Amazon Fraud Detector evaluates all rules and returns the outcomes for all matched rules. You can define and edit the rule mode at the detector version level, when it is in draft status. The default behavior is FIRST_MATCHED.
    public var ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode?
    /// The rules to include in the detector version.
    /// This member is required.
    public var rules: [FraudDetectorClientTypes.Rule]?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        externalModelEndpoints: [Swift.String]? = nil,
        modelVersions: [FraudDetectorClientTypes.ModelVersion]? = nil,
        ruleExecutionMode: FraudDetectorClientTypes.RuleExecutionMode? = nil,
        rules: [FraudDetectorClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.externalModelEndpoints = externalModelEndpoints
        self.modelVersions = modelVersions
        self.ruleExecutionMode = ruleExecutionMode
        self.rules = rules
    }
}

public struct UpdateDetectorVersionOutput {

    public init() { }
}

public struct UpdateDetectorVersionMetadataInput {
    /// The description.
    /// This member is required.
    public var description: Swift.String?
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?

    public init(
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil
    )
    {
        self.description = description
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
    }
}

public struct UpdateDetectorVersionMetadataOutput {

    public init() { }
}

public struct UpdateDetectorVersionStatusInput {
    /// The detector ID.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The detector version ID.
    /// This member is required.
    public var detectorVersionId: Swift.String?
    /// The new status. The only supported values are ACTIVE and INACTIVE
    /// This member is required.
    public var status: FraudDetectorClientTypes.DetectorVersionStatus?

    public init(
        detectorId: Swift.String? = nil,
        detectorVersionId: Swift.String? = nil,
        status: FraudDetectorClientTypes.DetectorVersionStatus? = nil
    )
    {
        self.detectorId = detectorId
        self.detectorVersionId = detectorVersionId
        self.status = status
    }
}

public struct UpdateDetectorVersionStatusOutput {

    public init() { }
}

public struct UpdateEventLabelInput {
    /// The new label to assign to the event.
    /// This member is required.
    public var assignedLabel: Swift.String?
    /// The ID of the event associated with the label to update.
    /// This member is required.
    public var eventId: Swift.String?
    /// The event type of the event associated with the label to update.
    /// This member is required.
    public var eventTypeName: Swift.String?
    /// The timestamp associated with the label. The timestamp must be specified using ISO 8601 standard in UTC.
    /// This member is required.
    public var labelTimestamp: Swift.String?

    public init(
        assignedLabel: Swift.String? = nil,
        eventId: Swift.String? = nil,
        eventTypeName: Swift.String? = nil,
        labelTimestamp: Swift.String? = nil
    )
    {
        self.assignedLabel = assignedLabel
        self.eventId = eventId
        self.eventTypeName = eventTypeName
        self.labelTimestamp = labelTimestamp
    }
}

public struct UpdateEventLabelOutput {

    public init() { }
}

extension FraudDetectorClientTypes {

    public enum ListUpdateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case append
        case remove
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ListUpdateMode] {
            return [
                .append,
                .remove,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .remove: return "REMOVE"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateListInput {
    /// The new description.
    public var description: Swift.String?
    /// One or more list elements to add or replace. If you are providing the elements, make sure to specify the updateMode to use. If you are deleting all elements from the list, use REPLACE for the updateMode and provide an empty list (0 elements).
    public var elements: [Swift.String]?
    /// The name of the list to update.
    /// This member is required.
    public var name: Swift.String?
    /// The update mode (type).
    ///
    /// * Use APPEND if you are adding elements to the list.
    ///
    /// * Use REPLACE if you replacing existing elements in the list.
    ///
    /// * Use REMOVE if you are removing elements from the list.
    public var updateMode: FraudDetectorClientTypes.ListUpdateMode?
    /// The variable type you want to assign to the list. You cannot update a variable type of a list that already has a variable type assigned to it. You can assign a variable type to a list only if the list does not already have a variable type.
    public var variableType: Swift.String?

    public init(
        description: Swift.String? = nil,
        elements: [Swift.String]? = nil,
        name: Swift.String? = nil,
        updateMode: FraudDetectorClientTypes.ListUpdateMode? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.description = description
        self.elements = elements
        self.name = name
        self.updateMode = updateMode
        self.variableType = variableType
    }
}

extension UpdateListInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateListInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), updateMode: \(Swift.String(describing: updateMode)), variableType: \(Swift.String(describing: variableType)), elements: \"CONTENT_REDACTED\")"}
}

public struct UpdateListOutput {

    public init() { }
}

public struct UpdateModelInput {
    /// The new model description.
    public var description: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?

    public init(
        description: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil
    )
    {
        self.description = description
        self.modelId = modelId
        self.modelType = modelType
    }
}

public struct UpdateModelOutput {

    public init() { }
}

public struct UpdateModelVersionInput {
    /// The details of the external events data used for training the model version. Required if trainingDataSource is EXTERNAL_EVENTS.
    public var externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail?
    /// The details of the ingested event used for training the model version. Required if your trainingDataSource is INGESTED_EVENTS.
    public var ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail?
    /// The major version number.
    /// This member is required.
    public var majorVersionNumber: Swift.String?
    /// The model ID.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// A collection of key and value pairs.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        externalEventsDetail: FraudDetectorClientTypes.ExternalEventsDetail? = nil,
        ingestedEventsDetail: FraudDetectorClientTypes.IngestedEventsDetail? = nil,
        majorVersionNumber: Swift.String? = nil,
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.externalEventsDetail = externalEventsDetail
        self.ingestedEventsDetail = ingestedEventsDetail
        self.majorVersionNumber = majorVersionNumber
        self.modelId = modelId
        self.modelType = modelType
        self.tags = tags
    }
}

public struct UpdateModelVersionOutput {
    /// The model ID.
    public var modelId: Swift.String?
    /// The model type.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number of the model version updated.
    public var modelVersionNumber: Swift.String?
    /// The status of the updated model version.
    public var status: Swift.String?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: Swift.String? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

extension FraudDetectorClientTypes {

    public enum ModelVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case trainingCancelled
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelVersionStatus] {
            return [
                .active,
                .inactive,
                .trainingCancelled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case .trainingCancelled: return "TRAINING_CANCELLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateModelVersionStatusInput {
    /// The model ID of the model version to update.
    /// This member is required.
    public var modelId: Swift.String?
    /// The model type.
    /// This member is required.
    public var modelType: FraudDetectorClientTypes.ModelTypeEnum?
    /// The model version number.
    /// This member is required.
    public var modelVersionNumber: Swift.String?
    /// The model version status.
    /// This member is required.
    public var status: FraudDetectorClientTypes.ModelVersionStatus?

    public init(
        modelId: Swift.String? = nil,
        modelType: FraudDetectorClientTypes.ModelTypeEnum? = nil,
        modelVersionNumber: Swift.String? = nil,
        status: FraudDetectorClientTypes.ModelVersionStatus? = nil
    )
    {
        self.modelId = modelId
        self.modelType = modelType
        self.modelVersionNumber = modelVersionNumber
        self.status = status
    }
}

public struct UpdateModelVersionStatusOutput {

    public init() { }
}

public struct UpdateRuleMetadataInput {
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule to update.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        description: Swift.String? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.description = description
        self.rule = rule
    }
}

public struct UpdateRuleMetadataOutput {

    public init() { }
}

public struct UpdateRuleVersionInput {
    /// The description.
    public var description: Swift.String?
    /// The rule expression.
    /// This member is required.
    public var expression: Swift.String?
    /// The language.
    /// This member is required.
    public var language: FraudDetectorClientTypes.Language?
    /// The outcomes.
    /// This member is required.
    public var outcomes: [Swift.String]?
    /// The rule to update.
    /// This member is required.
    public var rule: FraudDetectorClientTypes.Rule?
    /// The tags to assign to the rule version.
    public var tags: [FraudDetectorClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        expression: Swift.String? = nil,
        language: FraudDetectorClientTypes.Language? = nil,
        outcomes: [Swift.String]? = nil,
        rule: FraudDetectorClientTypes.Rule? = nil,
        tags: [FraudDetectorClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.language = language
        self.outcomes = outcomes
        self.rule = rule
        self.tags = tags
    }
}

extension UpdateRuleVersionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRuleVersionInput(description: \(Swift.String(describing: description)), language: \(Swift.String(describing: language)), outcomes: \(Swift.String(describing: outcomes)), rule: \(Swift.String(describing: rule)), tags: \(Swift.String(describing: tags)), expression: \"CONTENT_REDACTED\")"}
}

public struct UpdateRuleVersionOutput {
    /// The new rule version that was created.
    public var rule: FraudDetectorClientTypes.Rule?

    public init(
        rule: FraudDetectorClientTypes.Rule? = nil
    )
    {
        self.rule = rule
    }
}

public struct UpdateVariableInput {
    /// The new default value of the variable.
    public var defaultValue: Swift.String?
    /// The new description.
    public var description: Swift.String?
    /// The name of the variable.
    /// This member is required.
    public var name: Swift.String?
    /// The variable type. For more information see [Variable types](https://docs.aws.amazon.com/frauddetector/latest/ug/create-a-variable.html#variable-types).
    public var variableType: Swift.String?

    public init(
        defaultValue: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        variableType: Swift.String? = nil
    )
    {
        self.defaultValue = defaultValue
        self.description = description
        self.name = name
        self.variableType = variableType
    }
}

public struct UpdateVariableOutput {

    public init() { }
}

extension BatchCreateVariableInput {

    static func urlPathProvider(_ value: BatchCreateVariableInput) -> Swift.String? {
        return "/"
    }
}

extension BatchGetVariableInput {

    static func urlPathProvider(_ value: BatchGetVariableInput) -> Swift.String? {
        return "/"
    }
}

extension CancelBatchImportJobInput {

    static func urlPathProvider(_ value: CancelBatchImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CancelBatchPredictionJobInput {

    static func urlPathProvider(_ value: CancelBatchPredictionJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBatchImportJobInput {

    static func urlPathProvider(_ value: CreateBatchImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBatchPredictionJobInput {

    static func urlPathProvider(_ value: CreateBatchPredictionJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDetectorVersionInput {

    static func urlPathProvider(_ value: CreateDetectorVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateListInput {

    static func urlPathProvider(_ value: CreateListInput) -> Swift.String? {
        return "/"
    }
}

extension CreateModelInput {

    static func urlPathProvider(_ value: CreateModelInput) -> Swift.String? {
        return "/"
    }
}

extension CreateModelVersionInput {

    static func urlPathProvider(_ value: CreateModelVersionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRuleInput {

    static func urlPathProvider(_ value: CreateRuleInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVariableInput {

    static func urlPathProvider(_ value: CreateVariableInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBatchImportJobInput {

    static func urlPathProvider(_ value: DeleteBatchImportJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBatchPredictionJobInput {

    static func urlPathProvider(_ value: DeleteBatchPredictionJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDetectorInput {

    static func urlPathProvider(_ value: DeleteDetectorInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDetectorVersionInput {

    static func urlPathProvider(_ value: DeleteDetectorVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEntityTypeInput {

    static func urlPathProvider(_ value: DeleteEntityTypeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventInput {

    static func urlPathProvider(_ value: DeleteEventInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventsByEventTypeInput {

    static func urlPathProvider(_ value: DeleteEventsByEventTypeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEventTypeInput {

    static func urlPathProvider(_ value: DeleteEventTypeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteExternalModelInput {

    static func urlPathProvider(_ value: DeleteExternalModelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteLabelInput {

    static func urlPathProvider(_ value: DeleteLabelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteListInput {

    static func urlPathProvider(_ value: DeleteListInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteModelInput {

    static func urlPathProvider(_ value: DeleteModelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteModelVersionInput {

    static func urlPathProvider(_ value: DeleteModelVersionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteOutcomeInput {

    static func urlPathProvider(_ value: DeleteOutcomeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRuleInput {

    static func urlPathProvider(_ value: DeleteRuleInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVariableInput {

    static func urlPathProvider(_ value: DeleteVariableInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeDetectorInput {

    static func urlPathProvider(_ value: DescribeDetectorInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeModelVersionsInput {

    static func urlPathProvider(_ value: DescribeModelVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension GetBatchImportJobsInput {

    static func urlPathProvider(_ value: GetBatchImportJobsInput) -> Swift.String? {
        return "/"
    }
}

extension GetBatchPredictionJobsInput {

    static func urlPathProvider(_ value: GetBatchPredictionJobsInput) -> Swift.String? {
        return "/"
    }
}

extension GetDeleteEventsByEventTypeStatusInput {

    static func urlPathProvider(_ value: GetDeleteEventsByEventTypeStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetDetectorsInput {

    static func urlPathProvider(_ value: GetDetectorsInput) -> Swift.String? {
        return "/"
    }
}

extension GetDetectorVersionInput {

    static func urlPathProvider(_ value: GetDetectorVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetEntityTypesInput {

    static func urlPathProvider(_ value: GetEntityTypesInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventInput {

    static func urlPathProvider(_ value: GetEventInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventPredictionInput {

    static func urlPathProvider(_ value: GetEventPredictionInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventPredictionMetadataInput {

    static func urlPathProvider(_ value: GetEventPredictionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetEventTypesInput {

    static func urlPathProvider(_ value: GetEventTypesInput) -> Swift.String? {
        return "/"
    }
}

extension GetExternalModelsInput {

    static func urlPathProvider(_ value: GetExternalModelsInput) -> Swift.String? {
        return "/"
    }
}

extension GetKMSEncryptionKeyInput {

    static func urlPathProvider(_ value: GetKMSEncryptionKeyInput) -> Swift.String? {
        return "/"
    }
}

extension GetLabelsInput {

    static func urlPathProvider(_ value: GetLabelsInput) -> Swift.String? {
        return "/"
    }
}

extension GetListElementsInput {

    static func urlPathProvider(_ value: GetListElementsInput) -> Swift.String? {
        return "/"
    }
}

extension GetListsMetadataInput {

    static func urlPathProvider(_ value: GetListsMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension GetModelsInput {

    static func urlPathProvider(_ value: GetModelsInput) -> Swift.String? {
        return "/"
    }
}

extension GetModelVersionInput {

    static func urlPathProvider(_ value: GetModelVersionInput) -> Swift.String? {
        return "/"
    }
}

extension GetOutcomesInput {

    static func urlPathProvider(_ value: GetOutcomesInput) -> Swift.String? {
        return "/"
    }
}

extension GetRulesInput {

    static func urlPathProvider(_ value: GetRulesInput) -> Swift.String? {
        return "/"
    }
}

extension GetVariablesInput {

    static func urlPathProvider(_ value: GetVariablesInput) -> Swift.String? {
        return "/"
    }
}

extension ListEventPredictionsInput {

    static func urlPathProvider(_ value: ListEventPredictionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutDetectorInput {

    static func urlPathProvider(_ value: PutDetectorInput) -> Swift.String? {
        return "/"
    }
}

extension PutEntityTypeInput {

    static func urlPathProvider(_ value: PutEntityTypeInput) -> Swift.String? {
        return "/"
    }
}

extension PutEventTypeInput {

    static func urlPathProvider(_ value: PutEventTypeInput) -> Swift.String? {
        return "/"
    }
}

extension PutExternalModelInput {

    static func urlPathProvider(_ value: PutExternalModelInput) -> Swift.String? {
        return "/"
    }
}

extension PutKMSEncryptionKeyInput {

    static func urlPathProvider(_ value: PutKMSEncryptionKeyInput) -> Swift.String? {
        return "/"
    }
}

extension PutLabelInput {

    static func urlPathProvider(_ value: PutLabelInput) -> Swift.String? {
        return "/"
    }
}

extension PutOutcomeInput {

    static func urlPathProvider(_ value: PutOutcomeInput) -> Swift.String? {
        return "/"
    }
}

extension SendEventInput {

    static func urlPathProvider(_ value: SendEventInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDetectorVersionInput {

    static func urlPathProvider(_ value: UpdateDetectorVersionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDetectorVersionMetadataInput {

    static func urlPathProvider(_ value: UpdateDetectorVersionMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDetectorVersionStatusInput {

    static func urlPathProvider(_ value: UpdateDetectorVersionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEventLabelInput {

    static func urlPathProvider(_ value: UpdateEventLabelInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateListInput {

    static func urlPathProvider(_ value: UpdateListInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateModelInput {

    static func urlPathProvider(_ value: UpdateModelInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateModelVersionInput {

    static func urlPathProvider(_ value: UpdateModelVersionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateModelVersionStatusInput {

    static func urlPathProvider(_ value: UpdateModelVersionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRuleMetadataInput {

    static func urlPathProvider(_ value: UpdateRuleMetadataInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRuleVersionInput {

    static func urlPathProvider(_ value: UpdateRuleVersionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVariableInput {

    static func urlPathProvider(_ value: UpdateVariableInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreateVariableInput {

    static func write(value: BatchCreateVariableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["variableEntries"].writeList(value.variableEntries, memberWritingClosure: FraudDetectorClientTypes.VariableEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetVariableInput {

    static func write(value: BatchGetVariableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CancelBatchImportJobInput {

    static func write(value: CancelBatchImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension CancelBatchPredictionJobInput {

    static func write(value: CancelBatchPredictionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension CreateBatchImportJobInput {

    static func write(value: CreateBatchImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["iamRoleArn"].write(value.iamRoleArn)
        try writer["inputPath"].write(value.inputPath)
        try writer["jobId"].write(value.jobId)
        try writer["outputPath"].write(value.outputPath)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBatchPredictionJobInput {

    static func write(value: CreateBatchPredictionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorName"].write(value.detectorName)
        try writer["detectorVersion"].write(value.detectorVersion)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["iamRoleArn"].write(value.iamRoleArn)
        try writer["inputPath"].write(value.inputPath)
        try writer["jobId"].write(value.jobId)
        try writer["outputPath"].write(value.outputPath)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDetectorVersionInput {

    static func write(value: CreateDetectorVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["detectorId"].write(value.detectorId)
        try writer["externalModelEndpoints"].writeList(value.externalModelEndpoints, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelVersions"].writeList(value.modelVersions, memberWritingClosure: FraudDetectorClientTypes.ModelVersion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleExecutionMode"].write(value.ruleExecutionMode)
        try writer["rules"].writeList(value.rules, memberWritingClosure: FraudDetectorClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateListInput {

    static func write(value: CreateListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["elements"].writeList(value.elements, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["variableType"].write(value.variableType)
    }
}

extension CreateModelInput {

    static func write(value: CreateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateModelVersionInput {

    static func write(value: CreateModelVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalEventsDetail"].write(value.externalEventsDetail, with: FraudDetectorClientTypes.ExternalEventsDetail.write(value:to:))
        try writer["ingestedEventsDetail"].write(value.ingestedEventsDetail, with: FraudDetectorClientTypes.IngestedEventsDetail.write(value:to:))
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["trainingDataSchema"].write(value.trainingDataSchema, with: FraudDetectorClientTypes.TrainingDataSchema.write(value:to:))
        try writer["trainingDataSource"].write(value.trainingDataSource)
    }
}

extension CreateRuleInput {

    static func write(value: CreateRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["detectorId"].write(value.detectorId)
        try writer["expression"].write(value.expression)
        try writer["language"].write(value.language)
        try writer["outcomes"].writeList(value.outcomes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleId"].write(value.ruleId)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateVariableInput {

    static func write(value: CreateVariableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSource"].write(value.dataSource)
        try writer["dataType"].write(value.dataType)
        try writer["defaultValue"].write(value.defaultValue)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["variableType"].write(value.variableType)
    }
}

extension DeleteBatchImportJobInput {

    static func write(value: DeleteBatchImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension DeleteBatchPredictionJobInput {

    static func write(value: DeleteBatchPredictionJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
    }
}

extension DeleteDetectorInput {

    static func write(value: DeleteDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
    }
}

extension DeleteDetectorVersionInput {

    static func write(value: DeleteDetectorVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
    }
}

extension DeleteEntityTypeInput {

    static func write(value: DeleteEntityTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteEventInput {

    static func write(value: DeleteEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deleteAuditHistory"].write(value.deleteAuditHistory)
        try writer["eventId"].write(value.eventId)
        try writer["eventTypeName"].write(value.eventTypeName)
    }
}

extension DeleteEventsByEventTypeInput {

    static func write(value: DeleteEventsByEventTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTypeName"].write(value.eventTypeName)
    }
}

extension DeleteEventTypeInput {

    static func write(value: DeleteEventTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteExternalModelInput {

    static func write(value: DeleteExternalModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelEndpoint"].write(value.modelEndpoint)
    }
}

extension DeleteLabelInput {

    static func write(value: DeleteLabelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteListInput {

    static func write(value: DeleteListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteModelInput {

    static func write(value: DeleteModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
    }
}

extension DeleteModelVersionInput {

    static func write(value: DeleteModelVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["modelVersionNumber"].write(value.modelVersionNumber)
    }
}

extension DeleteOutcomeInput {

    static func write(value: DeleteOutcomeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DeleteRuleInput {

    static func write(value: DeleteRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["rule"].write(value.rule, with: FraudDetectorClientTypes.Rule.write(value:to:))
    }
}

extension DeleteVariableInput {

    static func write(value: DeleteVariableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension DescribeDetectorInput {

    static func write(value: DescribeDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension DescribeModelVersionsInput {

    static func write(value: DescribeModelVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["modelVersionNumber"].write(value.modelVersionNumber)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetBatchImportJobsInput {

    static func write(value: GetBatchImportJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetBatchPredictionJobsInput {

    static func write(value: GetBatchPredictionJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jobId"].write(value.jobId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetDeleteEventsByEventTypeStatusInput {

    static func write(value: GetDeleteEventsByEventTypeStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventTypeName"].write(value.eventTypeName)
    }
}

extension GetDetectorsInput {

    static func write(value: GetDetectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetDetectorVersionInput {

    static func write(value: GetDetectorVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
    }
}

extension GetEntityTypesInput {

    static func write(value: GetEntityTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetEventInput {

    static func write(value: GetEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventId"].write(value.eventId)
        try writer["eventTypeName"].write(value.eventTypeName)
    }
}

extension GetEventPredictionInput {

    static func write(value: GetEventPredictionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
        try writer["entities"].writeList(value.entities, memberWritingClosure: FraudDetectorClientTypes.Entity.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventId"].write(value.eventId)
        try writer["eventTimestamp"].write(value.eventTimestamp)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["eventVariables"].writeMap(value.eventVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["externalModelEndpointDataBlobs"].writeMap(value.externalModelEndpointDataBlobs, valueWritingClosure: FraudDetectorClientTypes.ModelEndpointDataBlob.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension GetEventPredictionMetadataInput {

    static func write(value: GetEventPredictionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
        try writer["eventId"].write(value.eventId)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["predictionTimestamp"].write(value.predictionTimestamp)
    }
}

extension GetEventTypesInput {

    static func write(value: GetEventTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetExternalModelsInput {

    static func write(value: GetExternalModelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["modelEndpoint"].write(value.modelEndpoint)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetKMSEncryptionKeyInput {

    static func write(value: GetKMSEncryptionKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetLabelsInput {

    static func write(value: GetLabelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetListElementsInput {

    static func write(value: GetListElementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetListsMetadataInput {

    static func write(value: GetListsMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetModelsInput {

    static func write(value: GetModelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetModelVersionInput {

    static func write(value: GetModelVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["modelVersionNumber"].write(value.modelVersionNumber)
    }
}

extension GetOutcomesInput {

    static func write(value: GetOutcomesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetRulesInput {

    static func write(value: GetRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["ruleId"].write(value.ruleId)
        try writer["ruleVersion"].write(value.ruleVersion)
    }
}

extension GetVariablesInput {

    static func write(value: GetVariablesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEventPredictionsInput {

    static func write(value: ListEventPredictionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId, with: FraudDetectorClientTypes.FilterCondition.write(value:to:))
        try writer["detectorVersionId"].write(value.detectorVersionId, with: FraudDetectorClientTypes.FilterCondition.write(value:to:))
        try writer["eventId"].write(value.eventId, with: FraudDetectorClientTypes.FilterCondition.write(value:to:))
        try writer["eventType"].write(value.eventType, with: FraudDetectorClientTypes.FilterCondition.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["predictionTimeRange"].write(value.predictionTimeRange, with: FraudDetectorClientTypes.PredictionTimeRange.write(value:to:))
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension PutDetectorInput {

    static func write(value: PutDetectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["detectorId"].write(value.detectorId)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutEntityTypeInput {

    static func write(value: PutEntityTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutEventTypeInput {

    static func write(value: PutEventTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["entityTypes"].writeList(value.entityTypes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventIngestion"].write(value.eventIngestion)
        try writer["eventOrchestration"].write(value.eventOrchestration, with: FraudDetectorClientTypes.EventOrchestration.write(value:to:))
        try writer["eventVariables"].writeList(value.eventVariables, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutExternalModelInput {

    static func write(value: PutExternalModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputConfiguration"].write(value.inputConfiguration, with: FraudDetectorClientTypes.ModelInputConfiguration.write(value:to:))
        try writer["invokeModelEndpointRoleArn"].write(value.invokeModelEndpointRoleArn)
        try writer["modelEndpoint"].write(value.modelEndpoint)
        try writer["modelEndpointStatus"].write(value.modelEndpointStatus)
        try writer["modelSource"].write(value.modelSource)
        try writer["outputConfiguration"].write(value.outputConfiguration, with: FraudDetectorClientTypes.ModelOutputConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutKMSEncryptionKeyInput {

    static func write(value: PutKMSEncryptionKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsEncryptionKeyArn"].write(value.kmsEncryptionKeyArn)
    }
}

extension PutLabelInput {

    static func write(value: PutLabelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutOutcomeInput {

    static func write(value: PutOutcomeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension SendEventInput {

    static func write(value: SendEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assignedLabel"].write(value.assignedLabel)
        try writer["entities"].writeList(value.entities, memberWritingClosure: FraudDetectorClientTypes.Entity.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["eventId"].write(value.eventId)
        try writer["eventTimestamp"].write(value.eventTimestamp)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["eventVariables"].writeMap(value.eventVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["labelTimestamp"].write(value.labelTimestamp)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDetectorVersionInput {

    static func write(value: UpdateDetectorVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
        try writer["externalModelEndpoints"].writeList(value.externalModelEndpoints, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["modelVersions"].writeList(value.modelVersions, memberWritingClosure: FraudDetectorClientTypes.ModelVersion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ruleExecutionMode"].write(value.ruleExecutionMode)
        try writer["rules"].writeList(value.rules, memberWritingClosure: FraudDetectorClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDetectorVersionMetadataInput {

    static func write(value: UpdateDetectorVersionMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
    }
}

extension UpdateDetectorVersionStatusInput {

    static func write(value: UpdateDetectorVersionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["detectorVersionId"].write(value.detectorVersionId)
        try writer["status"].write(value.status)
    }
}

extension UpdateEventLabelInput {

    static func write(value: UpdateEventLabelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assignedLabel"].write(value.assignedLabel)
        try writer["eventId"].write(value.eventId)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["labelTimestamp"].write(value.labelTimestamp)
    }
}

extension UpdateListInput {

    static func write(value: UpdateListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["elements"].writeList(value.elements, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["updateMode"].write(value.updateMode)
        try writer["variableType"].write(value.variableType)
    }
}

extension UpdateModelInput {

    static func write(value: UpdateModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
    }
}

extension UpdateModelVersionInput {

    static func write(value: UpdateModelVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["externalEventsDetail"].write(value.externalEventsDetail, with: FraudDetectorClientTypes.ExternalEventsDetail.write(value:to:))
        try writer["ingestedEventsDetail"].write(value.ingestedEventsDetail, with: FraudDetectorClientTypes.IngestedEventsDetail.write(value:to:))
        try writer["majorVersionNumber"].write(value.majorVersionNumber)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateModelVersionStatusInput {

    static func write(value: UpdateModelVersionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["modelVersionNumber"].write(value.modelVersionNumber)
        try writer["status"].write(value.status)
    }
}

extension UpdateRuleMetadataInput {

    static func write(value: UpdateRuleMetadataInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["rule"].write(value.rule, with: FraudDetectorClientTypes.Rule.write(value:to:))
    }
}

extension UpdateRuleVersionInput {

    static func write(value: UpdateRuleVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["expression"].write(value.expression)
        try writer["language"].write(value.language)
        try writer["outcomes"].writeList(value.outcomes, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["rule"].write(value.rule, with: FraudDetectorClientTypes.Rule.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: FraudDetectorClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateVariableInput {

    static func write(value: UpdateVariableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultValue"].write(value.defaultValue)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["variableType"].write(value.variableType)
    }
}

extension BatchCreateVariableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateVariableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateVariableOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.BatchCreateVariableError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetVariableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetVariableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetVariableOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.BatchGetVariableError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Variable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CancelBatchImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelBatchImportJobOutput {
        return CancelBatchImportJobOutput()
    }
}

extension CancelBatchPredictionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelBatchPredictionJobOutput {
        return CancelBatchPredictionJobOutput()
    }
}

extension CreateBatchImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBatchImportJobOutput {
        return CreateBatchImportJobOutput()
    }
}

extension CreateBatchPredictionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBatchPredictionJobOutput {
        return CreateBatchPredictionJobOutput()
    }
}

extension CreateDetectorVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDetectorVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDetectorVersionOutput()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorVersionId = try reader["detectorVersionId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateListOutput {
        return CreateListOutput()
    }
}

extension CreateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelOutput {
        return CreateModelOutput()
    }
}

extension CreateModelVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateModelVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateModelVersionOutput()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.modelVersionNumber = try reader["modelVersionNumber"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRuleOutput()
        value.rule = try reader["rule"].readIfPresent(with: FraudDetectorClientTypes.Rule.read(from:))
        return value
    }
}

extension CreateVariableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVariableOutput {
        return CreateVariableOutput()
    }
}

extension DeleteBatchImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBatchImportJobOutput {
        return DeleteBatchImportJobOutput()
    }
}

extension DeleteBatchPredictionJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBatchPredictionJobOutput {
        return DeleteBatchPredictionJobOutput()
    }
}

extension DeleteDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDetectorOutput {
        return DeleteDetectorOutput()
    }
}

extension DeleteDetectorVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDetectorVersionOutput {
        return DeleteDetectorVersionOutput()
    }
}

extension DeleteEntityTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEntityTypeOutput {
        return DeleteEntityTypeOutput()
    }
}

extension DeleteEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventOutput {
        return DeleteEventOutput()
    }
}

extension DeleteEventsByEventTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventsByEventTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEventsByEventTypeOutput()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.eventsDeletionStatus = try reader["eventsDeletionStatus"].readIfPresent()
        return value
    }
}

extension DeleteEventTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEventTypeOutput {
        return DeleteEventTypeOutput()
    }
}

extension DeleteExternalModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteExternalModelOutput {
        return DeleteExternalModelOutput()
    }
}

extension DeleteLabelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLabelOutput {
        return DeleteLabelOutput()
    }
}

extension DeleteListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteListOutput {
        return DeleteListOutput()
    }
}

extension DeleteModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelOutput {
        return DeleteModelOutput()
    }
}

extension DeleteModelVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteModelVersionOutput {
        return DeleteModelVersionOutput()
    }
}

extension DeleteOutcomeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteOutcomeOutput {
        return DeleteOutcomeOutput()
    }
}

extension DeleteRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRuleOutput {
        return DeleteRuleOutput()
    }
}

extension DeleteVariableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVariableOutput {
        return DeleteVariableOutput()
    }
}

extension DescribeDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDetectorOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDetectorOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorVersionSummaries = try reader["detectorVersionSummaries"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.DetectorVersionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension DescribeModelVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeModelVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeModelVersionsOutput()
        value.modelVersionDetails = try reader["modelVersionDetails"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ModelVersionDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetBatchImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBatchImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBatchImportJobsOutput()
        value.batchImports = try reader["batchImports"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.BatchImport.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetBatchPredictionJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBatchPredictionJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBatchPredictionJobsOutput()
        value.batchPredictions = try reader["batchPredictions"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.BatchPrediction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDeleteEventsByEventTypeStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeleteEventsByEventTypeStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeleteEventsByEventTypeStatusOutput()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.eventsDeletionStatus = try reader["eventsDeletionStatus"].readIfPresent()
        return value
    }
}

extension GetDetectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDetectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDetectorsOutput()
        value.detectors = try reader["detectors"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Detector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetDetectorVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDetectorVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDetectorVersionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorVersionId = try reader["detectorVersionId"].readIfPresent()
        value.externalModelEndpoints = try reader["externalModelEndpoints"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.modelVersions = try reader["modelVersions"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ModelVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleExecutionMode = try reader["ruleExecutionMode"].readIfPresent()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetEntityTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEntityTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEntityTypesOutput()
        value.entityTypes = try reader["entityTypes"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EntityType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventOutput()
        value.event = try reader["event"].readIfPresent(with: FraudDetectorClientTypes.Event.read(from:))
        return value
    }
}

extension GetEventPredictionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventPredictionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventPredictionOutput()
        value.externalModelOutputs = try reader["externalModelOutputs"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ExternalModelOutputs.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelScores = try reader["modelScores"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ModelScores.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ruleResults = try reader["ruleResults"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.RuleResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEventPredictionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventPredictionMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventPredictionMetadataOutput()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorVersionId = try reader["detectorVersionId"].readIfPresent()
        value.detectorVersionStatus = try reader["detectorVersionStatus"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent()
        value.entityType = try reader["entityType"].readIfPresent()
        value.evaluatedExternalModels = try reader["evaluatedExternalModels"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EvaluatedExternalModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluatedModelVersions = try reader["evaluatedModelVersions"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EvaluatedModelVersion.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventTimestamp = try reader["eventTimestamp"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.eventVariables = try reader["eventVariables"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EventVariableSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.outcomes = try reader["outcomes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.predictionTimestamp = try reader["predictionTimestamp"].readIfPresent()
        value.ruleExecutionMode = try reader["ruleExecutionMode"].readIfPresent()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EvaluatedRule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetEventTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEventTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEventTypesOutput()
        value.eventTypes = try reader["eventTypes"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EventType.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetExternalModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetExternalModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetExternalModelsOutput()
        value.externalModels = try reader["externalModels"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ExternalModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetKMSEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKMSEncryptionKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKMSEncryptionKeyOutput()
        value.kmsKey = try reader["kmsKey"].readIfPresent(with: FraudDetectorClientTypes.KMSKey.read(from:))
        return value
    }
}

extension GetLabelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLabelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLabelsOutput()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Label.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetListElementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetListElementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListElementsOutput()
        value.elements = try reader["elements"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetListsMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetListsMetadataOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetListsMetadataOutput()
        value.lists = try reader["lists"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.AllowDenyList.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelsOutput()
        value.models = try reader["models"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Model.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetModelVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetModelVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetModelVersionOutput()
        value.arn = try reader["arn"].readIfPresent()
        value.externalEventsDetail = try reader["externalEventsDetail"].readIfPresent(with: FraudDetectorClientTypes.ExternalEventsDetail.read(from:))
        value.ingestedEventsDetail = try reader["ingestedEventsDetail"].readIfPresent(with: FraudDetectorClientTypes.IngestedEventsDetail.read(from:))
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.modelVersionNumber = try reader["modelVersionNumber"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.trainingDataSchema = try reader["trainingDataSchema"].readIfPresent(with: FraudDetectorClientTypes.TrainingDataSchema.read(from:))
        value.trainingDataSource = try reader["trainingDataSource"].readIfPresent()
        return value
    }
}

extension GetOutcomesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOutcomesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOutcomesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.outcomes = try reader["outcomes"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Outcome.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRulesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.ruleDetails = try reader["ruleDetails"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.RuleDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetVariablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVariablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVariablesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Variable.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListEventPredictionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEventPredictionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventPredictionsOutput()
        value.eventPredictionSummaries = try reader["eventPredictionSummaries"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.EventPredictionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutDetectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDetectorOutput {
        return PutDetectorOutput()
    }
}

extension PutEntityTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEntityTypeOutput {
        return PutEntityTypeOutput()
    }
}

extension PutEventTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutEventTypeOutput {
        return PutEventTypeOutput()
    }
}

extension PutExternalModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutExternalModelOutput {
        return PutExternalModelOutput()
    }
}

extension PutKMSEncryptionKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutKMSEncryptionKeyOutput {
        return PutKMSEncryptionKeyOutput()
    }
}

extension PutLabelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLabelOutput {
        return PutLabelOutput()
    }
}

extension PutOutcomeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutOutcomeOutput {
        return PutOutcomeOutput()
    }
}

extension SendEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendEventOutput {
        return SendEventOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDetectorVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDetectorVersionOutput {
        return UpdateDetectorVersionOutput()
    }
}

extension UpdateDetectorVersionMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDetectorVersionMetadataOutput {
        return UpdateDetectorVersionMetadataOutput()
    }
}

extension UpdateDetectorVersionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDetectorVersionStatusOutput {
        return UpdateDetectorVersionStatusOutput()
    }
}

extension UpdateEventLabelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEventLabelOutput {
        return UpdateEventLabelOutput()
    }
}

extension UpdateListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateListOutput {
        return UpdateListOutput()
    }
}

extension UpdateModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelOutput {
        return UpdateModelOutput()
    }
}

extension UpdateModelVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateModelVersionOutput()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.modelVersionNumber = try reader["modelVersionNumber"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateModelVersionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateModelVersionStatusOutput {
        return UpdateModelVersionStatusOutput()
    }
}

extension UpdateRuleMetadataOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleMetadataOutput {
        return UpdateRuleMetadataOutput()
    }
}

extension UpdateRuleVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRuleVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRuleVersionOutput()
        value.rule = try reader["rule"].readIfPresent(with: FraudDetectorClientTypes.Rule.read(from:))
        return value
    }
}

extension UpdateVariableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVariableOutput {
        return UpdateVariableOutput()
    }
}

enum BatchCreateVariableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetVariableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelBatchImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelBatchPredictionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBatchImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBatchPredictionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDetectorVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateModelVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVariableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBatchImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBatchPredictionJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDetectorVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEntityTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventsByEventTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEventTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteExternalModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLabelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteModelVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteOutcomeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVariableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeModelVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBatchImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBatchPredictionJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeleteEventsByEventTypeStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDetectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDetectorVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEntityTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventPredictionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourceUnavailableException": return try ResourceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventPredictionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEventTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetExternalModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKMSEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLabelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetListElementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetListsMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetModelVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOutcomesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVariablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEventPredictionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDetectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEntityTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutEventTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutExternalModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutKMSEncryptionKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLabelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutOutcomeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDetectorVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDetectorVersionMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDetectorVersionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEventLabelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateModelVersionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleMetadataOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRuleVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVariableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ResourceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension FraudDetectorClientTypes.BatchCreateVariableError {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.BatchCreateVariableError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.BatchCreateVariableError()
        value.name = try reader["name"].readIfPresent()
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Variable {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Variable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Variable()
        value.name = try reader["name"].readIfPresent()
        value.dataType = try reader["dataType"].readIfPresent()
        value.dataSource = try reader["dataSource"].readIfPresent()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.variableType = try reader["variableType"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.BatchGetVariableError {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.BatchGetVariableError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.BatchGetVariableError()
        value.name = try reader["name"].readIfPresent()
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Rule {

    static func write(value: FraudDetectorClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectorId"].write(value.detectorId)
        try writer["ruleId"].write(value.ruleId)
        try writer["ruleVersion"].write(value.ruleVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Rule()
        value.detectorId = try reader["detectorId"].readIfPresent() ?? ""
        value.ruleId = try reader["ruleId"].readIfPresent() ?? ""
        value.ruleVersion = try reader["ruleVersion"].readIfPresent() ?? ""
        return value
    }
}

extension FraudDetectorClientTypes.DetectorVersionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.DetectorVersionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.DetectorVersionSummary()
        value.detectorVersionId = try reader["detectorVersionId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.ModelVersionDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelVersionDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelVersionDetail()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.modelVersionNumber = try reader["modelVersionNumber"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.trainingDataSource = try reader["trainingDataSource"].readIfPresent()
        value.trainingDataSchema = try reader["trainingDataSchema"].readIfPresent(with: FraudDetectorClientTypes.TrainingDataSchema.read(from:))
        value.externalEventsDetail = try reader["externalEventsDetail"].readIfPresent(with: FraudDetectorClientTypes.ExternalEventsDetail.read(from:))
        value.ingestedEventsDetail = try reader["ingestedEventsDetail"].readIfPresent(with: FraudDetectorClientTypes.IngestedEventsDetail.read(from:))
        value.trainingResult = try reader["trainingResult"].readIfPresent(with: FraudDetectorClientTypes.TrainingResult.read(from:))
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.trainingResultV2 = try reader["trainingResultV2"].readIfPresent(with: FraudDetectorClientTypes.TrainingResultV2.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.TrainingResultV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TrainingResultV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TrainingResultV2()
        value.dataValidationMetrics = try reader["dataValidationMetrics"].readIfPresent(with: FraudDetectorClientTypes.DataValidationMetrics.read(from:))
        value.trainingMetricsV2 = try reader["trainingMetricsV2"].readIfPresent(with: FraudDetectorClientTypes.TrainingMetricsV2.read(from:))
        value.variableImportanceMetrics = try reader["variableImportanceMetrics"].readIfPresent(with: FraudDetectorClientTypes.VariableImportanceMetrics.read(from:))
        value.aggregatedVariablesImportanceMetrics = try reader["aggregatedVariablesImportanceMetrics"].readIfPresent(with: FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.AggregatedVariablesImportanceMetrics()
        value.logOddsMetrics = try reader["logOddsMetrics"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.AggregatedLogOddsMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.AggregatedLogOddsMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.AggregatedLogOddsMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.AggregatedLogOddsMetric()
        value.variableNames = try reader["variableNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.aggregatedVariablesImportance = try reader["aggregatedVariablesImportance"].readIfPresent() ?? 0.0
        return value
    }
}

extension FraudDetectorClientTypes.VariableImportanceMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.VariableImportanceMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.VariableImportanceMetrics()
        value.logOddsMetrics = try reader["logOddsMetrics"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.LogOddsMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.LogOddsMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.LogOddsMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.LogOddsMetric()
        value.variableName = try reader["variableName"].readIfPresent() ?? ""
        value.variableType = try reader["variableType"].readIfPresent() ?? ""
        value.variableImportance = try reader["variableImportance"].readIfPresent() ?? 0.0
        return value
    }
}

extension FraudDetectorClientTypes.TrainingMetricsV2 {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TrainingMetricsV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TrainingMetricsV2()
        value.ofi = try reader["ofi"].readIfPresent(with: FraudDetectorClientTypes.OFITrainingMetricsValue.read(from:))
        value.tfi = try reader["tfi"].readIfPresent(with: FraudDetectorClientTypes.TFITrainingMetricsValue.read(from:))
        value.ati = try reader["ati"].readIfPresent(with: FraudDetectorClientTypes.ATITrainingMetricsValue.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.ATITrainingMetricsValue {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ATITrainingMetricsValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ATITrainingMetricsValue()
        value.metricDataPoints = try reader["metricDataPoints"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ATIMetricDataPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelPerformance = try reader["modelPerformance"].readIfPresent(with: FraudDetectorClientTypes.ATIModelPerformance.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.ATIModelPerformance {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ATIModelPerformance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ATIModelPerformance()
        value.asi = try reader["asi"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.ATIMetricDataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ATIMetricDataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ATIMetricDataPoint()
        value.cr = try reader["cr"].readIfPresent()
        value.adr = try reader["adr"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        value.atodr = try reader["atodr"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.TFITrainingMetricsValue {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TFITrainingMetricsValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TFITrainingMetricsValue()
        value.metricDataPoints = try reader["metricDataPoints"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.TFIMetricDataPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelPerformance = try reader["modelPerformance"].readIfPresent(with: FraudDetectorClientTypes.TFIModelPerformance.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.TFIModelPerformance {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TFIModelPerformance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TFIModelPerformance()
        value.auc = try reader["auc"].readIfPresent()
        value.uncertaintyRange = try reader["uncertaintyRange"].readIfPresent(with: FraudDetectorClientTypes.UncertaintyRange.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.UncertaintyRange {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.UncertaintyRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.UncertaintyRange()
        value.lowerBoundValue = try reader["lowerBoundValue"].readIfPresent() ?? 0.0
        value.upperBoundValue = try reader["upperBoundValue"].readIfPresent() ?? 0.0
        return value
    }
}

extension FraudDetectorClientTypes.TFIMetricDataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TFIMetricDataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TFIMetricDataPoint()
        value.fpr = try reader["fpr"].readIfPresent()
        value.precision = try reader["precision"].readIfPresent()
        value.tpr = try reader["tpr"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.OFITrainingMetricsValue {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.OFITrainingMetricsValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.OFITrainingMetricsValue()
        value.metricDataPoints = try reader["metricDataPoints"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.OFIMetricDataPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modelPerformance = try reader["modelPerformance"].readIfPresent(with: FraudDetectorClientTypes.OFIModelPerformance.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.OFIModelPerformance {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.OFIModelPerformance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.OFIModelPerformance()
        value.auc = try reader["auc"].readIfPresent()
        value.uncertaintyRange = try reader["uncertaintyRange"].readIfPresent(with: FraudDetectorClientTypes.UncertaintyRange.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.OFIMetricDataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.OFIMetricDataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.OFIMetricDataPoint()
        value.fpr = try reader["fpr"].readIfPresent()
        value.precision = try reader["precision"].readIfPresent()
        value.tpr = try reader["tpr"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.DataValidationMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.DataValidationMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.DataValidationMetrics()
        value.fileLevelMessages = try reader["fileLevelMessages"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.FileValidationMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fieldLevelMessages = try reader["fieldLevelMessages"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.FieldValidationMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.FieldValidationMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.FieldValidationMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.FieldValidationMessage()
        value.fieldName = try reader["fieldName"].readIfPresent()
        value.identifier = try reader["identifier"].readIfPresent()
        value.title = try reader["title"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.FileValidationMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.FileValidationMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.FileValidationMessage()
        value.title = try reader["title"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.TrainingResult {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TrainingResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TrainingResult()
        value.dataValidationMetrics = try reader["dataValidationMetrics"].readIfPresent(with: FraudDetectorClientTypes.DataValidationMetrics.read(from:))
        value.trainingMetrics = try reader["trainingMetrics"].readIfPresent(with: FraudDetectorClientTypes.TrainingMetrics.read(from:))
        value.variableImportanceMetrics = try reader["variableImportanceMetrics"].readIfPresent(with: FraudDetectorClientTypes.VariableImportanceMetrics.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.TrainingMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TrainingMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TrainingMetrics()
        value.auc = try reader["auc"].readIfPresent()
        value.metricDataPoints = try reader["metricDataPoints"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.MetricDataPoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.MetricDataPoint {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.MetricDataPoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.MetricDataPoint()
        value.fpr = try reader["fpr"].readIfPresent()
        value.precision = try reader["precision"].readIfPresent()
        value.tpr = try reader["tpr"].readIfPresent()
        value.threshold = try reader["threshold"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.IngestedEventsDetail {

    static func write(value: FraudDetectorClientTypes.IngestedEventsDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ingestedEventsTimeWindow"].write(value.ingestedEventsTimeWindow, with: FraudDetectorClientTypes.IngestedEventsTimeWindow.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.IngestedEventsDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.IngestedEventsDetail()
        value.ingestedEventsTimeWindow = try reader["ingestedEventsTimeWindow"].readIfPresent(with: FraudDetectorClientTypes.IngestedEventsTimeWindow.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.IngestedEventsTimeWindow {

    static func write(value: FraudDetectorClientTypes.IngestedEventsTimeWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].write(value.endTime)
        try writer["startTime"].write(value.startTime)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.IngestedEventsTimeWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.IngestedEventsTimeWindow()
        value.startTime = try reader["startTime"].readIfPresent() ?? ""
        value.endTime = try reader["endTime"].readIfPresent() ?? ""
        return value
    }
}

extension FraudDetectorClientTypes.ExternalEventsDetail {

    static func write(value: FraudDetectorClientTypes.ExternalEventsDetail?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataAccessRoleArn"].write(value.dataAccessRoleArn)
        try writer["dataLocation"].write(value.dataLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ExternalEventsDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ExternalEventsDetail()
        value.dataLocation = try reader["dataLocation"].readIfPresent() ?? ""
        value.dataAccessRoleArn = try reader["dataAccessRoleArn"].readIfPresent() ?? ""
        return value
    }
}

extension FraudDetectorClientTypes.TrainingDataSchema {

    static func write(value: FraudDetectorClientTypes.TrainingDataSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["labelSchema"].write(value.labelSchema, with: FraudDetectorClientTypes.LabelSchema.write(value:to:))
        try writer["modelVariables"].writeList(value.modelVariables, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.TrainingDataSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.TrainingDataSchema()
        value.modelVariables = try reader["modelVariables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.labelSchema = try reader["labelSchema"].readIfPresent(with: FraudDetectorClientTypes.LabelSchema.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.LabelSchema {

    static func write(value: FraudDetectorClientTypes.LabelSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["labelMapper"].writeMap(value.labelMapper, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["unlabeledEventsTreatment"].write(value.unlabeledEventsTreatment)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.LabelSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.LabelSchema()
        value.labelMapper = try reader["labelMapper"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.unlabeledEventsTreatment = try reader["unlabeledEventsTreatment"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.BatchImport {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.BatchImport {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.BatchImport()
        value.jobId = try reader["jobId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.completionTime = try reader["completionTime"].readIfPresent()
        value.inputPath = try reader["inputPath"].readIfPresent()
        value.outputPath = try reader["outputPath"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.iamRoleArn = try reader["iamRoleArn"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.processedRecordsCount = try reader["processedRecordsCount"].readIfPresent()
        value.failedRecordsCount = try reader["failedRecordsCount"].readIfPresent()
        value.totalRecordsCount = try reader["totalRecordsCount"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.BatchPrediction {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.BatchPrediction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.BatchPrediction()
        value.jobId = try reader["jobId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.failureReason = try reader["failureReason"].readIfPresent()
        value.startTime = try reader["startTime"].readIfPresent()
        value.completionTime = try reader["completionTime"].readIfPresent()
        value.lastHeartbeatTime = try reader["lastHeartbeatTime"].readIfPresent()
        value.inputPath = try reader["inputPath"].readIfPresent()
        value.outputPath = try reader["outputPath"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.detectorName = try reader["detectorName"].readIfPresent()
        value.detectorVersion = try reader["detectorVersion"].readIfPresent()
        value.iamRoleArn = try reader["iamRoleArn"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.processedRecordsCount = try reader["processedRecordsCount"].readIfPresent()
        value.totalRecordsCount = try reader["totalRecordsCount"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Detector {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Detector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Detector()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.ModelVersion {

    static func write(value: FraudDetectorClientTypes.ModelVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["modelId"].write(value.modelId)
        try writer["modelType"].write(value.modelType)
        try writer["modelVersionNumber"].write(value.modelVersionNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelVersion()
        value.modelId = try reader["modelId"].readIfPresent() ?? ""
        value.modelType = try reader["modelType"].readIfPresent() ?? .sdkUnknown("")
        value.modelVersionNumber = try reader["modelVersionNumber"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EntityType {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EntityType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EntityType()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Event {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Event {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Event()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.eventTimestamp = try reader["eventTimestamp"].readIfPresent()
        value.eventVariables = try reader["eventVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.currentLabel = try reader["currentLabel"].readIfPresent()
        value.labelTimestamp = try reader["labelTimestamp"].readIfPresent()
        value.entities = try reader["entities"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.Entity.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.Entity {

    static func write(value: FraudDetectorClientTypes.Entity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
        try writer["entityType"].write(value.entityType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Entity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Entity()
        value.entityType = try reader["entityType"].readIfPresent() ?? ""
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        return value
    }
}

extension FraudDetectorClientTypes.ModelScores {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelScores {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelScores()
        value.modelVersion = try reader["modelVersion"].readIfPresent(with: FraudDetectorClientTypes.ModelVersion.read(from:))
        value.scores = try reader["scores"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readFloat(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.RuleResult {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.RuleResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.RuleResult()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.outcomes = try reader["outcomes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.ExternalModelOutputs {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ExternalModelOutputs {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ExternalModelOutputs()
        value.externalModel = try reader["externalModel"].readIfPresent(with: FraudDetectorClientTypes.ExternalModelSummary.read(from:))
        value.outputs = try reader["outputs"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.ExternalModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ExternalModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ExternalModelSummary()
        value.modelEndpoint = try reader["modelEndpoint"].readIfPresent()
        value.modelSource = try reader["modelSource"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EventVariableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EventVariableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EventVariableSummary()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.source = try reader["source"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EvaluatedRule {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EvaluatedRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EvaluatedRule()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.ruleVersion = try reader["ruleVersion"].readIfPresent()
        value.expression = try reader["expression"].readIfPresent()
        value.expressionWithValues = try reader["expressionWithValues"].readIfPresent()
        value.outcomes = try reader["outcomes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.evaluated = try reader["evaluated"].readIfPresent()
        value.matched = try reader["matched"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EvaluatedModelVersion {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EvaluatedModelVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EvaluatedModelVersion()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelVersion = try reader["modelVersion"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.evaluations = try reader["evaluations"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.ModelVersionEvaluation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.ModelVersionEvaluation {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelVersionEvaluation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelVersionEvaluation()
        value.outputVariableName = try reader["outputVariableName"].readIfPresent()
        value.evaluationScore = try reader["evaluationScore"].readIfPresent()
        value.predictionExplanations = try reader["predictionExplanations"].readIfPresent(with: FraudDetectorClientTypes.PredictionExplanations.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.PredictionExplanations {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.PredictionExplanations {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.PredictionExplanations()
        value.variableImpactExplanations = try reader["variableImpactExplanations"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.VariableImpactExplanation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.aggregatedVariablesImpactExplanations = try reader["aggregatedVariablesImpactExplanations"].readListIfPresent(memberReadingClosure: FraudDetectorClientTypes.AggregatedVariablesImpactExplanation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.AggregatedVariablesImpactExplanation {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.AggregatedVariablesImpactExplanation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.AggregatedVariablesImpactExplanation()
        value.eventVariableNames = try reader["eventVariableNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.relativeImpact = try reader["relativeImpact"].readIfPresent()
        value.logOddsImpact = try reader["logOddsImpact"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.VariableImpactExplanation {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.VariableImpactExplanation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.VariableImpactExplanation()
        value.eventVariableName = try reader["eventVariableName"].readIfPresent()
        value.relativeImpact = try reader["relativeImpact"].readIfPresent()
        value.logOddsImpact = try reader["logOddsImpact"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EvaluatedExternalModel {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EvaluatedExternalModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EvaluatedExternalModel()
        value.modelEndpoint = try reader["modelEndpoint"].readIfPresent()
        value.useEventVariables = try reader["useEventVariables"].readIfPresent()
        value.inputVariables = try reader["inputVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.outputVariables = try reader["outputVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.EventType {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EventType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EventType()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.eventVariables = try reader["eventVariables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.entityTypes = try reader["entityTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.eventIngestion = try reader["eventIngestion"].readIfPresent()
        value.ingestedEventStatistics = try reader["ingestedEventStatistics"].readIfPresent(with: FraudDetectorClientTypes.IngestedEventStatistics.read(from:))
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.eventOrchestration = try reader["eventOrchestration"].readIfPresent(with: FraudDetectorClientTypes.EventOrchestration.read(from:))
        return value
    }
}

extension FraudDetectorClientTypes.EventOrchestration {

    static func write(value: FraudDetectorClientTypes.EventOrchestration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eventBridgeEnabled"].write(value.eventBridgeEnabled)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EventOrchestration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EventOrchestration()
        value.eventBridgeEnabled = try reader["eventBridgeEnabled"].readIfPresent() ?? false
        return value
    }
}

extension FraudDetectorClientTypes.IngestedEventStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.IngestedEventStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.IngestedEventStatistics()
        value.numberOfEvents = try reader["numberOfEvents"].readIfPresent()
        value.eventDataSizeInBytes = try reader["eventDataSizeInBytes"].readIfPresent()
        value.leastRecentEvent = try reader["leastRecentEvent"].readIfPresent()
        value.mostRecentEvent = try reader["mostRecentEvent"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.ExternalModel {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ExternalModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ExternalModel()
        value.modelEndpoint = try reader["modelEndpoint"].readIfPresent()
        value.modelSource = try reader["modelSource"].readIfPresent()
        value.invokeModelEndpointRoleArn = try reader["invokeModelEndpointRoleArn"].readIfPresent()
        value.inputConfiguration = try reader["inputConfiguration"].readIfPresent(with: FraudDetectorClientTypes.ModelInputConfiguration.read(from:))
        value.outputConfiguration = try reader["outputConfiguration"].readIfPresent(with: FraudDetectorClientTypes.ModelOutputConfiguration.read(from:))
        value.modelEndpointStatus = try reader["modelEndpointStatus"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.ModelOutputConfiguration {

    static func write(value: FraudDetectorClientTypes.ModelOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["csvIndexToVariableMap"].writeMap(value.csvIndexToVariableMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["format"].write(value.format)
        try writer["jsonKeyToVariableMap"].writeMap(value.jsonKeyToVariableMap, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelOutputConfiguration()
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.jsonKeyToVariableMap = try reader["jsonKeyToVariableMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.csvIndexToVariableMap = try reader["csvIndexToVariableMap"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension FraudDetectorClientTypes.ModelInputConfiguration {

    static func write(value: FraudDetectorClientTypes.ModelInputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["csvInputTemplate"].write(value.csvInputTemplate)
        try writer["eventTypeName"].write(value.eventTypeName)
        try writer["format"].write(value.format)
        try writer["jsonInputTemplate"].write(value.jsonInputTemplate)
        try writer["useEventVariables"].write(value.useEventVariables)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.ModelInputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.ModelInputConfiguration()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.format = try reader["format"].readIfPresent()
        value.useEventVariables = try reader["useEventVariables"].readIfPresent() ?? false
        value.jsonInputTemplate = try reader["jsonInputTemplate"].readIfPresent()
        value.csvInputTemplate = try reader["csvInputTemplate"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.KMSKey {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.KMSKey {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.KMSKey()
        value.kmsEncryptionKeyArn = try reader["kmsEncryptionKeyArn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Label {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Label {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Label()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.AllowDenyList {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.AllowDenyList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.AllowDenyList()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.variableType = try reader["variableType"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.updatedTime = try reader["updatedTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Model {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Model {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Model()
        value.modelId = try reader["modelId"].readIfPresent()
        value.modelType = try reader["modelType"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Outcome {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Outcome {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Outcome()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.RuleDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.RuleDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.RuleDetail()
        value.ruleId = try reader["ruleId"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.ruleVersion = try reader["ruleVersion"].readIfPresent()
        value.expression = try reader["expression"].readIfPresent()
        value.language = try reader["language"].readIfPresent()
        value.outcomes = try reader["outcomes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent()
        value.createdTime = try reader["createdTime"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.EventPredictionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.EventPredictionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.EventPredictionSummary()
        value.eventId = try reader["eventId"].readIfPresent()
        value.eventTypeName = try reader["eventTypeName"].readIfPresent()
        value.eventTimestamp = try reader["eventTimestamp"].readIfPresent()
        value.predictionTimestamp = try reader["predictionTimestamp"].readIfPresent()
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorVersionId = try reader["detectorVersionId"].readIfPresent()
        return value
    }
}

extension FraudDetectorClientTypes.Tag {

    static func write(value: FraudDetectorClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> FraudDetectorClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = FraudDetectorClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension FraudDetectorClientTypes.VariableEntry {

    static func write(value: FraudDetectorClientTypes.VariableEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataSource"].write(value.dataSource)
        try writer["dataType"].write(value.dataType)
        try writer["defaultValue"].write(value.defaultValue)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["variableType"].write(value.variableType)
    }
}

extension FraudDetectorClientTypes.ModelEndpointDataBlob {

    static func write(value: FraudDetectorClientTypes.ModelEndpointDataBlob?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["byteBuffer"].write(value.byteBuffer)
        try writer["contentType"].write(value.contentType)
    }
}

extension FraudDetectorClientTypes.FilterCondition {

    static func write(value: FraudDetectorClientTypes.FilterCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value)
    }
}

extension FraudDetectorClientTypes.PredictionTimeRange {

    static func write(value: FraudDetectorClientTypes.PredictionTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].write(value.endTime)
        try writer["startTime"].write(value.startTime)
    }
}

public enum FraudDetectorClientTypes {}
