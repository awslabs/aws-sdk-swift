// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    public enum AttachmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attached
        case attaching
        case detached
        case detaching
        case sdkUnknown(Swift.String)

        public static var allCases: [AttachmentStatus] {
            return [
                .attached,
                .attaching,
                .detached,
                .detaching,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attached: return "ATTACHED"
            case .attaching: return "ATTACHING"
            case .detached: return "DETACHED"
            case .detaching: return "DETACHING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttachmentStatus(rawValue: rawValue) ?? AttachmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension CancelTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())/cancel"
    }
}

public struct CancelTaskInput: Swift.Equatable {
    /// The ID of the task that you are attempting to cancel. You can retrieve a task ID by using the ListTasks operation.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelTaskInputBody: Swift.Equatable {
}

extension CancelTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.taskId = output.taskId
        } else {
            self.taskId = nil
        }
    }
}

public struct CancelTaskOutputResponse: Swift.Equatable {
    /// The ID of the task that you are attempting to cancel.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct CancelTaskOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
}

extension CancelTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
    }
}

extension SnowDeviceManagementClientTypes.Capacity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case available
        case name
        case total
        case unit
        case used
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let available = self.available {
            try encodeContainer.encode(available, forKey: .available)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let used = self.used {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let totalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .total)
        total = totalDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used)
        used = usedDecoded
        let availableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .available)
        available = availableDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The physical capacity of the Amazon Web Services Snow Family device.
    public struct Capacity: Swift.Equatable {
        /// The amount of capacity available for use on the device.
        public var available: Swift.Int?
        /// The name of the type of capacity, such as memory.
        public var name: Swift.String?
        /// The total capacity on the device.
        public var total: Swift.Int?
        /// The unit of measure for the type of capacity.
        public var unit: Swift.String?
        /// The amount of capacity used on the device.
        public var used: Swift.Int?

        public init (
            available: Swift.Int? = nil,
            name: Swift.String? = nil,
            total: Swift.Int? = nil,
            unit: Swift.String? = nil,
            used: Swift.Int? = nil
        )
        {
            self.available = available
            self.name = name
            self.total = total
            self.unit = unit
            self.used = used
        }
    }

}

extension SnowDeviceManagementClientTypes.Command: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reboot
        case sdkUnknown
        case unlock
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .reboot(reboot):
                try container.encode(reboot, forKey: .reboot)
            case let .unlock(unlock):
                try container.encode(unlock, forKey: .unlock)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let unlockDecoded = try values.decodeIfPresent(SnowDeviceManagementClientTypes.Unlock.self, forKey: .unlock)
        if let unlock = unlockDecoded {
            self = .unlock(unlock)
            return
        }
        let rebootDecoded = try values.decodeIfPresent(SnowDeviceManagementClientTypes.Reboot.self, forKey: .reboot)
        if let reboot = rebootDecoded {
            self = .reboot(reboot)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SnowDeviceManagementClientTypes {
    /// The command given to the device to execute.
    public enum Command: Swift.Equatable {
        /// Unlocks the device.
        case unlock(SnowDeviceManagementClientTypes.Unlock)
        /// Reboots the device.
        case reboot(SnowDeviceManagementClientTypes.Reboot)
        case sdkUnknown(Swift.String)
    }

}

extension SnowDeviceManagementClientTypes.CpuOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreCount
        case threadsPerCore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreCount = self.coreCount {
            try encodeContainer.encode(coreCount, forKey: .coreCount)
        }
        if let threadsPerCore = self.threadsPerCore {
            try encodeContainer.encode(threadsPerCore, forKey: .threadsPerCore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coreCount)
        coreCount = coreCountDecoded
        let threadsPerCoreDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .threadsPerCore)
        threadsPerCore = threadsPerCoreDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The options for how a device's CPU is configured.
    public struct CpuOptions: Swift.Equatable {
        /// The number of cores that the CPU can use.
        public var coreCount: Swift.Int?
        /// The number of threads per core in the CPU.
        public var threadsPerCore: Swift.Int?

        public init (
            coreCount: Swift.Int? = nil,
            threadsPerCore: Swift.Int? = nil
        )
        {
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }

}

extension CreateTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case command
        case description
        case tags
        case targets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for string0 in targets {
                try targetsContainer.encode(string0)
            }
        }
    }
}

extension CreateTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/task"
    }
}

public struct CreateTaskInput: Swift.Equatable {
    /// A token ensuring that the action is called only once with the specified details.
    public var clientToken: Swift.String?
    /// The task to be performed. Only one task is executed on a device at a time.
    /// This member is required.
    public var command: SnowDeviceManagementClientTypes.Command?
    /// A description of the task and its targets.
    public var description: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String:Swift.String]?
    /// A list of managed device IDs.
    /// This member is required.
    public var targets: [Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        command: SnowDeviceManagementClientTypes.Command? = nil,
        description: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.command = command
        self.description = description
        self.tags = tags
        self.targets = targets
    }
}

struct CreateTaskInputBody: Swift.Equatable {
    let targets: [Swift.String]?
    let command: SnowDeviceManagementClientTypes.Command?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case command
        case description
        case tags
        case targets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let commandDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.Command.self, forKey: .command)
        command = commandDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.taskArn = output.taskArn
            self.taskId = output.taskId
        } else {
            self.taskArn = nil
            self.taskId = nil
        }
    }
}

public struct CreateTaskOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the task that you created.
    public var taskArn: Swift.String?
    /// The ID of the task that you created.
    public var taskId: Swift.String?

    public init (
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

struct CreateTaskOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
    let taskArn: Swift.String?
}

extension CreateTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case taskArn
        case taskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
    }
}

extension DescribeDeviceEc2InstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for string0 in instanceIds {
                try instanceIdsContainer.encode(string0)
            }
        }
    }
}

extension DescribeDeviceEc2InstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let managedDeviceId = managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/resources/ec2/describe"
    }
}

public struct DescribeDeviceEc2InstancesInput: Swift.Equatable {
    /// A list of instance IDs associated with the managed device.
    /// This member is required.
    public var instanceIds: [Swift.String]?
    /// The ID of the managed device.
    /// This member is required.
    public var managedDeviceId: Swift.String?

    public init (
        instanceIds: [Swift.String]? = nil,
        managedDeviceId: Swift.String? = nil
    )
    {
        self.instanceIds = instanceIds
        self.managedDeviceId = managedDeviceId
    }
}

struct DescribeDeviceEc2InstancesInputBody: Swift.Equatable {
    let instanceIds: [Swift.String]?
}

extension DescribeDeviceEc2InstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension DescribeDeviceEc2InstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceEc2InstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeviceEc2InstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceEc2InstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeviceEc2InstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
        } else {
            self.instances = nil
        }
    }
}

public struct DescribeDeviceEc2InstancesOutputResponse: Swift.Equatable {
    /// A list of structures containing information about each instance.
    public var instances: [SnowDeviceManagementClientTypes.InstanceSummary]?

    public init (
        instances: [SnowDeviceManagementClientTypes.InstanceSummary]? = nil
    )
    {
        self.instances = instances
    }
}

struct DescribeDeviceEc2InstancesOutputResponseBody: Swift.Equatable {
    let instances: [SnowDeviceManagementClientTypes.InstanceSummary]?
}

extension DescribeDeviceEc2InstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.InstanceSummary?].self, forKey: .instances)
        var instancesDecoded0:[SnowDeviceManagementClientTypes.InstanceSummary]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [SnowDeviceManagementClientTypes.InstanceSummary]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension DescribeDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let managedDeviceId = managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/describe"
    }
}

public struct DescribeDeviceInput: Swift.Equatable {
    /// The ID of the device that you are checking the information of.
    /// This member is required.
    public var managedDeviceId: Swift.String?

    public init (
        managedDeviceId: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
    }
}

struct DescribeDeviceInputBody: Swift.Equatable {
}

extension DescribeDeviceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDeviceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associatedWithJob = output.associatedWithJob
            self.deviceCapacities = output.deviceCapacities
            self.deviceState = output.deviceState
            self.deviceType = output.deviceType
            self.lastReachedOutAt = output.lastReachedOutAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.managedDeviceArn = output.managedDeviceArn
            self.managedDeviceId = output.managedDeviceId
            self.physicalNetworkInterfaces = output.physicalNetworkInterfaces
            self.software = output.software
            self.tags = output.tags
        } else {
            self.associatedWithJob = nil
            self.deviceCapacities = nil
            self.deviceState = nil
            self.deviceType = nil
            self.lastReachedOutAt = nil
            self.lastUpdatedAt = nil
            self.managedDeviceArn = nil
            self.managedDeviceId = nil
            self.physicalNetworkInterfaces = nil
            self.software = nil
            self.tags = nil
        }
    }
}

public struct DescribeDeviceOutputResponse: Swift.Equatable {
    /// The ID of the job used when ordering the device.
    public var associatedWithJob: Swift.String?
    /// The hardware specifications of the device.
    public var deviceCapacities: [SnowDeviceManagementClientTypes.Capacity]?
    /// The current state of the device.
    public var deviceState: SnowDeviceManagementClientTypes.UnlockState?
    /// The type of Amazon Web Services Snow Family device.
    public var deviceType: Swift.String?
    /// When the device last contacted the Amazon Web Services Cloud. Indicates that the device is online.
    public var lastReachedOutAt: ClientRuntime.Date?
    /// When the device last pushed an update to the Amazon Web Services Cloud. Indicates when the device cache was refreshed.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the device.
    public var managedDeviceArn: Swift.String?
    /// The ID of the device that you checked the information for.
    public var managedDeviceId: Swift.String?
    /// The network interfaces available on the device.
    public var physicalNetworkInterfaces: [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]?
    /// The software installed on the device.
    public var software: SnowDeviceManagementClientTypes.SoftwareInformation?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String:Swift.String]?

    public init (
        associatedWithJob: Swift.String? = nil,
        deviceCapacities: [SnowDeviceManagementClientTypes.Capacity]? = nil,
        deviceState: SnowDeviceManagementClientTypes.UnlockState? = nil,
        deviceType: Swift.String? = nil,
        lastReachedOutAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        managedDeviceArn: Swift.String? = nil,
        managedDeviceId: Swift.String? = nil,
        physicalNetworkInterfaces: [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]? = nil,
        software: SnowDeviceManagementClientTypes.SoftwareInformation? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.associatedWithJob = associatedWithJob
        self.deviceCapacities = deviceCapacities
        self.deviceState = deviceState
        self.deviceType = deviceType
        self.lastReachedOutAt = lastReachedOutAt
        self.lastUpdatedAt = lastUpdatedAt
        self.managedDeviceArn = managedDeviceArn
        self.managedDeviceId = managedDeviceId
        self.physicalNetworkInterfaces = physicalNetworkInterfaces
        self.software = software
        self.tags = tags
    }
}

struct DescribeDeviceOutputResponseBody: Swift.Equatable {
    let lastReachedOutAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let managedDeviceId: Swift.String?
    let managedDeviceArn: Swift.String?
    let deviceType: Swift.String?
    let associatedWithJob: Swift.String?
    let deviceState: SnowDeviceManagementClientTypes.UnlockState?
    let physicalNetworkInterfaces: [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]?
    let deviceCapacities: [SnowDeviceManagementClientTypes.Capacity]?
    let software: SnowDeviceManagementClientTypes.SoftwareInformation?
}

extension DescribeDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedWithJob
        case deviceCapacities
        case deviceState
        case deviceType
        case lastReachedOutAt
        case lastUpdatedAt
        case managedDeviceArn
        case managedDeviceId
        case physicalNetworkInterfaces
        case software
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastReachedOutAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastReachedOutAt)
        lastReachedOutAt = lastReachedOutAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let managedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceId)
        managedDeviceId = managedDeviceIdDecoded
        let managedDeviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceArn)
        managedDeviceArn = managedDeviceArnDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let associatedWithJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedWithJob)
        associatedWithJob = associatedWithJobDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.UnlockState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
        let physicalNetworkInterfacesContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.PhysicalNetworkInterface?].self, forKey: .physicalNetworkInterfaces)
        var physicalNetworkInterfacesDecoded0:[SnowDeviceManagementClientTypes.PhysicalNetworkInterface]? = nil
        if let physicalNetworkInterfacesContainer = physicalNetworkInterfacesContainer {
            physicalNetworkInterfacesDecoded0 = [SnowDeviceManagementClientTypes.PhysicalNetworkInterface]()
            for structure0 in physicalNetworkInterfacesContainer {
                if let structure0 = structure0 {
                    physicalNetworkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        physicalNetworkInterfaces = physicalNetworkInterfacesDecoded0
        let deviceCapacitiesContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.Capacity?].self, forKey: .deviceCapacities)
        var deviceCapacitiesDecoded0:[SnowDeviceManagementClientTypes.Capacity]? = nil
        if let deviceCapacitiesContainer = deviceCapacitiesContainer {
            deviceCapacitiesDecoded0 = [SnowDeviceManagementClientTypes.Capacity]()
            for structure0 in deviceCapacitiesContainer {
                if let structure0 = structure0 {
                    deviceCapacitiesDecoded0?.append(structure0)
                }
            }
        }
        deviceCapacities = deviceCapacitiesDecoded0
        let softwareDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.SoftwareInformation.self, forKey: .software)
        software = softwareDecoded
    }
}

extension DescribeExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        guard let managedDeviceId = managedDeviceId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())/execution/\(managedDeviceId.urlPercentEncoding())"
    }
}

public struct DescribeExecutionInput: Swift.Equatable {
    /// The ID of the managed device.
    /// This member is required.
    public var managedDeviceId: Swift.String?
    /// The ID of the task that the action is describing.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        managedDeviceId: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
        self.taskId = taskId
    }
}

struct DescribeExecutionInputBody: Swift.Equatable {
}

extension DescribeExecutionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeExecutionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executionId = output.executionId
            self.lastUpdatedAt = output.lastUpdatedAt
            self.managedDeviceId = output.managedDeviceId
            self.startedAt = output.startedAt
            self.state = output.state
            self.taskId = output.taskId
        } else {
            self.executionId = nil
            self.lastUpdatedAt = nil
            self.managedDeviceId = nil
            self.startedAt = nil
            self.state = nil
            self.taskId = nil
        }
    }
}

public struct DescribeExecutionOutputResponse: Swift.Equatable {
    /// The ID of the execution.
    public var executionId: Swift.String?
    /// When the status of the execution was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The ID of the managed device that the task is being executed on.
    public var managedDeviceId: Swift.String?
    /// When the execution began.
    public var startedAt: ClientRuntime.Date?
    /// The current state of the execution.
    public var state: SnowDeviceManagementClientTypes.ExecutionState?
    /// The ID of the task being executed on the device.
    public var taskId: Swift.String?

    public init (
        executionId: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        managedDeviceId: Swift.String? = nil,
        startedAt: ClientRuntime.Date? = nil,
        state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.executionId = executionId
        self.lastUpdatedAt = lastUpdatedAt
        self.managedDeviceId = managedDeviceId
        self.startedAt = startedAt
        self.state = state
        self.taskId = taskId
    }
}

struct DescribeExecutionOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
    let executionId: Swift.String?
    let managedDeviceId: Swift.String?
    let state: SnowDeviceManagementClientTypes.ExecutionState?
    let startedAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension DescribeExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
        case lastUpdatedAt
        case managedDeviceId
        case startedAt
        case state
        case taskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let managedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceId)
        managedDeviceId = managedDeviceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.ExecutionState.self, forKey: .state)
        state = stateDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension DescribeTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let taskId = taskId else {
            return nil
        }
        return "/task/\(taskId.urlPercentEncoding())"
    }
}

public struct DescribeTaskInput: Swift.Equatable {
    /// The ID of the task to be described.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        taskId: Swift.String? = nil
    )
    {
        self.taskId = taskId
    }
}

struct DescribeTaskInputBody: Swift.Equatable {
}

extension DescribeTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completedAt = output.completedAt
            self.createdAt = output.createdAt
            self.description = output.description
            self.lastUpdatedAt = output.lastUpdatedAt
            self.state = output.state
            self.tags = output.tags
            self.targets = output.targets
            self.taskArn = output.taskArn
            self.taskId = output.taskId
        } else {
            self.completedAt = nil
            self.createdAt = nil
            self.description = nil
            self.lastUpdatedAt = nil
            self.state = nil
            self.tags = nil
            self.targets = nil
            self.taskArn = nil
            self.taskId = nil
        }
    }
}

public struct DescribeTaskOutputResponse: Swift.Equatable {
    /// When the task was completed.
    public var completedAt: ClientRuntime.Date?
    /// When the CreateTask operation was called.
    public var createdAt: ClientRuntime.Date?
    /// The description provided of the task and managed devices.
    public var description: Swift.String?
    /// When the state of the task was last updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// The current state of the task.
    public var state: SnowDeviceManagementClientTypes.TaskState?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    public var tags: [Swift.String:Swift.String]?
    /// The managed devices that the task was sent to.
    public var targets: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the task.
    public var taskArn: Swift.String?
    /// The ID of the task.
    public var taskId: Swift.String?

    public init (
        completedAt: ClientRuntime.Date? = nil,
        createdAt: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        state: SnowDeviceManagementClientTypes.TaskState? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [Swift.String]? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.description = description
        self.lastUpdatedAt = lastUpdatedAt
        self.state = state
        self.tags = tags
        self.targets = targets
        self.taskArn = taskArn
        self.taskId = taskId
    }
}

struct DescribeTaskOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
    let taskArn: Swift.String?
    let targets: [Swift.String]?
    let state: SnowDeviceManagementClientTypes.TaskState?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension DescribeTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt
        case createdAt
        case description
        case lastUpdatedAt
        case state
        case tags
        case targets
        case taskArn
        case taskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targets)
        var targetsDecoded0:[Swift.String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Swift.String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.TaskState.self, forKey: .state)
        state = stateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let completedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedAt)
        completedAt = completedAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SnowDeviceManagementClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedWithJob
        case managedDeviceArn
        case managedDeviceId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedWithJob = self.associatedWithJob {
            try encodeContainer.encode(associatedWithJob, forKey: .associatedWithJob)
        }
        if let managedDeviceArn = self.managedDeviceArn {
            try encodeContainer.encode(managedDeviceArn, forKey: .managedDeviceArn)
        }
        if let managedDeviceId = self.managedDeviceId {
            try encodeContainer.encode(managedDeviceId, forKey: .managedDeviceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceId)
        managedDeviceId = managedDeviceIdDecoded
        let managedDeviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceArn)
        managedDeviceArn = managedDeviceArnDecoded
        let associatedWithJobDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedWithJob)
        associatedWithJob = associatedWithJobDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SnowDeviceManagementClientTypes {
    /// Identifying information about the device.
    public struct DeviceSummary: Swift.Equatable {
        /// The ID of the job used to order the device.
        public var associatedWithJob: Swift.String?
        /// The Amazon Resource Name (ARN) of the device.
        public var managedDeviceArn: Swift.String?
        /// The ID of the device.
        public var managedDeviceId: Swift.String?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public var tags: [Swift.String:Swift.String]?

        public init (
            associatedWithJob: Swift.String? = nil,
            managedDeviceArn: Swift.String? = nil,
            managedDeviceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.associatedWithJob = associatedWithJob
            self.managedDeviceArn = managedDeviceArn
            self.managedDeviceId = managedDeviceId
            self.tags = tags
        }
    }

}

extension SnowDeviceManagementClientTypes.EbsInstanceBlockDevice: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachTime
        case deleteOnTermination
        case status
        case volumeId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachTime = self.attachTime {
            try encodeContainer.encodeTimestamp(attachTime, format: .epochSeconds, forKey: .attachTime)
        }
        if let deleteOnTermination = self.deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let volumeId = self.volumeId {
            try encodeContainer.encode(volumeId, forKey: .volumeId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .attachTime)
        attachTime = attachTimeDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.AttachmentStatus.self, forKey: .status)
        status = statusDecoded
        let volumeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeId)
        volumeId = volumeIdDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// Describes a parameter used to set up an Amazon Elastic Block Store (Amazon EBS) volume in a block device mapping.
    public struct EbsInstanceBlockDevice: Swift.Equatable {
        /// When the attachment was initiated.
        public var attachTime: ClientRuntime.Date?
        /// A value that indicates whether the volume is deleted on instance termination.
        public var deleteOnTermination: Swift.Bool?
        /// The attachment state.
        public var status: SnowDeviceManagementClientTypes.AttachmentStatus?
        /// The ID of the Amazon EBS volume.
        public var volumeId: Swift.String?

        public init (
            attachTime: ClientRuntime.Date? = nil,
            deleteOnTermination: Swift.Bool? = nil,
            status: SnowDeviceManagementClientTypes.AttachmentStatus? = nil,
            volumeId: Swift.String? = nil
        )
        {
            self.attachTime = attachTime
            self.deleteOnTermination = deleteOnTermination
            self.status = status
            self.volumeId = volumeId
        }
    }

}

extension SnowDeviceManagementClientTypes {
    public enum ExecutionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case queued
        case rejected
        case succeeded
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionState] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .queued,
                .rejected,
                .succeeded,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .queued: return "QUEUED"
            case .rejected: return "REJECTED"
            case .succeeded: return "SUCCEEDED"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionState(rawValue: rawValue) ?? ExecutionState.sdkUnknown(rawValue)
        }
    }
}

extension SnowDeviceManagementClientTypes.ExecutionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionId
        case managedDeviceId
        case state
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionId = self.executionId {
            try encodeContainer.encode(executionId, forKey: .executionId)
        }
        if let managedDeviceId = self.managedDeviceId {
            try encodeContainer.encode(managedDeviceId, forKey: .managedDeviceId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let executionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionId)
        executionId = executionIdDecoded
        let managedDeviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedDeviceId)
        managedDeviceId = managedDeviceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.ExecutionState.self, forKey: .state)
        state = stateDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The summary of a task execution on a specified device.
    public struct ExecutionSummary: Swift.Equatable {
        /// The ID of the execution.
        public var executionId: Swift.String?
        /// The ID of the managed device that the task is being executed on.
        public var managedDeviceId: Swift.String?
        /// The state of the execution.
        public var state: SnowDeviceManagementClientTypes.ExecutionState?
        /// The ID of the task.
        public var taskId: Swift.String?

        public init (
            executionId: Swift.String? = nil,
            managedDeviceId: Swift.String? = nil,
            state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.executionId = executionId
            self.managedDeviceId = managedDeviceId
            self.state = state
            self.taskId = taskId
        }
    }

}

extension SnowDeviceManagementClientTypes.Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiLaunchIndex
        case blockDeviceMappings
        case cpuOptions
        case createdAt
        case imageId
        case instanceId
        case instanceType
        case privateIpAddress
        case publicIpAddress
        case rootDeviceName
        case securityGroups
        case state
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiLaunchIndex = self.amiLaunchIndex {
            try encodeContainer.encode(amiLaunchIndex, forKey: .amiLaunchIndex)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let cpuOptions = self.cpuOptions {
            try encodeContainer.encode(cpuOptions, forKey: .cpuOptions)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let publicIpAddress = self.publicIpAddress {
            try encodeContainer.encode(publicIpAddress, forKey: .publicIpAddress)
        }
        if let rootDeviceName = self.rootDeviceName {
            try encodeContainer.encode(rootDeviceName, forKey: .rootDeviceName)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupidentifier0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupidentifier0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let amiLaunchIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .amiLaunchIndex)
        amiLaunchIndex = amiLaunchIndexDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.InstanceState.self, forKey: .state)
        state = stateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let publicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIpAddress)
        publicIpAddress = publicIpAddressDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.SecurityGroupIdentifier?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[SnowDeviceManagementClientTypes.SecurityGroupIdentifier]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [SnowDeviceManagementClientTypes.SecurityGroupIdentifier]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let cpuOptionsDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.CpuOptions.self, forKey: .cpuOptions)
        cpuOptions = cpuOptionsDecoded
        let rootDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootDeviceName)
        rootDeviceName = rootDeviceNameDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The description of an instance. Currently, Amazon EC2 instances are the only supported instance type.
    public struct Instance: Swift.Equatable {
        /// The Amazon Machine Image (AMI) launch index, which you can use to find this instance in the launch group.
        public var amiLaunchIndex: Swift.Int?
        /// Any block device mapping entries for the instance.
        public var blockDeviceMappings: [SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]?
        /// The CPU options for the instance.
        public var cpuOptions: SnowDeviceManagementClientTypes.CpuOptions?
        /// When the instance was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the AMI used to launch the instance.
        public var imageId: Swift.String?
        /// The ID of the instance.
        public var instanceId: Swift.String?
        /// The instance type.
        public var instanceType: Swift.String?
        /// The private IPv4 address assigned to the instance.
        public var privateIpAddress: Swift.String?
        /// The public IPv4 address assigned to the instance.
        public var publicIpAddress: Swift.String?
        /// The device name of the root device volume (for example, /dev/sda1).
        public var rootDeviceName: Swift.String?
        /// The security groups for the instance.
        public var securityGroups: [SnowDeviceManagementClientTypes.SecurityGroupIdentifier]?
        /// The description of the current state of an instance.
        public var state: SnowDeviceManagementClientTypes.InstanceState?
        /// When the instance was last updated.
        public var updatedAt: ClientRuntime.Date?

        public init (
            amiLaunchIndex: Swift.Int? = nil,
            blockDeviceMappings: [SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping]? = nil,
            cpuOptions: SnowDeviceManagementClientTypes.CpuOptions? = nil,
            createdAt: ClientRuntime.Date? = nil,
            imageId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            publicIpAddress: Swift.String? = nil,
            rootDeviceName: Swift.String? = nil,
            securityGroups: [SnowDeviceManagementClientTypes.SecurityGroupIdentifier]? = nil,
            state: SnowDeviceManagementClientTypes.InstanceState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.amiLaunchIndex = amiLaunchIndex
            self.blockDeviceMappings = blockDeviceMappings
            self.cpuOptions = cpuOptions
            self.createdAt = createdAt
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceType = instanceType
            self.privateIpAddress = privateIpAddress
            self.publicIpAddress = publicIpAddress
            self.rootDeviceName = rootDeviceName
            self.securityGroups = securityGroups
            self.state = state
            self.updatedAt = updatedAt
        }
    }

}

extension SnowDeviceManagementClientTypes.InstanceBlockDeviceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case ebs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.EbsInstanceBlockDevice.self, forKey: .ebs)
        ebs = ebsDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The description of a block device mapping.
    public struct InstanceBlockDeviceMapping: Swift.Equatable {
        /// The block device name.
        public var deviceName: Swift.String?
        /// The parameters used to automatically set up Amazon Elastic Block Store (Amazon EBS) volumes when the instance is launched.
        public var ebs: SnowDeviceManagementClientTypes.EbsInstanceBlockDevice?

        public init (
            deviceName: Swift.String? = nil,
            ebs: SnowDeviceManagementClientTypes.EbsInstanceBlockDevice? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
        }
    }

}

extension SnowDeviceManagementClientTypes.InstanceState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code)
        code = codeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.InstanceStateName.self, forKey: .name)
        name = nameDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The description of the current state of an instance.
    public struct InstanceState: Swift.Equatable {
        /// The state of the instance as a 16-bit unsigned integer. The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored. The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. The valid values for the instance state code are all in the range of the low byte. These values are:
        ///
        /// * 0 : pending
        ///
        /// * 16 : running
        ///
        /// * 32 : shutting-down
        ///
        /// * 48 : terminated
        ///
        /// * 64 : stopping
        ///
        /// * 80 : stopped
        ///
        ///
        /// You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.
        public var code: Swift.Int?
        /// The current state of the instance.
        public var name: SnowDeviceManagementClientTypes.InstanceStateName?

        public init (
            code: Swift.Int? = nil,
            name: SnowDeviceManagementClientTypes.InstanceStateName? = nil
        )
        {
            self.code = code
            self.name = name
        }
    }

}

extension SnowDeviceManagementClientTypes {
    public enum InstanceStateName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pending
        case running
        case shuttingDown
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStateName] {
            return [
                .pending,
                .running,
                .shuttingDown,
                .stopped,
                .stopping,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .shuttingDown: return "SHUTTING_DOWN"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStateName(rawValue: rawValue) ?? InstanceStateName.sdkUnknown(rawValue)
        }
    }
}

extension SnowDeviceManagementClientTypes.InstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance
        case lastUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instance = self.instance {
            try encodeContainer.encode(instance, forKey: .instance)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.Instance.self, forKey: .instance)
        instance = instanceDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The details about the instance.
    public struct InstanceSummary: Swift.Equatable {
        /// A structure containing details about the instance.
        public var instance: SnowDeviceManagementClientTypes.Instance?
        /// When the instance summary was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?

        public init (
            instance: SnowDeviceManagementClientTypes.Instance? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.instance = instance
            self.lastUpdatedAt = lastUpdatedAt
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred while processing the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    public enum IpAddressAssignment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dhcp
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressAssignment] {
            return [
                .dhcp,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dhcp: return "DHCP"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpAddressAssignment(rawValue: rawValue) ?? IpAddressAssignment.sdkUnknown(rawValue)
        }
    }
}

extension ListDeviceResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let managedDeviceId = managedDeviceId else {
            return nil
        }
        return "/managed-device/\(managedDeviceId.urlPercentEncoding())/resources"
    }
}

public struct ListDeviceResourcesInput: Swift.Equatable {
    /// The ID of the managed device that you are listing the resources of.
    /// This member is required.
    public var managedDeviceId: Swift.String?
    /// The maximum number of resources per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A structure used to filter the results by type of resource.
    public var type: Swift.String?

    public init (
        managedDeviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.managedDeviceId = managedDeviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListDeviceResourcesInputBody: Swift.Equatable {
}

extension ListDeviceResourcesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDeviceResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDeviceResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListDeviceResourcesOutputResponse: Swift.Equatable {
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A structure defining the resource's type, Amazon Resource Name (ARN), and ID.
    public var resources: [SnowDeviceManagementClientTypes.ResourceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [SnowDeviceManagementClientTypes.ResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListDeviceResourcesOutputResponseBody: Swift.Equatable {
    let resources: [SnowDeviceManagementClientTypes.ResourceSummary]?
    let nextToken: Swift.String?
}

extension ListDeviceResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case resources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.ResourceSummary?].self, forKey: .resources)
        var resourcesDecoded0:[SnowDeviceManagementClientTypes.ResourceSummary]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [SnowDeviceManagementClientTypes.ResourceSummary]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDevicesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let jobId = jobId {
                let jobIdQueryItem = ClientRuntime.URLQueryItem(name: "jobId".urlPercentEncoding(), value: Swift.String(jobId).urlPercentEncoding())
                items.append(jobIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/managed-devices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// The ID of the job used to order the device.
    public var jobId: Swift.String?
    /// The maximum number of devices to list per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
}

extension ListDevicesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDevicesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutputResponse: Swift.Equatable {
    /// A list of device structures that contain information about the device.
    public var devices: [SnowDeviceManagementClientTypes.DeviceSummary]?
    /// A pagination token to continue to the next page of devices.
    public var nextToken: Swift.String?

    public init (
        devices: [SnowDeviceManagementClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputResponseBody: Swift.Equatable {
    let devices: [SnowDeviceManagementClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[SnowDeviceManagementClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [SnowDeviceManagementClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExecutionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            guard let taskId = taskId else {
                let message = "Creating a URL Query Item failed. taskId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let taskIdQueryItem = ClientRuntime.URLQueryItem(name: "taskId".urlPercentEncoding(), value: Swift.String(taskId).urlPercentEncoding())
            items.append(taskIdQueryItem)
            return items
        }
    }
}

extension ListExecutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/executions"
    }
}

public struct ListExecutionsInput: Swift.Equatable {
    /// The maximum number of tasks to list per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A structure used to filter the tasks by their current state.
    public var state: SnowDeviceManagementClientTypes.ExecutionState?
    /// The ID of the task.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: SnowDeviceManagementClientTypes.ExecutionState? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
        self.taskId = taskId
    }
}

struct ListExecutionsInputBody: Swift.Equatable {
}

extension ListExecutionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListExecutionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.executions = output.executions
            self.nextToken = output.nextToken
        } else {
            self.executions = nil
            self.nextToken = nil
        }
    }
}

public struct ListExecutionsOutputResponse: Swift.Equatable {
    /// A list of executions. Each execution contains the task ID, the device that the task is executing on, the execution ID, and the status of the execution.
    public var executions: [SnowDeviceManagementClientTypes.ExecutionSummary]?
    /// A pagination token to continue to the next page of executions.
    public var nextToken: Swift.String?

    public init (
        executions: [SnowDeviceManagementClientTypes.ExecutionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.executions = executions
        self.nextToken = nextToken
    }
}

struct ListExecutionsOutputResponseBody: Swift.Equatable {
    let executions: [SnowDeviceManagementClientTypes.ExecutionSummary]?
    let nextToken: Swift.String?
}

extension ListExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executions
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionsContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.ExecutionSummary?].self, forKey: .executions)
        var executionsDecoded0:[SnowDeviceManagementClientTypes.ExecutionSummary]? = nil
        if let executionsContainer = executionsContainer {
            executionsDecoded0 = [SnowDeviceManagementClientTypes.ExecutionSummary]()
            for structure0 in executionsContainer {
                if let structure0 = structure0 {
                    executionsDecoded0?.append(structure0)
                }
            }
        }
        executions = executionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of tags for the device or task.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let state = state {
                let stateQueryItem = ClientRuntime.URLQueryItem(name: "state".urlPercentEncoding(), value: Swift.String(state.rawValue).urlPercentEncoding())
                items.append(stateQueryItem)
            }
            return items
        }
    }
}

extension ListTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tasks"
    }
}

public struct ListTasksInput: Swift.Equatable {
    /// The maximum number of tasks per page.
    public var maxResults: Swift.Int?
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A structure used to filter the list of tasks.
    public var state: SnowDeviceManagementClientTypes.TaskState?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: SnowDeviceManagementClientTypes.TaskState? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListTasksInputBody: Swift.Equatable {
}

extension ListTasksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tasks = output.tasks
        } else {
            self.nextToken = nil
            self.tasks = nil
        }
    }
}

public struct ListTasksOutputResponse: Swift.Equatable {
    /// A pagination token to continue to the next page of tasks.
    public var nextToken: Swift.String?
    /// A list of task structures containing details about each task.
    public var tasks: [SnowDeviceManagementClientTypes.TaskSummary]?

    public init (
        nextToken: Swift.String? = nil,
        tasks: [SnowDeviceManagementClientTypes.TaskSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.tasks = tasks
    }
}

struct ListTasksOutputResponseBody: Swift.Equatable {
    let tasks: [SnowDeviceManagementClientTypes.TaskSummary]?
    let nextToken: Swift.String?
}

extension ListTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tasks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tasksContainer = try containerValues.decodeIfPresent([SnowDeviceManagementClientTypes.TaskSummary?].self, forKey: .tasks)
        var tasksDecoded0:[SnowDeviceManagementClientTypes.TaskSummary]? = nil
        if let tasksContainer = tasksContainer {
            tasksDecoded0 = [SnowDeviceManagementClientTypes.TaskSummary]()
            for structure0 in tasksContainer {
                if let structure0 = structure0 {
                    tasksDecoded0?.append(structure0)
                }
            }
        }
        tasks = tasksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    public enum PhysicalConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case qsfp
        case rj45
        case rj452
        case sfpPlus
        case wifi
        case sdkUnknown(Swift.String)

        public static var allCases: [PhysicalConnectorType] {
            return [
                .qsfp,
                .rj45,
                .rj452,
                .sfpPlus,
                .wifi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .qsfp: return "QSFP"
            case .rj45: return "RJ45"
            case .rj452: return "RJ45_2"
            case .sfpPlus: return "SFP_PLUS"
            case .wifi: return "WIFI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhysicalConnectorType(rawValue: rawValue) ?? PhysicalConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension SnowDeviceManagementClientTypes.PhysicalNetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultGateway
        case ipAddress
        case ipAddressAssignment
        case macAddress
        case netmask
        case physicalConnectorType
        case physicalNetworkInterfaceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultGateway = self.defaultGateway {
            try encodeContainer.encode(defaultGateway, forKey: .defaultGateway)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let ipAddressAssignment = self.ipAddressAssignment {
            try encodeContainer.encode(ipAddressAssignment.rawValue, forKey: .ipAddressAssignment)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let netmask = self.netmask {
            try encodeContainer.encode(netmask, forKey: .netmask)
        }
        if let physicalConnectorType = self.physicalConnectorType {
            try encodeContainer.encode(physicalConnectorType.rawValue, forKey: .physicalConnectorType)
        }
        if let physicalNetworkInterfaceId = self.physicalNetworkInterfaceId {
            try encodeContainer.encode(physicalNetworkInterfaceId, forKey: .physicalNetworkInterfaceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let physicalNetworkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalNetworkInterfaceId)
        physicalNetworkInterfaceId = physicalNetworkInterfaceIdDecoded
        let physicalConnectorTypeDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.PhysicalConnectorType.self, forKey: .physicalConnectorType)
        physicalConnectorType = physicalConnectorTypeDecoded
        let ipAddressAssignmentDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.IpAddressAssignment.self, forKey: .ipAddressAssignment)
        ipAddressAssignment = ipAddressAssignmentDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let netmaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netmask)
        netmask = netmaskDecoded
        let defaultGatewayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultGateway)
        defaultGateway = defaultGatewayDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// The details about the physical network interface for the device.
    public struct PhysicalNetworkInterface: Swift.Equatable {
        /// The default gateway of the device.
        public var defaultGateway: Swift.String?
        /// The IP address of the device.
        public var ipAddress: Swift.String?
        /// A value that describes whether the IP address is dynamic or persistent.
        public var ipAddressAssignment: SnowDeviceManagementClientTypes.IpAddressAssignment?
        /// The MAC address of the device.
        public var macAddress: Swift.String?
        /// The netmask used to divide the IP address into subnets.
        public var netmask: Swift.String?
        /// The physical connector type.
        public var physicalConnectorType: SnowDeviceManagementClientTypes.PhysicalConnectorType?
        /// The physical network interface ID.
        public var physicalNetworkInterfaceId: Swift.String?

        public init (
            defaultGateway: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            ipAddressAssignment: SnowDeviceManagementClientTypes.IpAddressAssignment? = nil,
            macAddress: Swift.String? = nil,
            netmask: Swift.String? = nil,
            physicalConnectorType: SnowDeviceManagementClientTypes.PhysicalConnectorType? = nil,
            physicalNetworkInterfaceId: Swift.String? = nil
        )
        {
            self.defaultGateway = defaultGateway
            self.ipAddress = ipAddress
            self.ipAddressAssignment = ipAddressAssignment
            self.macAddress = macAddress
            self.netmask = netmask
            self.physicalConnectorType = physicalConnectorType
            self.physicalNetworkInterfaceId = physicalNetworkInterfaceId
        }
    }

}

extension SnowDeviceManagementClientTypes.Reboot: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SnowDeviceManagementClientTypes {
    /// A structure used to reboot the device.
    public struct Reboot: Swift.Equatable {

        public init () { }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request references a resource that doesn't exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowDeviceManagementClientTypes.ResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// A summary of a resource available on the device.
    public struct ResourceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var arn: Swift.String?
        /// The ID of the resource.
        public var id: Swift.String?
        /// The resource type.
        /// This member is required.
        public var resourceType: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.resourceType = resourceType
        }
    }

}

extension SnowDeviceManagementClientTypes.SecurityGroupIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// Information about the device's security group.
    public struct SecurityGroupIdentifier: Swift.Equatable {
        /// The security group ID.
        public var groupId: Swift.String?
        /// The security group name.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowDeviceManagementClientTypes.SoftwareInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case installState
        case installedVersion
        case installingVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let installState = self.installState {
            try encodeContainer.encode(installState, forKey: .installState)
        }
        if let installedVersion = self.installedVersion {
            try encodeContainer.encode(installedVersion, forKey: .installedVersion)
        }
        if let installingVersion = self.installingVersion {
            try encodeContainer.encode(installingVersion, forKey: .installingVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let installedVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installedVersion)
        installedVersion = installedVersionDecoded
        let installingVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installingVersion)
        installingVersion = installingVersionDecoded
        let installStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .installState)
        installState = installStateDecoded
    }
}

extension SnowDeviceManagementClientTypes {
    /// Information about the software on the device.
    public struct SoftwareInformation: Swift.Equatable {
        /// The state of the software that is installed or that is being installed on the device.
        public var installState: Swift.String?
        /// The version of the software currently installed on the device.
        public var installedVersion: Swift.String?
        /// The version of the software being installed on the device.
        public var installingVersion: Swift.String?

        public init (
            installState: Swift.String? = nil,
            installedVersion: Swift.String? = nil,
            installingVersion: Swift.String? = nil
        )
        {
            self.installState = installState
            self.installedVersion = installedVersion
            self.installingVersion = installingVersion
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension SnowDeviceManagementClientTypes {
    public enum TaskState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case completed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskState] {
            return [
                .canceled,
                .completed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskState(rawValue: rawValue) ?? TaskState.sdkUnknown(rawValue)
        }
    }
}

extension SnowDeviceManagementClientTypes.TaskSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case tags
        case taskArn
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let taskArn = self.taskArn {
            try encodeContainer.encode(taskArn, forKey: .taskArn)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let taskArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskArn)
        taskArn = taskArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SnowDeviceManagementClientTypes.TaskState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SnowDeviceManagementClientTypes {
    /// Information about the task assigned to one or many devices.
    public struct TaskSummary: Swift.Equatable {
        /// The state of the task assigned to one or many devices.
        public var state: SnowDeviceManagementClientTypes.TaskState?
        /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
        public var tags: [Swift.String:Swift.String]?
        /// The Amazon Resource Name (ARN) of the task.
        public var taskArn: Swift.String?
        /// The task ID.
        /// This member is required.
        public var taskId: Swift.String?

        public init (
            state: SnowDeviceManagementClientTypes.TaskState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            taskArn: Swift.String? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.state = state
            self.tags = tags
            self.taskArn = taskArn
            self.taskId = taskId
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SnowDeviceManagementClientTypes.Unlock: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension SnowDeviceManagementClientTypes {
    /// A structure used to unlock a device.
    public struct Unlock: Swift.Equatable {

        public init () { }
    }

}

extension SnowDeviceManagementClientTypes {
    public enum UnlockState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case locked
        case unlocked
        case unlocking
        case sdkUnknown(Swift.String)

        public static var allCases: [UnlockState] {
            return [
                .locked,
                .unlocked,
                .unlocking,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .locked: return "LOCKED"
            case .unlocked: return "UNLOCKED"
            case .unlocking: return "UNLOCKING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UnlockState(rawValue: rawValue) ?? UnlockState.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the device or task.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Optional metadata that you assign to a resource. You can use tags to categorize a resource in different ways, such as by purpose, owner, or environment.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
