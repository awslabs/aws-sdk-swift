// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GetPersonalizedRankingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputList = inputList {
            var inputListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputList)
            for itemid0 in inputList {
                try inputListContainer.encode(itemid0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetPersonalizedRankingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/personalize-ranking"
    }
}

public struct GetPersonalizedRankingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to use for generating the personalized ranking.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The contextual metadata to use when getting recommendations. Contextual metadata includes any interaction information that might be relevant when getting a user's recommendations, such as the user's current location or device type.
    public var context: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of a filter you created to include items or exclude items from recommendations for a given user. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterArn: Swift.String?
    /// The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values.In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterValues: [Swift.String:Swift.String]?
    /// A list of items (by itemId) to rank. If an item was not included in the training dataset, the item is appended to the end of the reranked list. The maximum is 500.
    /// This member is required.
    public var inputList: [Swift.String]?
    /// The user for which you want the campaign to provide a personalized ranking.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        campaignArn: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        filterArn: Swift.String? = nil,
        filterValues: [Swift.String:Swift.String]? = nil,
        inputList: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.inputList = inputList
        self.userId = userId
    }
}

struct GetPersonalizedRankingInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let inputList: [Swift.String]?
    let userId: Swift.String?
    let context: [Swift.String:Swift.String]?
    let filterArn: Swift.String?
    let filterValues: [Swift.String:Swift.String]?
}

extension GetPersonalizedRankingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let inputListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inputList)
        var inputListDecoded0:[Swift.String]? = nil
        if let inputListContainer = inputListContainer {
            inputListDecoded0 = [Swift.String]()
            for string0 in inputListContainer {
                if let string0 = string0 {
                    inputListDecoded0?.append(string0)
                }
            }
        }
        inputList = inputListDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension GetPersonalizedRankingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPersonalizedRankingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPersonalizedRankingOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPersonalizedRankingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPersonalizedRankingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.personalizedRanking = output.personalizedRanking
            self.recommendationId = output.recommendationId
        } else {
            self.personalizedRanking = nil
            self.recommendationId = nil
        }
    }
}

public struct GetPersonalizedRankingOutputResponse: Swift.Equatable {
    /// A list of items in order of most likely interest to the user. The maximum is 500.
    public var personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]?
    /// The ID of the recommendation.
    public var recommendationId: Swift.String?

    public init (
        personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.personalizedRanking = personalizedRanking
        self.recommendationId = recommendationId
    }
}

struct GetPersonalizedRankingOutputResponseBody: Swift.Equatable {
    let personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]?
    let recommendationId: Swift.String?
}

extension GetPersonalizedRankingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case personalizedRanking
        case recommendationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personalizedRankingContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.PredictedItem?].self, forKey: .personalizedRanking)
        var personalizedRankingDecoded0:[PersonalizeRuntimeClientTypes.PredictedItem]? = nil
        if let personalizedRankingContainer = personalizedRankingContainer {
            personalizedRankingDecoded0 = [PersonalizeRuntimeClientTypes.PredictedItem]()
            for structure0 in personalizedRankingContainer {
                if let structure0 = structure0 {
                    personalizedRankingDecoded0?.append(structure0)
                }
            }
        }
        personalizedRanking = personalizedRankingDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

extension GetRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case promotions
        case recommenderArn
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if numResults != 0 {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let promotions = promotions {
            var promotionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .promotions)
            for promotion0 in promotions {
                try promotionsContainer.encode(promotion0)
            }
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recommendations"
    }
}

public struct GetRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to use for getting recommendations.
    public var campaignArn: Swift.String?
    /// The contextual metadata to use when getting recommendations. Contextual metadata includes any interaction information that might be relevant when getting a user's recommendations, such as the user's current location or device type.
    public var context: [Swift.String:Swift.String]?
    /// The ARN of the filter to apply to the returned recommendations. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html). When using this parameter, be sure the filter resource is ACTIVE.
    public var filterArn: Swift.String?
    /// The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values.In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information, see [Filtering recommendations and user segments](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterValues: [Swift.String:Swift.String]?
    /// The item ID to provide recommendations for. Required for RELATED_ITEMS recipe type.
    public var itemId: Swift.String?
    /// The number of results to return. The default is 25. The maximum is 500.
    public var numResults: Swift.Int
    /// The promotions to apply to the recommendation request. A promotion defines additional business rules that apply to a configurable subset of recommended items.
    public var promotions: [PersonalizeRuntimeClientTypes.Promotion]?
    /// The Amazon Resource Name (ARN) of the recommender to use to get recommendations. Provide a recommender ARN if you created a Domain dataset group with a recommender for a domain use case.
    public var recommenderArn: Swift.String?
    /// The user ID to provide recommendations for. Required for USER_PERSONALIZATION recipe type.
    public var userId: Swift.String?

    public init (
        campaignArn: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        filterArn: Swift.String? = nil,
        filterValues: [Swift.String:Swift.String]? = nil,
        itemId: Swift.String? = nil,
        numResults: Swift.Int = 0,
        promotions: [PersonalizeRuntimeClientTypes.Promotion]? = nil,
        recommenderArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.itemId = itemId
        self.numResults = numResults
        self.promotions = promotions
        self.recommenderArn = recommenderArn
        self.userId = userId
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let itemId: Swift.String?
    let userId: Swift.String?
    let numResults: Swift.Int
    let context: [Swift.String:Swift.String]?
    let filterArn: Swift.String?
    let filterValues: [Swift.String:Swift.String]?
    let recommenderArn: Swift.String?
    let promotions: [PersonalizeRuntimeClientTypes.Promotion]?
}

extension GetRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case promotions
        case recommenderArn
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults) ?? 0
        numResults = numResultsDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let promotionsContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.Promotion?].self, forKey: .promotions)
        var promotionsDecoded0:[PersonalizeRuntimeClientTypes.Promotion]? = nil
        if let promotionsContainer = promotionsContainer {
            promotionsDecoded0 = [PersonalizeRuntimeClientTypes.Promotion]()
            for structure0 in promotionsContainer {
                if let structure0 = structure0 {
                    promotionsDecoded0?.append(structure0)
                }
            }
        }
        promotions = promotionsDecoded0
    }
}

extension GetRecommendationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecommendationsOutputError: Swift.Error, Swift.Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.itemList = output.itemList
            self.recommendationId = output.recommendationId
        } else {
            self.itemList = nil
            self.recommendationId = nil
        }
    }
}

public struct GetRecommendationsOutputResponse: Swift.Equatable {
    /// A list of recommendations sorted in descending order by prediction score. There can be a maximum of 500 items in the list.
    public var itemList: [PersonalizeRuntimeClientTypes.PredictedItem]?
    /// The ID of the recommendation.
    public var recommendationId: Swift.String?

    public init (
        itemList: [PersonalizeRuntimeClientTypes.PredictedItem]? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.itemList = itemList
        self.recommendationId = recommendationId
    }
}

struct GetRecommendationsOutputResponseBody: Swift.Equatable {
    let itemList: [PersonalizeRuntimeClientTypes.PredictedItem]?
    let recommendationId: Swift.String?
}

extension GetRecommendationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemList
        case recommendationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemListContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.PredictedItem?].self, forKey: .itemList)
        var itemListDecoded0:[PersonalizeRuntimeClientTypes.PredictedItem]? = nil
        if let itemListContainer = itemListContainer {
            itemListDecoded0 = [PersonalizeRuntimeClientTypes.PredictedItem]()
            for structure0 in itemListContainer {
                if let structure0 = structure0 {
                    itemListDecoded0?.append(structure0)
                }
            }
        }
        itemList = itemListDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

extension InvalidInputException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeRuntimeClientTypes.PredictedItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemId
        case promotionName
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let promotionName = self.promotionName {
            try encodeContainer.encode(promotionName, forKey: .promotionName)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let promotionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promotionName)
        promotionName = promotionNameDecoded
    }
}

extension PersonalizeRuntimeClientTypes {
    /// An object that identifies an item. The and APIs return a list of PredictedItems.
    public struct PredictedItem: Swift.Equatable {
        /// The recommended item ID.
        public var itemId: Swift.String?
        /// The name of the promotion that included the predicted item.
        public var promotionName: Swift.String?
        /// A numeric representation of the model's certainty that the item will be the next user selection. For more information on scoring logic, see [how-scores-work].
        public var score: Swift.Double?

        public init (
            itemId: Swift.String? = nil,
            promotionName: Swift.String? = nil,
            score: Swift.Double? = nil
        )
        {
            self.itemId = itemId
            self.promotionName = promotionName
            self.score = score
        }
    }

}

extension PersonalizeRuntimeClientTypes.Promotion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case filterValues
        case name
        case percentPromotedItems
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if percentPromotedItems != 0 {
            try encodeContainer.encode(percentPromotedItems, forKey: .percentPromotedItems)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let percentPromotedItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentPromotedItems) ?? 0
        percentPromotedItems = percentPromotedItemsDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension PersonalizeRuntimeClientTypes {
    /// Contains information on a promotion. A promotion defines additional business rules that apply to a configurable subset of recommended items.
    public struct Promotion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the filter used by the promotion. This filter defines the criteria for promoted items. For more information, see [Promotion filters](https://docs.aws.amazon.com/personalize/latest/dg/promoting-items.html#promotion-filters).
        public var filterArn: Swift.String?
        /// The values to use when promoting items. For each placeholder parameter in your promotion's filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values. In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information on creating filters, see [Filtering recommendations and user segments](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
        public var filterValues: [Swift.String:Swift.String]?
        /// The name of the promotion.
        public var name: Swift.String?
        /// The percentage of recommended items to apply the promotion to.
        public var percentPromotedItems: Swift.Int

        public init (
            filterArn: Swift.String? = nil,
            filterValues: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            percentPromotedItems: Swift.Int = 0
        )
        {
            self.filterArn = filterArn
            self.filterValues = filterValues
            self.name = name
            self.percentPromotedItems = percentPromotedItems
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
