// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension GetPersonalizedRankingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputList = inputList {
            var inputListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputList)
            for itemid0 in inputList {
                try inputListContainer.encode(itemid0)
            }
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetPersonalizedRankingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/personalize-ranking"
    }
}

public struct GetPersonalizedRankingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to use for generating the personalized ranking.
    /// This member is required.
    public var campaignArn: Swift.String?
    /// The contextual metadata to use when getting recommendations. Contextual metadata includes any interaction information that might be relevant when getting a user's recommendations, such as the user's current location or device type.
    public var context: [Swift.String:Swift.String]?
    /// The Amazon Resource Name (ARN) of a filter you created to include items or exclude items from recommendations for a given user. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterArn: Swift.String?
    /// The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values.In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterValues: [Swift.String:Swift.String]?
    /// A list of items (by itemId) to rank. If an item was not included in the training dataset, the item is appended to the end of the reranked list. The maximum is 500.
    /// This member is required.
    public var inputList: [Swift.String]?
    /// The user for which you want the campaign to provide a personalized ranking.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        campaignArn: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        filterArn: Swift.String? = nil,
        filterValues: [Swift.String:Swift.String]? = nil,
        inputList: [Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.inputList = inputList
        self.userId = userId
    }
}

struct GetPersonalizedRankingInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let inputList: [Swift.String]?
    let userId: Swift.String?
    let context: [Swift.String:Swift.String]?
    let filterArn: Swift.String?
    let filterValues: [Swift.String:Swift.String]?
}

extension GetPersonalizedRankingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case inputList
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let inputListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .inputList)
        var inputListDecoded0:[Swift.String]? = nil
        if let inputListContainer = inputListContainer {
            inputListDecoded0 = [Swift.String]()
            for string0 in inputListContainer {
                if let string0 = string0 {
                    inputListDecoded0?.append(string0)
                }
            }
        }
        inputList = inputListDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension GetPersonalizedRankingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPersonalizedRankingOutputBody = try responseDecoder.decode(responseBody: data)
            self.personalizedRanking = output.personalizedRanking
            self.recommendationId = output.recommendationId
        } else {
            self.personalizedRanking = nil
            self.recommendationId = nil
        }
    }
}

public struct GetPersonalizedRankingOutput: Swift.Equatable {
    /// A list of items in order of most likely interest to the user. The maximum is 500.
    public var personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]?
    /// The ID of the recommendation.
    public var recommendationId: Swift.String?

    public init(
        personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.personalizedRanking = personalizedRanking
        self.recommendationId = recommendationId
    }
}

struct GetPersonalizedRankingOutputBody: Swift.Equatable {
    let personalizedRanking: [PersonalizeRuntimeClientTypes.PredictedItem]?
    let recommendationId: Swift.String?
}

extension GetPersonalizedRankingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case personalizedRanking
        case recommendationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personalizedRankingContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.PredictedItem?].self, forKey: .personalizedRanking)
        var personalizedRankingDecoded0:[PersonalizeRuntimeClientTypes.PredictedItem]? = nil
        if let personalizedRankingContainer = personalizedRankingContainer {
            personalizedRankingDecoded0 = [PersonalizeRuntimeClientTypes.PredictedItem]()
            for structure0 in personalizedRankingContainer {
                if let structure0 = structure0 {
                    personalizedRankingDecoded0?.append(structure0)
                }
            }
        }
        personalizedRanking = personalizedRankingDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

enum GetPersonalizedRankingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case promotions
        case recommenderArn
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignArn = self.campaignArn {
            try encodeContainer.encode(campaignArn, forKey: .campaignArn)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .context)
            for (dictKey0, context0) in context {
                try contextContainer.encode(context0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let numResults = self.numResults {
            try encodeContainer.encode(numResults, forKey: .numResults)
        }
        if let promotions = promotions {
            var promotionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .promotions)
            for promotion0 in promotions {
                try promotionsContainer.encode(promotion0)
            }
        }
        if let recommenderArn = self.recommenderArn {
            try encodeContainer.encode(recommenderArn, forKey: .recommenderArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension GetRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/recommendations"
    }
}

public struct GetRecommendationsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the campaign to use for getting recommendations.
    public var campaignArn: Swift.String?
    /// The contextual metadata to use when getting recommendations. Contextual metadata includes any interaction information that might be relevant when getting a user's recommendations, such as the user's current location or device type.
    public var context: [Swift.String:Swift.String]?
    /// The ARN of the filter to apply to the returned recommendations. For more information, see [Filtering Recommendations](https://docs.aws.amazon.com/personalize/latest/dg/filter.html). When using this parameter, be sure the filter resource is ACTIVE.
    public var filterArn: Swift.String?
    /// The values to use when filtering recommendations. For each placeholder parameter in your filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values.In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information, see [Filtering recommendations and user segments](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
    public var filterValues: [Swift.String:Swift.String]?
    /// The item ID to provide recommendations for. Required for RELATED_ITEMS recipe type.
    public var itemId: Swift.String?
    /// The number of results to return. The default is 25. The maximum is 500.
    public var numResults: Swift.Int?
    /// The promotions to apply to the recommendation request. A promotion defines additional business rules that apply to a configurable subset of recommended items.
    public var promotions: [PersonalizeRuntimeClientTypes.Promotion]?
    /// The Amazon Resource Name (ARN) of the recommender to use to get recommendations. Provide a recommender ARN if you created a Domain dataset group with a recommender for a domain use case.
    public var recommenderArn: Swift.String?
    /// The user ID to provide recommendations for. Required for USER_PERSONALIZATION recipe type.
    public var userId: Swift.String?

    public init(
        campaignArn: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        filterArn: Swift.String? = nil,
        filterValues: [Swift.String:Swift.String]? = nil,
        itemId: Swift.String? = nil,
        numResults: Swift.Int? = nil,
        promotions: [PersonalizeRuntimeClientTypes.Promotion]? = nil,
        recommenderArn: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.campaignArn = campaignArn
        self.context = context
        self.filterArn = filterArn
        self.filterValues = filterValues
        self.itemId = itemId
        self.numResults = numResults
        self.promotions = promotions
        self.recommenderArn = recommenderArn
        self.userId = userId
    }
}

struct GetRecommendationsInputBody: Swift.Equatable {
    let campaignArn: Swift.String?
    let itemId: Swift.String?
    let userId: Swift.String?
    let numResults: Swift.Int?
    let context: [Swift.String:Swift.String]?
    let filterArn: Swift.String?
    let filterValues: [Swift.String:Swift.String]?
    let recommenderArn: Swift.String?
    let promotions: [PersonalizeRuntimeClientTypes.Promotion]?
}

extension GetRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case campaignArn
        case context
        case filterArn
        case filterValues
        case itemId
        case numResults
        case promotions
        case recommenderArn
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .campaignArn)
        campaignArn = campaignArnDecoded
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let numResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numResults)
        numResults = numResultsDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in contextContainer {
                if let attributevalue0 = attributevalue0 {
                    contextDecoded0?[key0] = attributevalue0
                }
            }
        }
        context = contextDecoded0
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
        let recommenderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommenderArn)
        recommenderArn = recommenderArnDecoded
        let promotionsContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.Promotion?].self, forKey: .promotions)
        var promotionsDecoded0:[PersonalizeRuntimeClientTypes.Promotion]? = nil
        if let promotionsContainer = promotionsContainer {
            promotionsDecoded0 = [PersonalizeRuntimeClientTypes.Promotion]()
            for structure0 in promotionsContainer {
                if let structure0 = structure0 {
                    promotionsDecoded0?.append(structure0)
                }
            }
        }
        promotions = promotionsDecoded0
    }
}

extension GetRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.itemList = output.itemList
            self.recommendationId = output.recommendationId
        } else {
            self.itemList = nil
            self.recommendationId = nil
        }
    }
}

public struct GetRecommendationsOutput: Swift.Equatable {
    /// A list of recommendations sorted in descending order by prediction score. There can be a maximum of 500 items in the list.
    public var itemList: [PersonalizeRuntimeClientTypes.PredictedItem]?
    /// The ID of the recommendation.
    public var recommendationId: Swift.String?

    public init(
        itemList: [PersonalizeRuntimeClientTypes.PredictedItem]? = nil,
        recommendationId: Swift.String? = nil
    )
    {
        self.itemList = itemList
        self.recommendationId = recommendationId
    }
}

struct GetRecommendationsOutputBody: Swift.Equatable {
    let itemList: [PersonalizeRuntimeClientTypes.PredictedItem]?
    let recommendationId: Swift.String?
}

extension GetRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemList
        case recommendationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemListContainer = try containerValues.decodeIfPresent([PersonalizeRuntimeClientTypes.PredictedItem?].self, forKey: .itemList)
        var itemListDecoded0:[PersonalizeRuntimeClientTypes.PredictedItem]? = nil
        if let itemListContainer = itemListContainer {
            itemListDecoded0 = [PersonalizeRuntimeClientTypes.PredictedItem]()
            for structure0 in itemListContainer {
                if let structure0 = structure0 {
                    itemListDecoded0?.append(structure0)
                }
            }
        }
        itemList = itemListDecoded0
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

enum GetRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidInputException": return try await InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidInputException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Provide a valid value for the field or parameter.
public struct InvalidInputException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInputException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidInputExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidInputExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PersonalizeRuntimeClientTypes.PredictedItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemId
        case promotionName
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let itemId = self.itemId {
            try encodeContainer.encode(itemId, forKey: .itemId)
        }
        if let promotionName = self.promotionName {
            try encodeContainer.encode(promotionName, forKey: .promotionName)
        }
        if let score = self.score {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .itemId)
        itemId = itemIdDecoded
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score)
        score = scoreDecoded
        let promotionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .promotionName)
        promotionName = promotionNameDecoded
    }
}

extension PersonalizeRuntimeClientTypes {
    /// An object that identifies an item. The and APIs return a list of PredictedItems.
    public struct PredictedItem: Swift.Equatable {
        /// The recommended item ID.
        public var itemId: Swift.String?
        /// The name of the promotion that included the predicted item.
        public var promotionName: Swift.String?
        /// A numeric representation of the model's certainty that the item will be the next user selection. For more information on scoring logic, see [how-scores-work].
        public var score: Swift.Double?

        public init(
            itemId: Swift.String? = nil,
            promotionName: Swift.String? = nil,
            score: Swift.Double? = nil
        )
        {
            self.itemId = itemId
            self.promotionName = promotionName
            self.score = score
        }
    }

}

extension PersonalizeRuntimeClientTypes.Promotion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterArn
        case filterValues
        case name
        case percentPromotedItems
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterArn = self.filterArn {
            try encodeContainer.encode(filterArn, forKey: .filterArn)
        }
        if let filterValues = filterValues {
            var filterValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filterValues)
            for (dictKey0, filterValues0) in filterValues {
                try filterValuesContainer.encode(filterValues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if percentPromotedItems != 0 {
            try encodeContainer.encode(percentPromotedItems, forKey: .percentPromotedItems)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let percentPromotedItemsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentPromotedItems) ?? 0
        percentPromotedItems = percentPromotedItemsDecoded
        let filterArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterArn)
        filterArn = filterArnDecoded
        let filterValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .filterValues)
        var filterValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let filterValuesContainer = filterValuesContainer {
            filterValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, filterattributevalue0) in filterValuesContainer {
                if let filterattributevalue0 = filterattributevalue0 {
                    filterValuesDecoded0?[key0] = filterattributevalue0
                }
            }
        }
        filterValues = filterValuesDecoded0
    }
}

extension PersonalizeRuntimeClientTypes {
    /// Contains information on a promotion. A promotion defines additional business rules that apply to a configurable subset of recommended items.
    public struct Promotion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the filter used by the promotion. This filter defines the criteria for promoted items. For more information, see [Promotion filters](https://docs.aws.amazon.com/personalize/latest/dg/promoting-items.html#promotion-filters).
        public var filterArn: Swift.String?
        /// The values to use when promoting items. For each placeholder parameter in your promotion's filter expression, provide the parameter name (in matching case) as a key and the filter value(s) as the corresponding value. Separate multiple values for one parameter with a comma. For filter expressions that use an INCLUDE element to include items, you must provide values for all parameters that are defined in the expression. For filters with expressions that use an EXCLUDE element to exclude items, you can omit the filter-values. In this case, Amazon Personalize doesn't use that portion of the expression to filter recommendations. For more information on creating filters, see [Filtering recommendations and user segments](https://docs.aws.amazon.com/personalize/latest/dg/filter.html).
        public var filterValues: [Swift.String:Swift.String]?
        /// The name of the promotion.
        public var name: Swift.String?
        /// The percentage of recommended items to apply the promotion to.
        public var percentPromotedItems: Swift.Int

        public init(
            filterArn: Swift.String? = nil,
            filterValues: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            percentPromotedItems: Swift.Int = 0
        )
        {
            self.filterArn = filterArn
            self.filterValues = filterValues
            self.name = name
            self.percentPromotedItems = percentPromotedItems
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
