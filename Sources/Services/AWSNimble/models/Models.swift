// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptEulasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for string0 in eulaIds {
                try eulaIdsContainer.encode(string0)
            }
        }
    }
}

extension AcceptEulasInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension AcceptEulasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

public struct AcceptEulasInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EULA ID.
    public var eulaIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eulaIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eulaIds = eulaIds
        self.studioId = studioId
    }
}

struct AcceptEulasInputBody: Swift.Equatable {
    let eulaIds: [Swift.String]?
}

extension AcceptEulasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
    }
}

extension AcceptEulasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AcceptEulasOutputBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
        } else {
            self.eulaAcceptances = nil
        }
    }
}

public struct AcceptEulasOutput: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?

    public init(
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
    }
}

struct AcceptEulasOutputBody: Swift.Equatable {
    let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
}

extension AcceptEulasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
    }
}

enum AcceptEulasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryComputerAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes {
    /// An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.
    public struct ActiveDirectoryComputerAttribute: Swift.Equatable {
        /// The name for the LDAP attribute.
        public var name: Swift.String?
        /// The value for the LDAP attribute.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes
        case directoryId
        case organizationalUnitDistinguishedName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattribute0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattribute0)
            }
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let organizationalUnitDistinguishedName = self.organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryConfiguration(directoryId: \(Swift.String(describing: directoryId)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), computerAttributes: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
    public struct ActiveDirectoryConfiguration: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public var directoryId: Swift.String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init(
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension NimbleClientTypes {
    public enum AutomaticTerminationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomaticTerminationMode] {
            return [
                .activated,
                .deactivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutomaticTerminationMode(rawValue: rawValue) ?? AutomaticTerminationMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectoryUser
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectoryUser = self.activeDirectoryUser {
            try encodeContainer.encode(activeDirectoryUser, forKey: .activeDirectoryUser)
        }
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryUserDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activeDirectoryUser)
        activeDirectoryUser = activeDirectoryUserDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeFarmConfiguration(activeDirectoryUser: \(Swift.String(describing: activeDirectoryUser)), endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a render farm that is associated with a studio resource.
    public struct ComputeFarmConfiguration: Swift.Equatable {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public var activeDirectoryUser: Swift.String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init(
            activeDirectoryUser: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Another operation is in progress.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2SubnetIds
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetid0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetid0)
            }
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversion0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversion0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for string0 in studioComponentIds {
                try studioComponentIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

public struct CreateLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
    /// This member is required.
    public var ec2SubnetIds: [Swift.String]?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    /// This member is required.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    /// This member is required.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    /// This member is required.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2SubnetIds: [Swift.String]? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateLaunchProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let ec2SubnetIds: [Swift.String]?
    let launchProfileProtocolVersions: [Swift.String]?
    let name: Swift.String?
    let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    let studioComponentIds: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2SubnetIds
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLaunchProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLaunchProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct CreateLaunchProfileOutput: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct CreateLaunchProfileOutputBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension CreateLaunchProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

enum CreateLaunchProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateStreamingImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2ImageId
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = self.ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

public struct CreateStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A human-readable description of the streaming image.
    public var description: Swift.String?
    /// The ID of an EC2 machine image with which to create this streaming image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// A friendly name for a streaming image resource.
    /// This member is required.
    public var name: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2ImageId: Swift.String? = nil,
        name: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.name = name
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingImageInputBody: Swift.Equatable {
    let description: Swift.String?
    let ec2ImageId: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case ec2ImageId
        case name
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamingImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct CreateStreamingImageOutput: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct CreateStreamingImageOutputBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension CreateStreamingImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

enum CreateStreamingImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamingSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType
        case launchProfileId
        case ownedBy
        case streamingImageId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceType = self.ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType.rawValue, forKey: .ec2InstanceType)
        }
        if let launchProfileId = self.launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let streamingImageId = self.streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

public struct CreateStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EC2 Instance type used for the streaming session.
    public var ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
    public var ownedBy: Swift.String?
    /// The ID of the streaming image.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        ec2InstanceType: NimbleClientTypes.StreamingInstanceType? = nil,
        launchProfileId: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.ownedBy = ownedBy
        self.streamingImageId = streamingImageId
        self.studioId = studioId
        self.tags = tags
    }
}

struct CreateStreamingSessionInputBody: Swift.Equatable {
    let ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    let launchProfileId: Swift.String?
    let ownedBy: Swift.String?
    let streamingImageId: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamingSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceType
        case launchProfileId
        case ownedBy
        case streamingImageId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingInstanceType.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamingSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamingSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct CreateStreamingSessionOutput: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct CreateStreamingSessionOutputBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension CreateStreamingSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

enum CreateStreamingSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamingSessionStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationInSeconds = self.expirationInSeconds {
            try encodeContainer.encode(expirationInSeconds, forKey: .expirationInSeconds)
        }
    }
}

extension CreateStreamingSessionStreamInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams"
    }
}

public struct CreateStreamingSessionStreamInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The expiration time in seconds.
    public var expirationInSeconds: Swift.Int?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        expirationInSeconds: Swift.Int? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInSeconds = expirationInSeconds
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct CreateStreamingSessionStreamInputBody: Swift.Equatable {
    let expirationInSeconds: Swift.Int?
}

extension CreateStreamingSessionStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationInSeconds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationInSeconds)
        expirationInSeconds = expirationInSecondsDecoded
    }
}

extension CreateStreamingSessionStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamingSessionStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct CreateStreamingSessionStreamOutput: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init(
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct CreateStreamingSessionStreamOutputBody: Swift.Equatable {
    let stream: NimbleClientTypes.StreamingSessionStream?
}

extension CreateStreamingSessionStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

enum CreateStreamingSessionStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

extension CreateStudioComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case subtype
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for securitygroupid0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscript0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscript0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for scriptparameterkeyvalue0 in scriptParameters {
                try scriptParametersContainer.encode(scriptparameterkeyvalue0)
            }
        }
        if let secureInitializationRoleArn = self.secureInitializationRoleArn {
            try encodeContainer.encode(secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

public struct CreateStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    /// This member is required.
    public var name: Swift.String?
    /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    public var runtimeRoleArn: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    public var secureInitializationRoleArn: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the studio component.
    /// This member is required.
    public var type: NimbleClientTypes.StudioComponentType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.scriptParameters = scriptParameters
        self.secureInitializationRoleArn = secureInitializationRoleArn
        self.studioId = studioId
        self.subtype = subtype
        self.tags = tags
        self.type = type
    }
}

struct CreateStudioComponentInputBody: Swift.Equatable {
    let configuration: NimbleClientTypes.StudioComponentConfiguration?
    let description: Swift.String?
    let ec2SecurityGroupIds: [Swift.String]?
    let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    let name: Swift.String?
    let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    let subtype: NimbleClientTypes.StudioComponentSubtype?
    let tags: [Swift.String:Swift.String]?
    let type: NimbleClientTypes.StudioComponentType?
    let secureInitializationRoleArn: Swift.String?
    let runtimeRoleArn: Swift.String?
}

extension CreateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case subtype
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let secureInitializationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secureInitializationRoleArn)
        secureInitializationRoleArn = secureInitializationRoleArnDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
    }
}

extension CreateStudioComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStudioComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct CreateStudioComponentOutput: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct CreateStudioComponentOutputBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension CreateStudioComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

enum CreateStudioComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioName: \(Swift.String(describing: studioName)), tags: \(Swift.String(describing: tags)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension CreateStudioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case studioEncryptionConfiguration
        case studioName
        case tags
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = self.adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let studioEncryptionConfiguration = self.studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioName = self.studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userRoleArn = self.userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

extension CreateStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/studios"
    }
}

public struct CreateStudioInput: Swift.Equatable {
    /// The IAM role that studio admins will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    /// This member is required.
    public var displayName: Swift.String?
    /// The studio encryption configuration.
    public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
    /// This member is required.
    public var studioName: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?
    /// The IAM role that studio users will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var userRoleArn: Swift.String?

    public init(
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
        studioName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioName = studioName
        self.tags = tags
        self.userRoleArn = userRoleArn
    }
}

struct CreateStudioInputBody: Swift.Equatable {
    let adminRoleArn: Swift.String?
    let displayName: Swift.String?
    let studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    let studioName: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let userRoleArn: Swift.String?
}

extension CreateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case studioEncryptionConfiguration
        case studioName
        case tags
        case userRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension CreateStudioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStudioOutputBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct CreateStudioOutput: Swift.Equatable {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct CreateStudioOutputBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension CreateStudioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

enum CreateStudioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

public struct DeleteLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct DeleteLaunchProfileMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteLaunchProfileMemberInputBody: Swift.Equatable {
}

extension DeleteLaunchProfileMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLaunchProfileMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLaunchProfileMemberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLaunchProfileMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLaunchProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct DeleteLaunchProfileOutput: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct DeleteLaunchProfileOutputBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension DeleteLaunchProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

enum DeleteLaunchProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

public struct DeleteStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct DeleteStreamingImageInputBody: Swift.Equatable {
}

extension DeleteStreamingImageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteStreamingImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct DeleteStreamingImageOutput: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct DeleteStreamingImageOutputBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension DeleteStreamingImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

enum DeleteStreamingImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct DeleteStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct DeleteStreamingSessionInputBody: Swift.Equatable {
}

extension DeleteStreamingSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStreamingSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteStreamingSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct DeleteStreamingSessionOutput: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct DeleteStreamingSessionOutputBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension DeleteStreamingSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

enum DeleteStreamingSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

public struct DeleteStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct DeleteStudioComponentInputBody: Swift.Equatable {
}

extension DeleteStudioComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteStudioComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct DeleteStudioComponentOutput: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct DeleteStudioComponentOutputBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension DeleteStudioComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

enum DeleteStudioComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

public struct DeleteStudioInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct DeleteStudioInputBody: Swift.Equatable {
}

extension DeleteStudioInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct DeleteStudioMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct DeleteStudioMemberInputBody: Swift.Equatable {
}

extension DeleteStudioMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteStudioMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStudioMemberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStudioMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStudioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteStudioOutputBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct DeleteStudioOutput: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct DeleteStudioOutputBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension DeleteStudioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

enum DeleteStudioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NimbleClientTypes.Eula: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case createdAt
        case eulaId
        case name
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let eulaId = self.eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension NimbleClientTypes {
    /// Represents a EULA resource.
    public struct Eula: Swift.Equatable {
        /// The EULA content.
        public var content: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The EULA ID.
        public var eulaId: Swift.String?
        /// The name for the EULA.
        public var name: Swift.String?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            content: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            eulaId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

extension NimbleClientTypes.EulaAcceptance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedAt
        case acceptedBy
        case accepteeId
        case eulaAcceptanceId
        case eulaId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedAt = self.acceptedAt {
            try encodeContainer.encodeTimestamp(acceptedAt, format: .dateTime, forKey: .acceptedAt)
        }
        if let acceptedBy = self.acceptedBy {
            try encodeContainer.encode(acceptedBy, forKey: .acceptedBy)
        }
        if let accepteeId = self.accepteeId {
            try encodeContainer.encode(accepteeId, forKey: .accepteeId)
        }
        if let eulaAcceptanceId = self.eulaAcceptanceId {
            try encodeContainer.encode(eulaAcceptanceId, forKey: .eulaAcceptanceId)
        }
        if let eulaId = self.eulaId {
            try encodeContainer.encode(eulaId, forKey: .eulaId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .acceptedAt)
        acceptedAt = acceptedAtDecoded
        let acceptedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptedBy)
        acceptedBy = acceptedByDecoded
        let accepteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accepteeId)
        accepteeId = accepteeIdDecoded
        let eulaAcceptanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaAcceptanceId)
        eulaAcceptanceId = eulaAcceptanceIdDecoded
        let eulaIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eulaId)
        eulaId = eulaIdDecoded
    }
}

extension NimbleClientTypes {
    /// The acceptance of a EULA, required to use Amazon-provided streaming images.
    public struct EulaAcceptance: Swift.Equatable {
        /// The ISO timestamp in seconds for when the EULA was accepted.
        public var acceptedAt: ClientRuntime.Date?
        /// The ID of the person who accepted the EULA.
        public var acceptedBy: Swift.String?
        /// The ID of the acceptee.
        public var accepteeId: Swift.String?
        /// The EULA acceptance ID.
        public var eulaAcceptanceId: Swift.String?
        /// The EULA ID.
        public var eulaId: Swift.String?

        public init(
            acceptedAt: ClientRuntime.Date? = nil,
            acceptedBy: Swift.String? = nil,
            accepteeId: Swift.String? = nil,
            eulaAcceptanceId: Swift.String? = nil,
            eulaId: Swift.String? = nil
        )
        {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }
    }

}

extension GetEulaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let eulaId = eulaId else {
            return nil
        }
        return "/2020-08-01/eulas/\(eulaId.urlPercentEncoding())"
    }
}

public struct GetEulaInput: Swift.Equatable {
    /// The EULA ID.
    /// This member is required.
    public var eulaId: Swift.String?

    public init(
        eulaId: Swift.String? = nil
    )
    {
        self.eulaId = eulaId
    }
}

struct GetEulaInputBody: Swift.Equatable {
}

extension GetEulaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEulaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEulaOutputBody = try responseDecoder.decode(responseBody: data)
            self.eula = output.eula
        } else {
            self.eula = nil
        }
    }
}

public struct GetEulaOutput: Swift.Equatable {
    /// The EULA.
    public var eula: NimbleClientTypes.Eula?

    public init(
        eula: NimbleClientTypes.Eula? = nil
    )
    {
        self.eula = eula
    }
}

struct GetEulaOutputBody: Swift.Equatable {
    let eula: NimbleClientTypes.Eula?
}

extension GetEulaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eula
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Eula.self, forKey: .eula)
        eula = eulaDecoded
    }
}

enum GetEulaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchProfileDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/details"
    }
}

public struct GetLaunchProfileDetailsInput: Swift.Equatable {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileDetailsInputBody: Swift.Equatable {
}

extension GetLaunchProfileDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchProfileDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
            self.streamingImages = output.streamingImages
            self.studioComponentSummaries = output.studioComponentSummaries
        } else {
            self.launchProfile = nil
            self.streamingImages = nil
            self.studioComponentSummaries = nil
        }
    }
}

public struct GetLaunchProfileDetailsOutput: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?
    /// A collection of studio component summaries.
    public var studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil,
        studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]? = nil
    )
    {
        self.launchProfile = launchProfile
        self.streamingImages = streamingImages
        self.studioComponentSummaries = studioComponentSummaries
    }
}

struct GetLaunchProfileDetailsOutputBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
    let streamingImages: [NimbleClientTypes.StreamingImage]?
    let studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?
}

extension GetLaunchProfileDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
        case streamingImages
        case studioComponentSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
        let studioComponentSummariesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentSummary?].self, forKey: .studioComponentSummaries)
        var studioComponentSummariesDecoded0:[NimbleClientTypes.StudioComponentSummary]? = nil
        if let studioComponentSummariesContainer = studioComponentSummariesContainer {
            studioComponentSummariesDecoded0 = [NimbleClientTypes.StudioComponentSummary]()
            for structure0 in studioComponentSummariesContainer {
                if let structure0 = structure0 {
                    studioComponentSummariesDecoded0?.append(structure0)
                }
            }
        }
        studioComponentSummaries = studioComponentSummariesDecoded0
    }
}

enum GetLaunchProfileDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchProfileInitializationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let launchProfileProtocolVersions = launchProfileProtocolVersions else {
                let message = "Creating a URL Query Item failed. launchProfileProtocolVersions is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            launchProfileProtocolVersions.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "launchProfileProtocolVersions".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let launchPurpose = launchPurpose else {
                let message = "Creating a URL Query Item failed. launchPurpose is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let launchPurposeQueryItem = ClientRuntime.URLQueryItem(name: "launchPurpose".urlPercentEncoding(), value: Swift.String(launchPurpose).urlPercentEncoding())
            items.append(launchPurposeQueryItem)
            guard let platform = platform else {
                let message = "Creating a URL Query Item failed. platform is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform).urlPercentEncoding())
            items.append(platformQueryItem)
            return items
        }
    }
}

extension GetLaunchProfileInitializationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/init"
    }
}

public struct GetLaunchProfileInitializationInput: Swift.Equatable {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The launch profile protocol versions supported by the client.
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The launch purpose.
    /// This member is required.
    public var launchPurpose: Swift.String?
    /// The platform where this Launch Profile will be used, either Windows or Linux.
    /// This member is required.
    public var platform: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        launchPurpose: Swift.String? = nil,
        platform: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.launchPurpose = launchPurpose
        self.platform = platform
        self.studioId = studioId
    }
}

struct GetLaunchProfileInitializationInputBody: Swift.Equatable {
}

extension GetLaunchProfileInitializationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileInitializationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchProfileInitializationOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfileInitialization = output.launchProfileInitialization
        } else {
            self.launchProfileInitialization = nil
        }
    }
}

public struct GetLaunchProfileInitializationOutput: Swift.Equatable {
    /// The launch profile initialization.
    public var launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?

    public init(
        launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization? = nil
    )
    {
        self.launchProfileInitialization = launchProfileInitialization
    }
}

struct GetLaunchProfileInitializationOutputBody: Swift.Equatable {
    let launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?
}

extension GetLaunchProfileInitializationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileInitialization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileInitializationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitialization.self, forKey: .launchProfileInitialization)
        launchProfileInitialization = launchProfileInitializationDecoded
    }
}

enum GetLaunchProfileInitializationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

public struct GetLaunchProfileInput: Swift.Equatable {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

struct GetLaunchProfileInputBody: Swift.Equatable {
}

extension GetLaunchProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct GetLaunchProfileMemberInput: Swift.Equatable {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetLaunchProfileMemberInputBody: Swift.Equatable {
}

extension GetLaunchProfileMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLaunchProfileMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchProfileMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetLaunchProfileMemberOutput: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init(
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetLaunchProfileMemberOutputBody: Swift.Equatable {
    let member: NimbleClientTypes.LaunchProfileMembership?
}

extension GetLaunchProfileMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

enum GetLaunchProfileMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct GetLaunchProfileOutput: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct GetLaunchProfileOutputBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension GetLaunchProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

enum GetLaunchProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

public struct GetStreamingImageInput: Swift.Equatable {
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct GetStreamingImageInputBody: Swift.Equatable {
}

extension GetStreamingImageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamingImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct GetStreamingImageOutput: Swift.Equatable {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct GetStreamingImageOutputBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension GetStreamingImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

enum GetStreamingImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamingSessionBackupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let backupId = backupId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-session-backups/\(backupId.urlPercentEncoding())"
    }
}

public struct GetStreamingSessionBackupInput: Swift.Equatable {
    /// The ID of the backup.
    /// This member is required.
    public var backupId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.studioId = studioId
    }
}

struct GetStreamingSessionBackupInputBody: Swift.Equatable {
}

extension GetStreamingSessionBackupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionBackupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamingSessionBackupOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingSessionBackup = output.streamingSessionBackup
        } else {
            self.streamingSessionBackup = nil
        }
    }
}

public struct GetStreamingSessionBackupOutput: Swift.Equatable {
    /// Information about the streaming session backup.
    public var streamingSessionBackup: NimbleClientTypes.StreamingSessionBackup?

    public init(
        streamingSessionBackup: NimbleClientTypes.StreamingSessionBackup? = nil
    )
    {
        self.streamingSessionBackup = streamingSessionBackup
    }
}

struct GetStreamingSessionBackupOutputBody: Swift.Equatable {
    let streamingSessionBackup: NimbleClientTypes.StreamingSessionBackup?
}

extension GetStreamingSessionBackupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingSessionBackup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingSessionBackupDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionBackup.self, forKey: .streamingSessionBackup)
        streamingSessionBackup = streamingSessionBackupDecoded
    }
}

enum GetStreamingSessionBackupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

public struct GetStreamingSessionInput: Swift.Equatable {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct GetStreamingSessionInputBody: Swift.Equatable {
}

extension GetStreamingSessionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamingSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct GetStreamingSessionOutput: Swift.Equatable {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct GetStreamingSessionOutputBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension GetStreamingSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

enum GetStreamingSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamingSessionStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        guard let streamId = streamId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams/\(streamId.urlPercentEncoding())"
    }
}

public struct GetStreamingSessionStreamInput: Swift.Equatable {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The streaming session stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        streamId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamId = streamId
        self.studioId = studioId
    }
}

struct GetStreamingSessionStreamInputBody: Swift.Equatable {
}

extension GetStreamingSessionStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStreamingSessionStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamingSessionStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamingSessionStreamOutput: Swift.Equatable {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init(
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamingSessionStreamOutputBody: Swift.Equatable {
    let stream: NimbleClientTypes.StreamingSessionStream?
}

extension GetStreamingSessionStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStream.self, forKey: .stream)
        stream = streamDecoded
    }
}

enum GetStreamingSessionStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

public struct GetStudioComponentInput: Swift.Equatable {
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

struct GetStudioComponentInputBody: Swift.Equatable {
}

extension GetStudioComponentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStudioComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct GetStudioComponentOutput: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct GetStudioComponentOutputBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension GetStudioComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

enum GetStudioComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

public struct GetStudioInput: Swift.Equatable {
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        studioId: Swift.String? = nil
    )
    {
        self.studioId = studioId
    }
}

struct GetStudioInputBody: Swift.Equatable {
}

extension GetStudioInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct GetStudioMemberInput: Swift.Equatable {
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct GetStudioMemberInputBody: Swift.Equatable {
}

extension GetStudioMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetStudioMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStudioMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct GetStudioMemberOutput: Swift.Equatable {
    /// The member.
    public var member: NimbleClientTypes.StudioMembership?

    public init(
        member: NimbleClientTypes.StudioMembership? = nil
    )
    {
        self.member = member
    }
}

struct GetStudioMemberOutputBody: Swift.Equatable {
    let member: NimbleClientTypes.StudioMembership?
}

extension GetStudioMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioMembership.self, forKey: .member)
        member = memberDecoded
    }
}

enum GetStudioMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStudioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStudioOutputBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct GetStudioOutput: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct GetStudioOutputBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension GetStudioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

enum GetStudioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.LaunchProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case createdBy
        case description
        case ec2SubnetIds
        case launchProfileId
        case launchProfileProtocolVersions
        case name
        case state
        case statusCode
        case statusMessage
        case streamConfiguration
        case studioComponentIds
        case tags
        case updatedAt
        case updatedBy
        case validationResults
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SubnetIds = ec2SubnetIds {
            var ec2SubnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SubnetIds)
            for ec2subnetid0 in ec2SubnetIds {
                try ec2SubnetIdsContainer.encode(ec2subnetid0)
            }
        }
        if let launchProfileId = self.launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversion0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversion0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for string0 in studioComponentIds {
                try studioComponentIdsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let validationResults = validationResults {
            var validationResultsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validationResults)
            for validationresult0 in validationResults {
                try validationResultsContainer.encode(validationresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SubnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SubnetIds)
        var ec2SubnetIdsDecoded0:[Swift.String]? = nil
        if let ec2SubnetIdsContainer = ec2SubnetIdsContainer {
            ec2SubnetIdsDecoded0 = [Swift.String]()
            for string0 in ec2SubnetIdsContainer {
                if let string0 = string0 {
                    ec2SubnetIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SubnetIds = ec2SubnetIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfiguration.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let validationResultsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ValidationResult?].self, forKey: .validationResults)
        var validationResultsDecoded0:[NimbleClientTypes.ValidationResult]? = nil
        if let validationResultsContainer = validationResultsContainer {
            validationResultsDecoded0 = [NimbleClientTypes.ValidationResult]()
            for structure0 in validationResultsContainer {
                if let structure0 = structure0 {
                    validationResultsDecoded0?.append(structure0)
                }
            }
        }
        validationResults = validationResultsDecoded0
    }
}

extension NimbleClientTypes.LaunchProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfile(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), validationResults: \(Swift.String(describing: validationResults)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A launch profile controls your artist workforce’s access to studio components, like compute farms, shared file systems, managed file systems, and license server configurations, as well as instance types and Amazon Machine Images (AMIs). Studio administrators create launch profiles in the Nimble Studio console. Artists can use their launch profiles to launch an instance from the Nimble Studio portal. Each user’s launch profile defines how they can launch a streaming session. By default, studio admins can use all launch profiles.
    public struct LaunchProfile: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the launch profile.
        public var createdBy: Swift.String?
        /// A human-readable description of the launch profile.
        public var description: Swift.String?
        /// Unique identifiers for a collection of EC2 subnets.
        public var ec2SubnetIds: [Swift.String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersions: [Swift.String]?
        /// A friendly name for the launch profile.
        public var name: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.LaunchProfileState?
        /// The status code.
        public var statusCode: NimbleClientTypes.LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public var statusMessage: Swift.String?
        /// A configuration for a streaming session.
        public var streamConfiguration: NimbleClientTypes.StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public var studioComponentIds: [Swift.String]?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?
        /// The list of the latest validation results.
        public var validationResults: [NimbleClientTypes.ValidationResult]?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SubnetIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersions: [Swift.String]? = nil,
            name: Swift.String? = nil,
            state: NimbleClientTypes.LaunchProfileState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamConfiguration: NimbleClientTypes.StreamConfiguration? = nil,
            studioComponentIds: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            validationResults: [NimbleClientTypes.ValidationResult]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.validationResults = validationResults
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeDirectory
        case ec2SecurityGroupIds
        case launchProfileId
        case launchProfileProtocolVersion
        case launchPurpose
        case name
        case platform
        case systemInitializationScripts
        case userInitializationScripts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeDirectory = self.activeDirectory {
            try encodeContainer.encode(activeDirectory, forKey: .activeDirectory)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for securitygroupid0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let launchProfileId = self.launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let launchProfileProtocolVersion = self.launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let launchPurpose = self.launchPurpose {
            try encodeContainer.encode(launchPurpose, forKey: .launchPurpose)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let systemInitializationScripts = systemInitializationScripts {
            var systemInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemInitializationScripts)
            for launchprofileinitializationscript0 in systemInitializationScripts {
                try systemInitializationScriptsContainer.encode(launchprofileinitializationscript0)
            }
        }
        if let userInitializationScripts = userInitializationScripts {
            var userInitializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userInitializationScripts)
            for launchprofileinitializationscript0 in userInitializationScripts {
                try userInitializationScriptsContainer.encode(launchprofileinitializationscript0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activeDirectoryDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileInitializationActiveDirectory.self, forKey: .activeDirectory)
        activeDirectory = activeDirectoryDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let launchPurposeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPurpose)
        launchPurpose = launchPurposeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let systemInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .systemInitializationScripts)
        var systemInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let systemInitializationScriptsContainer = systemInitializationScriptsContainer {
            systemInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in systemInitializationScriptsContainer {
                if let structure0 = structure0 {
                    systemInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        systemInitializationScripts = systemInitializationScriptsDecoded0
        let userInitializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileInitializationScript?].self, forKey: .userInitializationScripts)
        var userInitializationScriptsDecoded0:[NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        if let userInitializationScriptsContainer = userInitializationScriptsContainer {
            userInitializationScriptsDecoded0 = [NimbleClientTypes.LaunchProfileInitializationScript]()
            for structure0 in userInitializationScriptsContainer {
                if let structure0 = structure0 {
                    userInitializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        userInitializationScripts = userInitializationScriptsDecoded0
    }
}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitialization(activeDirectory: \(Swift.String(describing: activeDirectory)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), launchPurpose: \(Swift.String(describing: launchPurpose)), platform: \(Swift.String(describing: platform)), systemInitializationScripts: \(Swift.String(describing: systemInitializationScripts)), userInitializationScripts: \(Swift.String(describing: userInitializationScripts)), name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A launch profile initialization contains information required for a workstation or server to connect to a launch profile. This includes scripts, endpoints, security groups, subnets, and other configuration.
    public struct LaunchProfileInitialization: Swift.Equatable {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public var activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The launch purpose.
        public var launchPurpose: Swift.String?
        /// The name for the launch profile.
        public var name: Swift.String?
        /// The platform of the launch platform, either Windows or Linux.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The system initializtion scripts.
        public var systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public var userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?

        public init(
            activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersion: Swift.String? = nil,
            launchPurpose: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil,
            userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        )
        {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computerAttributes
        case directoryId
        case directoryName
        case dnsIpAddresses
        case organizationalUnitDistinguishedName
        case studioComponentId
        case studioComponentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computerAttributes = computerAttributes {
            var computerAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .computerAttributes)
            for activedirectorycomputerattribute0 in computerAttributes {
                try computerAttributesContainer.encode(activedirectorycomputerattribute0)
            }
        }
        if let directoryId = self.directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let directoryName = self.directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let dnsIpAddresses = dnsIpAddresses {
            var dnsIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dnsIpAddresses)
            for activedirectorydnsipaddress0 in dnsIpAddresses {
                try dnsIpAddressesContainer.encode(activedirectorydnsipaddress0)
            }
        }
        if let organizationalUnitDistinguishedName = self.organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
        if let studioComponentId = self.studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = self.studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computerAttributesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ActiveDirectoryComputerAttribute?].self, forKey: .computerAttributes)
        var computerAttributesDecoded0:[NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil
        if let computerAttributesContainer = computerAttributesContainer {
            computerAttributesDecoded0 = [NimbleClientTypes.ActiveDirectoryComputerAttribute]()
            for structure0 in computerAttributesContainer {
                if let structure0 = structure0 {
                    computerAttributesDecoded0?.append(structure0)
                }
            }
        }
        computerAttributes = computerAttributesDecoded0
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let dnsIpAddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dnsIpAddresses)
        var dnsIpAddressesDecoded0:[Swift.String]? = nil
        if let dnsIpAddressesContainer = dnsIpAddressesContainer {
            dnsIpAddressesDecoded0 = [Swift.String]()
            for string0 in dnsIpAddressesContainer {
                if let string0 = string0 {
                    dnsIpAddressesDecoded0?.append(string0)
                }
            }
        }
        dnsIpAddresses = dnsIpAddressesDecoded0
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
    }
}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationActiveDirectory(directoryId: \(Swift.String(describing: directoryId)), directoryName: \(Swift.String(describing: directoryName)), dnsIpAddresses: \(Swift.String(describing: dnsIpAddresses)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), studioComponentId: \(Swift.String(describing: studioComponentId)), computerAttributes: \"CONTENT_REDACTED\", studioComponentName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The launch profile initialization Active Directory contains information required for the launch profile to connect to the Active Directory.
    public struct LaunchProfileInitializationActiveDirectory: Swift.Equatable {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public var directoryId: Swift.String?
        /// The directory name.
        public var directoryName: Swift.String?
        /// The DNS IP address.
        public var dnsIpAddresses: [Swift.String]?
        /// The name for the organizational unit distinguished name.
        public var organizationalUnitDistinguishedName: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init(
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeRoleArn
        case script
        case secureInitializationRoleArn
        case studioComponentId
        case studioComponentName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let script = self.script {
            try encodeContainer.encode(script, forKey: .script)
        }
        if let secureInitializationRoleArn = self.secureInitializationRoleArn {
            try encodeContainer.encode(secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
        }
        if let studioComponentId = self.studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let studioComponentName = self.studioComponentName {
            try encodeContainer.encode(studioComponentName, forKey: .studioComponentName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let studioComponentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentName)
        studioComponentName = studioComponentNameDecoded
        let secureInitializationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secureInitializationRoleArn)
        secureInitializationRoleArn = secureInitializationRoleArnDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
    }
}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationScript(runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioComponentId: \(Swift.String(describing: studioComponentId)), script: \"CONTENT_REDACTED\", studioComponentName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The launch profile initialization script is used when start streaming session runs.
    public struct LaunchProfileInitializationScript: Swift.Equatable {
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public var runtimeRoleArn: Swift.String?
        /// The initialization script.
        public var script: Swift.String?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public var secureInitializationRoleArn: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init(
            runtimeRoleArn: Swift.String? = nil,
            script: Swift.String? = nil,
            secureInitializationRoleArn: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.runtimeRoleArn = runtimeRoleArn
            self.script = script
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case persona
        case principalId
        case sid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sid = self.sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
    }
}

extension NimbleClientTypes {
    /// Studio admins can use launch profile membership to delegate launch profile access to studio users in the Nimble Studio portal without writing or maintaining complex IAM policies. A launch profile member is a user association from your studio identity source who is granted permissions to a launch profile. A launch profile member (type USER) provides the following permissions to that launch profile:
    ///
    /// * GetLaunchProfile
    ///
    /// * GetLaunchProfileInitialization
    ///
    /// * GetLaunchProfileMembers
    ///
    /// * GetLaunchProfileMember
    ///
    /// * CreateStreamingSession
    ///
    /// * GetLaunchProfileDetails
    public struct LaunchProfileMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

extension NimbleClientTypes {
    public enum LaunchProfilePersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePersona] {
            return [
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePersona(rawValue: rawValue) ?? LaunchProfilePersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfilePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePlatform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfilePlatform(rawValue: rawValue) ?? LaunchProfilePlatform.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileState(rawValue: rawValue) ?? LaunchProfileState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case invalidInstanceTypesProvided
        case invalidSubnetsCombination
        case invalidSubnetsProvided
        case launchProfileCreated
        case launchProfileCreateInProgress
        case launchProfileDeleted
        case launchProfileDeleteInProgress
        case launchProfileUpdated
        case launchProfileUpdateInProgress
        case launchProfileWithStreamSessionsNotDeleted
        case streamingImageNotFound
        case streamingImageNotReady
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileStatusCode] {
            return [
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .invalidInstanceTypesProvided,
                .invalidSubnetsCombination,
                .invalidSubnetsProvided,
                .launchProfileCreated,
                .launchProfileCreateInProgress,
                .launchProfileDeleted,
                .launchProfileDeleteInProgress,
                .launchProfileUpdated,
                .launchProfileUpdateInProgress,
                .launchProfileWithStreamSessionsNotDeleted,
                .streamingImageNotFound,
                .streamingImageNotReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInstanceTypesProvided: return "INVALID_INSTANCE_TYPES_PROVIDED"
            case .invalidSubnetsCombination: return "INVALID_SUBNETS_COMBINATION"
            case .invalidSubnetsProvided: return "INVALID_SUBNETS_PROVIDED"
            case .launchProfileCreated: return "LAUNCH_PROFILE_CREATED"
            case .launchProfileCreateInProgress: return "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            case .launchProfileDeleted: return "LAUNCH_PROFILE_DELETED"
            case .launchProfileDeleteInProgress: return "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            case .launchProfileUpdated: return "LAUNCH_PROFILE_UPDATED"
            case .launchProfileUpdateInProgress: return "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            case .launchProfileWithStreamSessionsNotDeleted: return "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            case .streamingImageNotFound: return "STREAMING_IMAGE_NOT_FOUND"
            case .streamingImageNotReady: return "STREAMING_IMAGE_NOT_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileStatusCode(rawValue: rawValue) ?? LaunchProfileStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileValidationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case validationFailed
        case validationFailedInternalServerError
        case validationInProgress
        case validationNotStarted
        case validationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationState] {
            return [
                .validationFailed,
                .validationFailedInternalServerError,
                .validationInProgress,
                .validationNotStarted,
                .validationSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .validationFailed: return "VALIDATION_FAILED"
            case .validationFailedInternalServerError: return "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            case .validationInProgress: return "VALIDATION_IN_PROGRESS"
            case .validationNotStarted: return "VALIDATION_NOT_STARTED"
            case .validationSuccess: return "VALIDATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileValidationState(rawValue: rawValue) ?? LaunchProfileValidationState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileValidationStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case validationFailedInternalServerError
        case validationFailedInvalidActiveDirectory
        case validationFailedInvalidSecurityGroupAssociation
        case validationFailedInvalidSubnetRouteTableAssociation
        case validationFailedSubnetNotFound
        case validationFailedUnauthorized
        case validationInProgress
        case validationNotStarted
        case validationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationStatusCode] {
            return [
                .validationFailedInternalServerError,
                .validationFailedInvalidActiveDirectory,
                .validationFailedInvalidSecurityGroupAssociation,
                .validationFailedInvalidSubnetRouteTableAssociation,
                .validationFailedSubnetNotFound,
                .validationFailedUnauthorized,
                .validationInProgress,
                .validationNotStarted,
                .validationSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .validationFailedInternalServerError: return "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            case .validationFailedInvalidActiveDirectory: return "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY"
            case .validationFailedInvalidSecurityGroupAssociation: return "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION"
            case .validationFailedInvalidSubnetRouteTableAssociation: return "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION"
            case .validationFailedSubnetNotFound: return "VALIDATION_FAILED_SUBNET_NOT_FOUND"
            case .validationFailedUnauthorized: return "VALIDATION_FAILED_UNAUTHORIZED"
            case .validationInProgress: return "VALIDATION_IN_PROGRESS"
            case .validationNotStarted: return "VALIDATION_NOT_STARTED"
            case .validationSuccess: return "VALIDATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileValidationStatusCode(rawValue: rawValue) ?? LaunchProfileValidationStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum LaunchProfileValidationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case validateActiveDirectoryStudioComponent
        case validateNetworkAclAssociation
        case validateSecurityGroupAssociation
        case validateSubnetAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationType] {
            return [
                .validateActiveDirectoryStudioComponent,
                .validateNetworkAclAssociation,
                .validateSecurityGroupAssociation,
                .validateSubnetAssociation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .validateActiveDirectoryStudioComponent: return "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
            case .validateNetworkAclAssociation: return "VALIDATE_NETWORK_ACL_ASSOCIATION"
            case .validateSecurityGroupAssociation: return "VALIDATE_SECURITY_GROUP_ASSOCIATION"
            case .validateSubnetAssociation: return "VALIDATE_SUBNET_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchProfileValidationType(rawValue: rawValue) ?? LaunchProfileValidationType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseServiceConfiguration(endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a license service that is associated with a studio resource.
    public struct LicenseServiceConfiguration: Swift.Equatable {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init(
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension ListEulaAcceptancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let eulaIds = eulaIds {
                eulaIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListEulaAcceptancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

public struct ListEulaAcceptancesInput: Swift.Equatable {
    /// The list of EULA IDs that have been previously accepted.
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListEulaAcceptancesInputBody: Swift.Equatable {
}

extension ListEulaAcceptancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEulaAcceptancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEulaAcceptancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.eulaAcceptances = output.eulaAcceptances
            self.nextToken = output.nextToken
        } else {
            self.eulaAcceptances = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulaAcceptancesOutput: Swift.Equatable {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
        self.nextToken = nextToken
    }
}

struct ListEulaAcceptancesOutputBody: Swift.Equatable {
    let eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    let nextToken: Swift.String?
}

extension ListEulaAcceptancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulaAcceptances
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulaAcceptancesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.EulaAcceptance?].self, forKey: .eulaAcceptances)
        var eulaAcceptancesDecoded0:[NimbleClientTypes.EulaAcceptance]? = nil
        if let eulaAcceptancesContainer = eulaAcceptancesContainer {
            eulaAcceptancesDecoded0 = [NimbleClientTypes.EulaAcceptance]()
            for structure0 in eulaAcceptancesContainer {
                if let structure0 = structure0 {
                    eulaAcceptancesDecoded0?.append(structure0)
                }
            }
        }
        eulaAcceptances = eulaAcceptancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEulaAcceptancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEulasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let eulaIds = eulaIds {
                eulaIds.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListEulasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/eulas"
    }
}

public struct ListEulasInput: Swift.Equatable {
    /// The list of EULA IDs that should be returned
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
    }
}

struct ListEulasInputBody: Swift.Equatable {
}

extension ListEulasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEulasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEulasOutputBody = try responseDecoder.decode(responseBody: data)
            self.eulas = output.eulas
            self.nextToken = output.nextToken
        } else {
            self.eulas = nil
            self.nextToken = nil
        }
    }
}

public struct ListEulasOutput: Swift.Equatable {
    /// A collection of EULA resources.
    public var eulas: [NimbleClientTypes.Eula]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulas: [NimbleClientTypes.Eula]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulas = eulas
        self.nextToken = nextToken
    }
}

struct ListEulasOutputBody: Swift.Equatable {
    let eulas: [NimbleClientTypes.Eula]?
    let nextToken: Swift.String?
}

extension ListEulasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eulas
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eulasContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Eula?].self, forKey: .eulas)
        var eulasDecoded0:[NimbleClientTypes.Eula]? = nil
        if let eulasContainer = eulasContainer {
            eulasDecoded0 = [NimbleClientTypes.Eula]()
            for structure0 in eulasContainer {
                if let structure0 = structure0 {
                    eulasDecoded0?.append(structure0)
                }
            }
        }
        eulas = eulasDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEulasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLaunchProfileMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListLaunchProfileMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

public struct ListLaunchProfileMembersInput: Swift.Equatable {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListLaunchProfileMembersInputBody: Swift.Equatable {
}

extension ListLaunchProfileMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfileMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLaunchProfileMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfileMembersOutput: Swift.Equatable {
    /// A list of members.
    public var members: [NimbleClientTypes.LaunchProfileMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        members: [NimbleClientTypes.LaunchProfileMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListLaunchProfileMembersOutputBody: Swift.Equatable {
    let members: [NimbleClientTypes.LaunchProfileMembership]?
    let nextToken: Swift.String?
}

extension ListLaunchProfileMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfileMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.LaunchProfileMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.LaunchProfileMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLaunchProfileMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLaunchProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let principalId = principalId {
                let principalIdQueryItem = ClientRuntime.URLQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
                items.append(principalIdQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListLaunchProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

public struct ListLaunchProfilesInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    public var principalId: Swift.String?
    /// Filter this request to launch profiles in any of the given states.
    public var states: [NimbleClientTypes.LaunchProfileState]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        states: [NimbleClientTypes.LaunchProfileState]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.states = states
        self.studioId = studioId
    }
}

struct ListLaunchProfilesInputBody: Swift.Equatable {
}

extension ListLaunchProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLaunchProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLaunchProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfiles = output.launchProfiles
            self.nextToken = output.nextToken
        } else {
            self.launchProfiles = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchProfilesOutput: Swift.Equatable {
    /// A collection of launch profiles.
    public var launchProfiles: [NimbleClientTypes.LaunchProfile]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        launchProfiles: [NimbleClientTypes.LaunchProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchProfiles = launchProfiles
        self.nextToken = nextToken
    }
}

struct ListLaunchProfilesOutputBody: Swift.Equatable {
    let launchProfiles: [NimbleClientTypes.LaunchProfile]?
    let nextToken: Swift.String?
}

extension ListLaunchProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfiles
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfilesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.LaunchProfile?].self, forKey: .launchProfiles)
        var launchProfilesDecoded0:[NimbleClientTypes.LaunchProfile]? = nil
        if let launchProfilesContainer = launchProfilesContainer {
            launchProfilesDecoded0 = [NimbleClientTypes.LaunchProfile]()
            for structure0 in launchProfilesContainer {
                if let structure0 = structure0 {
                    launchProfilesDecoded0?.append(structure0)
                }
            }
        }
        launchProfiles = launchProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLaunchProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamingImagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let owner = owner {
                let ownerQueryItem = ClientRuntime.URLQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner).urlPercentEncoding())
                items.append(ownerQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStreamingImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

public struct ListStreamingImagesInput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filter this request to streaming images with the given owner
    public var owner: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.owner = owner
        self.studioId = studioId
    }
}

struct ListStreamingImagesInputBody: Swift.Equatable {
}

extension ListStreamingImagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamingImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamingImages = output.streamingImages
        } else {
            self.nextToken = nil
            self.streamingImages = nil
        }
    }
}

public struct ListStreamingImagesOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?

    public init(
        nextToken: Swift.String? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingImages = streamingImages
    }
}

struct ListStreamingImagesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamingImages: [NimbleClientTypes.StreamingImage]?
}

extension ListStreamingImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamingImages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamingImagesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingImage?].self, forKey: .streamingImages)
        var streamingImagesDecoded0:[NimbleClientTypes.StreamingImage]? = nil
        if let streamingImagesContainer = streamingImagesContainer {
            streamingImagesDecoded0 = [NimbleClientTypes.StreamingImage]()
            for structure0 in streamingImagesContainer {
                if let structure0 = structure0 {
                    streamingImagesDecoded0?.append(structure0)
                }
            }
        }
        streamingImages = streamingImagesDecoded0
    }
}

enum ListStreamingImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamingSessionBackupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let ownedBy = ownedBy {
                let ownedByQueryItem = ClientRuntime.URLQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
                items.append(ownedByQueryItem)
            }
            return items
        }
    }
}

extension ListStreamingSessionBackupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-session-backups"
    }
}

public struct ListStreamingSessionBackupsInput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The user ID of the user that owns the streaming session.
    public var ownedBy: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.studioId = studioId
    }
}

struct ListStreamingSessionBackupsInputBody: Swift.Equatable {
}

extension ListStreamingSessionBackupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingSessionBackupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamingSessionBackupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamingSessionBackups = output.streamingSessionBackups
        } else {
            self.nextToken = nil
            self.streamingSessionBackups = nil
        }
    }
}

public struct ListStreamingSessionBackupsOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about the streaming session backups.
    public var streamingSessionBackups: [NimbleClientTypes.StreamingSessionBackup]?

    public init(
        nextToken: Swift.String? = nil,
        streamingSessionBackups: [NimbleClientTypes.StreamingSessionBackup]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingSessionBackups = streamingSessionBackups
    }
}

struct ListStreamingSessionBackupsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamingSessionBackups: [NimbleClientTypes.StreamingSessionBackup]?
}

extension ListStreamingSessionBackupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamingSessionBackups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamingSessionBackupsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingSessionBackup?].self, forKey: .streamingSessionBackups)
        var streamingSessionBackupsDecoded0:[NimbleClientTypes.StreamingSessionBackup]? = nil
        if let streamingSessionBackupsContainer = streamingSessionBackupsContainer {
            streamingSessionBackupsDecoded0 = [NimbleClientTypes.StreamingSessionBackup]()
            for structure0 in streamingSessionBackupsContainer {
                if let structure0 = structure0 {
                    streamingSessionBackupsDecoded0?.append(structure0)
                }
            }
        }
        streamingSessionBackups = streamingSessionBackupsDecoded0
    }
}

enum ListStreamingSessionBackupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamingSessionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let createdBy = createdBy {
                let createdByQueryItem = ClientRuntime.URLQueryItem(name: "createdBy".urlPercentEncoding(), value: Swift.String(createdBy).urlPercentEncoding())
                items.append(createdByQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let ownedBy = ownedBy {
                let ownedByQueryItem = ClientRuntime.URLQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
                items.append(ownedByQueryItem)
            }
            if let sessionIds = sessionIds {
                let sessionIdsQueryItem = ClientRuntime.URLQueryItem(name: "sessionIds".urlPercentEncoding(), value: Swift.String(sessionIds).urlPercentEncoding())
                items.append(sessionIdsQueryItem)
            }
            return items
        }
    }
}

extension ListStreamingSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

public struct ListStreamingSessionsInput: Swift.Equatable {
    /// Filters the request to streaming sessions created by the given user.
    public var createdBy: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the request to streaming session owned by the given user
    public var ownedBy: Swift.String?
    /// Filters the request to only the provided session IDs.
    public var sessionIds: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        createdBy: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        sessionIds: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.createdBy = createdBy
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.sessionIds = sessionIds
        self.studioId = studioId
    }
}

struct ListStreamingSessionsInputBody: Swift.Equatable {
}

extension ListStreamingSessionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStreamingSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamingSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct ListStreamingSessionsOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming sessions.
    public var sessions: [NimbleClientTypes.StreamingSession]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [NimbleClientTypes.StreamingSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct ListStreamingSessionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sessions: [NimbleClientTypes.StreamingSession]?
}

extension ListStreamingSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sessionsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingSession?].self, forKey: .sessions)
        var sessionsDecoded0:[NimbleClientTypes.StreamingSession]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [NimbleClientTypes.StreamingSession]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
    }
}

enum ListStreamingSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStudioComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let types = types {
                types.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let states = states {
                states.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension ListStudioComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

public struct ListStudioComponentsInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the request to studio components that are in one of the given states.
    public var states: [NimbleClientTypes.StudioComponentState]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// Filters the request to studio components that are of one of the given types.
    public var types: [NimbleClientTypes.StudioComponentType]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        states: [NimbleClientTypes.StudioComponentState]? = nil,
        studioId: Swift.String? = nil,
        types: [NimbleClientTypes.StudioComponentType]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.studioId = studioId
        self.types = types
    }
}

struct ListStudioComponentsInputBody: Swift.Equatable {
}

extension ListStudioComponentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStudioComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studioComponents = output.studioComponents
        } else {
            self.nextToken = nil
            self.studioComponents = nil
        }
    }
}

public struct ListStudioComponentsOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studio components.
    public var studioComponents: [NimbleClientTypes.StudioComponent]?

    public init(
        nextToken: Swift.String? = nil,
        studioComponents: [NimbleClientTypes.StudioComponent]? = nil
    )
    {
        self.nextToken = nextToken
        self.studioComponents = studioComponents
    }
}

struct ListStudioComponentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let studioComponents: [NimbleClientTypes.StudioComponent]?
}

extension ListStudioComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case studioComponents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studioComponentsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponent?].self, forKey: .studioComponents)
        var studioComponentsDecoded0:[NimbleClientTypes.StudioComponent]? = nil
        if let studioComponentsContainer = studioComponentsContainer {
            studioComponentsDecoded0 = [NimbleClientTypes.StudioComponent]()
            for structure0 in studioComponentsContainer {
                if let structure0 = structure0 {
                    studioComponentsDecoded0?.append(structure0)
                }
            }
        }
        studioComponents = studioComponentsDecoded0
    }
}

enum ListStudioComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStudioMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStudioMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

public struct ListStudioMembersInput: Swift.Equatable {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

struct ListStudioMembersInputBody: Swift.Equatable {
}

extension ListStudioMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStudioMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStudioMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListStudioMembersOutput: Swift.Equatable {
    /// A list of admin members.
    public var members: [NimbleClientTypes.StudioMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        members: [NimbleClientTypes.StudioMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListStudioMembersOutputBody: Swift.Equatable {
    let members: [NimbleClientTypes.StudioMembership]?
    let nextToken: Swift.String?
}

extension ListStudioMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioMembership?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.StudioMembership]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.StudioMembership]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStudioMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStudiosInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStudiosInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/2020-08-01/studios"
    }
}

public struct ListStudiosInput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListStudiosInputBody: Swift.Equatable {
}

extension ListStudiosInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStudiosOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStudiosOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.studios = output.studios
        } else {
            self.nextToken = nil
            self.studios = nil
        }
    }
}

public struct ListStudiosOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studios.
    /// This member is required.
    public var studios: [NimbleClientTypes.Studio]?

    public init(
        nextToken: Swift.String? = nil,
        studios: [NimbleClientTypes.Studio]? = nil
    )
    {
        self.nextToken = nextToken
        self.studios = studios
    }
}

struct ListStudiosOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let studios: [NimbleClientTypes.Studio]?
}

extension ListStudiosOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case studios
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let studiosContainer = try containerValues.decodeIfPresent([NimbleClientTypes.Studio?].self, forKey: .studios)
        var studiosDecoded0:[NimbleClientTypes.Studio]? = nil
        if let studiosContainer = studiosContainer {
            studiosDecoded0 = [NimbleClientTypes.Studio]()
            for structure0 in studiosContainer {
                if let structure0 = structure0 {
                    studiosDecoded0?.append(structure0)
                }
            }
        }
        studios = studiosDecoded0
    }
}

enum ListStudiosOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NimbleClientTypes.NewLaunchProfileMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
        case principalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes {
    /// A new member that is added to a launch profile.
    public struct NewLaunchProfileMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init(
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension NimbleClientTypes.NewStudioMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
        case principalId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension NimbleClientTypes {
    /// A new studio user's membership.
    public struct NewStudioMember: Swift.Equatable {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init(
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

extension PutLaunchProfileMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newlaunchprofilemember0 in members {
                try membersContainer.encode(newlaunchprofilemember0)
            }
        }
    }
}

extension PutLaunchProfileMembersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension PutLaunchProfileMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

public struct PutLaunchProfileMembersInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewLaunchProfileMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        members: [NimbleClientTypes.NewLaunchProfileMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.launchProfileId = launchProfileId
        self.members = members
        self.studioId = studioId
    }
}

struct PutLaunchProfileMembersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let members: [NimbleClientTypes.NewLaunchProfileMember]?
}

extension PutLaunchProfileMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewLaunchProfileMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewLaunchProfileMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewLaunchProfileMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutLaunchProfileMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLaunchProfileMembersOutput: Swift.Equatable {

    public init() { }
}

enum PutLaunchProfileMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutStudioMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for newstudiomember0 in members {
                try membersContainer.encode(newstudiomember0)
            }
        }
    }
}

extension PutStudioMembersInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension PutStudioMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

public struct PutStudioMembersInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewStudioMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        members: [NimbleClientTypes.NewStudioMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.members = members
        self.studioId = studioId
    }
}

struct PutStudioMembersInputBody: Swift.Equatable {
    let identityStoreId: Swift.String?
    let members: [NimbleClientTypes.NewStudioMember]?
}

extension PutStudioMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case members
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let membersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.NewStudioMember?].self, forKey: .members)
        var membersDecoded0:[NimbleClientTypes.NewStudioMember]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [NimbleClientTypes.NewStudioMember]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension PutStudioMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutStudioMembersOutput: Swift.Equatable {

    public init() { }
}

enum PutStudioMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ScriptParameterKeyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NimbleClientTypes {
    /// A parameter for a studio component script, in the form of a key-value pair.
    public struct ScriptParameterKeyValue: Swift.Equatable {
        /// A script parameter key.
        public var key: Swift.String?
        /// A script parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your current quota does not allow you to perform the request action. You can request increases for some quotas, and other quotas cannot be increased. Please use Amazon Web Services Service Quotas to request an increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes {
    public enum SessionBackupMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionBackupMode] {
            return [
                .automatic,
                .deactivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionBackupMode(rawValue: rawValue) ?? SessionBackupMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum SessionPersistenceMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionPersistenceMode] {
            return [
                .activated,
                .deactivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionPersistenceMode(rawValue: rawValue) ?? SessionPersistenceMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
        case fileSystemId
        case linuxMountPoint
        case shareName
        case windowsMountDrive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = self.endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let fileSystemId = self.fileSystemId {
            try encodeContainer.encode(fileSystemId, forKey: .fileSystemId)
        }
        if let linuxMountPoint = self.linuxMountPoint {
            try encodeContainer.encode(linuxMountPoint, forKey: .linuxMountPoint)
        }
        if let shareName = self.shareName {
            try encodeContainer.encode(shareName, forKey: .shareName)
        }
        if let windowsMountDrive = self.windowsMountDrive {
            try encodeContainer.encode(windowsMountDrive, forKey: .windowsMountDrive)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let fileSystemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemId)
        fileSystemId = fileSystemIdDecoded
        let linuxMountPointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linuxMountPoint)
        linuxMountPoint = linuxMountPointDecoded
        let shareNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareName)
        shareName = shareNameDecoded
        let windowsMountDriveDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windowsMountDrive)
        windowsMountDrive = windowsMountDriveDecoded
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedFileSystemConfiguration(fileSystemId: \(Swift.String(describing: fileSystemId)), windowsMountDrive: \(Swift.String(describing: windowsMountDrive)), endpoint: \"CONTENT_REDACTED\", linuxMountPoint: \"CONTENT_REDACTED\", shareName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a shared file storage system that is associated with a studio resource.
    public struct SharedFileSystemConfiguration: Swift.Equatable {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public var endpoint: Swift.String?
        /// The unique identifier for a file system.
        public var fileSystemId: Swift.String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public var linuxMountPoint: Swift.String?
        /// The name of the file share.
        public var shareName: Swift.String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public var windowsMountDrive: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            linuxMountPoint: Swift.String? = nil,
            shareName: Swift.String? = nil,
            windowsMountDrive: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }
    }

}

extension StartStreamingSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

extension StartStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/start"
    }
}

public struct StartStreamingSessionInput: Swift.Equatable {
    /// The ID of the backup.
    public var backupId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

struct StartStreamingSessionInputBody: Swift.Equatable {
    let backupId: Swift.String?
}

extension StartStreamingSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension StartStreamingSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartStreamingSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct StartStreamingSessionOutput: Swift.Equatable {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct StartStreamingSessionOutputBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension StartStreamingSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

enum StartStreamingSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartStudioSSOConfigurationRepairInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStudioSSOConfigurationRepairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/sso-configuration"
    }
}

public struct StartStudioSSOConfigurationRepairInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

struct StartStudioSSOConfigurationRepairInputBody: Swift.Equatable {
}

extension StartStudioSSOConfigurationRepairInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StartStudioSSOConfigurationRepairOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartStudioSSOConfigurationRepairOutputBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct StartStudioSSOConfigurationRepairOutput: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct StartStudioSSOConfigurationRepairOutputBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension StartStudioSSOConfigurationRepairOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

enum StartStudioSSOConfigurationRepairOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopStreamingSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeRetentionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let volumeRetentionMode = self.volumeRetentionMode {
            try encodeContainer.encode(volumeRetentionMode.rawValue, forKey: .volumeRetentionMode)
        }
    }
}

extension StopStreamingSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StopStreamingSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let sessionId = sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/stop"
    }
}

public struct StopStreamingSessionInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StopStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studioId for the StopStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?
    /// Adds additional instructions to a streaming session stop action to either retain the EBS volumes or delete the EBS volumes.
    public var volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode?

    public init(
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
        self.volumeRetentionMode = volumeRetentionMode
    }
}

struct StopStreamingSessionInputBody: Swift.Equatable {
    let volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode?
}

extension StopStreamingSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case volumeRetentionMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeRetentionModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.VolumeRetentionMode.self, forKey: .volumeRetentionMode)
        volumeRetentionMode = volumeRetentionModeDecoded
    }
}

extension StopStreamingSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopStreamingSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.session = output.session
        } else {
            self.session = nil
        }
    }
}

public struct StopStreamingSessionOutput: Swift.Equatable {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

struct StopStreamingSessionOutputBody: Swift.Equatable {
    let session: NimbleClientTypes.StreamingSession?
}

extension StopStreamingSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case session
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSession.self, forKey: .session)
        session = sessionDecoded
    }
}

enum StopStreamingSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NimbleClientTypes.StreamConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTerminationMode
        case clipboardMode
        case ec2InstanceTypes
        case maxSessionLengthInMinutes
        case maxStoppedSessionLengthInMinutes
        case sessionBackup
        case sessionPersistenceMode
        case sessionStorage
        case streamingImageIds
        case volumeConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTerminationMode = self.automaticTerminationMode {
            try encodeContainer.encode(automaticTerminationMode.rawValue, forKey: .automaticTerminationMode)
        }
        if let clipboardMode = self.clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetype0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetype0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = self.maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let maxStoppedSessionLengthInMinutes = self.maxStoppedSessionLengthInMinutes {
            try encodeContainer.encode(maxStoppedSessionLengthInMinutes, forKey: .maxStoppedSessionLengthInMinutes)
        }
        if let sessionBackup = self.sessionBackup {
            try encodeContainer.encode(sessionBackup, forKey: .sessionBackup)
        }
        if let sessionPersistenceMode = self.sessionPersistenceMode {
            try encodeContainer.encode(sessionPersistenceMode.rawValue, forKey: .sessionPersistenceMode)
        }
        if let sessionStorage = self.sessionStorage {
            try encodeContainer.encode(sessionStorage, forKey: .sessionStorage)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageid0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageid0)
            }
        }
        if let volumeConfiguration = self.volumeConfiguration {
            try encodeContainer.encode(volumeConfiguration, forKey: .volumeConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for enum0 in ec2InstanceTypesContainer {
                if let enum0 = enum0 {
                    ec2InstanceTypesDecoded0?.append(enum0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
        let maxStoppedSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStoppedSessionLengthInMinutes)
        maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutesDecoded
        let sessionStorageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationSessionStorage.self, forKey: .sessionStorage)
        sessionStorage = sessionStorageDecoded
        let sessionBackupDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationSessionBackup.self, forKey: .sessionBackup)
        sessionBackup = sessionBackupDecoded
        let sessionPersistenceModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SessionPersistenceMode.self, forKey: .sessionPersistenceMode)
        sessionPersistenceMode = sessionPersistenceModeDecoded
        let volumeConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.VolumeConfiguration.self, forKey: .volumeConfiguration)
        volumeConfiguration = volumeConfigurationDecoded
        let automaticTerminationModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.AutomaticTerminationMode.self, forKey: .automaticTerminationMode)
        automaticTerminationMode = automaticTerminationModeDecoded
    }
}

extension NimbleClientTypes {
    /// A configuration for a streaming session.
    public struct StreamConfiguration: Swift.Equatable {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// Information about the streaming session backup.
        public var sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The upload storage for a streaming session.
        public var sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?

        public init(
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            maxStoppedSessionLengthInMinutes: Swift.Int? = nil,
            sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage? = nil,
            streamingImageIds: [Swift.String]? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil
        )
        {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }
    }

}

extension NimbleClientTypes.StreamConfigurationCreate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticTerminationMode
        case clipboardMode
        case ec2InstanceTypes
        case maxSessionLengthInMinutes
        case maxStoppedSessionLengthInMinutes
        case sessionBackup
        case sessionPersistenceMode
        case sessionStorage
        case streamingImageIds
        case volumeConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticTerminationMode = self.automaticTerminationMode {
            try encodeContainer.encode(automaticTerminationMode.rawValue, forKey: .automaticTerminationMode)
        }
        if let clipboardMode = self.clipboardMode {
            try encodeContainer.encode(clipboardMode.rawValue, forKey: .clipboardMode)
        }
        if let ec2InstanceTypes = ec2InstanceTypes {
            var ec2InstanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2InstanceTypes)
            for streaminginstancetype0 in ec2InstanceTypes {
                try ec2InstanceTypesContainer.encode(streaminginstancetype0.rawValue)
            }
        }
        if let maxSessionLengthInMinutes = self.maxSessionLengthInMinutes {
            try encodeContainer.encode(maxSessionLengthInMinutes, forKey: .maxSessionLengthInMinutes)
        }
        if let maxStoppedSessionLengthInMinutes = self.maxStoppedSessionLengthInMinutes {
            try encodeContainer.encode(maxStoppedSessionLengthInMinutes, forKey: .maxStoppedSessionLengthInMinutes)
        }
        if let sessionBackup = self.sessionBackup {
            try encodeContainer.encode(sessionBackup, forKey: .sessionBackup)
        }
        if let sessionPersistenceMode = self.sessionPersistenceMode {
            try encodeContainer.encode(sessionPersistenceMode.rawValue, forKey: .sessionPersistenceMode)
        }
        if let sessionStorage = self.sessionStorage {
            try encodeContainer.encode(sessionStorage, forKey: .sessionStorage)
        }
        if let streamingImageIds = streamingImageIds {
            var streamingImageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .streamingImageIds)
            for streamingimageid0 in streamingImageIds {
                try streamingImageIdsContainer.encode(streamingimageid0)
            }
        }
        if let volumeConfiguration = self.volumeConfiguration {
            try encodeContainer.encode(volumeConfiguration, forKey: .volumeConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clipboardModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingClipboardMode.self, forKey: .clipboardMode)
        clipboardMode = clipboardModeDecoded
        let ec2InstanceTypesContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingInstanceType?].self, forKey: .ec2InstanceTypes)
        var ec2InstanceTypesDecoded0:[NimbleClientTypes.StreamingInstanceType]? = nil
        if let ec2InstanceTypesContainer = ec2InstanceTypesContainer {
            ec2InstanceTypesDecoded0 = [NimbleClientTypes.StreamingInstanceType]()
            for enum0 in ec2InstanceTypesContainer {
                if let enum0 = enum0 {
                    ec2InstanceTypesDecoded0?.append(enum0)
                }
            }
        }
        ec2InstanceTypes = ec2InstanceTypesDecoded0
        let maxSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSessionLengthInMinutes)
        maxSessionLengthInMinutes = maxSessionLengthInMinutesDecoded
        let streamingImageIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .streamingImageIds)
        var streamingImageIdsDecoded0:[Swift.String]? = nil
        if let streamingImageIdsContainer = streamingImageIdsContainer {
            streamingImageIdsDecoded0 = [Swift.String]()
            for string0 in streamingImageIdsContainer {
                if let string0 = string0 {
                    streamingImageIdsDecoded0?.append(string0)
                }
            }
        }
        streamingImageIds = streamingImageIdsDecoded0
        let maxStoppedSessionLengthInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxStoppedSessionLengthInMinutes)
        maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutesDecoded
        let sessionStorageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationSessionStorage.self, forKey: .sessionStorage)
        sessionStorage = sessionStorageDecoded
        let sessionBackupDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationSessionBackup.self, forKey: .sessionBackup)
        sessionBackup = sessionBackupDecoded
        let sessionPersistenceModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SessionPersistenceMode.self, forKey: .sessionPersistenceMode)
        sessionPersistenceMode = sessionPersistenceModeDecoded
        let volumeConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.VolumeConfiguration.self, forKey: .volumeConfiguration)
        volumeConfiguration = volumeConfigurationDecoded
        let automaticTerminationModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.AutomaticTerminationMode.self, forKey: .automaticTerminationMode)
        automaticTerminationMode = automaticTerminationModeDecoded
    }
}

extension NimbleClientTypes {
    /// Configuration for streaming workstations created using this launch profile.
    public struct StreamConfigurationCreate: Swift.Equatable {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// Configures how streaming sessions are backed up when launched from this launch profile.
        public var sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The upload storage for a streaming workstation that is created using this launch profile.
        public var sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?

        public init(
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = nil,
            maxStoppedSessionLengthInMinutes: Swift.Int? = nil,
            sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage? = nil,
            streamingImageIds: [Swift.String]? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil
        )
        {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }
    }

}

extension NimbleClientTypes.StreamConfigurationSessionBackup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxBackupsToRetain
        case mode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxBackupsToRetain = self.maxBackupsToRetain {
            try encodeContainer.encode(maxBackupsToRetain, forKey: .maxBackupsToRetain)
        }
        if let mode = self.mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SessionBackupMode.self, forKey: .mode)
        mode = modeDecoded
        let maxBackupsToRetainDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBackupsToRetain)
        maxBackupsToRetain = maxBackupsToRetainDecoded
    }
}

extension NimbleClientTypes {
    /// Configures how streaming sessions are backed up when launched from this launch profile.
    public struct StreamConfigurationSessionBackup: Swift.Equatable {
        /// The maximum number of backups that each streaming session created from this launch profile can have.
        public var maxBackupsToRetain: Swift.Int?
        /// Specifies how artists sessions are backed up. Configures backups for streaming sessions launched with this launch profile. The default value is DEACTIVATED, which means that backups are deactivated. To allow backups, set this value to AUTOMATIC.
        public var mode: NimbleClientTypes.SessionBackupMode?

        public init(
            maxBackupsToRetain: Swift.Int? = nil,
            mode: NimbleClientTypes.SessionBackupMode? = nil
        )
        {
            self.maxBackupsToRetain = maxBackupsToRetain
            self.mode = mode
        }
    }

}

extension NimbleClientTypes.StreamConfigurationSessionStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mode
        case root
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            var modeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mode)
            for streamingsessionstoragemode0 in mode {
                try modeContainer.encode(streamingsessionstoragemode0.rawValue)
            }
        }
        if let root = self.root {
            try encodeContainer.encode(root, forKey: .root)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rootDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStorageRoot.self, forKey: .root)
        root = rootDecoded
        let modeContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StreamingSessionStorageMode?].self, forKey: .mode)
        var modeDecoded0:[NimbleClientTypes.StreamingSessionStorageMode]? = nil
        if let modeContainer = modeContainer {
            modeDecoded0 = [NimbleClientTypes.StreamingSessionStorageMode]()
            for enum0 in modeContainer {
                if let enum0 = enum0 {
                    modeDecoded0?.append(enum0)
                }
            }
        }
        mode = modeDecoded0
    }
}

extension NimbleClientTypes {
    /// The configuration for a streaming session’s upload storage.
    public struct StreamConfigurationSessionStorage: Swift.Equatable {
        /// Allows artists to upload files to their workstations. The only valid option is UPLOAD.
        /// This member is required.
        public var mode: [NimbleClientTypes.StreamingSessionStorageMode]?
        /// The configuration for the upload storage root of the streaming session.
        public var root: NimbleClientTypes.StreamingSessionStorageRoot?

        public init(
            mode: [NimbleClientTypes.StreamingSessionStorageMode]? = nil,
            root: NimbleClientTypes.StreamingSessionStorageRoot? = nil
        )
        {
            self.mode = mode
            self.root = root
        }
    }

}

extension NimbleClientTypes {
    public enum StreamingClipboardMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingClipboardMode] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingClipboardMode(rawValue: rawValue) ?? StreamingClipboardMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingImage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case description
        case ec2ImageId
        case encryptionConfiguration
        case eulaIds
        case name
        case owner
        case platform
        case state
        case statusCode
        case statusMessage
        case streamingImageId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2ImageId = self.ec2ImageId {
            try encodeContainer.encode(ec2ImageId, forKey: .ec2ImageId)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let eulaIds = eulaIds {
            var eulaIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eulaIds)
            for string0 in eulaIds {
                try eulaIdsContainer.encode(string0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let streamingImageId = self.streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2ImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2ImageId)
        ec2ImageId = ec2ImageIdDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let eulaIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eulaIds)
        var eulaIdsDecoded0:[Swift.String]? = nil
        if let eulaIdsContainer = eulaIdsContainer {
            eulaIdsDecoded0 = [Swift.String]()
            for string0 in eulaIdsContainer {
                if let string0 = string0 {
                    eulaIdsDecoded0?.append(string0)
                }
            }
        }
        eulaIds = eulaIdsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes.StreamingImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingImage(arn: \(Swift.String(describing: arn)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), eulaIds: \(Swift.String(describing: eulaIds)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamingImageId: \(Swift.String(describing: streamingImageId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// Represents a streaming image resource. Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session. Amazon provides a number of streaming images that include popular 3rd-party software. You can create your own streaming images using an Amazon EC2 machine image that you create for this purpose. You can also include software that your users require.
    public struct StreamingImage: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// A human-readable description of the streaming image.
        public var description: Swift.String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public var ec2ImageId: Swift.String?
        /// The encryption configuration.
        public var encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public var eulaIds: [Swift.String]?
        /// A friendly name for a streaming image resource.
        public var name: Swift.String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or amazon for images that are provided by Amazon Nimble Studio.
        public var owner: Swift.String?
        /// The platform of the streaming image, either Windows or Linux.
        public var platform: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingImageState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingImageStatusCode?
        /// The status message for the streaming image.
        public var statusMessage: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2ImageId: Swift.String? = nil,
            encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration? = nil,
            eulaIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: Swift.String? = nil,
            state: NimbleClientTypes.StreamingImageState? = nil,
            statusCode: NimbleClientTypes.StreamingImageStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }
    }

}

extension NimbleClientTypes.StreamingImageEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = self.keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes {
    /// Specifies how a streaming image is encrypted.
    public struct StreamingImageEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType?

        public init(
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    public enum StreamingImageEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageEncryptionConfigurationKeyType] {
            return [
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageEncryptionConfigurationKeyType(rawValue: rawValue) ?? StreamingImageEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageState(rawValue: rawValue) ?? StreamingImageState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StreamingImageStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalError
        case streamingImageCreateInProgress
        case streamingImageDeleted
        case streamingImageDeleteInProgress
        case streamingImageReady
        case streamingImageUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageStatusCode] {
            return [
                .accessDenied,
                .internalError,
                .streamingImageCreateInProgress,
                .streamingImageDeleted,
                .streamingImageDeleteInProgress,
                .streamingImageReady,
                .streamingImageUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case .streamingImageCreateInProgress: return "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            case .streamingImageDeleted: return "STREAMING_IMAGE_DELETED"
            case .streamingImageDeleteInProgress: return "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            case .streamingImageReady: return "STREAMING_IMAGE_READY"
            case .streamingImageUpdateInProgress: return "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingImageStatusCode(rawValue: rawValue) ?? StreamingImageStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case g34xlarge
        case g3sXlarge
        case g4dn12xlarge
        case g4dn16xlarge
        case g4dn2xlarge
        case g4dn4xlarge
        case g4dn8xlarge
        case g4dnXlarge
        case g516xlarge
        case g52xlarge
        case g54xlarge
        case g58xlarge
        case g5Xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingInstanceType] {
            return [
                .g34xlarge,
                .g3sXlarge,
                .g4dn12xlarge,
                .g4dn16xlarge,
                .g4dn2xlarge,
                .g4dn4xlarge,
                .g4dn8xlarge,
                .g4dnXlarge,
                .g516xlarge,
                .g52xlarge,
                .g54xlarge,
                .g58xlarge,
                .g5Xlarge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .g34xlarge: return "g3.4xlarge"
            case .g3sXlarge: return "g3s.xlarge"
            case .g4dn12xlarge: return "g4dn.12xlarge"
            case .g4dn16xlarge: return "g4dn.16xlarge"
            case .g4dn2xlarge: return "g4dn.2xlarge"
            case .g4dn4xlarge: return "g4dn.4xlarge"
            case .g4dn8xlarge: return "g4dn.8xlarge"
            case .g4dnXlarge: return "g4dn.xlarge"
            case .g516xlarge: return "g5.16xlarge"
            case .g52xlarge: return "g5.2xlarge"
            case .g54xlarge: return "g5.4xlarge"
            case .g58xlarge: return "g5.8xlarge"
            case .g5Xlarge: return "g5.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingInstanceType(rawValue: rawValue) ?? StreamingInstanceType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case automaticTerminationMode
        case backupMode
        case createdAt
        case createdBy
        case ec2InstanceType
        case launchProfileId
        case maxBackupsToRetain
        case ownedBy
        case sessionId
        case sessionPersistenceMode
        case startedAt
        case startedBy
        case startedFromBackupId
        case state
        case statusCode
        case statusMessage
        case stopAt
        case stoppedAt
        case stoppedBy
        case streamingImageId
        case tags
        case terminateAt
        case updatedAt
        case updatedBy
        case volumeConfiguration
        case volumeRetentionMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let automaticTerminationMode = self.automaticTerminationMode {
            try encodeContainer.encode(automaticTerminationMode.rawValue, forKey: .automaticTerminationMode)
        }
        if let backupMode = self.backupMode {
            try encodeContainer.encode(backupMode.rawValue, forKey: .backupMode)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let ec2InstanceType = self.ec2InstanceType {
            try encodeContainer.encode(ec2InstanceType, forKey: .ec2InstanceType)
        }
        if let launchProfileId = self.launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let maxBackupsToRetain = self.maxBackupsToRetain {
            try encodeContainer.encode(maxBackupsToRetain, forKey: .maxBackupsToRetain)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let sessionPersistenceMode = self.sessionPersistenceMode {
            try encodeContainer.encode(sessionPersistenceMode.rawValue, forKey: .sessionPersistenceMode)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .dateTime, forKey: .startedAt)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let startedFromBackupId = self.startedFromBackupId {
            try encodeContainer.encode(startedFromBackupId, forKey: .startedFromBackupId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let stopAt = self.stopAt {
            try encodeContainer.encodeTimestamp(stopAt, format: .dateTime, forKey: .stopAt)
        }
        if let stoppedAt = self.stoppedAt {
            try encodeContainer.encodeTimestamp(stoppedAt, format: .dateTime, forKey: .stoppedAt)
        }
        if let stoppedBy = self.stoppedBy {
            try encodeContainer.encode(stoppedBy, forKey: .stoppedBy)
        }
        if let streamingImageId = self.streamingImageId {
            try encodeContainer.encode(streamingImageId, forKey: .streamingImageId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateAt = self.terminateAt {
            try encodeContainer.encodeTimestamp(terminateAt, format: .dateTime, forKey: .terminateAt)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
        if let volumeConfiguration = self.volumeConfiguration {
            try encodeContainer.encode(volumeConfiguration, forKey: .volumeConfiguration)
        }
        if let volumeRetentionMode = self.volumeRetentionMode {
            try encodeContainer.encode(volumeRetentionMode.rawValue, forKey: .volumeRetentionMode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let ec2InstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceType)
        ec2InstanceType = ec2InstanceTypeDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let streamingImageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingImageId)
        streamingImageId = streamingImageIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let terminateAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .terminateAt)
        terminateAt = terminateAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let stoppedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stoppedAt)
        stoppedAt = stoppedAtDecoded
        let stoppedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stoppedBy)
        stoppedBy = stoppedByDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let stopAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopAt)
        stopAt = stopAtDecoded
        let startedFromBackupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedFromBackupId)
        startedFromBackupId = startedFromBackupIdDecoded
        let backupModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SessionBackupMode.self, forKey: .backupMode)
        backupMode = backupModeDecoded
        let maxBackupsToRetainDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBackupsToRetain)
        maxBackupsToRetain = maxBackupsToRetainDecoded
        let volumeRetentionModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.VolumeRetentionMode.self, forKey: .volumeRetentionMode)
        volumeRetentionMode = volumeRetentionModeDecoded
        let sessionPersistenceModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.SessionPersistenceMode.self, forKey: .sessionPersistenceMode)
        sessionPersistenceMode = sessionPersistenceModeDecoded
        let volumeConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.VolumeConfiguration.self, forKey: .volumeConfiguration)
        volumeConfiguration = volumeConfigurationDecoded
        let automaticTerminationModeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.AutomaticTerminationMode.self, forKey: .automaticTerminationMode)
        automaticTerminationMode = automaticTerminationModeDecoded
    }
}

extension NimbleClientTypes {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public struct StreamingSession: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Shows the current backup setting of the session.
        public var backupMode: NimbleClientTypes.SessionBackupMode?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session.
        public var createdBy: Swift.String?
        /// The EC2 Instance type used for the streaming session.
        public var ec2InstanceType: Swift.String?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.
        public var maxBackupsToRetain: Swift.Int?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public var ownedBy: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The time the session entered START_IN_PROGRESS state.
        public var startedAt: ClientRuntime.Date?
        /// The user ID of the user that started the streaming session.
        public var startedBy: Swift.String?
        /// The backup ID used to restore a streaming session.
        public var startedFromBackupId: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public var statusMessage: Swift.String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        public var stopAt: ClientRuntime.Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        public var stoppedAt: ClientRuntime.Date?
        /// The user ID of the user that stopped the streaming session.
        public var stoppedBy: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        public var terminateAt: ClientRuntime.Date?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?
        /// Determine if an EBS volume created from this streaming session will be backed up.
        public var volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode?

        public init(
            arn: Swift.String? = nil,
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            backupMode: NimbleClientTypes.SessionBackupMode? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            launchProfileId: Swift.String? = nil,
            maxBackupsToRetain: Swift.Int? = nil,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            startedAt: ClientRuntime.Date? = nil,
            startedBy: Swift.String? = nil,
            startedFromBackupId: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            stopAt: ClientRuntime.Date? = nil,
            stoppedAt: ClientRuntime.Date? = nil,
            stoppedBy: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateAt: ClientRuntime.Date? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil,
            volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode? = nil
        )
        {
            self.arn = arn
            self.automaticTerminationMode = automaticTerminationMode
            self.backupMode = backupMode
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.maxBackupsToRetain = maxBackupsToRetain
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.sessionPersistenceMode = sessionPersistenceMode
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.startedFromBackupId = startedFromBackupId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.volumeConfiguration = volumeConfiguration
            self.volumeRetentionMode = volumeRetentionMode
        }
    }

}

extension NimbleClientTypes.StreamingSessionBackup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case backupId
        case createdAt
        case launchProfileId
        case ownedBy
        case sessionId
        case state
        case statusCode
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let backupId = self.backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let launchProfileId = self.launchProfileId {
            try encodeContainer.encode(launchProfileId, forKey: .launchProfileId)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let sessionId = self.sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let launchProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileId)
        launchProfileId = launchProfileIdDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension NimbleClientTypes {
    /// Information about the streaming session backup.
    public struct StreamingSessionBackup: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ID of the backup.
        public var backupId: Swift.String?
        /// The ISO timestamp in for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the launch profile which allowed the backups for the streaming session.
        public var launchProfileId: Swift.String?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The streaming session ID for the StreamingSessionBackup.
        public var sessionId: Swift.String?
        /// The streaming session state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session backup.
        public var statusMessage: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            launchProfileId: Swift.String? = nil,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.backupId = backupId
            self.createdAt = createdAt
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension NimbleClientTypes {
    /// The streaming session state.
    public enum StreamingSessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case startFailed
        case startInProgress
        case stopped
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .startFailed,
                .startInProgress,
                .stopped,
                .stopFailed,
                .stopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionState(rawValue: rawValue) ?? StreamingSessionState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingSessionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryDomainJoinError
        case amiValidationError
        case decryptStreamingImageError
        case initializationScriptError
        case insufficientCapacity
        case internalError
        case networkConnectionError
        case networkInterfaceError
        case streamingSessionCreateInProgress
        case streamingSessionDeleted
        case streamingSessionDeleteInProgress
        case streamingSessionReady
        case streamingSessionStarted
        case streamingSessionStartInProgress
        case streamingSessionStopped
        case streamingSessionStopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStatusCode] {
            return [
                .activeDirectoryDomainJoinError,
                .amiValidationError,
                .decryptStreamingImageError,
                .initializationScriptError,
                .insufficientCapacity,
                .internalError,
                .networkConnectionError,
                .networkInterfaceError,
                .streamingSessionCreateInProgress,
                .streamingSessionDeleted,
                .streamingSessionDeleteInProgress,
                .streamingSessionReady,
                .streamingSessionStarted,
                .streamingSessionStartInProgress,
                .streamingSessionStopped,
                .streamingSessionStopInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryDomainJoinError: return "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            case .amiValidationError: return "AMI_VALIDATION_ERROR"
            case .decryptStreamingImageError: return "DECRYPT_STREAMING_IMAGE_ERROR"
            case .initializationScriptError: return "INITIALIZATION_SCRIPT_ERROR"
            case .insufficientCapacity: return "INSUFFICIENT_CAPACITY"
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .networkInterfaceError: return "NETWORK_INTERFACE_ERROR"
            case .streamingSessionCreateInProgress: return "STREAMING_SESSION_CREATE_IN_PROGRESS"
            case .streamingSessionDeleted: return "STREAMING_SESSION_DELETED"
            case .streamingSessionDeleteInProgress: return "STREAMING_SESSION_DELETE_IN_PROGRESS"
            case .streamingSessionReady: return "STREAMING_SESSION_READY"
            case .streamingSessionStarted: return "STREAMING_SESSION_STARTED"
            case .streamingSessionStartInProgress: return "STREAMING_SESSION_START_IN_PROGRESS"
            case .streamingSessionStopped: return "STREAMING_SESSION_STOPPED"
            case .streamingSessionStopInProgress: return "STREAMING_SESSION_STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStatusCode(rawValue: rawValue) ?? StreamingSessionStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingSessionStorageMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case upload
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStorageMode] {
            return [
                .upload,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .upload: return "UPLOAD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStorageMode(rawValue: rawValue) ?? StreamingSessionStorageMode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StreamingSessionStorageRoot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case linux
        case windows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linux = self.linux {
            try encodeContainer.encode(linux, forKey: .linux)
        }
        if let windows = self.windows {
            try encodeContainer.encode(windows, forKey: .windows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linuxDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .linux)
        linux = linuxDecoded
        let windowsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .windows)
        windows = windowsDecoded
    }
}

extension NimbleClientTypes.StreamingSessionStorageRoot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStorageRoot(linux: \"CONTENT_REDACTED\", windows: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The upload storage root location (folder) on streaming workstations where files are uploaded.
    public struct StreamingSessionStorageRoot: Swift.Equatable {
        /// The folder path in Linux workstations where files are uploaded.
        public var linux: Swift.String?
        /// The folder path in Windows workstations where files are uploaded.
        public var windows: Swift.String?

        public init(
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension NimbleClientTypes.StreamingSessionStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case expiresAt
        case ownedBy
        case state
        case statusCode
        case streamId
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let expiresAt = self.expiresAt {
            try encodeContainer.encodeTimestamp(expiresAt, format: .dateTime, forKey: .expiresAt)
        }
        if let ownedBy = self.ownedBy {
            try encodeContainer.encode(ownedBy, forKey: .ownedBy)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let expiresAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let ownedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownedBy)
        ownedBy = ownedByDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingSessionStreamStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension NimbleClientTypes.StreamingSessionStream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStream(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), expiresAt: \(Swift.String(describing: expiresAt)), ownedBy: \(Swift.String(describing: ownedBy)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), streamId: \(Swift.String(describing: streamId)), url: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A stream is an active connection to a streaming session, enabling a studio user to control the streaming session using a compatible client. Streaming session streams are compatible with the NICE DCV web client, included in the Nimble Studio portal, or the NICE DCV desktop client.
    public struct StreamingSessionStream: Swift.Equatable {
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the streaming session stream.
        public var createdBy: Swift.String?
        /// The ISO timestamp in seconds for when the resource expires.
        public var expiresAt: ClientRuntime.Date?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public var ownedBy: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionStreamState?
        /// The streaming session stream status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The URL to connect to this stream using the DCV client.
        public var url: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil,
            ownedBy: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionStreamState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode? = nil,
            streamId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }
    }

}

extension NimbleClientTypes {
    public enum StreamingSessionStreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamState(rawValue: rawValue) ?? StreamingSessionStreamState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StreamingSessionStreamStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case networkConnectionError
        case streamCreateInProgress
        case streamDeleted
        case streamDeleteInProgress
        case streamReady
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamStatusCode] {
            return [
                .internalError,
                .networkConnectionError,
                .streamCreateInProgress,
                .streamDeleted,
                .streamDeleteInProgress,
                .streamReady,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .streamCreateInProgress: return "STREAM_CREATE_IN_PROGRESS"
            case .streamDeleted: return "STREAM_DELETED"
            case .streamDeleteInProgress: return "STREAM_DELETE_IN_PROGRESS"
            case .streamReady: return "STREAM_READY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamingSessionStreamStatusCode(rawValue: rawValue) ?? StreamingSessionStreamStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.Studio: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case arn
        case createdAt
        case displayName
        case homeRegion
        case ssoClientId
        case state
        case statusCode
        case statusMessage
        case studioEncryptionConfiguration
        case studioId
        case studioName
        case studioUrl
        case tags
        case updatedAt
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = self.adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let homeRegion = self.homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let ssoClientId = self.ssoClientId {
            try encodeContainer.encode(ssoClientId, forKey: .ssoClientId)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioEncryptionConfiguration = self.studioEncryptionConfiguration {
            try encodeContainer.encode(studioEncryptionConfiguration, forKey: .studioEncryptionConfiguration)
        }
        if let studioId = self.studioId {
            try encodeContainer.encode(studioId, forKey: .studioId)
        }
        if let studioName = self.studioName {
            try encodeContainer.encode(studioName, forKey: .studioName)
        }
        if let studioUrl = self.studioUrl {
            try encodeContainer.encode(studioUrl, forKey: .studioUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let userRoleArn = self.userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let ssoClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoClientId)
        ssoClientId = ssoClientIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioEncryptionConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfiguration.self, forKey: .studioEncryptionConfiguration)
        studioEncryptionConfiguration = studioEncryptionConfigurationDecoded
        let studioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioId)
        studioId = studioIdDecoded
        let studioNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioName)
        studioName = studioNameDecoded
        let studioUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioUrl)
        studioUrl = studioUrlDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension NimbleClientTypes.Studio: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Studio(adminRoleArn: \(Swift.String(describing: adminRoleArn)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), homeRegion: \(Swift.String(describing: homeRegion)), ssoClientId: \(Swift.String(describing: ssoClientId)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioId: \(Swift.String(describing: studioId)), studioName: \(Swift.String(describing: studioName)), studioUrl: \(Swift.String(describing: studioUrl)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// Represents a studio resource. A studio is the core resource used with Nimble Studio. You must create a studio first, before any other resource type can be created. All other resources you create and manage in Nimble Studio are contained within a studio. When creating a studio, you must provides two IAM roles for use with the Nimble Studio portal. These roles are assumed by your users when they log in to the Nimble Studio portal via IAM Identity Center and your identity source. The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly. The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly. Your studio roles must trust the identity.nimble.amazonaws.com service principal to function properly.
    public struct Studio: Swift.Equatable {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public var adminRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// A friendly name for the studio.
        public var displayName: Swift.String?
        /// The Amazon Web Services Region where the studio resource is located.
        public var homeRegion: Swift.String?
        /// The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.
        public var ssoClientId: Swift.String?
        /// The current state of the studio resource.
        public var state: NimbleClientTypes.StudioState?
        /// Status codes that provide additional detail on the studio state.
        public var statusCode: NimbleClientTypes.StudioStatusCode?
        /// Additional detail on the studio state.
        public var statusMessage: Swift.String?
        /// Configuration of the encryption method that is used for the studio.
        public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public var studioId: Swift.String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public var studioName: Swift.String?
        /// The address of the web page for the studio.
        public var studioUrl: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public var userRoleArn: Swift.String?

        public init(
            adminRoleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            ssoClientId: Swift.String? = nil,
            state: NimbleClientTypes.StudioState? = nil,
            statusCode: NimbleClientTypes.StudioStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
            studioId: Swift.String? = nil,
            studioName: Swift.String? = nil,
            studioUrl: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            userRoleArn: Swift.String? = nil
        )
        {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }
    }

}

extension NimbleClientTypes.StudioComponent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configuration
        case createdAt
        case createdBy
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case state
        case statusCode
        case statusMessage
        case studioComponentId
        case subtype
        case tags
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for securitygroupid0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscript0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscript0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for scriptparameterkeyvalue0 in scriptParameters {
                try scriptParametersContainer.encode(scriptparameterkeyvalue0)
            }
        }
        if let secureInitializationRoleArn = self.secureInitializationRoleArn {
            try encodeContainer.encode(secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let studioComponentId = self.studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
        let secureInitializationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secureInitializationRoleArn)
        secureInitializationRoleArn = secureInitializationRoleArnDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
    }
}

extension NimbleClientTypes.StudioComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponent(arn: \(Swift.String(describing: arn)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A studio component represents a network resource to be used by a studio's users and workflows. A typical studio contains studio components for each of the following: render farm, Active Directory, licensing, and file system. Access to a studio component is managed by specifying security groups for the resource, as well as its endpoint. A studio component also has a set of initialization scripts that are returned by GetLaunchProfileInitialization. These initialization scripts run on streaming sessions when they start. They provide users with flexibility in controlling how the studio resources are configured on a streaming session.
    public struct StudioComponent: Swift.Equatable {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The configuration of the studio component, based on component type.
        public var configuration: NimbleClientTypes.StudioComponentConfiguration?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// A human-readable description for the studio component resource.
        public var description: Swift.String?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// Initialization scripts for studio components.
        public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public var name: Swift.String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public var runtimeRoleArn: Swift.String?
        /// Parameters for the studio component scripts.
        public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public var secureInitializationRoleArn: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StudioComponentState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StudioComponentStatusCode?
        /// The status message for the studio component.
        public var statusMessage: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init(
            arn: Swift.String? = nil,
            configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
            name: Swift.String? = nil,
            runtimeRoleArn: Swift.String? = nil,
            scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
            secureInitializationRoleArn: Swift.String? = nil,
            state: NimbleClientTypes.StudioComponentState? = nil,
            statusCode: NimbleClientTypes.StudioComponentStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.StudioComponentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activedirectoryconfiguration = "activeDirectoryConfiguration"
        case computefarmconfiguration = "computeFarmConfiguration"
        case licenseserviceconfiguration = "licenseServiceConfiguration"
        case sdkUnknown
        case sharedfilesystemconfiguration = "sharedFileSystemConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .activedirectoryconfiguration(activedirectoryconfiguration):
                try container.encode(activedirectoryconfiguration, forKey: .activedirectoryconfiguration)
            case let .computefarmconfiguration(computefarmconfiguration):
                try container.encode(computefarmconfiguration, forKey: .computefarmconfiguration)
            case let .licenseserviceconfiguration(licenseserviceconfiguration):
                try container.encode(licenseserviceconfiguration, forKey: .licenseserviceconfiguration)
            case let .sharedfilesystemconfiguration(sharedfilesystemconfiguration):
                try container.encode(sharedfilesystemconfiguration, forKey: .sharedfilesystemconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let activedirectoryconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.ActiveDirectoryConfiguration.self, forKey: .activedirectoryconfiguration)
        if let activedirectoryconfiguration = activedirectoryconfigurationDecoded {
            self = .activedirectoryconfiguration(activedirectoryconfiguration)
            return
        }
        let computefarmconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.ComputeFarmConfiguration.self, forKey: .computefarmconfiguration)
        if let computefarmconfiguration = computefarmconfigurationDecoded {
            self = .computefarmconfiguration(computefarmconfiguration)
            return
        }
        let licenseserviceconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.LicenseServiceConfiguration.self, forKey: .licenseserviceconfiguration)
        if let licenseserviceconfiguration = licenseserviceconfigurationDecoded {
            self = .licenseserviceconfiguration(licenseserviceconfiguration)
            return
        }
        let sharedfilesystemconfigurationDecoded = try values.decodeIfPresent(NimbleClientTypes.SharedFileSystemConfiguration.self, forKey: .sharedfilesystemconfiguration)
        if let sharedfilesystemconfiguration = sharedfilesystemconfigurationDecoded {
            self = .sharedfilesystemconfiguration(sharedfilesystemconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension NimbleClientTypes {
    /// The configuration of the studio component, based on component type.
    public enum StudioComponentConfiguration: Swift.Equatable {
        /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
        case activedirectoryconfiguration(NimbleClientTypes.ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computefarmconfiguration(NimbleClientTypes.ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseserviceconfiguration(NimbleClientTypes.LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedfilesystemconfiguration(NimbleClientTypes.SharedFileSystemConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfileProtocolVersion
        case platform
        case runContext
        case script
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchProfileProtocolVersion = self.launchProfileProtocolVersion {
            try encodeContainer.encode(launchProfileProtocolVersion, forKey: .launchProfileProtocolVersion)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let runContext = self.runContext {
            try encodeContainer.encode(runContext.rawValue, forKey: .runContext)
        }
        if let script = self.script {
            try encodeContainer.encode(script, forKey: .script)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileProtocolVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchProfileProtocolVersion)
        launchProfileProtocolVersion = launchProfileProtocolVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePlatform.self, forKey: .platform)
        platform = platformDecoded
        let runContextDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentInitializationScriptRunContext.self, forKey: .runContext)
        runContext = runContextDecoded
        let scriptDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .script)
        script = scriptDecoded
    }
}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentInitializationScript(launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), platform: \(Swift.String(describing: platform)), runContext: \(Swift.String(describing: runContext)), script: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// Initialization scripts for studio components.
    public struct StudioComponentInitializationScript: Swift.Equatable {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The platform of the initialization script, either Windows or Linux.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public var runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public var script: Swift.String?

        public init(
            launchProfileProtocolVersion: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext? = nil,
            script: Swift.String? = nil
        )
        {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }
    }

}

extension NimbleClientTypes {
    public enum StudioComponentInitializationScriptRunContext: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case systemInitialization
        case userInitialization
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentInitializationScriptRunContext] {
            return [
                .systemInitialization,
                .userInitialization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .systemInitialization: return "SYSTEM_INITIALIZATION"
            case .userInitialization: return "USER_INITIALIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentInitializationScriptRunContext(rawValue: rawValue) ?? StudioComponentInitializationScriptRunContext.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current state of the studio component resource. While a studio component is being created, modified, or deleted, its state will be CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, or DELETE_IN_PROGRESS. These are called transition states. No modifications may be made to the studio component while it is in a transition state. If creation of the resource fails, the state will change to CREATE_FAILED. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time. If updating the resource fails, the state will change to UPDATE_FAILED. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. If deleting the resource fails, the state will change to DELETE_FAILED. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the DELETED state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.
    public enum StudioComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentState(rawValue: rawValue) ?? StudioComponentState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The current status of the studio component resource. When the resource is in the READY state, the status code signals what the last mutation made to the resource was. When the resource is in a CREATE_FAILED, UPDATE_FAILED, or DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.
    public enum StudioComponentStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectoryAlreadyExists
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case studioComponentCreated
        case studioComponentCreateInProgress
        case studioComponentDeleted
        case studioComponentDeleteInProgress
        case studioComponentUpdated
        case studioComponentUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentStatusCode] {
            return [
                .activeDirectoryAlreadyExists,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .studioComponentCreated,
                .studioComponentCreateInProgress,
                .studioComponentDeleted,
                .studioComponentDeleteInProgress,
                .studioComponentUpdated,
                .studioComponentUpdateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryAlreadyExists: return "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .studioComponentCreated: return "STUDIO_COMPONENT_CREATED"
            case .studioComponentCreateInProgress: return "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            case .studioComponentDeleted: return "STUDIO_COMPONENT_DELETED"
            case .studioComponentDeleteInProgress: return "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            case .studioComponentUpdated: return "STUDIO_COMPONENT_UPDATED"
            case .studioComponentUpdateInProgress: return "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentStatusCode(rawValue: rawValue) ?? StudioComponentStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StudioComponentSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonFsxForLustre
        case amazonFsxForWindows
        case awsManagedMicrosoftAd
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentSubtype] {
            return [
                .amazonFsxForLustre,
                .amazonFsxForWindows,
                .awsManagedMicrosoftAd,
                .custom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonFsxForLustre: return "AMAZON_FSX_FOR_LUSTRE"
            case .amazonFsxForWindows: return "AMAZON_FSX_FOR_WINDOWS"
            case .awsManagedMicrosoftAd: return "AWS_MANAGED_MICROSOFT_AD"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentSubtype(rawValue: rawValue) ?? StudioComponentSubtype.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case createdBy
        case description
        case name
        case studioComponentId
        case subtype
        case type
        case updatedAt
        case updatedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let studioComponentId = self.studioComponentId {
            try encodeContainer.encode(studioComponentId, forKey: .studioComponentId)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
        if let updatedBy = self.updatedBy {
            try encodeContainer.encode(updatedBy, forKey: .updatedBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let studioComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .studioComponentId)
        studioComponentId = studioComponentIdDecoded
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let updatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedBy)
        updatedBy = updatedByDecoded
    }
}

extension NimbleClientTypes.StudioComponentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The studio component's summary.
    public struct StudioComponentSummary: Swift.Equatable {
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: ClientRuntime.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name for the studio component.
        public var name: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: ClientRuntime.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes {
    public enum StudioComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activeDirectory
        case computeFarm
        case custom
        case licenseService
        case sharedFileSystem
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentType] {
            return [
                .activeDirectory,
                .computeFarm,
                .custom,
                .licenseService,
                .sharedFileSystem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .computeFarm: return "COMPUTE_FARM"
            case .custom: return "CUSTOM"
            case .licenseService: return "LICENSE_SERVICE"
            case .sharedFileSystem: return "SHARED_FILE_SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioComponentType(rawValue: rawValue) ?? StudioComponentType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioEncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case keyType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = self.keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let keyType = self.keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioEncryptionConfigurationKeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
    }
}

extension NimbleClientTypes {
    /// Configuration of the encryption method that is used for the studio.
    public struct StudioEncryptionConfiguration: Swift.Equatable {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType?

        public init(
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {
    /// The type of KMS key that is used to encrypt studio data.
    public enum StudioEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioEncryptionConfigurationKeyType] {
            return [
                .awsOwnedKey,
                .customerManagedKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioEncryptionConfigurationKeyType(rawValue: rawValue) ?? StudioEncryptionConfigurationKeyType.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes.StudioMembership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId
        case persona
        case principalId
        case sid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let sid = self.sid {
            try encodeContainer.encode(sid, forKey: .sid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioPersona.self, forKey: .persona)
        persona = personaDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let sidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sid)
        sid = sidDecoded
    }
}

extension NimbleClientTypes {
    /// A studio member is an association of a user from your studio identity source to elevated permissions that they are granted in the studio. When you add a user to your studio using the Nimble Studio console, they are given access to the studio's IAM Identity Center application and are given access to log in to the Nimble Studio portal. These users have the permissions provided by the studio's user IAM role and do not appear in the studio membership collection. Only studio admins appear in studio membership. When you add a user to studio membership with the ADMIN persona, upon logging in to the Nimble Studio portal, they are granted permissions specified by the Studio's Admin IAM role.
    public struct StudioMembership: Swift.Equatable {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

extension NimbleClientTypes {
    public enum StudioPersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioPersona] {
            return [
                .administrator,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioPersona(rawValue: rawValue) ?? StudioPersona.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    public enum StudioState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioState(rawValue: rawValue) ?? StudioState.sdkUnknown(rawValue)
        }
    }
}

extension NimbleClientTypes {
    /// The status code.
    public enum StudioStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsSsoAccessDenied
        case awsSsoConfigurationRepaired
        case awsSsoConfigurationRepairInProgress
        case awsSsoNotEnabled
        case awsStsRegionDisabled
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case roleCouldNotBeAssumed
        case roleNotOwnedByStudioOwner
        case studioCreated
        case studioCreateInProgress
        case studioDeleted
        case studioDeleteInProgress
        case studioUpdated
        case studioUpdateInProgress
        case studioWithLaunchProfilesNotDeleted
        case studioWithStreamingImagesNotDeleted
        case studioWithStudioComponentsNotDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioStatusCode] {
            return [
                .awsSsoAccessDenied,
                .awsSsoConfigurationRepaired,
                .awsSsoConfigurationRepairInProgress,
                .awsSsoNotEnabled,
                .awsStsRegionDisabled,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .roleCouldNotBeAssumed,
                .roleNotOwnedByStudioOwner,
                .studioCreated,
                .studioCreateInProgress,
                .studioDeleted,
                .studioDeleteInProgress,
                .studioUpdated,
                .studioUpdateInProgress,
                .studioWithLaunchProfilesNotDeleted,
                .studioWithStreamingImagesNotDeleted,
                .studioWithStudioComponentsNotDeleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsSsoAccessDenied: return "AWS_SSO_ACCESS_DENIED"
            case .awsSsoConfigurationRepaired: return "AWS_SSO_CONFIGURATION_REPAIRED"
            case .awsSsoConfigurationRepairInProgress: return "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            case .awsSsoNotEnabled: return "AWS_SSO_NOT_ENABLED"
            case .awsStsRegionDisabled: return "AWS_STS_REGION_DISABLED"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .roleCouldNotBeAssumed: return "ROLE_COULD_NOT_BE_ASSUMED"
            case .roleNotOwnedByStudioOwner: return "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
            case .studioCreated: return "STUDIO_CREATED"
            case .studioCreateInProgress: return "STUDIO_CREATE_IN_PROGRESS"
            case .studioDeleted: return "STUDIO_DELETED"
            case .studioDeleteInProgress: return "STUDIO_DELETE_IN_PROGRESS"
            case .studioUpdated: return "STUDIO_UPDATED"
            case .studioUpdateInProgress: return "STUDIO_UPDATE_IN_PROGRESS"
            case .studioWithLaunchProfilesNotDeleted: return "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            case .studioWithStreamingImagesNotDeleted: return "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            case .studioWithStudioComponentsNotDeleted: return "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StudioStatusCode(rawValue: rawValue) ?? StudioStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateLaunchProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let launchProfileProtocolVersions = launchProfileProtocolVersions {
            var launchProfileProtocolVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchProfileProtocolVersions)
            for launchprofileprotocolversion0 in launchProfileProtocolVersions {
                try launchProfileProtocolVersionsContainer.encode(launchprofileprotocolversion0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let streamConfiguration = self.streamConfiguration {
            try encodeContainer.encode(streamConfiguration, forKey: .streamConfiguration)
        }
        if let studioComponentIds = studioComponentIds {
            var studioComponentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .studioComponentIds)
            for string0 in studioComponentIds {
                try studioComponentIdsContainer.encode(string0)
            }
        }
    }
}

extension UpdateLaunchProfileInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateLaunchProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

public struct UpdateLaunchProfileInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileInputBody: Swift.Equatable {
    let description: Swift.String?
    let launchProfileProtocolVersions: [Swift.String]?
    let name: Swift.String?
    let streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    let studioComponentIds: [Swift.String]?
}

extension UpdateLaunchProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case launchProfileProtocolVersions
        case name
        case streamConfiguration
        case studioComponentIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let launchProfileProtocolVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchProfileProtocolVersions)
        var launchProfileProtocolVersionsDecoded0:[Swift.String]? = nil
        if let launchProfileProtocolVersionsContainer = launchProfileProtocolVersionsContainer {
            launchProfileProtocolVersionsDecoded0 = [Swift.String]()
            for string0 in launchProfileProtocolVersionsContainer {
                if let string0 = string0 {
                    launchProfileProtocolVersionsDecoded0?.append(string0)
                }
            }
        }
        launchProfileProtocolVersions = launchProfileProtocolVersionsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let streamConfigurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamConfigurationCreate.self, forKey: .streamConfiguration)
        streamConfiguration = streamConfigurationDecoded
        let studioComponentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .studioComponentIds)
        var studioComponentIdsDecoded0:[Swift.String]? = nil
        if let studioComponentIdsContainer = studioComponentIdsContainer {
            studioComponentIdsDecoded0 = [Swift.String]()
            for string0 in studioComponentIdsContainer {
                if let string0 = string0 {
                    studioComponentIdsDecoded0?.append(string0)
                }
            }
        }
        studioComponentIds = studioComponentIdsDecoded0
    }
}

extension UpdateLaunchProfileMemberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let persona = self.persona {
            try encodeContainer.encode(persona.rawValue, forKey: .persona)
        }
    }
}

extension UpdateLaunchProfileMemberInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateLaunchProfileMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let launchProfileId = launchProfileId else {
            return nil
        }
        guard let principalId = principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

public struct UpdateLaunchProfileMemberInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The persona.
    /// This member is required.
    public var persona: NimbleClientTypes.LaunchProfilePersona?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        persona: NimbleClientTypes.LaunchProfilePersona? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.persona = persona
        self.principalId = principalId
        self.studioId = studioId
    }
}

struct UpdateLaunchProfileMemberInputBody: Swift.Equatable {
    let persona: NimbleClientTypes.LaunchProfilePersona?
}

extension UpdateLaunchProfileMemberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case persona
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let personaDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfilePersona.self, forKey: .persona)
        persona = personaDecoded
    }
}

extension UpdateLaunchProfileMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchProfileMemberOutputBody = try responseDecoder.decode(responseBody: data)
            self.member = output.member
        } else {
            self.member = nil
        }
    }
}

public struct UpdateLaunchProfileMemberOutput: Swift.Equatable {
    /// The updated member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init(
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

struct UpdateLaunchProfileMemberOutputBody: Swift.Equatable {
    let member: NimbleClientTypes.LaunchProfileMembership?
}

extension UpdateLaunchProfileMemberOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case member
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileMembership.self, forKey: .member)
        member = memberDecoded
    }
}

enum UpdateLaunchProfileMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchProfile = output.launchProfile
        } else {
            self.launchProfile = nil
        }
    }
}

public struct UpdateLaunchProfileOutput: Swift.Equatable {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

struct UpdateLaunchProfileOutputBody: Swift.Equatable {
    let launchProfile: NimbleClientTypes.LaunchProfile?
}

extension UpdateLaunchProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchProfile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchProfileDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfile.self, forKey: .launchProfile)
        launchProfile = launchProfileDecoded
    }
}

enum UpdateLaunchProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateStreamingImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateStreamingImageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStreamingImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let streamingImageId = streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

public struct UpdateStreamingImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name for the streaming image.
    public var name: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

struct UpdateStreamingImageInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
}

extension UpdateStreamingImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateStreamingImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStreamingImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamingImage = output.streamingImage
        } else {
            self.streamingImage = nil
        }
    }
}

public struct UpdateStreamingImageOutput: Swift.Equatable {
    /// Represents a streaming image resource. Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session. Amazon provides a number of streaming images that include popular 3rd-party software. You can create your own streaming images using an Amazon EC2 machine image that you create for this purpose. You can also include software that your users require.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

struct UpdateStreamingImageOutputBody: Swift.Equatable {
    let streamingImage: NimbleClientTypes.StreamingImage?
}

extension UpdateStreamingImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamingImage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingImageDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StreamingImage.self, forKey: .streamingImage)
        streamingImage = streamingImageDecoded
    }
}

enum UpdateStreamingImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

extension UpdateStudioComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case subtype
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2SecurityGroupIds = ec2SecurityGroupIds {
            var ec2SecurityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2SecurityGroupIds)
            for securitygroupid0 in ec2SecurityGroupIds {
                try ec2SecurityGroupIdsContainer.encode(securitygroupid0)
            }
        }
        if let initializationScripts = initializationScripts {
            var initializationScriptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .initializationScripts)
            for studiocomponentinitializationscript0 in initializationScripts {
                try initializationScriptsContainer.encode(studiocomponentinitializationscript0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let runtimeRoleArn = self.runtimeRoleArn {
            try encodeContainer.encode(runtimeRoleArn, forKey: .runtimeRoleArn)
        }
        if let scriptParameters = scriptParameters {
            var scriptParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scriptParameters)
            for scriptparameterkeyvalue0 in scriptParameters {
                try scriptParametersContainer.encode(scriptparameterkeyvalue0)
            }
        }
        if let secureInitializationRoleArn = self.secureInitializationRoleArn {
            try encodeContainer.encode(secureInitializationRoleArn, forKey: .secureInitializationRoleArn)
        }
        if let subtype = self.subtype {
            try encodeContainer.encode(subtype.rawValue, forKey: .subtype)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateStudioComponentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        guard let studioComponentId = studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

public struct UpdateStudioComponentInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    public var name: Swift.String?
    /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    public var runtimeRoleArn: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    public var secureInitializationRoleArn: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// The type of the studio component.
    public var type: NimbleClientTypes.StudioComponentType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.scriptParameters = scriptParameters
        self.secureInitializationRoleArn = secureInitializationRoleArn
        self.studioComponentId = studioComponentId
        self.studioId = studioId
        self.subtype = subtype
        self.type = type
    }
}

struct UpdateStudioComponentInputBody: Swift.Equatable {
    let configuration: NimbleClientTypes.StudioComponentConfiguration?
    let description: Swift.String?
    let ec2SecurityGroupIds: [Swift.String]?
    let initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    let name: Swift.String?
    let scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    let subtype: NimbleClientTypes.StudioComponentSubtype?
    let type: NimbleClientTypes.StudioComponentType?
    let secureInitializationRoleArn: Swift.String?
    let runtimeRoleArn: Swift.String?
}

extension UpdateStudioComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case description
        case ec2SecurityGroupIds
        case initializationScripts
        case name
        case runtimeRoleArn
        case scriptParameters
        case secureInitializationRoleArn
        case subtype
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ec2SecurityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ec2SecurityGroupIds)
        var ec2SecurityGroupIdsDecoded0:[Swift.String]? = nil
        if let ec2SecurityGroupIdsContainer = ec2SecurityGroupIdsContainer {
            ec2SecurityGroupIdsDecoded0 = [Swift.String]()
            for string0 in ec2SecurityGroupIdsContainer {
                if let string0 = string0 {
                    ec2SecurityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        ec2SecurityGroupIds = ec2SecurityGroupIdsDecoded0
        let initializationScriptsContainer = try containerValues.decodeIfPresent([NimbleClientTypes.StudioComponentInitializationScript?].self, forKey: .initializationScripts)
        var initializationScriptsDecoded0:[NimbleClientTypes.StudioComponentInitializationScript]? = nil
        if let initializationScriptsContainer = initializationScriptsContainer {
            initializationScriptsDecoded0 = [NimbleClientTypes.StudioComponentInitializationScript]()
            for structure0 in initializationScriptsContainer {
                if let structure0 = structure0 {
                    initializationScriptsDecoded0?.append(structure0)
                }
            }
        }
        initializationScripts = initializationScriptsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let scriptParametersContainer = try containerValues.decodeIfPresent([NimbleClientTypes.ScriptParameterKeyValue?].self, forKey: .scriptParameters)
        var scriptParametersDecoded0:[NimbleClientTypes.ScriptParameterKeyValue]? = nil
        if let scriptParametersContainer = scriptParametersContainer {
            scriptParametersDecoded0 = [NimbleClientTypes.ScriptParameterKeyValue]()
            for structure0 in scriptParametersContainer {
                if let structure0 = structure0 {
                    scriptParametersDecoded0?.append(structure0)
                }
            }
        }
        scriptParameters = scriptParametersDecoded0
        let subtypeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentSubtype.self, forKey: .subtype)
        subtype = subtypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponentType.self, forKey: .type)
        type = typeDecoded
        let secureInitializationRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secureInitializationRoleArn)
        secureInitializationRoleArn = secureInitializationRoleArnDecoded
        let runtimeRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeRoleArn)
        runtimeRoleArn = runtimeRoleArnDecoded
    }
}

extension UpdateStudioComponentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStudioComponentOutputBody = try responseDecoder.decode(responseBody: data)
            self.studioComponent = output.studioComponent
        } else {
            self.studioComponent = nil
        }
    }
}

public struct UpdateStudioComponentOutput: Swift.Equatable {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

struct UpdateStudioComponentOutputBody: Swift.Equatable {
    let studioComponent: NimbleClientTypes.StudioComponent?
}

extension UpdateStudioComponentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studioComponent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioComponentDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.StudioComponent.self, forKey: .studioComponent)
        studioComponent = studioComponentDecoded
    }
}

enum UpdateStudioComponentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioId: \(Swift.String(describing: studioId)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension UpdateStudioInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case userRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminRoleArn = self.adminRoleArn {
            try encodeContainer.encode(adminRoleArn, forKey: .adminRoleArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let userRoleArn = self.userRoleArn {
            try encodeContainer.encode(userRoleArn, forKey: .userRoleArn)
        }
    }
}

extension UpdateStudioInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let clientToken = clientToken {
            items.add(Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let studioId = studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

public struct UpdateStudioInput: Swift.Equatable {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    public var displayName: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    public var userRoleArn: Swift.String?

    public init(
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioId: Swift.String? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioId = studioId
        self.userRoleArn = userRoleArn
    }
}

struct UpdateStudioInputBody: Swift.Equatable {
    let adminRoleArn: Swift.String?
    let displayName: Swift.String?
    let userRoleArn: Swift.String?
}

extension UpdateStudioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminRoleArn
        case displayName
        case userRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminRoleArn)
        adminRoleArn = adminRoleArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let userRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userRoleArn)
        userRoleArn = userRoleArnDecoded
    }
}

extension UpdateStudioOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateStudioOutputBody = try responseDecoder.decode(responseBody: data)
            self.studio = output.studio
        } else {
            self.studio = nil
        }
    }
}

public struct UpdateStudioOutput: Swift.Equatable {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

struct UpdateStudioOutputBody: Swift.Equatable {
    let studio: NimbleClientTypes.Studio?
}

extension UpdateStudioOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case studio
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let studioDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.Studio.self, forKey: .studio)
        studio = studioDecoded
    }
}

enum UpdateStudioOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.context = output.context
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.context = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One of the parameters in the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String:Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String:Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let code: Swift.String?
    let context: [Swift.String:Swift.String]?
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case context
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let contextContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .context)
        var contextDecoded0: [Swift.String:Swift.String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in contextContainer {
                if let string0 = string0 {
                    contextDecoded0?[key0] = string0
                }
            }
        }
        context = contextDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NimbleClientTypes.ValidationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case statusCode
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileValidationType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileValidationState.self, forKey: .state)
        state = stateDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(NimbleClientTypes.LaunchProfileValidationStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension NimbleClientTypes {
    /// The launch profile validation result.
    public struct ValidationResult: Swift.Equatable {
        /// The current state.
        /// This member is required.
        public var state: NimbleClientTypes.LaunchProfileValidationState?
        /// The status code. This will contain the failure reason if the state is VALIDATION_FAILED.
        /// This member is required.
        public var statusCode: NimbleClientTypes.LaunchProfileValidationStatusCode?
        /// The status message for the validation result.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The type of the validation result.
        /// This member is required.
        public var type: NimbleClientTypes.LaunchProfileValidationType?

        public init(
            state: NimbleClientTypes.LaunchProfileValidationState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileValidationStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            type: NimbleClientTypes.LaunchProfileValidationType? = nil
        )
        {
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension NimbleClientTypes.VolumeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iops
        case size
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension NimbleClientTypes {
    /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
    public struct VolumeConfiguration: Swift.Equatable {
        /// The number of I/O operations per second for the root volume that is attached to streaming session.
        public var iops: Swift.Int?
        /// The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.
        public var size: Swift.Int?
        /// The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.
        public var throughput: Swift.Int?

        public init(
            iops: Swift.Int? = nil,
            size: Swift.Int? = nil,
            throughput: Swift.Int? = nil
        )
        {
            self.iops = iops
            self.size = size
            self.throughput = throughput
        }
    }

}

extension NimbleClientTypes {
    public enum VolumeRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeRetentionMode] {
            return [
                .delete,
                .retain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeRetentionMode(rawValue: rawValue) ?? VolumeRetentionMode.sdkUnknown(rawValue)
        }
    }
}
