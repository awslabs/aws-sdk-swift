//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You are not authorized to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// Another operation is in progress.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// Your current quota does not allow you to perform the request action. You can request increases for some quotas, and other quotas cannot be increased. Please use Amazon Web Services Service Quotas to request an increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// The request throughput limit was exceeded.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

/// One of the parameters in the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A more specific error code.
        public internal(set) var code: Swift.String? = nil
        /// The exception context.
        public internal(set) var context: [Swift.String: Swift.String]? = nil
        /// A human-readable description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        context: [Swift.String: Swift.String]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.context = context
        self.properties.message = message
    }
}

public struct AcceptEulasInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EULA ID.
    public var eulaIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        eulaIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.eulaIds = eulaIds
        self.studioId = studioId
    }
}

extension NimbleClientTypes {
    /// The acceptance of a EULA, required to use Amazon-provided streaming images.
    public struct EulaAcceptance {
        /// The ISO timestamp in seconds for when the EULA was accepted.
        public var acceptedAt: Foundation.Date?
        /// The ID of the person who accepted the EULA.
        public var acceptedBy: Swift.String?
        /// The ID of the acceptee.
        public var accepteeId: Swift.String?
        /// The EULA acceptance ID.
        public var eulaAcceptanceId: Swift.String?
        /// The EULA ID.
        public var eulaId: Swift.String?

        public init(
            acceptedAt: Foundation.Date? = nil,
            acceptedBy: Swift.String? = nil,
            accepteeId: Swift.String? = nil,
            eulaAcceptanceId: Swift.String? = nil,
            eulaId: Swift.String? = nil
        )
        {
            self.acceptedAt = acceptedAt
            self.acceptedBy = acceptedBy
            self.accepteeId = accepteeId
            self.eulaAcceptanceId = eulaAcceptanceId
            self.eulaId = eulaId
        }
    }

}

public struct AcceptEulasOutput {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?

    public init(
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
    }
}

extension NimbleClientTypes {
    /// An LDAP attribute of an Active Directory computer account, in the form of a name:value pair.
    public struct ActiveDirectoryComputerAttribute {
        /// The name for the LDAP attribute.
        public var name: Swift.String?
        /// The value for the LDAP attribute.
        public var value: Swift.String?

        public init(
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension NimbleClientTypes {
    /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
    public struct ActiveDirectoryConfiguration {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this studio component.
        public var directoryId: Swift.String?
        /// The distinguished name (DN) and organizational unit (OU) of an Active Directory computer.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init(
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension NimbleClientTypes.ActiveDirectoryConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveDirectoryConfiguration(directoryId: \(Swift.String(describing: directoryId)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), computerAttributes: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    public enum AutomaticTerminationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [AutomaticTerminationMode] {
            return [
                .activated,
                .deactivated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// The configuration for a render farm that is associated with a studio resource.
    public struct ComputeFarmConfiguration {
        /// The name of an Active Directory user that is used on ComputeFarm worker instances.
        public var activeDirectoryUser: Swift.String?
        /// The endpoint of the ComputeFarm that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init(
            activeDirectoryUser: Swift.String? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.activeDirectoryUser = activeDirectoryUser
            self.endpoint = endpoint
        }
    }

}

extension NimbleClientTypes.ComputeFarmConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComputeFarmConfiguration(activeDirectoryUser: \(Swift.String(describing: activeDirectoryUser)), endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    public enum StreamingClipboardMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingClipboardMode] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StreamingInstanceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case g34xlarge
        case g3sXlarge
        case g4dn12xlarge
        case g4dn16xlarge
        case g4dn2xlarge
        case g4dn4xlarge
        case g4dn8xlarge
        case g4dnXlarge
        case g516xlarge
        case g52xlarge
        case g54xlarge
        case g58xlarge
        case g5Xlarge
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingInstanceType] {
            return [
                .g34xlarge,
                .g3sXlarge,
                .g4dn12xlarge,
                .g4dn16xlarge,
                .g4dn2xlarge,
                .g4dn4xlarge,
                .g4dn8xlarge,
                .g4dnXlarge,
                .g516xlarge,
                .g52xlarge,
                .g54xlarge,
                .g58xlarge,
                .g5Xlarge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .g34xlarge: return "g3.4xlarge"
            case .g3sXlarge: return "g3s.xlarge"
            case .g4dn12xlarge: return "g4dn.12xlarge"
            case .g4dn16xlarge: return "g4dn.16xlarge"
            case .g4dn2xlarge: return "g4dn.2xlarge"
            case .g4dn4xlarge: return "g4dn.4xlarge"
            case .g4dn8xlarge: return "g4dn.8xlarge"
            case .g4dnXlarge: return "g4dn.xlarge"
            case .g516xlarge: return "g5.16xlarge"
            case .g52xlarge: return "g5.2xlarge"
            case .g54xlarge: return "g5.4xlarge"
            case .g58xlarge: return "g5.8xlarge"
            case .g5Xlarge: return "g5.xlarge"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum SessionBackupMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionBackupMode] {
            return [
                .automatic,
                .deactivated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Configures how streaming sessions are backed up when launched from this launch profile.
    public struct StreamConfigurationSessionBackup {
        /// The maximum number of backups that each streaming session created from this launch profile can have.
        public var maxBackupsToRetain: Swift.Int?
        /// Specifies how artists sessions are backed up. Configures backups for streaming sessions launched with this launch profile. The default value is DEACTIVATED, which means that backups are deactivated. To allow backups, set this value to AUTOMATIC.
        public var mode: NimbleClientTypes.SessionBackupMode?

        public init(
            maxBackupsToRetain: Swift.Int? = 0,
            mode: NimbleClientTypes.SessionBackupMode? = nil
        )
        {
            self.maxBackupsToRetain = maxBackupsToRetain
            self.mode = mode
        }
    }

}

extension NimbleClientTypes {

    public enum SessionPersistenceMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case deactivated
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionPersistenceMode] {
            return [
                .activated,
                .deactivated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .deactivated: return "DEACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StreamingSessionStorageMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case upload
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStorageMode] {
            return [
                .upload
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .upload: return "UPLOAD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// The upload storage root location (folder) on streaming workstations where files are uploaded.
    public struct StreamingSessionStorageRoot {
        /// The folder path in Linux workstations where files are uploaded.
        public var linux: Swift.String?
        /// The folder path in Windows workstations where files are uploaded.
        public var windows: Swift.String?

        public init(
            linux: Swift.String? = nil,
            windows: Swift.String? = nil
        )
        {
            self.linux = linux
            self.windows = windows
        }
    }

}

extension NimbleClientTypes.StreamingSessionStorageRoot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStorageRoot(linux: \"CONTENT_REDACTED\", windows: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a streaming session’s upload storage.
    public struct StreamConfigurationSessionStorage {
        /// Allows artists to upload files to their workstations. The only valid option is UPLOAD.
        /// This member is required.
        public var mode: [NimbleClientTypes.StreamingSessionStorageMode]?
        /// The configuration for the upload storage root of the streaming session.
        public var root: NimbleClientTypes.StreamingSessionStorageRoot?

        public init(
            mode: [NimbleClientTypes.StreamingSessionStorageMode]? = nil,
            root: NimbleClientTypes.StreamingSessionStorageRoot? = nil
        )
        {
            self.mode = mode
            self.root = root
        }
    }

}

extension NimbleClientTypes {
    /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
    public struct VolumeConfiguration {
        /// The number of I/O operations per second for the root volume that is attached to streaming session.
        public var iops: Swift.Int?
        /// The size of the root volume that is attached to the streaming session. The root volume size is measured in GiBs.
        public var size: Swift.Int?
        /// The throughput to provision for the root volume that is attached to the streaming session. The throughput is measured in MiB/s.
        public var throughput: Swift.Int?

        public init(
            iops: Swift.Int? = 3000,
            size: Swift.Int? = 500,
            throughput: Swift.Int? = 125
        )
        {
            self.iops = iops
            self.size = size
            self.throughput = throughput
        }
    }

}

extension NimbleClientTypes {
    /// Configuration for streaming workstations created using this launch profile.
    public struct StreamConfigurationCreate {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// Configures how streaming sessions are backed up when launched from this launch profile.
        public var sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The upload storage for a streaming workstation that is created using this launch profile.
        public var sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?

        public init(
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = 690,
            maxStoppedSessionLengthInMinutes: Swift.Int? = 0,
            sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage? = nil,
            streamingImageIds: [Swift.String]? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil
        )
        {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }
    }

}

public struct CreateLaunchProfileInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// Specifies the IDs of the EC2 subnets where streaming sessions will be accessible from. These subnets must support the specified instance types.
    /// This member is required.
    public var ec2SubnetIds: [Swift.String]?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    /// This member is required.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    /// This member is required.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    /// This member is required.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2SubnetIds: [Swift.String]? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2SubnetIds = ec2SubnetIds
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
        self.tags = tags
    }
}

extension CreateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    public enum LaunchProfileState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum LaunchProfileStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case invalidInstanceTypesProvided
        case invalidSubnetsCombination
        case invalidSubnetsProvided
        case launchProfileCreated
        case launchProfileCreateInProgress
        case launchProfileDeleted
        case launchProfileDeleteInProgress
        case launchProfileUpdated
        case launchProfileUpdateInProgress
        case launchProfileWithStreamSessionsNotDeleted
        case streamingImageNotFound
        case streamingImageNotReady
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileStatusCode] {
            return [
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .invalidInstanceTypesProvided,
                .invalidSubnetsCombination,
                .invalidSubnetsProvided,
                .launchProfileCreated,
                .launchProfileCreateInProgress,
                .launchProfileDeleted,
                .launchProfileDeleteInProgress,
                .launchProfileUpdated,
                .launchProfileUpdateInProgress,
                .launchProfileWithStreamSessionsNotDeleted,
                .streamingImageNotFound,
                .streamingImageNotReady
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidInstanceTypesProvided: return "INVALID_INSTANCE_TYPES_PROVIDED"
            case .invalidSubnetsCombination: return "INVALID_SUBNETS_COMBINATION"
            case .invalidSubnetsProvided: return "INVALID_SUBNETS_PROVIDED"
            case .launchProfileCreated: return "LAUNCH_PROFILE_CREATED"
            case .launchProfileCreateInProgress: return "LAUNCH_PROFILE_CREATE_IN_PROGRESS"
            case .launchProfileDeleted: return "LAUNCH_PROFILE_DELETED"
            case .launchProfileDeleteInProgress: return "LAUNCH_PROFILE_DELETE_IN_PROGRESS"
            case .launchProfileUpdated: return "LAUNCH_PROFILE_UPDATED"
            case .launchProfileUpdateInProgress: return "LAUNCH_PROFILE_UPDATE_IN_PROGRESS"
            case .launchProfileWithStreamSessionsNotDeleted: return "LAUNCH_PROFILE_WITH_STREAM_SESSIONS_NOT_DELETED"
            case .streamingImageNotFound: return "STREAMING_IMAGE_NOT_FOUND"
            case .streamingImageNotReady: return "STREAMING_IMAGE_NOT_READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// A configuration for a streaming session.
    public struct StreamConfiguration {
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        /// This member is required.
        public var clipboardMode: NimbleClientTypes.StreamingClipboardMode?
        /// The EC2 instance types that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]?
        /// The length of time, in minutes, that a streaming session can be active before it is stopped or terminated. After this point, Nimble Studio automatically terminates or stops the session. The default length of time is 690 minutes, and the maximum length of time is 30 days.
        public var maxSessionLengthInMinutes: Swift.Int?
        /// Integer that determines if you can start and stop your sessions and how long a session can stay in the STOPPED state. The default value is 0. The maximum value is 5760. This field is allowed only when sessionPersistenceMode is ACTIVATED and automaticTerminationMode is ACTIVATED. If the value is set to 0, your sessions can’t be STOPPED. If you then call StopStreamingSession, the session fails. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be terminated (instead of STOPPED). If the value is set to a positive number, the session can be stopped. You can call StopStreamingSession to stop sessions in the READY state. If the time that a session stays in the READY state exceeds the maxSessionLengthInMinutes value, the session will automatically be stopped (instead of terminated).
        public var maxStoppedSessionLengthInMinutes: Swift.Int?
        /// Information about the streaming session backup.
        public var sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The upload storage for a streaming session.
        public var sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage?
        /// The streaming images that users can select from when launching a streaming session with this launch profile.
        /// This member is required.
        public var streamingImageIds: [Swift.String]?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?

        public init(
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            clipboardMode: NimbleClientTypes.StreamingClipboardMode? = nil,
            ec2InstanceTypes: [NimbleClientTypes.StreamingInstanceType]? = nil,
            maxSessionLengthInMinutes: Swift.Int? = 690,
            maxStoppedSessionLengthInMinutes: Swift.Int? = 0,
            sessionBackup: NimbleClientTypes.StreamConfigurationSessionBackup? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            sessionStorage: NimbleClientTypes.StreamConfigurationSessionStorage? = nil,
            streamingImageIds: [Swift.String]? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil
        )
        {
            self.automaticTerminationMode = automaticTerminationMode
            self.clipboardMode = clipboardMode
            self.ec2InstanceTypes = ec2InstanceTypes
            self.maxSessionLengthInMinutes = maxSessionLengthInMinutes
            self.maxStoppedSessionLengthInMinutes = maxStoppedSessionLengthInMinutes
            self.sessionBackup = sessionBackup
            self.sessionPersistenceMode = sessionPersistenceMode
            self.sessionStorage = sessionStorage
            self.streamingImageIds = streamingImageIds
            self.volumeConfiguration = volumeConfiguration
        }
    }

}

extension NimbleClientTypes {

    public enum LaunchProfileValidationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case validationFailed
        case validationFailedInternalServerError
        case validationInProgress
        case validationNotStarted
        case validationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationState] {
            return [
                .validationFailed,
                .validationFailedInternalServerError,
                .validationInProgress,
                .validationNotStarted,
                .validationSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .validationFailed: return "VALIDATION_FAILED"
            case .validationFailedInternalServerError: return "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            case .validationInProgress: return "VALIDATION_IN_PROGRESS"
            case .validationNotStarted: return "VALIDATION_NOT_STARTED"
            case .validationSuccess: return "VALIDATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum LaunchProfileValidationStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case validationFailedInternalServerError
        case validationFailedInvalidActiveDirectory
        case validationFailedInvalidSecurityGroupAssociation
        case validationFailedInvalidSubnetRouteTableAssociation
        case validationFailedSubnetNotFound
        case validationFailedUnauthorized
        case validationInProgress
        case validationNotStarted
        case validationSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationStatusCode] {
            return [
                .validationFailedInternalServerError,
                .validationFailedInvalidActiveDirectory,
                .validationFailedInvalidSecurityGroupAssociation,
                .validationFailedInvalidSubnetRouteTableAssociation,
                .validationFailedSubnetNotFound,
                .validationFailedUnauthorized,
                .validationInProgress,
                .validationNotStarted,
                .validationSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .validationFailedInternalServerError: return "VALIDATION_FAILED_INTERNAL_SERVER_ERROR"
            case .validationFailedInvalidActiveDirectory: return "VALIDATION_FAILED_INVALID_ACTIVE_DIRECTORY"
            case .validationFailedInvalidSecurityGroupAssociation: return "VALIDATION_FAILED_INVALID_SECURITY_GROUP_ASSOCIATION"
            case .validationFailedInvalidSubnetRouteTableAssociation: return "VALIDATION_FAILED_INVALID_SUBNET_ROUTE_TABLE_ASSOCIATION"
            case .validationFailedSubnetNotFound: return "VALIDATION_FAILED_SUBNET_NOT_FOUND"
            case .validationFailedUnauthorized: return "VALIDATION_FAILED_UNAUTHORIZED"
            case .validationInProgress: return "VALIDATION_IN_PROGRESS"
            case .validationNotStarted: return "VALIDATION_NOT_STARTED"
            case .validationSuccess: return "VALIDATION_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum LaunchProfileValidationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case validateActiveDirectoryStudioComponent
        case validateNetworkAclAssociation
        case validateSecurityGroupAssociation
        case validateSubnetAssociation
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfileValidationType] {
            return [
                .validateActiveDirectoryStudioComponent,
                .validateNetworkAclAssociation,
                .validateSecurityGroupAssociation,
                .validateSubnetAssociation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .validateActiveDirectoryStudioComponent: return "VALIDATE_ACTIVE_DIRECTORY_STUDIO_COMPONENT"
            case .validateNetworkAclAssociation: return "VALIDATE_NETWORK_ACL_ASSOCIATION"
            case .validateSecurityGroupAssociation: return "VALIDATE_SECURITY_GROUP_ASSOCIATION"
            case .validateSubnetAssociation: return "VALIDATE_SUBNET_ASSOCIATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// The launch profile validation result.
    public struct ValidationResult {
        /// The current state.
        /// This member is required.
        public var state: NimbleClientTypes.LaunchProfileValidationState?
        /// The status code. This will contain the failure reason if the state is VALIDATION_FAILED.
        /// This member is required.
        public var statusCode: NimbleClientTypes.LaunchProfileValidationStatusCode?
        /// The status message for the validation result.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The type of the validation result.
        /// This member is required.
        public var type: NimbleClientTypes.LaunchProfileValidationType?

        public init(
            state: NimbleClientTypes.LaunchProfileValidationState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileValidationStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            type: NimbleClientTypes.LaunchProfileValidationType? = nil
        )
        {
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension NimbleClientTypes {
    /// A launch profile controls your artist workforce’s access to studio components, like compute farms, shared file systems, managed file systems, and license server configurations, as well as instance types and Amazon Machine Images (AMIs). Studio administrators create launch profiles in the Nimble Studio console. Artists can use their launch profiles to launch an instance from the Nimble Studio portal. Each user’s launch profile defines how they can launch a streaming session. By default, studio admins can use all launch profiles.
    public struct LaunchProfile {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The user ID of the user that created the launch profile.
        public var createdBy: Swift.String?
        /// A human-readable description of the launch profile.
        public var description: Swift.String?
        /// Unique identifiers for a collection of EC2 subnets.
        public var ec2SubnetIds: [Swift.String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersions: [Swift.String]?
        /// A friendly name for the launch profile.
        public var name: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.LaunchProfileState?
        /// The status code.
        public var statusCode: NimbleClientTypes.LaunchProfileStatusCode?
        /// The status message for the launch profile.
        public var statusMessage: Swift.String?
        /// A configuration for a streaming session.
        public var streamConfiguration: NimbleClientTypes.StreamConfiguration?
        /// Unique identifiers for a collection of studio components that can be used with this launch profile.
        public var studioComponentIds: [Swift.String]?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?
        /// The list of the latest validation results.
        public var validationResults: [NimbleClientTypes.ValidationResult]?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SubnetIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersions: [Swift.String]? = nil,
            name: Swift.String? = nil,
            state: NimbleClientTypes.LaunchProfileState? = nil,
            statusCode: NimbleClientTypes.LaunchProfileStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamConfiguration: NimbleClientTypes.StreamConfiguration? = nil,
            studioComponentIds: [Swift.String]? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            validationResults: [NimbleClientTypes.ValidationResult]? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SubnetIds = ec2SubnetIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersions = launchProfileProtocolVersions
            self.name = name
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamConfiguration = streamConfiguration
            self.studioComponentIds = studioComponentIds
            self.tags = tags
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.validationResults = validationResults
        }
    }

}

extension NimbleClientTypes.LaunchProfile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfile(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), ec2SubnetIds: \(Swift.String(describing: ec2SubnetIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), validationResults: \(Swift.String(describing: validationResults)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateLaunchProfileOutput {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

public struct CreateStreamingImageInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A human-readable description of the streaming image.
    public var description: Swift.String?
    /// The ID of an EC2 machine image with which to create this streaming image.
    /// This member is required.
    public var ec2ImageId: Swift.String?
    /// A friendly name for a streaming image resource.
    /// This member is required.
    public var name: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        ec2ImageId: Swift.String? = nil,
        name: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.ec2ImageId = ec2ImageId
        self.name = name
        self.studioId = studioId
        self.tags = tags
    }
}

extension CreateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), studioId: \(Swift.String(describing: studioId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    public enum StreamingImageEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageEncryptionConfigurationKeyType] {
            return [
                .customerManagedKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Specifies how a streaming image is encrypted.
    public struct StreamingImageEncryptionConfiguration {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType?

        public init(
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StreamingImageEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

extension NimbleClientTypes {

    public enum StreamingImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    /// The status code.
    public enum StreamingImageStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalError
        case streamingImageCreateInProgress
        case streamingImageDeleted
        case streamingImageDeleteInProgress
        case streamingImageReady
        case streamingImageUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingImageStatusCode] {
            return [
                .accessDenied,
                .internalError,
                .streamingImageCreateInProgress,
                .streamingImageDeleted,
                .streamingImageDeleteInProgress,
                .streamingImageReady,
                .streamingImageUpdateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalError: return "INTERNAL_ERROR"
            case .streamingImageCreateInProgress: return "STREAMING_IMAGE_CREATE_IN_PROGRESS"
            case .streamingImageDeleted: return "STREAMING_IMAGE_DELETED"
            case .streamingImageDeleteInProgress: return "STREAMING_IMAGE_DELETE_IN_PROGRESS"
            case .streamingImageReady: return "STREAMING_IMAGE_READY"
            case .streamingImageUpdateInProgress: return "STREAMING_IMAGE_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Represents a streaming image resource. Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session. Amazon provides a number of streaming images that include popular 3rd-party software. You can create your own streaming images using an Amazon EC2 machine image that you create for this purpose. You can also include software that your users require.
    public struct StreamingImage {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// A human-readable description of the streaming image.
        public var description: Swift.String?
        /// The ID of an EC2 machine image with which to create the streaming image.
        public var ec2ImageId: Swift.String?
        /// The encryption configuration.
        public var encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration?
        /// The list of EULAs that must be accepted before a Streaming Session can be started using this streaming image.
        public var eulaIds: [Swift.String]?
        /// A friendly name for a streaming image resource.
        public var name: Swift.String?
        /// The owner of the streaming image, either the studioId that contains the streaming image, or amazon for images that are provided by Amazon Nimble Studio.
        public var owner: Swift.String?
        /// The platform of the streaming image, either Windows or Linux.
        public var platform: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingImageState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingImageStatusCode?
        /// The status message for the streaming image.
        public var statusMessage: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2ImageId: Swift.String? = nil,
            encryptionConfiguration: NimbleClientTypes.StreamingImageEncryptionConfiguration? = nil,
            eulaIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: Swift.String? = nil,
            state: NimbleClientTypes.StreamingImageState? = nil,
            statusCode: NimbleClientTypes.StreamingImageStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.ec2ImageId = ec2ImageId
            self.encryptionConfiguration = encryptionConfiguration
            self.eulaIds = eulaIds
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.streamingImageId = streamingImageId
            self.tags = tags
        }
    }

}

extension NimbleClientTypes.StreamingImage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingImage(arn: \(Swift.String(describing: arn)), ec2ImageId: \(Swift.String(describing: ec2ImageId)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), eulaIds: \(Swift.String(describing: eulaIds)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), streamingImageId: \(Swift.String(describing: streamingImageId)), tags: \(Swift.String(describing: tags)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateStreamingImageOutput {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

public struct CreateStreamingSessionInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The EC2 Instance type used for the streaming session.
    public var ec2InstanceType: NimbleClientTypes.StreamingInstanceType?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
    public var ownedBy: Swift.String?
    /// The ID of the streaming image.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        ec2InstanceType: NimbleClientTypes.StreamingInstanceType? = nil,
        launchProfileId: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.ec2InstanceType = ec2InstanceType
        self.launchProfileId = launchProfileId
        self.ownedBy = ownedBy
        self.streamingImageId = streamingImageId
        self.studioId = studioId
        self.tags = tags
    }
}

extension NimbleClientTypes {

    /// The streaming session state.
    public enum StreamingSessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case startFailed
        case startInProgress
        case stopped
        case stopFailed
        case stopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .startFailed,
                .startInProgress,
                .stopped,
                .stopFailed,
                .stopInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .startFailed: return "START_FAILED"
            case .startInProgress: return "START_IN_PROGRESS"
            case .stopped: return "STOPPED"
            case .stopFailed: return "STOP_FAILED"
            case .stopInProgress: return "STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StreamingSessionStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeDirectoryDomainJoinError
        case amiValidationError
        case decryptStreamingImageError
        case initializationScriptError
        case insufficientCapacity
        case internalError
        case networkConnectionError
        case networkInterfaceError
        case streamingSessionCreateInProgress
        case streamingSessionDeleted
        case streamingSessionDeleteInProgress
        case streamingSessionReady
        case streamingSessionStarted
        case streamingSessionStartInProgress
        case streamingSessionStopped
        case streamingSessionStopInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStatusCode] {
            return [
                .activeDirectoryDomainJoinError,
                .amiValidationError,
                .decryptStreamingImageError,
                .initializationScriptError,
                .insufficientCapacity,
                .internalError,
                .networkConnectionError,
                .networkInterfaceError,
                .streamingSessionCreateInProgress,
                .streamingSessionDeleted,
                .streamingSessionDeleteInProgress,
                .streamingSessionReady,
                .streamingSessionStarted,
                .streamingSessionStartInProgress,
                .streamingSessionStopped,
                .streamingSessionStopInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryDomainJoinError: return "ACTIVE_DIRECTORY_DOMAIN_JOIN_ERROR"
            case .amiValidationError: return "AMI_VALIDATION_ERROR"
            case .decryptStreamingImageError: return "DECRYPT_STREAMING_IMAGE_ERROR"
            case .initializationScriptError: return "INITIALIZATION_SCRIPT_ERROR"
            case .insufficientCapacity: return "INSUFFICIENT_CAPACITY"
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .networkInterfaceError: return "NETWORK_INTERFACE_ERROR"
            case .streamingSessionCreateInProgress: return "STREAMING_SESSION_CREATE_IN_PROGRESS"
            case .streamingSessionDeleted: return "STREAMING_SESSION_DELETED"
            case .streamingSessionDeleteInProgress: return "STREAMING_SESSION_DELETE_IN_PROGRESS"
            case .streamingSessionReady: return "STREAMING_SESSION_READY"
            case .streamingSessionStarted: return "STREAMING_SESSION_STARTED"
            case .streamingSessionStartInProgress: return "STREAMING_SESSION_START_IN_PROGRESS"
            case .streamingSessionStopped: return "STREAMING_SESSION_STOPPED"
            case .streamingSessionStopInProgress: return "STREAMING_SESSION_STOP_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum VolumeRetentionMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case retain
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeRetentionMode] {
            return [
                .delete,
                .retain
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .retain: return "RETAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public struct StreamingSession {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a STOPPED state.
        ///
        /// * When ACTIVATED, the streaming session is scheduled for termination after being in the STOPPED state for the time specified in maxStoppedSessionLengthInMinutes.
        ///
        /// * When DEACTIVATED, the streaming session can remain in the STOPPED state indefinitely.
        ///
        ///
        /// This parameter is only allowed when sessionPersistenceMode is ACTIVATED. When allowed, the default value for this parameter is DEACTIVATED.
        public var automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode?
        /// Shows the current backup setting of the session.
        public var backupMode: NimbleClientTypes.SessionBackupMode?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The user ID of the user that created the streaming session.
        public var createdBy: Swift.String?
        /// The EC2 Instance type used for the streaming session.
        public var ec2InstanceType: Swift.String?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The maximum number of backups of a streaming session that you can have. When the maximum number of backups is reached, the oldest backup is deleted.
        public var maxBackupsToRetain: Swift.Int?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public var ownedBy: Swift.String?
        /// The session ID.
        public var sessionId: Swift.String?
        /// Determine if a streaming session created from this launch profile can configure persistent storage. This means that volumeConfiguration and automaticTerminationMode are configured.
        public var sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode?
        /// The time the session entered START_IN_PROGRESS state.
        public var startedAt: Foundation.Date?
        /// The user ID of the user that started the streaming session.
        public var startedBy: Swift.String?
        /// The backup ID used to restore a streaming session.
        public var startedFromBackupId: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session.
        public var statusMessage: Swift.String?
        /// The time the streaming session will automatically be stopped if the user doesn’t stop the session themselves.
        public var stopAt: Foundation.Date?
        /// The time the session entered STOP_IN_PROGRESS state.
        public var stoppedAt: Foundation.Date?
        /// The user ID of the user that stopped the streaming session.
        public var stoppedBy: Swift.String?
        /// The ID of the streaming image.
        public var streamingImageId: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The time the streaming session will automatically terminate if not terminated by the user.
        public var terminateAt: Foundation.Date?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?
        /// Custom volume configuration for the root volumes that are attached to streaming sessions. This parameter is only allowed when sessionPersistenceMode is ACTIVATED.
        public var volumeConfiguration: NimbleClientTypes.VolumeConfiguration?
        /// Determine if an EBS volume created from this streaming session will be backed up.
        public var volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode?

        public init(
            arn: Swift.String? = nil,
            automaticTerminationMode: NimbleClientTypes.AutomaticTerminationMode? = nil,
            backupMode: NimbleClientTypes.SessionBackupMode? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            ec2InstanceType: Swift.String? = nil,
            launchProfileId: Swift.String? = nil,
            maxBackupsToRetain: Swift.Int? = 0,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            sessionPersistenceMode: NimbleClientTypes.SessionPersistenceMode? = nil,
            startedAt: Foundation.Date? = nil,
            startedBy: Swift.String? = nil,
            startedFromBackupId: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            stopAt: Foundation.Date? = nil,
            stoppedAt: Foundation.Date? = nil,
            stoppedBy: Swift.String? = nil,
            streamingImageId: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            terminateAt: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil,
            volumeConfiguration: NimbleClientTypes.VolumeConfiguration? = nil,
            volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode? = nil
        )
        {
            self.arn = arn
            self.automaticTerminationMode = automaticTerminationMode
            self.backupMode = backupMode
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.ec2InstanceType = ec2InstanceType
            self.launchProfileId = launchProfileId
            self.maxBackupsToRetain = maxBackupsToRetain
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.sessionPersistenceMode = sessionPersistenceMode
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.startedFromBackupId = startedFromBackupId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.stopAt = stopAt
            self.stoppedAt = stoppedAt
            self.stoppedBy = stoppedBy
            self.streamingImageId = streamingImageId
            self.tags = tags
            self.terminateAt = terminateAt
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
            self.volumeConfiguration = volumeConfiguration
            self.volumeRetentionMode = volumeRetentionMode
        }
    }

}

public struct CreateStreamingSessionOutput {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

public struct CreateStreamingSessionStreamInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The expiration time in seconds.
    public var expirationInSeconds: Swift.Int?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        expirationInSeconds: Swift.Int? = 120,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.expirationInSeconds = expirationInSeconds
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

extension NimbleClientTypes {

    public enum StreamingSessionStreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StreamingSessionStreamStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case networkConnectionError
        case streamCreateInProgress
        case streamDeleted
        case streamDeleteInProgress
        case streamReady
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamingSessionStreamStatusCode] {
            return [
                .internalError,
                .networkConnectionError,
                .streamCreateInProgress,
                .streamDeleted,
                .streamDeleteInProgress,
                .streamReady
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .networkConnectionError: return "NETWORK_CONNECTION_ERROR"
            case .streamCreateInProgress: return "STREAM_CREATE_IN_PROGRESS"
            case .streamDeleted: return "STREAM_DELETED"
            case .streamDeleteInProgress: return "STREAM_DELETE_IN_PROGRESS"
            case .streamReady: return "STREAM_READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// A stream is an active connection to a streaming session, enabling a studio user to control the streaming session using a compatible client. Streaming session streams are compatible with the NICE DCV web client, included in the Nimble Studio portal, or the NICE DCV desktop client.
    public struct StreamingSessionStream {
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The user ID of the user that created the streaming session stream.
        public var createdBy: Swift.String?
        /// The ISO timestamp in seconds for when the resource expires.
        public var expiresAt: Foundation.Date?
        /// The user ID of the user that owns the streaming session. The user that owns the session will be logging into the session and interacting with the virtual workstation.
        public var ownedBy: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StreamingSessionStreamState?
        /// The streaming session stream status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode?
        /// The stream ID.
        public var streamId: Swift.String?
        /// The URL to connect to this stream using the DCV client.
        public var url: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            expiresAt: Foundation.Date? = nil,
            ownedBy: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionStreamState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStreamStatusCode? = nil,
            streamId: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.expiresAt = expiresAt
            self.ownedBy = ownedBy
            self.state = state
            self.statusCode = statusCode
            self.streamId = streamId
            self.url = url
        }
    }

}

extension NimbleClientTypes.StreamingSessionStream: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamingSessionStream(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), expiresAt: \(Swift.String(describing: expiresAt)), ownedBy: \(Swift.String(describing: ownedBy)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), streamId: \(Swift.String(describing: streamId)), url: \"CONTENT_REDACTED\")"}
}

public struct CreateStreamingSessionStreamOutput {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init(
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

extension NimbleClientTypes {

    /// The type of KMS key that is used to encrypt studio data.
    public enum StudioEncryptionConfigurationKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsOwnedKey
        case customerManagedKey
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioEncryptionConfigurationKeyType] {
            return [
                .awsOwnedKey,
                .customerManagedKey
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsOwnedKey: return "AWS_OWNED_KEY"
            case .customerManagedKey: return "CUSTOMER_MANAGED_KEY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Configuration of the encryption method that is used for the studio.
    public struct StudioEncryptionConfiguration {
        /// The ARN for a KMS key that is used to encrypt studio data.
        public var keyArn: Swift.String?
        /// The type of KMS key that is used to encrypt studio data.
        /// This member is required.
        public var keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType?

        public init(
            keyArn: Swift.String? = nil,
            keyType: NimbleClientTypes.StudioEncryptionConfigurationKeyType? = nil
        )
        {
            self.keyArn = keyArn
            self.keyType = keyType
        }
    }

}

public struct CreateStudioInput {
    /// The IAM role that studio admins will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    /// This member is required.
    public var displayName: Swift.String?
    /// The studio encryption configuration.
    public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
    /// The studio name that is used in the URL of the Nimble Studio portal when accessed by Nimble Studio users.
    /// This member is required.
    public var studioName: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The IAM role that studio users will assume when logging in to the Nimble Studio portal.
    /// This member is required.
    public var userRoleArn: Swift.String?

    public init(
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
        studioName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioEncryptionConfiguration = studioEncryptionConfiguration
        self.studioName = studioName
        self.tags = tags
        self.userRoleArn = userRoleArn
    }
}

extension CreateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioName: \(Swift.String(describing: studioName)), tags: \(Swift.String(describing: tags)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    public enum StudioState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    /// The status code.
    public enum StudioStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsSsoAccessDenied
        case awsSsoConfigurationRepaired
        case awsSsoConfigurationRepairInProgress
        case awsSsoNotEnabled
        case awsStsRegionDisabled
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case roleCouldNotBeAssumed
        case roleNotOwnedByStudioOwner
        case studioCreated
        case studioCreateInProgress
        case studioDeleted
        case studioDeleteInProgress
        case studioUpdated
        case studioUpdateInProgress
        case studioWithLaunchProfilesNotDeleted
        case studioWithStreamingImagesNotDeleted
        case studioWithStudioComponentsNotDeleted
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioStatusCode] {
            return [
                .awsSsoAccessDenied,
                .awsSsoConfigurationRepaired,
                .awsSsoConfigurationRepairInProgress,
                .awsSsoNotEnabled,
                .awsStsRegionDisabled,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .roleCouldNotBeAssumed,
                .roleNotOwnedByStudioOwner,
                .studioCreated,
                .studioCreateInProgress,
                .studioDeleted,
                .studioDeleteInProgress,
                .studioUpdated,
                .studioUpdateInProgress,
                .studioWithLaunchProfilesNotDeleted,
                .studioWithStreamingImagesNotDeleted,
                .studioWithStudioComponentsNotDeleted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsSsoAccessDenied: return "AWS_SSO_ACCESS_DENIED"
            case .awsSsoConfigurationRepaired: return "AWS_SSO_CONFIGURATION_REPAIRED"
            case .awsSsoConfigurationRepairInProgress: return "AWS_SSO_CONFIGURATION_REPAIR_IN_PROGRESS"
            case .awsSsoNotEnabled: return "AWS_SSO_NOT_ENABLED"
            case .awsStsRegionDisabled: return "AWS_STS_REGION_DISABLED"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .roleCouldNotBeAssumed: return "ROLE_COULD_NOT_BE_ASSUMED"
            case .roleNotOwnedByStudioOwner: return "ROLE_NOT_OWNED_BY_STUDIO_OWNER"
            case .studioCreated: return "STUDIO_CREATED"
            case .studioCreateInProgress: return "STUDIO_CREATE_IN_PROGRESS"
            case .studioDeleted: return "STUDIO_DELETED"
            case .studioDeleteInProgress: return "STUDIO_DELETE_IN_PROGRESS"
            case .studioUpdated: return "STUDIO_UPDATED"
            case .studioUpdateInProgress: return "STUDIO_UPDATE_IN_PROGRESS"
            case .studioWithLaunchProfilesNotDeleted: return "STUDIO_WITH_LAUNCH_PROFILES_NOT_DELETED"
            case .studioWithStreamingImagesNotDeleted: return "STUDIO_WITH_STREAMING_IMAGES_NOT_DELETED"
            case .studioWithStudioComponentsNotDeleted: return "STUDIO_WITH_STUDIO_COMPONENTS_NOT_DELETED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Represents a studio resource. A studio is the core resource used with Nimble Studio. You must create a studio first, before any other resource type can be created. All other resources you create and manage in Nimble Studio are contained within a studio. When creating a studio, you must provides two IAM roles for use with the Nimble Studio portal. These roles are assumed by your users when they log in to the Nimble Studio portal via IAM Identity Center and your identity source. The user role must have the AmazonNimbleStudio-StudioUser managed policy attached for the portal to function properly. The admin role must have the AmazonNimbleStudio-StudioAdmin managed policy attached for the portal to function properly. Your studio roles must trust the identity.nimble.amazonaws.com service principal to function properly.
    public struct Studio {
        /// The IAM role that studio admins assume when logging in to the Nimble Studio portal.
        public var adminRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// A friendly name for the studio.
        public var displayName: Swift.String?
        /// The Amazon Web Services Region where the studio resource is located.
        public var homeRegion: Swift.String?
        /// The IAM Identity Center application client ID used to integrate with IAM Identity Center. This ID allows IAM Identity Center users to log in to Nimble Studio portal.
        public var ssoClientId: Swift.String?
        /// The current state of the studio resource.
        public var state: NimbleClientTypes.StudioState?
        /// Status codes that provide additional detail on the studio state.
        public var statusCode: NimbleClientTypes.StudioStatusCode?
        /// Additional detail on the studio state.
        public var statusMessage: Swift.String?
        /// Configuration of the encryption method that is used for the studio.
        public var studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration?
        /// The unique identifier for a studio resource. In Nimble Studio, all other resources are contained in a studio resource.
        public var studioId: Swift.String?
        /// The name of the studio, as included in the URL when accessing it in the Nimble Studio portal.
        public var studioName: Swift.String?
        /// The address of the web page for the studio.
        public var studioUrl: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The IAM role that studio users assume when logging in to the Nimble Studio portal.
        public var userRoleArn: Swift.String?

        public init(
            adminRoleArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            homeRegion: Swift.String? = nil,
            ssoClientId: Swift.String? = nil,
            state: NimbleClientTypes.StudioState? = nil,
            statusCode: NimbleClientTypes.StudioStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioEncryptionConfiguration: NimbleClientTypes.StudioEncryptionConfiguration? = nil,
            studioId: Swift.String? = nil,
            studioName: Swift.String? = nil,
            studioUrl: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil,
            userRoleArn: Swift.String? = nil
        )
        {
            self.adminRoleArn = adminRoleArn
            self.arn = arn
            self.createdAt = createdAt
            self.displayName = displayName
            self.homeRegion = homeRegion
            self.ssoClientId = ssoClientId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioEncryptionConfiguration = studioEncryptionConfiguration
            self.studioId = studioId
            self.studioName = studioName
            self.studioUrl = studioUrl
            self.tags = tags
            self.updatedAt = updatedAt
            self.userRoleArn = userRoleArn
        }
    }

}

extension NimbleClientTypes.Studio: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Studio(adminRoleArn: \(Swift.String(describing: adminRoleArn)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), homeRegion: \(Swift.String(describing: homeRegion)), ssoClientId: \(Swift.String(describing: ssoClientId)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioEncryptionConfiguration: \(Swift.String(describing: studioEncryptionConfiguration)), studioId: \(Swift.String(describing: studioId)), studioName: \(Swift.String(describing: studioName)), studioUrl: \(Swift.String(describing: studioUrl)), tags: \(Swift.String(describing: tags)), updatedAt: \(Swift.String(describing: updatedAt)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

public struct CreateStudioOutput {
    /// Information about a studio.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

extension NimbleClientTypes {
    /// The configuration for a license service that is associated with a studio resource.
    public struct LicenseServiceConfiguration {
        /// The endpoint of the license service that is accessed by the studio component resource.
        public var endpoint: Swift.String?

        public init(
            endpoint: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
        }
    }

}

extension NimbleClientTypes.LicenseServiceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LicenseServiceConfiguration(endpoint: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration for a shared file storage system that is associated with a studio resource.
    public struct SharedFileSystemConfiguration {
        /// The endpoint of the shared file system that is accessed by the studio component resource.
        public var endpoint: Swift.String?
        /// The unique identifier for a file system.
        public var fileSystemId: Swift.String?
        /// The mount location for a shared file system on a Linux virtual workstation.
        public var linuxMountPoint: Swift.String?
        /// The name of the file share.
        public var shareName: Swift.String?
        /// The mount location for a shared file system on a Windows virtual workstation.
        public var windowsMountDrive: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            fileSystemId: Swift.String? = nil,
            linuxMountPoint: Swift.String? = nil,
            shareName: Swift.String? = nil,
            windowsMountDrive: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.fileSystemId = fileSystemId
            self.linuxMountPoint = linuxMountPoint
            self.shareName = shareName
            self.windowsMountDrive = windowsMountDrive
        }
    }

}

extension NimbleClientTypes.SharedFileSystemConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SharedFileSystemConfiguration(fileSystemId: \(Swift.String(describing: fileSystemId)), windowsMountDrive: \(Swift.String(describing: windowsMountDrive)), endpoint: \"CONTENT_REDACTED\", linuxMountPoint: \"CONTENT_REDACTED\", shareName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The configuration of the studio component, based on component type.
    public enum StudioComponentConfiguration {
        /// The configuration for a Directory Service for Microsoft Active Directory studio resource.
        case activedirectoryconfiguration(NimbleClientTypes.ActiveDirectoryConfiguration)
        /// The configuration for a render farm that is associated with a studio resource.
        case computefarmconfiguration(NimbleClientTypes.ComputeFarmConfiguration)
        /// The configuration for a license service that is associated with a studio resource.
        case licenseserviceconfiguration(NimbleClientTypes.LicenseServiceConfiguration)
        /// The configuration for a shared file storage system that is associated with a studio resource.
        case sharedfilesystemconfiguration(NimbleClientTypes.SharedFileSystemConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension NimbleClientTypes {

    public enum LaunchProfilePlatform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePlatform] {
            return [
                .linux,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StudioComponentInitializationScriptRunContext: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case systemInitialization
        case userInitialization
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentInitializationScriptRunContext] {
            return [
                .systemInitialization,
                .userInitialization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .systemInitialization: return "SYSTEM_INITIALIZATION"
            case .userInitialization: return "USER_INITIALIZATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Initialization scripts for studio components.
    public struct StudioComponentInitializationScript {
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The platform of the initialization script, either Windows or Linux.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The method to use when running the initialization script.
        public var runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext?
        /// The initialization script.
        public var script: Swift.String?

        public init(
            launchProfileProtocolVersion: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            runContext: NimbleClientTypes.StudioComponentInitializationScriptRunContext? = nil,
            script: Swift.String? = nil
        )
        {
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.platform = platform
            self.runContext = runContext
            self.script = script
        }
    }

}

extension NimbleClientTypes.StudioComponentInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentInitializationScript(launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), platform: \(Swift.String(describing: platform)), runContext: \(Swift.String(describing: runContext)), script: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A parameter for a studio component script, in the form of a key-value pair.
    public struct ScriptParameterKeyValue {
        /// A script parameter key.
        public var key: Swift.String?
        /// A script parameter value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension NimbleClientTypes {

    public enum StudioComponentSubtype: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonFsxForLustre
        case amazonFsxForWindows
        case awsManagedMicrosoftAd
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentSubtype] {
            return [
                .amazonFsxForLustre,
                .amazonFsxForWindows,
                .awsManagedMicrosoftAd,
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonFsxForLustre: return "AMAZON_FSX_FOR_LUSTRE"
            case .amazonFsxForWindows: return "AMAZON_FSX_FOR_WINDOWS"
            case .awsManagedMicrosoftAd: return "AWS_MANAGED_MICROSOFT_AD"
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    public enum StudioComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeDirectory
        case computeFarm
        case custom
        case licenseService
        case sharedFileSystem
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentType] {
            return [
                .activeDirectory,
                .computeFarm,
                .custom,
                .licenseService,
                .sharedFileSystem
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeDirectory: return "ACTIVE_DIRECTORY"
            case .computeFarm: return "COMPUTE_FARM"
            case .custom: return "CUSTOM"
            case .licenseService: return "LICENSE_SERVICE"
            case .sharedFileSystem: return "SHARED_FILE_SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateStudioComponentInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    /// This member is required.
    public var name: Swift.String?
    /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    public var runtimeRoleArn: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    public var secureInitializationRoleArn: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?
    /// The type of the studio component.
    /// This member is required.
    public var type: NimbleClientTypes.StudioComponentType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.scriptParameters = scriptParameters
        self.secureInitializationRoleArn = secureInitializationRoleArn
        self.studioId = studioId
        self.subtype = subtype
        self.tags = tags
        self.type = type
    }
}

extension CreateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {

    /// The current state of the studio component resource. While a studio component is being created, modified, or deleted, its state will be CREATE_IN_PROGRESS, UPDATE_IN_PROGRESS, or DELETE_IN_PROGRESS. These are called transition states. No modifications may be made to the studio component while it is in a transition state. If creation of the resource fails, the state will change to CREATE_FAILED. The resource StatusCode and StatusMessage will provide more information of why creation failed. The resource in this state will automatically be deleted from your account after a period of time. If updating the resource fails, the state will change to UPDATE_FAILED. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. If deleting the resource fails, the state will change to DELETE_FAILED. The resource StatusCode and StatusMessage will provide more information of why the update failed. The resource will be returned to the state it was in when the update request was invoked. After the resource is deleted successfully, it will change to the DELETED state. The resource will no longer count against service quotas and cannot be used or acted upon any futher. It will be removed from your account after a period of time.
    public enum StudioComponentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createFailed
        case createInProgress
        case deleted
        case deleteFailed
        case deleteInProgress
        case ready
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentState] {
            return [
                .createFailed,
                .createInProgress,
                .deleted,
                .deleteFailed,
                .deleteInProgress,
                .ready,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case .ready: return "READY"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {

    /// The current status of the studio component resource. When the resource is in the READY state, the status code signals what the last mutation made to the resource was. When the resource is in a CREATE_FAILED, UPDATE_FAILED, or DELETE_FAILED state, the status code signals what went wrong and why the mutation failed.
    public enum StudioComponentStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeDirectoryAlreadyExists
        case encryptionKeyAccessDenied
        case encryptionKeyNotFound
        case internalError
        case studioComponentCreated
        case studioComponentCreateInProgress
        case studioComponentDeleted
        case studioComponentDeleteInProgress
        case studioComponentUpdated
        case studioComponentUpdateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioComponentStatusCode] {
            return [
                .activeDirectoryAlreadyExists,
                .encryptionKeyAccessDenied,
                .encryptionKeyNotFound,
                .internalError,
                .studioComponentCreated,
                .studioComponentCreateInProgress,
                .studioComponentDeleted,
                .studioComponentDeleteInProgress,
                .studioComponentUpdated,
                .studioComponentUpdateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeDirectoryAlreadyExists: return "ACTIVE_DIRECTORY_ALREADY_EXISTS"
            case .encryptionKeyAccessDenied: return "ENCRYPTION_KEY_ACCESS_DENIED"
            case .encryptionKeyNotFound: return "ENCRYPTION_KEY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .studioComponentCreated: return "STUDIO_COMPONENT_CREATED"
            case .studioComponentCreateInProgress: return "STUDIO_COMPONENT_CREATE_IN_PROGRESS"
            case .studioComponentDeleted: return "STUDIO_COMPONENT_DELETED"
            case .studioComponentDeleteInProgress: return "STUDIO_COMPONENT_DELETE_IN_PROGRESS"
            case .studioComponentUpdated: return "STUDIO_COMPONENT_UPDATED"
            case .studioComponentUpdateInProgress: return "STUDIO_COMPONENT_UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// A studio component represents a network resource to be used by a studio's users and workflows. A typical studio contains studio components for each of the following: render farm, Active Directory, licensing, and file system. Access to a studio component is managed by specifying security groups for the resource, as well as its endpoint. A studio component also has a set of initialization scripts that are returned by GetLaunchProfileInitialization. These initialization scripts run on streaming sessions when they start. They provide users with flexibility in controlling how the studio resources are configured on a streaming session.
    public struct StudioComponent {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The configuration of the studio component, based on component type.
        public var configuration: NimbleClientTypes.StudioComponentConfiguration?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// A human-readable description for the studio component resource.
        public var description: Swift.String?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// Initialization scripts for studio components.
        public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
        /// A friendly name for the studio component resource.
        public var name: Swift.String?
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public var runtimeRoleArn: Swift.String?
        /// Parameters for the studio component scripts.
        public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public var secureInitializationRoleArn: Swift.String?
        /// The current state.
        public var state: NimbleClientTypes.StudioComponentState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StudioComponentStatusCode?
        /// The status message for the studio component.
        public var statusMessage: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init(
            arn: Swift.String? = nil,
            configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
            name: Swift.String? = nil,
            runtimeRoleArn: Swift.String? = nil,
            scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
            secureInitializationRoleArn: Swift.String? = nil,
            state: NimbleClientTypes.StudioComponentState? = nil,
            statusCode: NimbleClientTypes.StudioComponentStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.arn = arn
            self.configuration = configuration
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.initializationScripts = initializationScripts
            self.name = name
            self.runtimeRoleArn = runtimeRoleArn
            self.scriptParameters = scriptParameters
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.tags = tags
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.StudioComponent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponent(arn: \(Swift.String(describing: arn)), configuration: \(Swift.String(describing: configuration)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), state: \(Swift.String(describing: state)), statusCode: \(Swift.String(describing: statusCode)), statusMessage: \(Swift.String(describing: statusMessage)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

public struct CreateStudioComponentOutput {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

public struct DeleteLaunchProfileInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

public struct DeleteLaunchProfileOutput {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

public struct DeleteLaunchProfileMemberInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

public struct DeleteLaunchProfileMemberOutput {

    public init() { }
}

public struct DeleteStreamingImageInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

public struct DeleteStreamingImageOutput {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

public struct DeleteStreamingSessionInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

public struct DeleteStreamingSessionOutput {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

public struct DeleteStudioInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

public struct DeleteStudioOutput {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

public struct DeleteStudioComponentInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

public struct DeleteStudioComponentOutput {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

public struct DeleteStudioMemberInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.principalId = principalId
        self.studioId = studioId
    }
}

public struct DeleteStudioMemberOutput {

    public init() { }
}

extension NimbleClientTypes {
    /// Represents a EULA resource.
    public struct Eula {
        /// The EULA content.
        public var content: Swift.String?
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The EULA ID.
        public var eulaId: Swift.String?
        /// The name for the EULA.
        public var name: Swift.String?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?

        public init(
            content: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            eulaId: Swift.String? = nil,
            name: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.content = content
            self.createdAt = createdAt
            self.eulaId = eulaId
            self.name = name
            self.updatedAt = updatedAt
        }
    }

}

public struct ListEulaAcceptancesInput {
    /// The list of EULA IDs that have been previously accepted.
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

public struct ListEulaAcceptancesOutput {
    /// A collection of EULA acceptances.
    public var eulaAcceptances: [NimbleClientTypes.EulaAcceptance]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulaAcceptances: [NimbleClientTypes.EulaAcceptance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaAcceptances = eulaAcceptances
        self.nextToken = nextToken
    }
}

public struct GetEulaInput {
    /// The EULA ID.
    /// This member is required.
    public var eulaId: Swift.String?

    public init(
        eulaId: Swift.String? = nil
    )
    {
        self.eulaId = eulaId
    }
}

public struct GetEulaOutput {
    /// The EULA.
    public var eula: NimbleClientTypes.Eula?

    public init(
        eula: NimbleClientTypes.Eula? = nil
    )
    {
        self.eula = eula
    }
}

public struct ListEulasInput {
    /// The list of EULA IDs that should be returned
    public var eulaIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulaIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulaIds = eulaIds
        self.nextToken = nextToken
    }
}

public struct ListEulasOutput {
    /// A collection of EULA resources.
    public var eulas: [NimbleClientTypes.Eula]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        eulas: [NimbleClientTypes.Eula]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eulas = eulas
        self.nextToken = nextToken
    }
}

public struct GetLaunchProfileInput {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

public struct GetLaunchProfileOutput {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

public struct GetLaunchProfileDetailsInput {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.studioId = studioId
    }
}

extension NimbleClientTypes {
    /// The studio component's summary.
    public struct StudioComponentSummary {
        /// The ISO timestamp in seconds for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The user ID of the user that created the studio component.
        public var createdBy: Swift.String?
        /// The description.
        public var description: Swift.String?
        /// The name for the studio component.
        public var name: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The specific subtype of a studio component.
        public var subtype: NimbleClientTypes.StudioComponentSubtype?
        /// The type of the studio component.
        public var type: NimbleClientTypes.StudioComponentType?
        /// The ISO timestamp in seconds for when the resource was updated.
        public var updatedAt: Foundation.Date?
        /// The user ID of the user that most recently updated the resource.
        public var updatedBy: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
            type: NimbleClientTypes.StudioComponentType? = nil,
            updatedAt: Foundation.Date? = nil,
            updatedBy: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.name = name
            self.studioComponentId = studioComponentId
            self.subtype = subtype
            self.type = type
            self.updatedAt = updatedAt
            self.updatedBy = updatedBy
        }
    }

}

extension NimbleClientTypes.StudioComponentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StudioComponentSummary(createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), studioComponentId: \(Swift.String(describing: studioComponentId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)), updatedAt: \(Swift.String(describing: updatedAt)), updatedBy: \(Swift.String(describing: updatedBy)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct GetLaunchProfileDetailsOutput {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?
    /// A collection of studio component summaries.
    public var studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil,
        studioComponentSummaries: [NimbleClientTypes.StudioComponentSummary]? = nil
    )
    {
        self.launchProfile = launchProfile
        self.streamingImages = streamingImages
        self.studioComponentSummaries = studioComponentSummaries
    }
}

public struct GetLaunchProfileInitializationInput {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The launch profile protocol versions supported by the client.
    /// This member is required.
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The launch purpose.
    /// This member is required.
    public var launchPurpose: Swift.String?
    /// The platform where this Launch Profile will be used, either Windows or Linux.
    /// This member is required.
    public var platform: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        launchPurpose: Swift.String? = nil,
        platform: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.launchPurpose = launchPurpose
        self.platform = platform
        self.studioId = studioId
    }
}

extension NimbleClientTypes {
    /// The launch profile initialization Active Directory contains information required for the launch profile to connect to the Active Directory.
    public struct LaunchProfileInitializationActiveDirectory {
        /// A collection of custom attributes for an Active Directory computer.
        public var computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]?
        /// The directory ID of the Directory Service for Microsoft Active Directory to access using this launch profile.
        public var directoryId: Swift.String?
        /// The directory name.
        public var directoryName: Swift.String?
        /// The DNS IP address.
        public var dnsIpAddresses: [Swift.String]?
        /// The name for the organizational unit distinguished name.
        public var organizationalUnitDistinguishedName: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init(
            computerAttributes: [NimbleClientTypes.ActiveDirectoryComputerAttribute]? = nil,
            directoryId: Swift.String? = nil,
            directoryName: Swift.String? = nil,
            dnsIpAddresses: [Swift.String]? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.computerAttributes = computerAttributes
            self.directoryId = directoryId
            self.directoryName = directoryName
            self.dnsIpAddresses = dnsIpAddresses
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationActiveDirectory(directoryId: \(Swift.String(describing: directoryId)), directoryName: \(Swift.String(describing: directoryName)), dnsIpAddresses: \(Swift.String(describing: dnsIpAddresses)), organizationalUnitDistinguishedName: \(Swift.String(describing: organizationalUnitDistinguishedName)), studioComponentId: \(Swift.String(describing: studioComponentId)), computerAttributes: \"CONTENT_REDACTED\", studioComponentName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// The launch profile initialization script is used when start streaming session runs.
    public struct LaunchProfileInitializationScript {
        /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
        public var runtimeRoleArn: Swift.String?
        /// The initialization script.
        public var script: Swift.String?
        /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
        public var secureInitializationRoleArn: Swift.String?
        /// The unique identifier for a studio component resource.
        public var studioComponentId: Swift.String?
        /// The name for the studio component.
        public var studioComponentName: Swift.String?

        public init(
            runtimeRoleArn: Swift.String? = nil,
            script: Swift.String? = nil,
            secureInitializationRoleArn: Swift.String? = nil,
            studioComponentId: Swift.String? = nil,
            studioComponentName: Swift.String? = nil
        )
        {
            self.runtimeRoleArn = runtimeRoleArn
            self.script = script
            self.secureInitializationRoleArn = secureInitializationRoleArn
            self.studioComponentId = studioComponentId
            self.studioComponentName = studioComponentName
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitializationScript: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitializationScript(runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioComponentId: \(Swift.String(describing: studioComponentId)), script: \"CONTENT_REDACTED\", studioComponentName: \"CONTENT_REDACTED\")"}
}

extension NimbleClientTypes {
    /// A launch profile initialization contains information required for a workstation or server to connect to a launch profile. This includes scripts, endpoints, security groups, subnets, and other configuration.
    public struct LaunchProfileInitialization {
        /// A LaunchProfileInitializationActiveDirectory resource.
        public var activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory?
        /// The EC2 security groups that control access to the studio component.
        public var ec2SecurityGroupIds: [Swift.String]?
        /// The ID of the launch profile used to control access from the streaming session.
        public var launchProfileId: Swift.String?
        /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
        public var launchProfileProtocolVersion: Swift.String?
        /// The launch purpose.
        public var launchPurpose: Swift.String?
        /// The name for the launch profile.
        public var name: Swift.String?
        /// The platform of the launch platform, either Windows or Linux.
        public var platform: NimbleClientTypes.LaunchProfilePlatform?
        /// The system initializtion scripts.
        public var systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?
        /// The user initializtion scripts.
        public var userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]?

        public init(
            activeDirectory: NimbleClientTypes.LaunchProfileInitializationActiveDirectory? = nil,
            ec2SecurityGroupIds: [Swift.String]? = nil,
            launchProfileId: Swift.String? = nil,
            launchProfileProtocolVersion: Swift.String? = nil,
            launchPurpose: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: NimbleClientTypes.LaunchProfilePlatform? = nil,
            systemInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil,
            userInitializationScripts: [NimbleClientTypes.LaunchProfileInitializationScript]? = nil
        )
        {
            self.activeDirectory = activeDirectory
            self.ec2SecurityGroupIds = ec2SecurityGroupIds
            self.launchProfileId = launchProfileId
            self.launchProfileProtocolVersion = launchProfileProtocolVersion
            self.launchPurpose = launchPurpose
            self.name = name
            self.platform = platform
            self.systemInitializationScripts = systemInitializationScripts
            self.userInitializationScripts = userInitializationScripts
        }
    }

}

extension NimbleClientTypes.LaunchProfileInitialization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchProfileInitialization(activeDirectory: \(Swift.String(describing: activeDirectory)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersion: \(Swift.String(describing: launchProfileProtocolVersion)), launchPurpose: \(Swift.String(describing: launchPurpose)), platform: \(Swift.String(describing: platform)), systemInitializationScripts: \(Swift.String(describing: systemInitializationScripts)), userInitializationScripts: \(Swift.String(describing: userInitializationScripts)), name: \"CONTENT_REDACTED\")"}
}

public struct GetLaunchProfileInitializationOutput {
    /// The launch profile initialization.
    public var launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization?

    public init(
        launchProfileInitialization: NimbleClientTypes.LaunchProfileInitialization? = nil
    )
    {
        self.launchProfileInitialization = launchProfileInitialization
    }
}

public struct GetLaunchProfileMemberInput {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.principalId = principalId
        self.studioId = studioId
    }
}

extension NimbleClientTypes {

    public enum LaunchProfilePersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchProfilePersona] {
            return [
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// Studio admins can use launch profile membership to delegate launch profile access to studio users in the Nimble Studio portal without writing or maintaining complex IAM policies. A launch profile member is a user association from your studio identity source who is granted permissions to a launch profile. A launch profile member (type USER) provides the following permissions to that launch profile:
    ///
    /// * GetLaunchProfile
    ///
    /// * GetLaunchProfileInitialization
    ///
    /// * GetLaunchProfileMembers
    ///
    /// * GetLaunchProfileMember
    ///
    /// * CreateStreamingSession
    ///
    /// * GetLaunchProfileDetails
    public struct LaunchProfileMembership {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

public struct GetLaunchProfileMemberOutput {
    /// The member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init(
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

public struct GetStreamingImageInput {
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

public struct GetStreamingImageOutput {
    /// The streaming image.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

public struct GetStreamingSessionInput {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

public struct GetStreamingSessionOutput {
    /// The session.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

public struct GetStreamingSessionBackupInput {
    /// The ID of the backup.
    /// This member is required.
    public var backupId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.studioId = studioId
    }
}

extension NimbleClientTypes {
    /// Information about the streaming session backup.
    public struct StreamingSessionBackup {
        /// The Amazon Resource Name (ARN) that is assigned to a studio resource and uniquely identifies it. ARNs are unique across all Regions.
        public var arn: Swift.String?
        /// The ID of the backup.
        public var backupId: Swift.String?
        /// The ISO timestamp in for when the resource was created.
        public var createdAt: Foundation.Date?
        /// The ID of the launch profile which allowed the backups for the streaming session.
        public var launchProfileId: Swift.String?
        /// The user ID of the user that owns the streaming session.
        public var ownedBy: Swift.String?
        /// The streaming session ID for the StreamingSessionBackup.
        public var sessionId: Swift.String?
        /// The streaming session state.
        public var state: NimbleClientTypes.StreamingSessionState?
        /// The status code.
        public var statusCode: NimbleClientTypes.StreamingSessionStatusCode?
        /// The status message for the streaming session backup.
        public var statusMessage: Swift.String?
        /// A collection of labels, in the form of key-value pairs, that apply to this resource.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            launchProfileId: Swift.String? = nil,
            ownedBy: Swift.String? = nil,
            sessionId: Swift.String? = nil,
            state: NimbleClientTypes.StreamingSessionState? = nil,
            statusCode: NimbleClientTypes.StreamingSessionStatusCode? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.backupId = backupId
            self.createdAt = createdAt
            self.launchProfileId = launchProfileId
            self.ownedBy = ownedBy
            self.sessionId = sessionId
            self.state = state
            self.statusCode = statusCode
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

public struct GetStreamingSessionBackupOutput {
    /// Information about the streaming session backup.
    public var streamingSessionBackup: NimbleClientTypes.StreamingSessionBackup?

    public init(
        streamingSessionBackup: NimbleClientTypes.StreamingSessionBackup? = nil
    )
    {
        self.streamingSessionBackup = streamingSessionBackup
    }
}

public struct GetStreamingSessionStreamInput {
    /// The streaming session ID.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The streaming session stream ID.
    /// This member is required.
    public var streamId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        sessionId: Swift.String? = nil,
        streamId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
        self.streamId = streamId
        self.studioId = studioId
    }
}

public struct GetStreamingSessionStreamOutput {
    /// The stream.
    public var stream: NimbleClientTypes.StreamingSessionStream?

    public init(
        stream: NimbleClientTypes.StreamingSessionStream? = nil
    )
    {
        self.stream = stream
    }
}

public struct GetStudioInput {
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        studioId: Swift.String? = nil
    )
    {
        self.studioId = studioId
    }
}

public struct GetStudioOutput {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

public struct GetStudioComponentInput {
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.studioComponentId = studioComponentId
        self.studioId = studioId
    }
}

public struct GetStudioComponentOutput {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

public struct GetStudioMemberInput {
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.principalId = principalId
        self.studioId = studioId
    }
}

extension NimbleClientTypes {

    public enum StudioPersona: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case administrator
        case sdkUnknown(Swift.String)

        public static var allCases: [StudioPersona] {
            return [
                .administrator
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension NimbleClientTypes {
    /// A studio member is an association of a user from your studio identity source to elevated permissions that they are granted in the studio. When you add a user to your studio using the Nimble Studio console, they are given access to the studio's IAM Identity Center application and are given access to log in to the Nimble Studio portal. These users have the permissions provided by the studio's user IAM role and do not appear in the studio membership collection. Only studio admins appear in studio membership. When you add a user to studio membership with the ADMIN persona, upon logging in to the Nimble Studio portal, they are granted permissions specified by the Studio's Admin IAM role.
    public struct StudioMembership {
        /// The ID of the identity store.
        public var identityStoreId: Swift.String?
        /// The persona.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        public var principalId: Swift.String?
        /// The Active Directory Security Identifier for this user, if available.
        public var sid: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil,
            sid: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.persona = persona
            self.principalId = principalId
            self.sid = sid
        }
    }

}

public struct GetStudioMemberOutput {
    /// The member.
    public var member: NimbleClientTypes.StudioMembership?

    public init(
        member: NimbleClientTypes.StudioMembership? = nil
    )
    {
        self.member = member
    }
}

public struct ListLaunchProfileMembersInput {
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        launchProfileId: Swift.String? = nil,
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.launchProfileId = launchProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

public struct ListLaunchProfileMembersOutput {
    /// A list of members.
    public var members: [NimbleClientTypes.LaunchProfileMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        members: [NimbleClientTypes.LaunchProfileMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListLaunchProfilesInput {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    public var principalId: Swift.String?
    /// Filter this request to launch profiles in any of the given states.
    public var states: [NimbleClientTypes.LaunchProfileState]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        states: [NimbleClientTypes.LaunchProfileState]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.states = states
        self.studioId = studioId
    }
}

public struct ListLaunchProfilesOutput {
    /// A collection of launch profiles.
    public var launchProfiles: [NimbleClientTypes.LaunchProfile]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        launchProfiles: [NimbleClientTypes.LaunchProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.launchProfiles = launchProfiles
        self.nextToken = nextToken
    }
}

extension NimbleClientTypes {
    /// A new member that is added to a launch profile.
    public struct NewLaunchProfileMember {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.LaunchProfilePersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init(
            persona: NimbleClientTypes.LaunchProfilePersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

public struct PutLaunchProfileMembersInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewLaunchProfileMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        members: [NimbleClientTypes.NewLaunchProfileMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.launchProfileId = launchProfileId
        self.members = members
        self.studioId = studioId
    }
}

public struct PutLaunchProfileMembersOutput {

    public init() { }
}

public struct UpdateLaunchProfileInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The version number of the protocol that is used by the launch profile. The only valid version is "2021-03-31".
    public var launchProfileProtocolVersions: [Swift.String]?
    /// The name for the launch profile.
    public var name: Swift.String?
    /// A configuration for a streaming session.
    public var streamConfiguration: NimbleClientTypes.StreamConfigurationCreate?
    /// Unique identifiers for a collection of studio components that can be used with this launch profile.
    public var studioComponentIds: [Swift.String]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        launchProfileProtocolVersions: [Swift.String]? = nil,
        name: Swift.String? = nil,
        streamConfiguration: NimbleClientTypes.StreamConfigurationCreate? = nil,
        studioComponentIds: [Swift.String]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.launchProfileId = launchProfileId
        self.launchProfileProtocolVersions = launchProfileProtocolVersions
        self.name = name
        self.streamConfiguration = streamConfiguration
        self.studioComponentIds = studioComponentIds
        self.studioId = studioId
    }
}

extension UpdateLaunchProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchProfileInput(clientToken: \(Swift.String(describing: clientToken)), launchProfileId: \(Swift.String(describing: launchProfileId)), launchProfileProtocolVersions: \(Swift.String(describing: launchProfileProtocolVersions)), streamConfiguration: \(Swift.String(describing: streamConfiguration)), studioComponentIds: \(Swift.String(describing: studioComponentIds)), studioId: \(Swift.String(describing: studioId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateLaunchProfileOutput {
    /// The launch profile.
    public var launchProfile: NimbleClientTypes.LaunchProfile?

    public init(
        launchProfile: NimbleClientTypes.LaunchProfile? = nil
    )
    {
        self.launchProfile = launchProfile
    }
}

public struct UpdateLaunchProfileMemberInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the launch profile used to control access from the streaming session.
    /// This member is required.
    public var launchProfileId: Swift.String?
    /// The persona.
    /// This member is required.
    public var persona: NimbleClientTypes.LaunchProfilePersona?
    /// The principal ID. This currently supports a IAM Identity Center UserId.
    /// This member is required.
    public var principalId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        launchProfileId: Swift.String? = nil,
        persona: NimbleClientTypes.LaunchProfilePersona? = nil,
        principalId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.launchProfileId = launchProfileId
        self.persona = persona
        self.principalId = principalId
        self.studioId = studioId
    }
}

public struct UpdateLaunchProfileMemberOutput {
    /// The updated member.
    public var member: NimbleClientTypes.LaunchProfileMembership?

    public init(
        member: NimbleClientTypes.LaunchProfileMembership? = nil
    )
    {
        self.member = member
    }
}

public struct ListStreamingImagesInput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filter this request to streaming images with the given owner
    public var owner: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        owner: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.owner = owner
        self.studioId = studioId
    }
}

public struct ListStreamingImagesOutput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming images.
    public var streamingImages: [NimbleClientTypes.StreamingImage]?

    public init(
        nextToken: Swift.String? = nil,
        streamingImages: [NimbleClientTypes.StreamingImage]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingImages = streamingImages
    }
}

public struct ListStreamingSessionBackupsInput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The user ID of the user that owns the streaming session.
    public var ownedBy: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.studioId = studioId
    }
}

public struct ListStreamingSessionBackupsOutput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Information about the streaming session backups.
    public var streamingSessionBackups: [NimbleClientTypes.StreamingSessionBackup]?

    public init(
        nextToken: Swift.String? = nil,
        streamingSessionBackups: [NimbleClientTypes.StreamingSessionBackup]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamingSessionBackups = streamingSessionBackups
    }
}

public struct ListStreamingSessionsInput {
    /// Filters the request to streaming sessions created by the given user.
    public var createdBy: Swift.String?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the request to streaming session owned by the given user
    public var ownedBy: Swift.String?
    /// Filters the request to only the provided session IDs.
    public var sessionIds: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        createdBy: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        ownedBy: Swift.String? = nil,
        sessionIds: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.createdBy = createdBy
        self.nextToken = nextToken
        self.ownedBy = ownedBy
        self.sessionIds = sessionIds
        self.studioId = studioId
    }
}

public struct ListStreamingSessionsOutput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of streaming sessions.
    public var sessions: [NimbleClientTypes.StreamingSession]?

    public init(
        nextToken: Swift.String? = nil,
        sessions: [NimbleClientTypes.StreamingSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

public struct ListStudioComponentsInput {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Filters the request to studio components that are in one of the given states.
    public var states: [NimbleClientTypes.StudioComponentState]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// Filters the request to studio components that are of one of the given types.
    public var types: [NimbleClientTypes.StudioComponentType]?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        states: [NimbleClientTypes.StudioComponentState]? = nil,
        studioId: Swift.String? = nil,
        types: [NimbleClientTypes.StudioComponentType]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.states = states
        self.studioId = studioId
        self.types = types
    }
}

public struct ListStudioComponentsOutput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studio components.
    public var studioComponents: [NimbleClientTypes.StudioComponent]?

    public init(
        nextToken: Swift.String? = nil,
        studioComponents: [NimbleClientTypes.StudioComponent]? = nil
    )
    {
        self.nextToken = nextToken
        self.studioComponents = studioComponents
    }
}

public struct ListStudioMembersInput {
    /// The max number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        maxResults: Swift.Int? = 100,
        nextToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.studioId = studioId
    }
}

public struct ListStudioMembersOutput {
    /// A list of admin members.
    public var members: [NimbleClientTypes.StudioMembership]?
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        members: [NimbleClientTypes.StudioMembership]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

public struct ListStudiosInput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

public struct ListStudiosOutput {
    /// The token for the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// A collection of studios.
    /// This member is required.
    public var studios: [NimbleClientTypes.Studio]?

    public init(
        nextToken: Swift.String? = nil,
        studios: [NimbleClientTypes.Studio]? = nil
    )
    {
        self.nextToken = nextToken
        self.studios = studios
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource for which you want to list tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension NimbleClientTypes {
    /// A new studio user's membership.
    public struct NewStudioMember {
        /// The persona.
        /// This member is required.
        public var persona: NimbleClientTypes.StudioPersona?
        /// The principal ID.
        /// This member is required.
        public var principalId: Swift.String?

        public init(
            persona: NimbleClientTypes.StudioPersona? = nil,
            principalId: Swift.String? = nil
        )
        {
            self.persona = persona
            self.principalId = principalId
        }
    }

}

public struct UpdateStreamingImageInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The description.
    public var description: Swift.String?
    /// The name for the streaming image.
    public var name: Swift.String?
    /// The streaming image ID.
    /// This member is required.
    public var streamingImageId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        streamingImageId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.streamingImageId = streamingImageId
        self.studioId = studioId
    }
}

extension UpdateStreamingImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStreamingImageInput(clientToken: \(Swift.String(describing: clientToken)), streamingImageId: \(Swift.String(describing: streamingImageId)), studioId: \(Swift.String(describing: studioId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateStreamingImageOutput {
    /// Represents a streaming image resource. Streaming images are used by studio users to select which operating system and software they want to use in a Nimble Studio streaming session. Amazon provides a number of streaming images that include popular 3rd-party software. You can create your own streaming images using an Amazon EC2 machine image that you create for this purpose. You can also include software that your users require.
    public var streamingImage: NimbleClientTypes.StreamingImage?

    public init(
        streamingImage: NimbleClientTypes.StreamingImage? = nil
    )
    {
        self.streamingImage = streamingImage
    }
}

public struct StartStreamingSessionInput {
    /// The ID of the backup.
    public var backupId: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studio ID for the StartStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        backupId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
    }
}

public struct StartStreamingSessionOutput {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

public struct StopStreamingSessionInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The streaming session ID for the StopStreamingSessionRequest.
    /// This member is required.
    public var sessionId: Swift.String?
    /// The studioId for the StopStreamingSessionRequest.
    /// This member is required.
    public var studioId: Swift.String?
    /// Adds additional instructions to a streaming session stop action to either retain the EBS volumes or delete the EBS volumes.
    public var volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode?

    public init(
        clientToken: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        volumeRetentionMode: NimbleClientTypes.VolumeRetentionMode? = nil
    )
    {
        self.clientToken = clientToken
        self.sessionId = sessionId
        self.studioId = studioId
        self.volumeRetentionMode = volumeRetentionMode
    }
}

public struct StopStreamingSessionOutput {
    /// A streaming session is a virtual workstation created using a particular launch profile.
    public var session: NimbleClientTypes.StreamingSession?

    public init(
        session: NimbleClientTypes.StreamingSession? = nil
    )
    {
        self.session = session
    }
}

public struct UpdateStudioComponentInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The configuration of the studio component, based on component type.
    public var configuration: NimbleClientTypes.StudioComponentConfiguration?
    /// The description.
    public var description: Swift.String?
    /// The EC2 security groups that control access to the studio component.
    public var ec2SecurityGroupIds: [Swift.String]?
    /// Initialization scripts for studio components.
    public var initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]?
    /// The name for the studio component.
    public var name: Swift.String?
    /// An IAM role attached to a Studio Component that gives the studio component access to Amazon Web Services resources at anytime while the instance is running.
    public var runtimeRoleArn: Swift.String?
    /// Parameters for the studio component scripts.
    public var scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]?
    /// An IAM role attached to Studio Component when the system initialization script runs which give the studio component access to Amazon Web Services resources when the system initialization script runs.
    public var secureInitializationRoleArn: Swift.String?
    /// The studio component ID.
    /// This member is required.
    public var studioComponentId: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The specific subtype of a studio component.
    public var subtype: NimbleClientTypes.StudioComponentSubtype?
    /// The type of the studio component.
    public var type: NimbleClientTypes.StudioComponentType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: NimbleClientTypes.StudioComponentConfiguration? = nil,
        description: Swift.String? = nil,
        ec2SecurityGroupIds: [Swift.String]? = nil,
        initializationScripts: [NimbleClientTypes.StudioComponentInitializationScript]? = nil,
        name: Swift.String? = nil,
        runtimeRoleArn: Swift.String? = nil,
        scriptParameters: [NimbleClientTypes.ScriptParameterKeyValue]? = nil,
        secureInitializationRoleArn: Swift.String? = nil,
        studioComponentId: Swift.String? = nil,
        studioId: Swift.String? = nil,
        subtype: NimbleClientTypes.StudioComponentSubtype? = nil,
        type: NimbleClientTypes.StudioComponentType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.description = description
        self.ec2SecurityGroupIds = ec2SecurityGroupIds
        self.initializationScripts = initializationScripts
        self.name = name
        self.runtimeRoleArn = runtimeRoleArn
        self.scriptParameters = scriptParameters
        self.secureInitializationRoleArn = secureInitializationRoleArn
        self.studioComponentId = studioComponentId
        self.studioId = studioId
        self.subtype = subtype
        self.type = type
    }
}

extension UpdateStudioComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioComponentInput(clientToken: \(Swift.String(describing: clientToken)), configuration: \(Swift.String(describing: configuration)), ec2SecurityGroupIds: \(Swift.String(describing: ec2SecurityGroupIds)), initializationScripts: \(Swift.String(describing: initializationScripts)), runtimeRoleArn: \(Swift.String(describing: runtimeRoleArn)), secureInitializationRoleArn: \(Swift.String(describing: secureInitializationRoleArn)), studioComponentId: \(Swift.String(describing: studioComponentId)), studioId: \(Swift.String(describing: studioId)), subtype: \(Swift.String(describing: subtype)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", scriptParameters: \"CONTENT_REDACTED\")"}
}

public struct UpdateStudioComponentOutput {
    /// Information about the studio component.
    public var studioComponent: NimbleClientTypes.StudioComponent?

    public init(
        studioComponent: NimbleClientTypes.StudioComponent? = nil
    )
    {
        self.studioComponent = studioComponent
    }
}

public struct PutStudioMembersInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The ID of the identity store.
    /// This member is required.
    public var identityStoreId: Swift.String?
    /// A list of members.
    /// This member is required.
    public var members: [NimbleClientTypes.NewStudioMember]?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identityStoreId: Swift.String? = nil,
        members: [NimbleClientTypes.NewStudioMember]? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.identityStoreId = identityStoreId
        self.members = members
        self.studioId = studioId
    }
}

public struct PutStudioMembersOutput {

    public init() { }
}

public struct StartStudioSSOConfigurationRepairInput {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        studioId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.studioId = studioId
    }
}

public struct StartStudioSSOConfigurationRepairOutput {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

public struct UpdateStudioInput {
    /// The IAM role that Studio Admins will assume when logging in to the Nimble Studio portal.
    public var adminRoleArn: Swift.String?
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If you don’t specify a client token, the Amazon Web Services SDK automatically generates a client token and uses it for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A friendly name for the studio.
    public var displayName: Swift.String?
    /// The studio ID.
    /// This member is required.
    public var studioId: Swift.String?
    /// The IAM role that Studio Users will assume when logging in to the Nimble Studio portal.
    public var userRoleArn: Swift.String?

    public init(
        adminRoleArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        studioId: Swift.String? = nil,
        userRoleArn: Swift.String? = nil
    )
    {
        self.adminRoleArn = adminRoleArn
        self.clientToken = clientToken
        self.displayName = displayName
        self.studioId = studioId
        self.userRoleArn = userRoleArn
    }
}

extension UpdateStudioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateStudioInput(adminRoleArn: \(Swift.String(describing: adminRoleArn)), clientToken: \(Swift.String(describing: clientToken)), studioId: \(Swift.String(describing: studioId)), userRoleArn: \(Swift.String(describing: userRoleArn)), displayName: \"CONTENT_REDACTED\")"}
}

public struct UpdateStudioOutput {
    /// Information about a studio.
    /// This member is required.
    public var studio: NimbleClientTypes.Studio?

    public init(
        studio: NimbleClientTypes.Studio? = nil
    )
    {
        self.studio = studio
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource you want to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of labels, in the form of key-value pairs, that apply to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// Identifies the Amazon Resource Name(ARN) key from which you are removing tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag keys. Specify only the tag keys, not the tag values.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

extension AcceptEulasInput {

    static func urlPathProvider(_ value: AcceptEulasInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

extension AcceptEulasInput {

    static func headerProvider(_ value: AcceptEulasInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateLaunchProfileInput {

    static func urlPathProvider(_ value: CreateLaunchProfileInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

extension CreateLaunchProfileInput {

    static func headerProvider(_ value: CreateLaunchProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingImageInput {

    static func urlPathProvider(_ value: CreateStreamingImageInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

extension CreateStreamingImageInput {

    static func headerProvider(_ value: CreateStreamingImageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionInput {

    static func urlPathProvider(_ value: CreateStreamingSessionInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

extension CreateStreamingSessionInput {

    static func headerProvider(_ value: CreateStreamingSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStreamingSessionStreamInput {

    static func urlPathProvider(_ value: CreateStreamingSessionStreamInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams"
    }
}

extension CreateStreamingSessionStreamInput {

    static func headerProvider(_ value: CreateStreamingSessionStreamInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioInput {

    static func urlPathProvider(_ value: CreateStudioInput) -> Swift.String? {
        return "/2020-08-01/studios"
    }
}

extension CreateStudioInput {

    static func headerProvider(_ value: CreateStudioInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension CreateStudioComponentInput {

    static func urlPathProvider(_ value: CreateStudioComponentInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

extension CreateStudioComponentInput {

    static func headerProvider(_ value: CreateStudioComponentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileInput {

    static func urlPathProvider(_ value: DeleteLaunchProfileInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

extension DeleteLaunchProfileInput {

    static func headerProvider(_ value: DeleteLaunchProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteLaunchProfileMemberInput {

    static func urlPathProvider(_ value: DeleteLaunchProfileMemberInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

extension DeleteLaunchProfileMemberInput {

    static func headerProvider(_ value: DeleteLaunchProfileMemberInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingImageInput {

    static func urlPathProvider(_ value: DeleteStreamingImageInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let streamingImageId = value.streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

extension DeleteStreamingImageInput {

    static func headerProvider(_ value: DeleteStreamingImageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStreamingSessionInput {

    static func urlPathProvider(_ value: DeleteStreamingSessionInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension DeleteStreamingSessionInput {

    static func headerProvider(_ value: DeleteStreamingSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioInput {

    static func urlPathProvider(_ value: DeleteStudioInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

extension DeleteStudioInput {

    static func headerProvider(_ value: DeleteStudioInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioComponentInput {

    static func urlPathProvider(_ value: DeleteStudioComponentInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let studioComponentId = value.studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

extension DeleteStudioComponentInput {

    static func headerProvider(_ value: DeleteStudioComponentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension DeleteStudioMemberInput {

    static func urlPathProvider(_ value: DeleteStudioMemberInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

extension DeleteStudioMemberInput {

    static func headerProvider(_ value: DeleteStudioMemberInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension GetEulaInput {

    static func urlPathProvider(_ value: GetEulaInput) -> Swift.String? {
        guard let eulaId = value.eulaId else {
            return nil
        }
        return "/2020-08-01/eulas/\(eulaId.urlPercentEncoding())"
    }
}

extension GetLaunchProfileInput {

    static func urlPathProvider(_ value: GetLaunchProfileInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

extension GetLaunchProfileDetailsInput {

    static func urlPathProvider(_ value: GetLaunchProfileDetailsInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/details"
    }
}

extension GetLaunchProfileInitializationInput {

    static func urlPathProvider(_ value: GetLaunchProfileInitializationInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/init"
    }
}

extension GetLaunchProfileInitializationInput {

    static func queryItemProvider(_ value: GetLaunchProfileInitializationInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let launchProfileProtocolVersions = value.launchProfileProtocolVersions else {
            let message = "Creating a URL Query Item failed. launchProfileProtocolVersions is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        launchProfileProtocolVersions.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "launchProfileProtocolVersions".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let launchPurpose = value.launchPurpose else {
            let message = "Creating a URL Query Item failed. launchPurpose is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let launchPurposeQueryItem = Smithy.URIQueryItem(name: "launchPurpose".urlPercentEncoding(), value: Swift.String(launchPurpose).urlPercentEncoding())
        items.append(launchPurposeQueryItem)
        guard let platform = value.platform else {
            let message = "Creating a URL Query Item failed. platform is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let platformQueryItem = Smithy.URIQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform).urlPercentEncoding())
        items.append(platformQueryItem)
        return items
    }
}

extension GetLaunchProfileMemberInput {

    static func urlPathProvider(_ value: GetLaunchProfileMemberInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

extension GetStreamingImageInput {

    static func urlPathProvider(_ value: GetStreamingImageInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let streamingImageId = value.streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

extension GetStreamingSessionInput {

    static func urlPathProvider(_ value: GetStreamingSessionInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())"
    }
}

extension GetStreamingSessionBackupInput {

    static func urlPathProvider(_ value: GetStreamingSessionBackupInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let backupId = value.backupId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-session-backups/\(backupId.urlPercentEncoding())"
    }
}

extension GetStreamingSessionStreamInput {

    static func urlPathProvider(_ value: GetStreamingSessionStreamInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        guard let streamId = value.streamId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/streams/\(streamId.urlPercentEncoding())"
    }
}

extension GetStudioInput {

    static func urlPathProvider(_ value: GetStudioInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

extension GetStudioComponentInput {

    static func urlPathProvider(_ value: GetStudioComponentInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let studioComponentId = value.studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

extension GetStudioMemberInput {

    static func urlPathProvider(_ value: GetStudioMemberInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

extension ListEulaAcceptancesInput {

    static func urlPathProvider(_ value: ListEulaAcceptancesInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/eula-acceptances"
    }
}

extension ListEulaAcceptancesInput {

    static func queryItemProvider(_ value: ListEulaAcceptancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eulaIds = value.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListEulasInput {

    static func urlPathProvider(_ value: ListEulasInput) -> Swift.String? {
        return "/2020-08-01/eulas"
    }
}

extension ListEulasInput {

    static func queryItemProvider(_ value: ListEulasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let eulaIds = value.eulaIds {
            eulaIds.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "eulaIds".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListLaunchProfileMembersInput {

    static func urlPathProvider(_ value: ListLaunchProfileMembersInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

extension ListLaunchProfileMembersInput {

    static func queryItemProvider(_ value: ListLaunchProfileMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListLaunchProfilesInput {

    static func urlPathProvider(_ value: ListLaunchProfilesInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles"
    }
}

extension ListLaunchProfilesInput {

    static func queryItemProvider(_ value: ListLaunchProfilesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let principalId = value.principalId {
            let principalIdQueryItem = Smithy.URIQueryItem(name: "principalId".urlPercentEncoding(), value: Swift.String(principalId).urlPercentEncoding())
            items.append(principalIdQueryItem)
        }
        if let states = value.states {
            states.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListStreamingImagesInput {

    static func urlPathProvider(_ value: ListStreamingImagesInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images"
    }
}

extension ListStreamingImagesInput {

    static func queryItemProvider(_ value: ListStreamingImagesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let owner = value.owner {
            let ownerQueryItem = Smithy.URIQueryItem(name: "owner".urlPercentEncoding(), value: Swift.String(owner).urlPercentEncoding())
            items.append(ownerQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStreamingSessionBackupsInput {

    static func urlPathProvider(_ value: ListStreamingSessionBackupsInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-session-backups"
    }
}

extension ListStreamingSessionBackupsInput {

    static func queryItemProvider(_ value: ListStreamingSessionBackupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let ownedBy = value.ownedBy {
            let ownedByQueryItem = Smithy.URIQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
            items.append(ownedByQueryItem)
        }
        return items
    }
}

extension ListStreamingSessionsInput {

    static func urlPathProvider(_ value: ListStreamingSessionsInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions"
    }
}

extension ListStreamingSessionsInput {

    static func queryItemProvider(_ value: ListStreamingSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let createdBy = value.createdBy {
            let createdByQueryItem = Smithy.URIQueryItem(name: "createdBy".urlPercentEncoding(), value: Swift.String(createdBy).urlPercentEncoding())
            items.append(createdByQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let ownedBy = value.ownedBy {
            let ownedByQueryItem = Smithy.URIQueryItem(name: "ownedBy".urlPercentEncoding(), value: Swift.String(ownedBy).urlPercentEncoding())
            items.append(ownedByQueryItem)
        }
        if let sessionIds = value.sessionIds {
            let sessionIdsQueryItem = Smithy.URIQueryItem(name: "sessionIds".urlPercentEncoding(), value: Swift.String(sessionIds).urlPercentEncoding())
            items.append(sessionIdsQueryItem)
        }
        return items
    }
}

extension ListStudioComponentsInput {

    static func urlPathProvider(_ value: ListStudioComponentsInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components"
    }
}

extension ListStudioComponentsInput {

    static func queryItemProvider(_ value: ListStudioComponentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let types = value.types {
            types.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "types".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let states = value.states {
            states.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "states".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListStudioMembersInput {

    static func urlPathProvider(_ value: ListStudioMembersInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

extension ListStudioMembersInput {

    static func queryItemProvider(_ value: ListStudioMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListStudiosInput {

    static func urlPathProvider(_ value: ListStudiosInput) -> Swift.String? {
        return "/2020-08-01/studios"
    }
}

extension ListStudiosInput {

    static func queryItemProvider(_ value: ListStudiosInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutLaunchProfileMembersInput {

    static func urlPathProvider(_ value: PutLaunchProfileMembersInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership"
    }
}

extension PutLaunchProfileMembersInput {

    static func headerProvider(_ value: PutLaunchProfileMembersInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension PutStudioMembersInput {

    static func urlPathProvider(_ value: PutStudioMembersInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/membership"
    }
}

extension PutStudioMembersInput {

    static func headerProvider(_ value: PutStudioMembersInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStreamingSessionInput {

    static func urlPathProvider(_ value: StartStreamingSessionInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/start"
    }
}

extension StartStreamingSessionInput {

    static func headerProvider(_ value: StartStreamingSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StartStudioSSOConfigurationRepairInput {

    static func urlPathProvider(_ value: StartStudioSSOConfigurationRepairInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/sso-configuration"
    }
}

extension StartStudioSSOConfigurationRepairInput {

    static func headerProvider(_ value: StartStudioSSOConfigurationRepairInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension StopStreamingSessionInput {

    static func urlPathProvider(_ value: StopStreamingSessionInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let sessionId = value.sessionId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-sessions/\(sessionId.urlPercentEncoding())/stop"
    }
}

extension StopStreamingSessionInput {

    static func headerProvider(_ value: StopStreamingSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/2020-08-01/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLaunchProfileInput {

    static func urlPathProvider(_ value: UpdateLaunchProfileInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())"
    }
}

extension UpdateLaunchProfileInput {

    static func headerProvider(_ value: UpdateLaunchProfileInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateLaunchProfileMemberInput {

    static func urlPathProvider(_ value: UpdateLaunchProfileMemberInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let launchProfileId = value.launchProfileId else {
            return nil
        }
        guard let principalId = value.principalId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/launch-profiles/\(launchProfileId.urlPercentEncoding())/membership/\(principalId.urlPercentEncoding())"
    }
}

extension UpdateLaunchProfileMemberInput {

    static func headerProvider(_ value: UpdateLaunchProfileMemberInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStreamingImageInput {

    static func urlPathProvider(_ value: UpdateStreamingImageInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let streamingImageId = value.streamingImageId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/streaming-images/\(streamingImageId.urlPercentEncoding())"
    }
}

extension UpdateStreamingImageInput {

    static func headerProvider(_ value: UpdateStreamingImageInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioInput {

    static func urlPathProvider(_ value: UpdateStudioInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())"
    }
}

extension UpdateStudioInput {

    static func headerProvider(_ value: UpdateStudioInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension UpdateStudioComponentInput {

    static func urlPathProvider(_ value: UpdateStudioComponentInput) -> Swift.String? {
        guard let studioId = value.studioId else {
            return nil
        }
        guard let studioComponentId = value.studioComponentId else {
            return nil
        }
        return "/2020-08-01/studios/\(studioId.urlPercentEncoding())/studio-components/\(studioComponentId.urlPercentEncoding())"
    }
}

extension UpdateStudioComponentInput {

    static func headerProvider(_ value: UpdateStudioComponentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let clientToken = value.clientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amz-Client-Token", value: Swift.String(clientToken)))
        }
        return items
    }
}

extension AcceptEulasInput {

    static func write(value: AcceptEulasInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["eulaIds"].writeList(value.eulaIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateLaunchProfileInput {

    static func write(value: CreateLaunchProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["ec2SubnetIds"].writeList(value.ec2SubnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["launchProfileProtocolVersions"].writeList(value.launchProfileProtocolVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["streamConfiguration"].write(value.streamConfiguration, with: NimbleClientTypes.StreamConfigurationCreate.write(value:to:))
        try writer["studioComponentIds"].writeList(value.studioComponentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStreamingImageInput {

    static func write(value: CreateStreamingImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["ec2ImageId"].write(value.ec2ImageId)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStreamingSessionInput {

    static func write(value: CreateStreamingSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ec2InstanceType"].write(value.ec2InstanceType)
        try writer["launchProfileId"].write(value.launchProfileId)
        try writer["ownedBy"].write(value.ownedBy)
        try writer["streamingImageId"].write(value.streamingImageId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStreamingSessionStreamInput {

    static func write(value: CreateStreamingSessionStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expirationInSeconds"].write(value.expirationInSeconds)
    }
}

extension CreateStudioInput {

    static func write(value: CreateStudioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminRoleArn"].write(value.adminRoleArn)
        try writer["displayName"].write(value.displayName)
        try writer["studioEncryptionConfiguration"].write(value.studioEncryptionConfiguration, with: NimbleClientTypes.StudioEncryptionConfiguration.write(value:to:))
        try writer["studioName"].write(value.studioName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["userRoleArn"].write(value.userRoleArn)
    }
}

extension CreateStudioComponentInput {

    static func write(value: CreateStudioComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: NimbleClientTypes.StudioComponentConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["ec2SecurityGroupIds"].writeList(value.ec2SecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initializationScripts"].writeList(value.initializationScripts, memberWritingClosure: NimbleClientTypes.StudioComponentInitializationScript.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["runtimeRoleArn"].write(value.runtimeRoleArn)
        try writer["scriptParameters"].writeList(value.scriptParameters, memberWritingClosure: NimbleClientTypes.ScriptParameterKeyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["secureInitializationRoleArn"].write(value.secureInitializationRoleArn)
        try writer["subtype"].write(value.subtype)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension PutLaunchProfileMembersInput {

    static func write(value: PutLaunchProfileMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["members"].writeList(value.members, memberWritingClosure: NimbleClientTypes.NewLaunchProfileMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutStudioMembersInput {

    static func write(value: PutStudioMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identityStoreId"].write(value.identityStoreId)
        try writer["members"].writeList(value.members, memberWritingClosure: NimbleClientTypes.NewStudioMember.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartStreamingSessionInput {

    static func write(value: StartStreamingSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["backupId"].write(value.backupId)
    }
}

extension StopStreamingSessionInput {

    static func write(value: StopStreamingSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["volumeRetentionMode"].write(value.volumeRetentionMode)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLaunchProfileInput {

    static func write(value: UpdateLaunchProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["launchProfileProtocolVersions"].writeList(value.launchProfileProtocolVersions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["streamConfiguration"].write(value.streamConfiguration, with: NimbleClientTypes.StreamConfigurationCreate.write(value:to:))
        try writer["studioComponentIds"].writeList(value.studioComponentIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateLaunchProfileMemberInput {

    static func write(value: UpdateLaunchProfileMemberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["persona"].write(value.persona)
    }
}

extension UpdateStreamingImageInput {

    static func write(value: UpdateStreamingImageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateStudioInput {

    static func write(value: UpdateStudioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adminRoleArn"].write(value.adminRoleArn)
        try writer["displayName"].write(value.displayName)
        try writer["userRoleArn"].write(value.userRoleArn)
    }
}

extension UpdateStudioComponentInput {

    static func write(value: UpdateStudioComponentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: NimbleClientTypes.StudioComponentConfiguration.write(value:to:))
        try writer["description"].write(value.description)
        try writer["ec2SecurityGroupIds"].writeList(value.ec2SecurityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initializationScripts"].writeList(value.initializationScripts, memberWritingClosure: NimbleClientTypes.StudioComponentInitializationScript.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["runtimeRoleArn"].write(value.runtimeRoleArn)
        try writer["scriptParameters"].writeList(value.scriptParameters, memberWritingClosure: NimbleClientTypes.ScriptParameterKeyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["secureInitializationRoleArn"].write(value.secureInitializationRoleArn)
        try writer["subtype"].write(value.subtype)
        try writer["type"].write(value.type)
    }
}

extension AcceptEulasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptEulasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptEulasOutput()
        value.eulaAcceptances = try reader["eulaAcceptances"].readListIfPresent(memberReadingClosure: NimbleClientTypes.EulaAcceptance.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateLaunchProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLaunchProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLaunchProfileOutput()
        value.launchProfile = try reader["launchProfile"].readIfPresent(with: NimbleClientTypes.LaunchProfile.read(from:))
        return value
    }
}

extension CreateStreamingImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingImageOutput()
        value.streamingImage = try reader["streamingImage"].readIfPresent(with: NimbleClientTypes.StreamingImage.read(from:))
        return value
    }
}

extension CreateStreamingSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingSessionOutput()
        value.session = try reader["session"].readIfPresent(with: NimbleClientTypes.StreamingSession.read(from:))
        return value
    }
}

extension CreateStreamingSessionStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamingSessionStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamingSessionStreamOutput()
        value.stream = try reader["stream"].readIfPresent(with: NimbleClientTypes.StreamingSessionStream.read(from:))
        return value
    }
}

extension CreateStudioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStudioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStudioOutput()
        value.studio = try reader["studio"].readIfPresent(with: NimbleClientTypes.Studio.read(from:))
        return value
    }
}

extension CreateStudioComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStudioComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStudioComponentOutput()
        value.studioComponent = try reader["studioComponent"].readIfPresent(with: NimbleClientTypes.StudioComponent.read(from:))
        return value
    }
}

extension DeleteLaunchProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLaunchProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteLaunchProfileOutput()
        value.launchProfile = try reader["launchProfile"].readIfPresent(with: NimbleClientTypes.LaunchProfile.read(from:))
        return value
    }
}

extension DeleteLaunchProfileMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLaunchProfileMemberOutput {
        return DeleteLaunchProfileMemberOutput()
    }
}

extension DeleteStreamingImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamingImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteStreamingImageOutput()
        value.streamingImage = try reader["streamingImage"].readIfPresent(with: NimbleClientTypes.StreamingImage.read(from:))
        return value
    }
}

extension DeleteStreamingSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamingSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteStreamingSessionOutput()
        value.session = try reader["session"].readIfPresent(with: NimbleClientTypes.StreamingSession.read(from:))
        return value
    }
}

extension DeleteStudioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStudioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteStudioOutput()
        value.studio = try reader["studio"].readIfPresent(with: NimbleClientTypes.Studio.read(from:))
        return value
    }
}

extension DeleteStudioComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStudioComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteStudioComponentOutput()
        value.studioComponent = try reader["studioComponent"].readIfPresent(with: NimbleClientTypes.StudioComponent.read(from:))
        return value
    }
}

extension DeleteStudioMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStudioMemberOutput {
        return DeleteStudioMemberOutput()
    }
}

extension GetEulaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEulaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEulaOutput()
        value.eula = try reader["eula"].readIfPresent(with: NimbleClientTypes.Eula.read(from:))
        return value
    }
}

extension GetLaunchProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchProfileOutput()
        value.launchProfile = try reader["launchProfile"].readIfPresent(with: NimbleClientTypes.LaunchProfile.read(from:))
        return value
    }
}

extension GetLaunchProfileDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchProfileDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchProfileDetailsOutput()
        value.launchProfile = try reader["launchProfile"].readIfPresent(with: NimbleClientTypes.LaunchProfile.read(from:))
        value.streamingImages = try reader["streamingImages"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StreamingImage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.studioComponentSummaries = try reader["studioComponentSummaries"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StudioComponentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetLaunchProfileInitializationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchProfileInitializationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchProfileInitializationOutput()
        value.launchProfileInitialization = try reader["launchProfileInitialization"].readIfPresent(with: NimbleClientTypes.LaunchProfileInitialization.read(from:))
        return value
    }
}

extension GetLaunchProfileMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLaunchProfileMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLaunchProfileMemberOutput()
        value.member = try reader["member"].readIfPresent(with: NimbleClientTypes.LaunchProfileMembership.read(from:))
        return value
    }
}

extension GetStreamingImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingImageOutput()
        value.streamingImage = try reader["streamingImage"].readIfPresent(with: NimbleClientTypes.StreamingImage.read(from:))
        return value
    }
}

extension GetStreamingSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingSessionOutput()
        value.session = try reader["session"].readIfPresent(with: NimbleClientTypes.StreamingSession.read(from:))
        return value
    }
}

extension GetStreamingSessionBackupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingSessionBackupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingSessionBackupOutput()
        value.streamingSessionBackup = try reader["streamingSessionBackup"].readIfPresent(with: NimbleClientTypes.StreamingSessionBackup.read(from:))
        return value
    }
}

extension GetStreamingSessionStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamingSessionStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamingSessionStreamOutput()
        value.stream = try reader["stream"].readIfPresent(with: NimbleClientTypes.StreamingSessionStream.read(from:))
        return value
    }
}

extension GetStudioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStudioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStudioOutput()
        value.studio = try reader["studio"].readIfPresent(with: NimbleClientTypes.Studio.read(from:))
        return value
    }
}

extension GetStudioComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStudioComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStudioComponentOutput()
        value.studioComponent = try reader["studioComponent"].readIfPresent(with: NimbleClientTypes.StudioComponent.read(from:))
        return value
    }
}

extension GetStudioMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStudioMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStudioMemberOutput()
        value.member = try reader["member"].readIfPresent(with: NimbleClientTypes.StudioMembership.read(from:))
        return value
    }
}

extension ListEulaAcceptancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEulaAcceptancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEulaAcceptancesOutput()
        value.eulaAcceptances = try reader["eulaAcceptances"].readListIfPresent(memberReadingClosure: NimbleClientTypes.EulaAcceptance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEulasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEulasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEulasOutput()
        value.eulas = try reader["eulas"].readListIfPresent(memberReadingClosure: NimbleClientTypes.Eula.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLaunchProfileMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLaunchProfileMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLaunchProfileMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: NimbleClientTypes.LaunchProfileMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListLaunchProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLaunchProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLaunchProfilesOutput()
        value.launchProfiles = try reader["launchProfiles"].readListIfPresent(memberReadingClosure: NimbleClientTypes.LaunchProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListStreamingImagesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamingImagesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamingImagesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streamingImages = try reader["streamingImages"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StreamingImage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStreamingSessionBackupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamingSessionBackupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamingSessionBackupsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.streamingSessionBackups = try reader["streamingSessionBackups"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StreamingSessionBackup.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStreamingSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamingSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamingSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sessions = try reader["sessions"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StreamingSession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStudioComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStudioComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStudioComponentsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.studioComponents = try reader["studioComponents"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StudioComponent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListStudioMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStudioMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStudioMembersOutput()
        value.members = try reader["members"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StudioMembership.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListStudiosOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStudiosOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStudiosOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.studios = try reader["studios"].readListIfPresent(memberReadingClosure: NimbleClientTypes.Studio.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutLaunchProfileMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLaunchProfileMembersOutput {
        return PutLaunchProfileMembersOutput()
    }
}

extension PutStudioMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutStudioMembersOutput {
        return PutStudioMembersOutput()
    }
}

extension StartStreamingSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartStreamingSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartStreamingSessionOutput()
        value.session = try reader["session"].readIfPresent(with: NimbleClientTypes.StreamingSession.read(from:))
        return value
    }
}

extension StartStudioSSOConfigurationRepairOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartStudioSSOConfigurationRepairOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartStudioSSOConfigurationRepairOutput()
        value.studio = try reader["studio"].readIfPresent(with: NimbleClientTypes.Studio.read(from:))
        return value
    }
}

extension StopStreamingSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopStreamingSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopStreamingSessionOutput()
        value.session = try reader["session"].readIfPresent(with: NimbleClientTypes.StreamingSession.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLaunchProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLaunchProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLaunchProfileOutput()
        value.launchProfile = try reader["launchProfile"].readIfPresent(with: NimbleClientTypes.LaunchProfile.read(from:))
        return value
    }
}

extension UpdateLaunchProfileMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLaunchProfileMemberOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLaunchProfileMemberOutput()
        value.member = try reader["member"].readIfPresent(with: NimbleClientTypes.LaunchProfileMembership.read(from:))
        return value
    }
}

extension UpdateStreamingImageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStreamingImageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStreamingImageOutput()
        value.streamingImage = try reader["streamingImage"].readIfPresent(with: NimbleClientTypes.StreamingImage.read(from:))
        return value
    }
}

extension UpdateStudioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStudioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStudioOutput()
        value.studio = try reader["studio"].readIfPresent(with: NimbleClientTypes.Studio.read(from:))
        return value
    }
}

extension UpdateStudioComponentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStudioComponentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStudioComponentOutput()
        value.studioComponent = try reader["studioComponent"].readIfPresent(with: NimbleClientTypes.StudioComponent.read(from:))
        return value
    }
}

enum AcceptEulasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLaunchProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamingSessionStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStudioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStudioComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLaunchProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLaunchProfileMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamingImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamingSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStudioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStudioComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStudioMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEulaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchProfileDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchProfileInitializationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLaunchProfileMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingSessionBackupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamingSessionStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStudioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStudioComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStudioMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEulaAcceptancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEulasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLaunchProfileMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLaunchProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamingImagesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamingSessionBackupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamingSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStudioComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStudioMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStudiosOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLaunchProfileMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutStudioMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartStreamingSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartStudioSSOConfigurationRepairOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopStreamingSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLaunchProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLaunchProfileMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStreamingImageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStudioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStudioComponentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.context = try reader["context"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NimbleClientTypes.EulaAcceptance {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.EulaAcceptance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.EulaAcceptance()
        value.acceptedAt = try reader["acceptedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.acceptedBy = try reader["acceptedBy"].readIfPresent()
        value.accepteeId = try reader["accepteeId"].readIfPresent()
        value.eulaAcceptanceId = try reader["eulaAcceptanceId"].readIfPresent()
        value.eulaId = try reader["eulaId"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.LaunchProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LaunchProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LaunchProfile()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ec2SubnetIds = try reader["ec2SubnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchProfileId = try reader["launchProfileId"].readIfPresent()
        value.launchProfileProtocolVersions = try reader["launchProfileProtocolVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.streamConfiguration = try reader["streamConfiguration"].readIfPresent(with: NimbleClientTypes.StreamConfiguration.read(from:))
        value.studioComponentIds = try reader["studioComponentIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.validationResults = try reader["validationResults"].readListIfPresent(memberReadingClosure: NimbleClientTypes.ValidationResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NimbleClientTypes.ValidationResult {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.ValidationResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.ValidationResult()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.statusCode = try reader["statusCode"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent() ?? ""
        return value
    }
}

extension NimbleClientTypes.StreamConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamConfiguration()
        value.clipboardMode = try reader["clipboardMode"].readIfPresent() ?? .sdkUnknown("")
        value.ec2InstanceTypes = try reader["ec2InstanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<NimbleClientTypes.StreamingInstanceType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxSessionLengthInMinutes = try reader["maxSessionLengthInMinutes"].readIfPresent() ?? 690
        value.streamingImageIds = try reader["streamingImageIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxStoppedSessionLengthInMinutes = try reader["maxStoppedSessionLengthInMinutes"].readIfPresent() ?? 0
        value.sessionStorage = try reader["sessionStorage"].readIfPresent(with: NimbleClientTypes.StreamConfigurationSessionStorage.read(from:))
        value.sessionBackup = try reader["sessionBackup"].readIfPresent(with: NimbleClientTypes.StreamConfigurationSessionBackup.read(from:))
        value.sessionPersistenceMode = try reader["sessionPersistenceMode"].readIfPresent()
        value.volumeConfiguration = try reader["volumeConfiguration"].readIfPresent(with: NimbleClientTypes.VolumeConfiguration.read(from:))
        value.automaticTerminationMode = try reader["automaticTerminationMode"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.VolumeConfiguration {

    static func write(value: NimbleClientTypes.VolumeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iops"].write(value.iops)
        try writer["size"].write(value.size)
        try writer["throughput"].write(value.throughput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.VolumeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.VolumeConfiguration()
        value.size = try reader["size"].readIfPresent() ?? 500
        value.throughput = try reader["throughput"].readIfPresent() ?? 125
        value.iops = try reader["iops"].readIfPresent() ?? 3000
        return value
    }
}

extension NimbleClientTypes.StreamConfigurationSessionBackup {

    static func write(value: NimbleClientTypes.StreamConfigurationSessionBackup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxBackupsToRetain"].write(value.maxBackupsToRetain)
        try writer["mode"].write(value.mode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamConfigurationSessionBackup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamConfigurationSessionBackup()
        value.mode = try reader["mode"].readIfPresent()
        value.maxBackupsToRetain = try reader["maxBackupsToRetain"].readIfPresent() ?? 0
        return value
    }
}

extension NimbleClientTypes.StreamConfigurationSessionStorage {

    static func write(value: NimbleClientTypes.StreamConfigurationSessionStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mode"].writeList(value.mode, memberWritingClosure: SmithyReadWrite.WritingClosureBox<NimbleClientTypes.StreamingSessionStorageMode>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["root"].write(value.root, with: NimbleClientTypes.StreamingSessionStorageRoot.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamConfigurationSessionStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamConfigurationSessionStorage()
        value.root = try reader["root"].readIfPresent(with: NimbleClientTypes.StreamingSessionStorageRoot.read(from:))
        value.mode = try reader["mode"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<NimbleClientTypes.StreamingSessionStorageMode>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension NimbleClientTypes.StreamingSessionStorageRoot {

    static func write(value: NimbleClientTypes.StreamingSessionStorageRoot?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["linux"].write(value.linux)
        try writer["windows"].write(value.windows)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingSessionStorageRoot {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingSessionStorageRoot()
        value.linux = try reader["linux"].readIfPresent()
        value.windows = try reader["windows"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StreamingImage {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingImage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingImage()
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ec2ImageId = try reader["ec2ImageId"].readIfPresent()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: NimbleClientTypes.StreamingImageEncryptionConfiguration.read(from:))
        value.eulaIds = try reader["eulaIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.streamingImageId = try reader["streamingImageId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NimbleClientTypes.StreamingImageEncryptionConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingImageEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingImageEncryptionConfiguration()
        value.keyArn = try reader["keyArn"].readIfPresent()
        value.keyType = try reader["keyType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NimbleClientTypes.StreamingSession {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingSession()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.ec2InstanceType = try reader["ec2InstanceType"].readIfPresent()
        value.launchProfileId = try reader["launchProfileId"].readIfPresent()
        value.ownedBy = try reader["ownedBy"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.streamingImageId = try reader["streamingImageId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.terminateAt = try reader["terminateAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.stoppedAt = try reader["stoppedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.stoppedBy = try reader["stoppedBy"].readIfPresent()
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedBy = try reader["startedBy"].readIfPresent()
        value.stopAt = try reader["stopAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedFromBackupId = try reader["startedFromBackupId"].readIfPresent()
        value.backupMode = try reader["backupMode"].readIfPresent()
        value.maxBackupsToRetain = try reader["maxBackupsToRetain"].readIfPresent() ?? 0
        value.volumeRetentionMode = try reader["volumeRetentionMode"].readIfPresent()
        value.sessionPersistenceMode = try reader["sessionPersistenceMode"].readIfPresent()
        value.volumeConfiguration = try reader["volumeConfiguration"].readIfPresent(with: NimbleClientTypes.VolumeConfiguration.read(from:))
        value.automaticTerminationMode = try reader["automaticTerminationMode"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StreamingSessionStream {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingSessionStream {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingSessionStream()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.ownedBy = try reader["ownedBy"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.streamId = try reader["streamId"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.Studio {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.Studio {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.Studio()
        value.adminRoleArn = try reader["adminRoleArn"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.displayName = try reader["displayName"].readIfPresent()
        value.homeRegion = try reader["homeRegion"].readIfPresent()
        value.ssoClientId = try reader["ssoClientId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.studioEncryptionConfiguration = try reader["studioEncryptionConfiguration"].readIfPresent(with: NimbleClientTypes.StudioEncryptionConfiguration.read(from:))
        value.studioId = try reader["studioId"].readIfPresent()
        value.studioName = try reader["studioName"].readIfPresent()
        value.studioUrl = try reader["studioUrl"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.userRoleArn = try reader["userRoleArn"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StudioEncryptionConfiguration {

    static func write(value: NimbleClientTypes.StudioEncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["keyArn"].write(value.keyArn)
        try writer["keyType"].write(value.keyType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioEncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StudioEncryptionConfiguration()
        value.keyArn = try reader["keyArn"].readIfPresent()
        value.keyType = try reader["keyType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension NimbleClientTypes.StudioComponent {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioComponent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StudioComponent()
        value.arn = try reader["arn"].readIfPresent()
        value.configuration = try reader["configuration"].readIfPresent(with: NimbleClientTypes.StudioComponentConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.ec2SecurityGroupIds = try reader["ec2SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.initializationScripts = try reader["initializationScripts"].readListIfPresent(memberReadingClosure: NimbleClientTypes.StudioComponentInitializationScript.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.scriptParameters = try reader["scriptParameters"].readListIfPresent(memberReadingClosure: NimbleClientTypes.ScriptParameterKeyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.studioComponentId = try reader["studioComponentId"].readIfPresent()
        value.subtype = try reader["subtype"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        value.secureInitializationRoleArn = try reader["secureInitializationRoleArn"].readIfPresent()
        value.runtimeRoleArn = try reader["runtimeRoleArn"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.ScriptParameterKeyValue {

    static func write(value: NimbleClientTypes.ScriptParameterKeyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.ScriptParameterKeyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.ScriptParameterKeyValue()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StudioComponentInitializationScript {

    static func write(value: NimbleClientTypes.StudioComponentInitializationScript?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["launchProfileProtocolVersion"].write(value.launchProfileProtocolVersion)
        try writer["platform"].write(value.platform)
        try writer["runContext"].write(value.runContext)
        try writer["script"].write(value.script)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioComponentInitializationScript {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StudioComponentInitializationScript()
        value.launchProfileProtocolVersion = try reader["launchProfileProtocolVersion"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.runContext = try reader["runContext"].readIfPresent()
        value.script = try reader["script"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StudioComponentConfiguration {

    static func write(value: NimbleClientTypes.StudioComponentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .activedirectoryconfiguration(activedirectoryconfiguration):
                try writer["activeDirectoryConfiguration"].write(activedirectoryconfiguration, with: NimbleClientTypes.ActiveDirectoryConfiguration.write(value:to:))
            case let .computefarmconfiguration(computefarmconfiguration):
                try writer["computeFarmConfiguration"].write(computefarmconfiguration, with: NimbleClientTypes.ComputeFarmConfiguration.write(value:to:))
            case let .licenseserviceconfiguration(licenseserviceconfiguration):
                try writer["licenseServiceConfiguration"].write(licenseserviceconfiguration, with: NimbleClientTypes.LicenseServiceConfiguration.write(value:to:))
            case let .sharedfilesystemconfiguration(sharedfilesystemconfiguration):
                try writer["sharedFileSystemConfiguration"].write(sharedfilesystemconfiguration, with: NimbleClientTypes.SharedFileSystemConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioComponentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "activeDirectoryConfiguration":
                return .activedirectoryconfiguration(try reader["activeDirectoryConfiguration"].read(with: NimbleClientTypes.ActiveDirectoryConfiguration.read(from:)))
            case "computeFarmConfiguration":
                return .computefarmconfiguration(try reader["computeFarmConfiguration"].read(with: NimbleClientTypes.ComputeFarmConfiguration.read(from:)))
            case "licenseServiceConfiguration":
                return .licenseserviceconfiguration(try reader["licenseServiceConfiguration"].read(with: NimbleClientTypes.LicenseServiceConfiguration.read(from:)))
            case "sharedFileSystemConfiguration":
                return .sharedfilesystemconfiguration(try reader["sharedFileSystemConfiguration"].read(with: NimbleClientTypes.SharedFileSystemConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension NimbleClientTypes.SharedFileSystemConfiguration {

    static func write(value: NimbleClientTypes.SharedFileSystemConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoint"].write(value.endpoint)
        try writer["fileSystemId"].write(value.fileSystemId)
        try writer["linuxMountPoint"].write(value.linuxMountPoint)
        try writer["shareName"].write(value.shareName)
        try writer["windowsMountDrive"].write(value.windowsMountDrive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.SharedFileSystemConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.SharedFileSystemConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.fileSystemId = try reader["fileSystemId"].readIfPresent()
        value.linuxMountPoint = try reader["linuxMountPoint"].readIfPresent()
        value.shareName = try reader["shareName"].readIfPresent()
        value.windowsMountDrive = try reader["windowsMountDrive"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.LicenseServiceConfiguration {

    static func write(value: NimbleClientTypes.LicenseServiceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LicenseServiceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LicenseServiceConfiguration()
        value.endpoint = try reader["endpoint"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.ComputeFarmConfiguration {

    static func write(value: NimbleClientTypes.ComputeFarmConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activeDirectoryUser"].write(value.activeDirectoryUser)
        try writer["endpoint"].write(value.endpoint)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.ComputeFarmConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.ComputeFarmConfiguration()
        value.activeDirectoryUser = try reader["activeDirectoryUser"].readIfPresent()
        value.endpoint = try reader["endpoint"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.ActiveDirectoryConfiguration {

    static func write(value: NimbleClientTypes.ActiveDirectoryConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computerAttributes"].writeList(value.computerAttributes, memberWritingClosure: NimbleClientTypes.ActiveDirectoryComputerAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["directoryId"].write(value.directoryId)
        try writer["organizationalUnitDistinguishedName"].write(value.organizationalUnitDistinguishedName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.ActiveDirectoryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.ActiveDirectoryConfiguration()
        value.computerAttributes = try reader["computerAttributes"].readListIfPresent(memberReadingClosure: NimbleClientTypes.ActiveDirectoryComputerAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.directoryId = try reader["directoryId"].readIfPresent()
        value.organizationalUnitDistinguishedName = try reader["organizationalUnitDistinguishedName"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.ActiveDirectoryComputerAttribute {

    static func write(value: NimbleClientTypes.ActiveDirectoryComputerAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.ActiveDirectoryComputerAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.ActiveDirectoryComputerAttribute()
        value.name = try reader["name"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.Eula {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.Eula {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.Eula()
        value.content = try reader["content"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.eulaId = try reader["eulaId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension NimbleClientTypes.StudioComponentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioComponentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StudioComponentSummary()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.studioComponentId = try reader["studioComponentId"].readIfPresent()
        value.subtype = try reader["subtype"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedBy = try reader["updatedBy"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.LaunchProfileInitialization {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LaunchProfileInitialization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LaunchProfileInitialization()
        value.activeDirectory = try reader["activeDirectory"].readIfPresent(with: NimbleClientTypes.LaunchProfileInitializationActiveDirectory.read(from:))
        value.ec2SecurityGroupIds = try reader["ec2SecurityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.launchProfileId = try reader["launchProfileId"].readIfPresent()
        value.launchProfileProtocolVersion = try reader["launchProfileProtocolVersion"].readIfPresent()
        value.launchPurpose = try reader["launchPurpose"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.systemInitializationScripts = try reader["systemInitializationScripts"].readListIfPresent(memberReadingClosure: NimbleClientTypes.LaunchProfileInitializationScript.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.userInitializationScripts = try reader["userInitializationScripts"].readListIfPresent(memberReadingClosure: NimbleClientTypes.LaunchProfileInitializationScript.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension NimbleClientTypes.LaunchProfileInitializationScript {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LaunchProfileInitializationScript {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LaunchProfileInitializationScript()
        value.script = try reader["script"].readIfPresent()
        value.studioComponentId = try reader["studioComponentId"].readIfPresent()
        value.studioComponentName = try reader["studioComponentName"].readIfPresent()
        value.secureInitializationRoleArn = try reader["secureInitializationRoleArn"].readIfPresent()
        value.runtimeRoleArn = try reader["runtimeRoleArn"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.LaunchProfileInitializationActiveDirectory {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LaunchProfileInitializationActiveDirectory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LaunchProfileInitializationActiveDirectory()
        value.computerAttributes = try reader["computerAttributes"].readListIfPresent(memberReadingClosure: NimbleClientTypes.ActiveDirectoryComputerAttribute.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.directoryId = try reader["directoryId"].readIfPresent()
        value.directoryName = try reader["directoryName"].readIfPresent()
        value.dnsIpAddresses = try reader["dnsIpAddresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.organizationalUnitDistinguishedName = try reader["organizationalUnitDistinguishedName"].readIfPresent()
        value.studioComponentId = try reader["studioComponentId"].readIfPresent()
        value.studioComponentName = try reader["studioComponentName"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.LaunchProfileMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.LaunchProfileMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.LaunchProfileMembership()
        value.identityStoreId = try reader["identityStoreId"].readIfPresent()
        value.persona = try reader["persona"].readIfPresent()
        value.principalId = try reader["principalId"].readIfPresent()
        value.sid = try reader["sid"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StreamingSessionBackup {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StreamingSessionBackup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StreamingSessionBackup()
        value.arn = try reader["arn"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.launchProfileId = try reader["launchProfileId"].readIfPresent()
        value.ownedBy = try reader["ownedBy"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.backupId = try reader["backupId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension NimbleClientTypes.StudioMembership {

    static func read(from reader: SmithyJSON.Reader) throws -> NimbleClientTypes.StudioMembership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = NimbleClientTypes.StudioMembership()
        value.identityStoreId = try reader["identityStoreId"].readIfPresent()
        value.persona = try reader["persona"].readIfPresent()
        value.principalId = try reader["principalId"].readIfPresent()
        value.sid = try reader["sid"].readIfPresent()
        return value
    }
}

extension NimbleClientTypes.StreamConfigurationCreate {

    static func write(value: NimbleClientTypes.StreamConfigurationCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["automaticTerminationMode"].write(value.automaticTerminationMode)
        try writer["clipboardMode"].write(value.clipboardMode)
        try writer["ec2InstanceTypes"].writeList(value.ec2InstanceTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<NimbleClientTypes.StreamingInstanceType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxSessionLengthInMinutes"].write(value.maxSessionLengthInMinutes)
        try writer["maxStoppedSessionLengthInMinutes"].write(value.maxStoppedSessionLengthInMinutes)
        try writer["sessionBackup"].write(value.sessionBackup, with: NimbleClientTypes.StreamConfigurationSessionBackup.write(value:to:))
        try writer["sessionPersistenceMode"].write(value.sessionPersistenceMode)
        try writer["sessionStorage"].write(value.sessionStorage, with: NimbleClientTypes.StreamConfigurationSessionStorage.write(value:to:))
        try writer["streamingImageIds"].writeList(value.streamingImageIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["volumeConfiguration"].write(value.volumeConfiguration, with: NimbleClientTypes.VolumeConfiguration.write(value:to:))
    }
}

extension NimbleClientTypes.NewLaunchProfileMember {

    static func write(value: NimbleClientTypes.NewLaunchProfileMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["persona"].write(value.persona)
        try writer["principalId"].write(value.principalId)
    }
}

extension NimbleClientTypes.NewStudioMember {

    static func write(value: NimbleClientTypes.NewStudioMember?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["persona"].write(value.persona)
        try writer["principalId"].write(value.principalId)
    }
}

public enum NimbleClientTypes {}
