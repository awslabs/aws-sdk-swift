// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension CodeartifactClient {
    /// Paginate over `[ListDomainsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDomainsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDomainsOutput`
    public func listDomainsPaginated(input: ListDomainsInput) -> ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutput> {
        return ClientRuntime.PaginatorSequence<ListDomainsInput, ListDomainsOutput>(input: input, inputKey: \ListDomainsInput.nextToken, outputKey: \ListDomainsOutput.nextToken, paginationFunction: self.listDomains(input:))
    }
}

extension ListDomainsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDomainsInput {
        return ListDomainsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDomainsInput, Output == ListDomainsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDomainsPaginated`
    /// to access the nested member `[CodeartifactClientTypes.DomainSummary]`
    /// - Returns: `[CodeartifactClientTypes.DomainSummary]`
    public func domains() async throws -> [CodeartifactClientTypes.DomainSummary] {
        return try await self.asyncCompactMap { item in item.domains }
    }
}
extension CodeartifactClient {
    /// Paginate over `[ListPackagesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackagesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackagesOutput`
    public func listPackagesPaginated(input: ListPackagesInput) -> ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput> {
        return ClientRuntime.PaginatorSequence<ListPackagesInput, ListPackagesOutput>(input: input, inputKey: \ListPackagesInput.nextToken, outputKey: \ListPackagesOutput.nextToken, paginationFunction: self.listPackages(input:))
    }
}

extension ListPackagesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackagesInput {
        return ListPackagesInput(
            domain: self.domain,
            domainOwner: self.domainOwner,
            format: self.format,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            packagePrefix: self.packagePrefix,
            publish: self.publish,
            repository: self.repository,
            upstream: self.upstream
        )}
}

extension PaginatorSequence where Input == ListPackagesInput, Output == ListPackagesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPackagesPaginated`
    /// to access the nested member `[CodeartifactClientTypes.PackageSummary]`
    /// - Returns: `[CodeartifactClientTypes.PackageSummary]`
    public func packages() async throws -> [CodeartifactClientTypes.PackageSummary] {
        return try await self.asyncCompactMap { item in item.packages }
    }
}
extension CodeartifactClient {
    /// Paginate over `[ListPackageVersionAssetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackageVersionAssetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackageVersionAssetsOutput`
    public func listPackageVersionAssetsPaginated(input: ListPackageVersionAssetsInput) -> ClientRuntime.PaginatorSequence<ListPackageVersionAssetsInput, ListPackageVersionAssetsOutput> {
        return ClientRuntime.PaginatorSequence<ListPackageVersionAssetsInput, ListPackageVersionAssetsOutput>(input: input, inputKey: \ListPackageVersionAssetsInput.nextToken, outputKey: \ListPackageVersionAssetsOutput.nextToken, paginationFunction: self.listPackageVersionAssets(input:))
    }
}

extension ListPackageVersionAssetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackageVersionAssetsInput {
        return ListPackageVersionAssetsInput(
            domain: self.domain,
            domainOwner: self.domainOwner,
            format: self.format,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            package: self.package,
            packageVersion: self.packageVersion,
            repository: self.repository
        )}
}

extension PaginatorSequence where Input == ListPackageVersionAssetsInput, Output == ListPackageVersionAssetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPackageVersionAssetsPaginated`
    /// to access the nested member `[CodeartifactClientTypes.AssetSummary]`
    /// - Returns: `[CodeartifactClientTypes.AssetSummary]`
    public func assets() async throws -> [CodeartifactClientTypes.AssetSummary] {
        return try await self.asyncCompactMap { item in item.assets }
    }
}
extension CodeartifactClient {
    /// Paginate over `[ListPackageVersionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPackageVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPackageVersionsOutput`
    public func listPackageVersionsPaginated(input: ListPackageVersionsInput) -> ClientRuntime.PaginatorSequence<ListPackageVersionsInput, ListPackageVersionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPackageVersionsInput, ListPackageVersionsOutput>(input: input, inputKey: \ListPackageVersionsInput.nextToken, outputKey: \ListPackageVersionsOutput.nextToken, paginationFunction: self.listPackageVersions(input:))
    }
}

extension ListPackageVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPackageVersionsInput {
        return ListPackageVersionsInput(
            domain: self.domain,
            domainOwner: self.domainOwner,
            format: self.format,
            maxResults: self.maxResults,
            namespace: self.namespace,
            nextToken: token,
            originType: self.originType,
            package: self.package,
            repository: self.repository,
            sortBy: self.sortBy,
            status: self.status
        )}
}

extension PaginatorSequence where Input == ListPackageVersionsInput, Output == ListPackageVersionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPackageVersionsPaginated`
    /// to access the nested member `[CodeartifactClientTypes.PackageVersionSummary]`
    /// - Returns: `[CodeartifactClientTypes.PackageVersionSummary]`
    public func versions() async throws -> [CodeartifactClientTypes.PackageVersionSummary] {
        return try await self.asyncCompactMap { item in item.versions }
    }
}
extension CodeartifactClient {
    /// Paginate over `[ListRepositoriesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRepositoriesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRepositoriesOutput`
    public func listRepositoriesPaginated(input: ListRepositoriesInput) -> ClientRuntime.PaginatorSequence<ListRepositoriesInput, ListRepositoriesOutput> {
        return ClientRuntime.PaginatorSequence<ListRepositoriesInput, ListRepositoriesOutput>(input: input, inputKey: \ListRepositoriesInput.nextToken, outputKey: \ListRepositoriesOutput.nextToken, paginationFunction: self.listRepositories(input:))
    }
}

extension ListRepositoriesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRepositoriesInput {
        return ListRepositoriesInput(
            maxResults: self.maxResults,
            nextToken: token,
            repositoryPrefix: self.repositoryPrefix
        )}
}

extension PaginatorSequence where Input == ListRepositoriesInput, Output == ListRepositoriesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRepositoriesPaginated`
    /// to access the nested member `[CodeartifactClientTypes.RepositorySummary]`
    /// - Returns: `[CodeartifactClientTypes.RepositorySummary]`
    public func repositories() async throws -> [CodeartifactClientTypes.RepositorySummary] {
        return try await self.asyncCompactMap { item in item.repositories }
    }
}
extension CodeartifactClient {
    /// Paginate over `[ListRepositoriesInDomainOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRepositoriesInDomainInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRepositoriesInDomainOutput`
    public func listRepositoriesInDomainPaginated(input: ListRepositoriesInDomainInput) -> ClientRuntime.PaginatorSequence<ListRepositoriesInDomainInput, ListRepositoriesInDomainOutput> {
        return ClientRuntime.PaginatorSequence<ListRepositoriesInDomainInput, ListRepositoriesInDomainOutput>(input: input, inputKey: \ListRepositoriesInDomainInput.nextToken, outputKey: \ListRepositoriesInDomainOutput.nextToken, paginationFunction: self.listRepositoriesInDomain(input:))
    }
}

extension ListRepositoriesInDomainInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRepositoriesInDomainInput {
        return ListRepositoriesInDomainInput(
            administratorAccount: self.administratorAccount,
            domain: self.domain,
            domainOwner: self.domainOwner,
            maxResults: self.maxResults,
            nextToken: token,
            repositoryPrefix: self.repositoryPrefix
        )}
}

extension PaginatorSequence where Input == ListRepositoriesInDomainInput, Output == ListRepositoriesInDomainOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRepositoriesInDomainPaginated`
    /// to access the nested member `[CodeartifactClientTypes.RepositorySummary]`
    /// - Returns: `[CodeartifactClientTypes.RepositorySummary]`
    public func repositories() async throws -> [CodeartifactClientTypes.RepositorySummary] {
        return try await self.asyncCompactMap { item in item.repositories }
    }
}
