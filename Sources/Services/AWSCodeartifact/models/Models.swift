// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because of an unauthorized access attempt.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes {
    public enum AllowPublish: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowPublish] {
            return [
                .allow,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowPublish(rawValue: rawValue) ?? AllowPublish.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum AllowUpstream: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowUpstream] {
            return [
                .allow,
                .block,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowUpstream(rawValue: rawValue) ?? AllowUpstream.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.AssetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hashes
        case name
        case size
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hashes = hashes {
            var hashesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .hashes)
            for (dictKey0, assetHashes0) in hashes {
                try hashesContainer.encode(assetHashes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let size = self.size {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .size)
        size = sizeDecoded
        let hashesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .hashes)
        var hashesDecoded0: [Swift.String:Swift.String]? = nil
        if let hashesContainer = hashesContainer {
            hashesDecoded0 = [Swift.String:Swift.String]()
            for (key0, hashvalue0) in hashesContainer {
                if let hashvalue0 = hashvalue0 {
                    hashesDecoded0?[key0] = hashvalue0
                }
            }
        }
        hashes = hashesDecoded0
    }
}

extension CodeartifactClientTypes {
    /// Contains details about a package version asset.
    public struct AssetSummary: Swift.Equatable {
        /// The hashes of the asset.
        public var hashes: [Swift.String:Swift.String]?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The size of the asset.
        public var size: Swift.Int?

        public init(
            hashes: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            size: Swift.Int? = nil
        )
        {
            self.hashes = hashes
            self.name = name
            self.size = size
        }
    }

}

extension AssociateExternalConnectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let externalConnection = externalConnection else {
                let message = "Creating a URL Query Item failed. externalConnection is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            items.append(externalConnectionQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension AssociateExternalConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/external-connection"
    }
}

public struct AssociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the external connection to add to the repository. The following values are supported:
    ///
    /// * public:npmjs - for the npm public repository.
    ///
    /// * public:nuget-org - for the NuGet Gallery.
    ///
    /// * public:pypi - for the Python Package Index.
    ///
    /// * public:maven-central - for Maven Central.
    ///
    /// * public:maven-googleandroid - for the Google Android repository.
    ///
    /// * public:maven-gradleplugins - for the Gradle plugins repository.
    ///
    /// * public:maven-commonsware - for the CommonsWare Android repository.
    ///
    /// * public:maven-clojars - for the Clojars repository.
    /// This member is required.
    public var externalConnection: Swift.String?
    /// The name of the repository to which the external connection is added.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct AssociateExternalConnectionInputBody: Swift.Equatable {
}

extension AssociateExternalConnectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension AssociateExternalConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateExternalConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct AssociateExternalConnectionOutput: Swift.Equatable {
    /// Information about the connected repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct AssociateExternalConnectionOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension AssociateExternalConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum AssociateExternalConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because prerequisites are not met.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Amazon Web Services resource.
        public internal(set) var resourceType: CodeartifactClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CopyPackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOverwrite = self.allowOverwrite {
            try encodeContainer.encode(allowOverwrite, forKey: .allowOverwrite)
        }
        if let includeFromUpstream = self.includeFromUpstream {
            try encodeContainer.encode(includeFromUpstream, forKey: .includeFromUpstream)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageVersionRevisionMap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageVersionRevisionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversion0 in versions {
                try versionsContainer.encode(packageversion0)
            }
        }
    }
}

extension CopyPackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let sourceRepository = sourceRepository else {
                let message = "Creating a URL Query Item failed. sourceRepository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let sourceRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "source-repository".urlPercentEncoding(), value: Swift.String(sourceRepository).urlPercentEncoding())
            items.append(sourceRepositoryQueryItem)
            guard let destinationRepository = destinationRepository else {
                let message = "Creating a URL Query Item failed. destinationRepository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let destinationRepositoryQueryItem = ClientRuntime.URLQueryItem(name: "destination-repository".urlPercentEncoding(), value: Swift.String(destinationRepository).urlPercentEncoding())
            items.append(destinationRepositoryQueryItem)
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            return items
        }
    }
}

extension CopyPackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/copy"
    }
}

public struct CopyPackageVersionsInput: Swift.Equatable {
    /// Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the failedVersions field of the response with an ALREADY_EXISTS error code.
    public var allowOverwrite: Swift.Bool?
    /// The name of the repository into which package versions are copied.
    /// This member is required.
    public var destinationRepository: Swift.String?
    /// The name of the domain that contains the source and destination repositories.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package versions to be copied.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var includeFromUpstream: Swift.Bool?
    /// The namespace of the package versions to be copied. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId. The namespace is required when copying Maven package versions.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package that contains the versions to be copied.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions to be copied.
    /// This member is required.
    public var sourceRepository: Swift.String?
    /// A list of key-value pairs. The keys are package versions and the values are package version revisions. A CopyPackageVersion operation succeeds if the specified versions in the source repository match the specified package version revision. You must specify versions or versionRevisions. You cannot specify both.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// The versions of the package to be copied. You must specify versions or versionRevisions. You cannot specify both.
    public var versions: [Swift.String]?

    public init(
        allowOverwrite: Swift.Bool? = nil,
        destinationRepository: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        includeFromUpstream: Swift.Bool? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        sourceRepository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.allowOverwrite = allowOverwrite
        self.destinationRepository = destinationRepository
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.includeFromUpstream = includeFromUpstream
        self.namespace = namespace
        self.package = package
        self.sourceRepository = sourceRepository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct CopyPackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let allowOverwrite: Swift.Bool?
    let includeFromUpstream: Swift.Bool?
}

extension CopyPackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOverwrite
        case includeFromUpstream
        case versionRevisions
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let allowOverwriteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowOverwrite)
        allowOverwrite = allowOverwriteDecoded
        let includeFromUpstreamDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeFromUpstream)
        includeFromUpstream = includeFromUpstreamDecoded
    }
}

extension CopyPackageVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CopyPackageVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct CopyPackageVersionsOutput: Swift.Equatable {
    /// A map of package versions that failed to copy and their error codes. The possible error codes are in the PackageVersionError data type. They are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully copied to your repository.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init(
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct CopyPackageVersionsOutputBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension CopyPackageVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

enum CopyPackageVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            return items
        }
    }
}

extension CreateDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct CreateDomainInput: Swift.Equatable {
    /// The name of the domain to create. All domain names in an Amazon Web Services Region that are in the same Amazon Web Services account must be unique. The domain name is used as the prefix in DNS hostnames. Do not use sensitive information in a domain name because it is publicly discoverable.
    /// This member is required.
    public var domain: Swift.String?
    /// The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an encryptionKey, your IAM role must have kms:DescribeKey and kms:CreateGrant permissions on the encryption key that is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax) in the Key Management Service API Reference and [Key Management Service API Permissions Reference](https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html) in the Key Management Service Developer Guide. CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Key Management Service Developer Guide.
    public var encryptionKey: Swift.String?
    /// One or more tag key-value pairs for the domain.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init(
        domain: Swift.String? = nil,
        encryptionKey: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.domain = domain
        self.encryptionKey = encryptionKey
        self.tags = tags
    }
}

struct CreateDomainInputBody: Swift.Equatable {
    let encryptionKey: Swift.String?
    let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct CreateDomainOutput: Swift.Equatable {
    /// Contains information about the created domain after processing the request.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init(
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct CreateDomainOutputBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension CreateDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum CreateDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepository0 in upstreams {
                try upstreamsContainer.encode(upstreamrepository0)
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// A description of the created repository.
    public var description: Swift.String?
    /// The name of the domain that contains the created repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to create.
    /// This member is required.
    public var repository: Swift.String?
    /// One or more tag key-value pairs for the repository.
    public var tags: [CodeartifactClientTypes.Tag]?
    /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init(
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.tags = tags
        self.upstreams = upstreams
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let description: Swift.String?
    let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
    let tags: [CodeartifactClientTypes.Tag]?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case tags
        case upstreams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutput: Swift.Equatable {
    /// Information about the created repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension CreateRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum CreateRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            return items
        }
    }
}

extension DeleteDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct DeleteDomainInput: Swift.Equatable {
    /// The name of the domain to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DeleteDomainInputBody: Swift.Equatable {
}

extension DeleteDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DeleteDomainOutput: Swift.Equatable {
    /// Contains information about the deleted domain after processing the request.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init(
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DeleteDomainOutputBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension DeleteDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum DeleteDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDomainPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            if let policyRevision = policyRevision {
                let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
                items.append(policyRevisionQueryItem)
            }
            return items
        }
    }
}

extension DeleteDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct DeleteDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain associated with the resource policy to be deleted.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The current revision of the resource policy to be deleted. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
    public var policyRevision: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
    }
}

struct DeleteDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDomainPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDomainPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteDomainPermissionsPolicyOutput: Swift.Equatable {
    /// Information about the deleted resource policy after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteDomainPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteDomainPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DeleteDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DeletePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package"
    }
}

public struct DeletePackageInput: Swift.Equatable {
    /// The name of the domain that contains the package to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the requested package to delete.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package to delete. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId. The namespace is required when deleting Maven package versions.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain corresponding components, packages of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package to delete.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package to delete.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
    }
}

struct DeletePackageInputBody: Swift.Equatable {
}

extension DeletePackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletedPackage = output.deletedPackage
        } else {
            self.deletedPackage = nil
        }
    }
}

public struct DeletePackageOutput: Swift.Equatable {
    /// Details about a package, including its format, namespace, and name.
    public var deletedPackage: CodeartifactClientTypes.PackageSummary?

    public init(
        deletedPackage: CodeartifactClientTypes.PackageSummary? = nil
    )
    {
        self.deletedPackage = deletedPackage
    }
}

struct DeletePackageOutputBody: Swift.Equatable {
    let deletedPackage: CodeartifactClientTypes.PackageSummary?
}

extension DeletePackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedPackage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedPackageDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageSummary.self, forKey: .deletedPackage)
        deletedPackage = deletedPackageDecoded
    }
}

enum DeletePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = self.expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversion0 in versions {
                try versionsContainer.encode(packageversion0)
            }
        }
    }
}

extension DeletePackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DeletePackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/delete"
    }
}

public struct DeletePackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the package to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The expected status of the package version to delete.
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// The format of the package versions to delete.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package versions to be deleted. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId. The namespace is required when deleting Maven package versions.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package with the versions to delete.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions to delete.
    /// This member is required.
    public var repository: Swift.String?
    /// An array of strings that specify the versions of the package to delete.
    /// This member is required.
    public var versions: [Swift.String]?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versions = versions
    }
}

struct DeletePackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DeletePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DeletePackageVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePackageVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DeletePackageVersionsOutput: Swift.Equatable {
    /// A PackageVersionError object that contains a map of errors codes for the deleted package that failed. The possible error codes are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully deleted. The status of every successful version will be Deleted.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init(
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DeletePackageVersionsOutputBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DeletePackageVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

enum DeletePackageVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// The name of the domain that contains the repository to delete.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
}

extension DeleteRepositoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutput: Swift.Equatable {
    /// Information about the deleted repository after processing the request.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DeleteRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum DeleteRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            if let policyRevision = policyRevision {
                let policyRevisionQueryItem = ClientRuntime.URLQueryItem(name: "policy-revision".urlPercentEncoding(), value: Swift.String(policyRevision).urlPercentEncoding())
                items.append(policyRevisionQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DeleteRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policies"
    }
}

public struct DeleteRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain that contains the repository associated with the resource policy to be deleted.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The revision of the repository's resource policy to be deleted. This revision is used for optimistic locking, which prevents others from accidentally overwriting your changes to the repository's resource policy.
    public var policyRevision: Swift.String?
    /// The name of the repository that is associated with the resource policy to be deleted
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct DeleteRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension DeleteRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRepositoryPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DeleteRepositoryPermissionsPolicyOutput: Swift.Equatable {
    /// Information about the deleted policy after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct DeleteRepositoryPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension DeleteRepositoryPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum DeleteRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            return items
        }
    }
}

extension DescribeDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain"
    }
}

public struct DescribeDomainInput: Swift.Equatable {
    /// A string that specifies the name of the requested domain.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct DescribeDomainInputBody: Swift.Equatable {
}

extension DescribeDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.domain = output.domain
        } else {
            self.domain = nil
        }
    }
}

public struct DescribeDomainOutput: Swift.Equatable {
    /// Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you add one or more repositories.
    public var domain: CodeartifactClientTypes.DomainDescription?

    public init(
        domain: CodeartifactClientTypes.DomainDescription? = nil
    )
    {
        self.domain = domain
    }
}

struct DescribeDomainOutputBody: Swift.Equatable {
    let domain: CodeartifactClientTypes.DomainDescription?
}

extension DescribeDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainDescription.self, forKey: .domain)
        domain = domainDecoded
    }
}

enum DescribeDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePackageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DescribePackageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package"
    }
}

public struct DescribePackageInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the requested package.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the requested package. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId. The namespace is required when requesting Maven packages.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the requested package.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the requested package.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
    }
}

struct DescribePackageInputBody: Swift.Equatable {
}

extension DescribePackageInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePackageOutputBody = try responseDecoder.decode(responseBody: data)
            self.package = output.package
        } else {
            self.package = nil
        }
    }
}

public struct DescribePackageOutput: Swift.Equatable {
    /// A [PackageDescription](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDescription.html) object that contains information about the requested package.
    /// This member is required.
    public var package: CodeartifactClientTypes.PackageDescription?

    public init(
        package: CodeartifactClientTypes.PackageDescription? = nil
    )
    {
        self.package = package
    }
}

struct DescribePackageOutputBody: Swift.Equatable {
    let package: CodeartifactClientTypes.PackageDescription?
}

extension DescribePackageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case package
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageDescription.self, forKey: .package)
        package = packageDecoded
    }
}

enum DescribePackageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DescribePackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version"
    }
}

public struct DescribePackageVersionInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package version.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the requested package version.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the requested package version. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the requested package version.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the package version.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct DescribePackageVersionInputBody: Swift.Equatable {
}

extension DescribePackageVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePackageVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.packageVersion = output.packageVersion
        } else {
            self.packageVersion = nil
        }
    }
}

public struct DescribePackageVersionOutput: Swift.Equatable {
    /// A [PackageVersionDescription](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionDescription.html) object that contains information about the requested package version.
    /// This member is required.
    public var packageVersion: CodeartifactClientTypes.PackageVersionDescription?

    public init(
        packageVersion: CodeartifactClientTypes.PackageVersionDescription? = nil
    )
    {
        self.packageVersion = packageVersion
    }
}

struct DescribePackageVersionOutputBody: Swift.Equatable {
    let packageVersion: CodeartifactClientTypes.PackageVersionDescription?
}

extension DescribePackageVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionDescription.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

enum DescribePackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DescribeRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct DescribeRepositoryInput: Swift.Equatable {
    /// The name of the domain that contains the repository to describe.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A string that specifies the name of the requested repository.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct DescribeRepositoryInputBody: Swift.Equatable {
}

extension DescribeRepositoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DescribeRepositoryOutput: Swift.Equatable {
    /// A RepositoryDescription object that contains the requested repository information.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DescribeRepositoryOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DescribeRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum DescribeRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateExternalConnectionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let externalConnection = externalConnection else {
                let message = "Creating a URL Query Item failed. externalConnection is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let externalConnectionQueryItem = ClientRuntime.URLQueryItem(name: "external-connection".urlPercentEncoding(), value: Swift.String(externalConnection).urlPercentEncoding())
            items.append(externalConnectionQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DisassociateExternalConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/external-connection"
    }
}

public struct DisassociateExternalConnectionInput: Swift.Equatable {
    /// The name of the domain that contains the repository from which to remove the external repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the external connection to be removed from the repository.
    /// This member is required.
    public var externalConnection: Swift.String?
    /// The name of the repository from which the external connection will be removed.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        externalConnection: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.externalConnection = externalConnection
        self.repository = repository
    }
}

struct DisassociateExternalConnectionInputBody: Swift.Equatable {
}

extension DisassociateExternalConnectionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateExternalConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateExternalConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DisassociateExternalConnectionOutput: Swift.Equatable {
    /// The repository associated with the removed external connection.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct DisassociateExternalConnectionOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension DisassociateExternalConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum DisassociateExternalConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisposePackageVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = self.expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageVersionRevisionMap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageVersionRevisionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversion0 in versions {
                try versionsContainer.encode(packageversion0)
            }
        }
    }
}

extension DisposePackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension DisposePackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/dispose"
    }
}

public struct DisposePackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the repository you want to dispose.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The expected status of the package version to dispose.
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A format that specifies the type of package versions you want to dispose.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package versions to be disposed. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package with the versions you want to dispose.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package versions you want to dispose.
    /// This member is required.
    public var repository: Swift.String?
    /// The revisions of the package versions you want to dispose.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// The versions of the package you want to dispose.
    /// This member is required.
    public var versions: [Swift.String]?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct DisposePackageVersionsInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension DisposePackageVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case versionRevisions
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
    }
}

extension DisposePackageVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisposePackageVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct DisposePackageVersionsOutput: Swift.Equatable {
    /// A PackageVersionError object that contains a map of errors codes for the disposed package versions that failed. The possible error codes are:
    ///
    /// * ALREADY_EXISTS
    ///
    /// * MISMATCHED_REVISION
    ///
    /// * MISMATCHED_STATUS
    ///
    /// * NOT_ALLOWED
    ///
    /// * NOT_FOUND
    ///
    /// * SKIPPED
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of the package versions that were successfully disposed.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init(
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct DisposePackageVersionsOutputBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension DisposePackageVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

enum DisposePackageVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeartifactClientTypes.DomainDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetSizeBytes
        case createdTime
        case encryptionKey
        case name
        case owner
        case repositoryCount
        case s3BucketArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if assetSizeBytes != 0 {
            try encodeContainer.encode(assetSizeBytes, forKey: .assetSizeBytes)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if repositoryCount != 0 {
            try encodeContainer.encode(repositoryCount, forKey: .repositoryCount)
        }
        if let s3BucketArn = self.s3BucketArn {
            try encodeContainer.encode(s3BucketArn, forKey: .s3BucketArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
        let repositoryCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .repositoryCount) ?? 0
        repositoryCount = repositoryCountDecoded
        let assetSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .assetSizeBytes) ?? 0
        assetSizeBytes = assetSizeBytesDecoded
        let s3BucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketArn)
        s3BucketArn = s3BucketArnDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about a domain. A domain is a container for repositories. When you create a domain, it is empty until you add one or more repositories.
    public struct DomainDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the domain.
        public var arn: Swift.String?
        /// The total size of all assets in the domain.
        public var assetSizeBytes: Swift.Int
        /// A timestamp that represents the date and time the domain was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of an Key Management Service (KMS) key associated with a domain.
        public var encryptionKey: Swift.String?
        /// The name of the domain.
        public var name: Swift.String?
        /// The Amazon Web Services account ID that owns the domain.
        public var owner: Swift.String?
        /// The number of repositories in the domain.
        public var repositoryCount: Swift.Int
        /// The Amazon Resource Name (ARN) of the Amazon S3 bucket that is used to store package assets in the domain.
        public var s3BucketArn: Swift.String?
        /// The current status of a domain.
        public var status: CodeartifactClientTypes.DomainStatus?

        public init(
            arn: Swift.String? = nil,
            assetSizeBytes: Swift.Int = 0,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            repositoryCount: Swift.Int = 0,
            s3BucketArn: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.assetSizeBytes = assetSizeBytes
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.repositoryCount = repositoryCount
            self.s3BucketArn = s3BucketArn
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.DomainEntryPoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalConnectionName
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalConnectionName = self.externalConnectionName {
            try encodeContainer.encode(externalConnectionName, forKey: .externalConnectionName)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let externalConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalConnectionName)
        externalConnectionName = externalConnectionNameDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about how a package originally entered the CodeArtifact domain. For packages published directly to CodeArtifact, the entry point is the repository it was published to. For packages ingested from an external repository, the entry point is the external connection that it was ingested from. An external connection is a CodeArtifact repository that is connected to an external repository such as the npm registry or NuGet gallery.
    public struct DomainEntryPoint: Swift.Equatable {
        /// The name of the external connection that a package was ingested from.
        public var externalConnectionName: Swift.String?
        /// The name of the repository that a package was originally published to.
        public var repositoryName: Swift.String?

        public init(
            externalConnectionName: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.externalConnectionName = externalConnectionName
            self.repositoryName = repositoryName
        }
    }

}

extension CodeartifactClientTypes {
    public enum DomainStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case sdkUnknown(Swift.String)

        public static var allCases: [DomainStatus] {
            return [
                .active,
                .deleted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .deleted: return "Deleted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DomainStatus(rawValue: rawValue) ?? DomainStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.DomainSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdTime
        case encryptionKey
        case name
        case owner
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let encryptionKey = self.encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about a domain, including its name, Amazon Resource Name (ARN), and status. The [ListDomains](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListDomains.html) operation returns a list of DomainSummary objects.
    public struct DomainSummary: Swift.Equatable {
        /// The ARN of the domain.
        public var arn: Swift.String?
        /// A timestamp that contains the date and time the domain was created.
        public var createdTime: ClientRuntime.Date?
        /// The key used to encrypt the domain.
        public var encryptionKey: Swift.String?
        /// The name of the domain.
        public var name: Swift.String?
        /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
        public var owner: Swift.String?
        /// A string that contains the status of the domain.
        public var status: CodeartifactClientTypes.DomainStatus?

        public init(
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            encryptionKey: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            status: CodeartifactClientTypes.DomainStatus? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.encryptionKey = encryptionKey
            self.name = name
            self.owner = owner
            self.status = status
        }
    }

}

extension CodeartifactClientTypes {
    public enum ExternalConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case sdkUnknown(Swift.String)

        public static var allCases: [ExternalConnectionStatus] {
            return [
                .available,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "Available"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExternalConnectionStatus(rawValue: rawValue) ?? ExternalConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let durationSeconds = durationSeconds {
                let durationSecondsQueryItem = ClientRuntime.URLQueryItem(name: "duration".urlPercentEncoding(), value: Swift.String(durationSeconds).urlPercentEncoding())
                items.append(durationSecondsQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            return items
        }
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/authorization-token"
    }
}

public struct GetAuthorizationTokenInput: Swift.Equatable {
    /// The name of the domain that is in scope for the generated authorization token.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The time, in seconds, that the generated authorization token is valid. Valid values are 0 and any number between 900 (15 minutes) and 43200 (12 hours). A value of 0 will set the expiration of the authorization token to the same expiration of the user's role's temporary credentials.
    public var durationSeconds: Swift.Int?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        durationSeconds: Swift.Int? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.durationSeconds = durationSeconds
    }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAuthorizationTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizationTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizationToken = output.authorizationToken
            self.expiration = output.expiration
        } else {
            self.authorizationToken = nil
            self.expiration = nil
        }
    }
}

public struct GetAuthorizationTokenOutput: Swift.Equatable {
    /// The returned authentication token.
    public var authorizationToken: Swift.String?
    /// A timestamp that specifies the date and time the authorization token expires.
    public var expiration: ClientRuntime.Date?

    public init(
        authorizationToken: Swift.String? = nil,
        expiration: ClientRuntime.Date? = nil
    )
    {
        self.authorizationToken = authorizationToken
        self.expiration = expiration
    }
}

struct GetAuthorizationTokenOutputBody: Swift.Equatable {
    let authorizationToken: Swift.String?
    let expiration: ClientRuntime.Date?
}

extension GetAuthorizationTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expirationDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiration)
        expiration = expirationDecoded
    }
}

enum GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDomainPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            return items
        }
    }
}

extension GetDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct GetDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain to which the resource policy is attached.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
    }
}

struct GetDomainPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetDomainPermissionsPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDomainPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDomainPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetDomainPermissionsPolicyOutput: Swift.Equatable {
    /// The returned resource policy.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetDomainPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetDomainPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPackageVersionAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            if let packageVersionRevision = packageVersionRevision {
                let packageVersionRevisionQueryItem = ClientRuntime.URLQueryItem(name: "revision".urlPercentEncoding(), value: Swift.String(packageVersionRevision).urlPercentEncoding())
                items.append(packageVersionRevisionQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            guard let asset = asset else {
                let message = "Creating a URL Query Item failed. asset is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assetQueryItem = ClientRuntime.URLQueryItem(name: "asset".urlPercentEncoding(), value: Swift.String(asset).urlPercentEncoding())
            items.append(assetQueryItem)
            return items
        }
    }
}

extension GetPackageVersionAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/asset"
    }
}

public struct GetPackageVersionAssetInput: Swift.Equatable {
    /// The name of the requested asset.
    /// This member is required.
    public var asset: Swift.String?
    /// The name of the domain that contains the repository that contains the package version with the requested asset.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package version with the requested asset file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version with the requested asset file. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package that contains the requested asset.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the package version revision that contains the requested asset.
    public var packageVersionRevision: Swift.String?
    /// The repository that contains the package version with the requested asset.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        asset: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.asset = asset
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
        self.repository = repository
    }
}

struct GetPackageVersionAssetInputBody: Swift.Equatable {
}

extension GetPackageVersionAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let assetNameHeaderValue = httpResponse.headers.value(for: "X-AssetName") {
            self.assetName = assetNameHeaderValue
        } else {
            self.assetName = nil
        }
        if let packageVersionHeaderValue = httpResponse.headers.value(for: "X-PackageVersion") {
            self.packageVersion = packageVersionHeaderValue
        } else {
            self.packageVersion = nil
        }
        if let packageVersionRevisionHeaderValue = httpResponse.headers.value(for: "X-PackageVersionRevision") {
            self.packageVersionRevision = packageVersionRevisionHeaderValue
        } else {
            self.packageVersionRevision = nil
        }
        switch httpResponse.body {
        case .data(let data):
            self.asset = .data(data)
        case .stream(let stream):
            self.asset = .stream(stream)
        case .none:
            self.asset = nil
        }
    }
}

public struct GetPackageVersionAssetOutput: Swift.Equatable {
    /// The binary file, or asset, that is downloaded.
    public var asset: ClientRuntime.ByteStream?
    /// The name of the asset that is downloaded.
    public var assetName: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    public var packageVersion: Swift.String?
    /// The name of the package version revision that contains the downloaded asset.
    public var packageVersionRevision: Swift.String?

    public init(
        asset: ClientRuntime.ByteStream? = nil,
        assetName: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        packageVersionRevision: Swift.String? = nil
    )
    {
        self.asset = asset
        self.assetName = assetName
        self.packageVersion = packageVersion
        self.packageVersionRevision = packageVersionRevision
    }
}

struct GetPackageVersionAssetOutputBody: Swift.Equatable {
    let asset: ClientRuntime.ByteStream?
}

extension GetPackageVersionAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asset
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .asset)
        asset = assetDecoded
    }
}

enum GetPackageVersionAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPackageVersionReadmeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension GetPackageVersionReadmeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/readme"
    }
}

public struct GetPackageVersionReadmeInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package version with the requested readme file.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package version with the requested readme file.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package version that contains the requested readme file.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The repository that contains the package with the requested readme file.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct GetPackageVersionReadmeInputBody: Swift.Equatable {
}

extension GetPackageVersionReadmeInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPackageVersionReadmeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPackageVersionReadmeOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.namespace = output.namespace
            self.package = output.package
            self.readme = output.readme
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.format = nil
            self.namespace = nil
            self.package = nil
            self.readme = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct GetPackageVersionReadmeOutput: Swift.Equatable {
    /// The format of the package with the requested readme file.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version with the requested readme file. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    public var namespace: Swift.String?
    /// The name of the package that contains the returned readme file.
    public var package: Swift.String?
    /// The text of the returned readme file.
    public var readme: Swift.String?
    /// The version of the package with the requested readme file.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init(
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        readme: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.format = format
        self.namespace = namespace
        self.package = package
        self.readme = readme
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct GetPackageVersionReadmeOutputBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let readme: Swift.String?
}

extension GetPackageVersionReadmeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case package
        case readme
        case version
        case versionRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let readmeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readme)
        readme = readmeDecoded
    }
}

enum GetPackageVersionReadmeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension GetRepositoryEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/endpoint"
    }
}

public struct GetRepositoryEndpointInput: Swift.Equatable {
    /// The name of the domain that contains the repository.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// Returns which endpoint of a repository to return. A repository has one endpoint for each package format.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The name of the repository.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.repository = repository
    }
}

struct GetRepositoryEndpointInputBody: Swift.Equatable {
}

extension GetRepositoryEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.repositoryEndpoint = output.repositoryEndpoint
        } else {
            self.repositoryEndpoint = nil
        }
    }
}

public struct GetRepositoryEndpointOutput: Swift.Equatable {
    /// A string that specifies the URL of the returned endpoint.
    public var repositoryEndpoint: Swift.String?

    public init(
        repositoryEndpoint: Swift.String? = nil
    )
    {
        self.repositoryEndpoint = repositoryEndpoint
    }
}

struct GetRepositoryEndpointOutputBody: Swift.Equatable {
    let repositoryEndpoint: Swift.String?
}

extension GetRepositoryEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryEndpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryEndpoint)
        repositoryEndpoint = repositoryEndpointDecoded
    }
}

enum GetRepositoryEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension GetRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policy"
    }
}

public struct GetRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain containing the repository whose associated resource policy is to be retrieved.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository whose associated resource policy is to be retrieved.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
    }
}

struct GetRepositoryPermissionsPolicyInputBody: Swift.Equatable {
}

extension GetRepositoryPermissionsPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRepositoryPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct GetRepositoryPermissionsPolicyOutput: Swift.Equatable {
    /// The returned resource policy.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct GetRepositoryPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension GetRepositoryPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeartifactClientTypes {
    public enum HashAlgorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case md5
        case sha1
        case sha256
        case sha512
        case sdkUnknown(Swift.String)

        public static var allCases: [HashAlgorithm] {
            return [
                .md5,
                .sha1,
                .sha256,
                .sha512,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .md5: return "MD5"
            case .sha1: return "SHA-1"
            case .sha256: return "SHA-256"
            case .sha512: return "SHA-512"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HashAlgorithm(rawValue: rawValue) ?? HashAlgorithm.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because of an error that occurred inside CodeArtifact.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeartifactClientTypes.LicenseInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details of the license data.
    public struct LicenseInfo: Swift.Equatable {
        /// Name of the license.
        public var name: Swift.String?
        /// The URL for license data.
        public var url: Swift.String?

        public init(
            name: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.name = name
            self.url = url
        }
    }

}

extension ListDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domains"
    }
}

public struct ListDomainsInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDomainsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDomainsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDomainsOutputBody = try responseDecoder.decode(responseBody: data)
            self.domains = output.domains
            self.nextToken = output.nextToken
        } else {
            self.domains = nil
            self.nextToken = nil
        }
    }
}

public struct ListDomainsOutput: Swift.Equatable {
    /// The returned list of [DomainSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainSummary.html) objects.
    public var domains: [CodeartifactClientTypes.DomainSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        domains: [CodeartifactClientTypes.DomainSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.domains = domains
        self.nextToken = nextToken
    }
}

struct ListDomainsOutputBody: Swift.Equatable {
    let domains: [CodeartifactClientTypes.DomainSummary]?
    let nextToken: Swift.String?
}

extension ListDomainsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domains
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.DomainSummary?].self, forKey: .domains)
        var domainsDecoded0:[CodeartifactClientTypes.DomainSummary]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [CodeartifactClientTypes.DomainSummary]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDomainsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackageVersionAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension ListPackageVersionAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/assets"
    }
}

public struct ListPackageVersionAssetsInput: Swift.Equatable {
    /// The name of the domain that contains the repository associated with the package version assets.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package that contains the requested package version assets.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the requested package version assets.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the package that contains the requested package version assets.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionAssetsInputBody: Swift.Equatable {
}

extension ListPackageVersionAssetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackageVersionAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assets = output.assets
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.assets = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionAssetsOutput: Swift.Equatable {
    /// The returned list of [AssetSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html) objects.
    public var assets: [CodeartifactClientTypes.AssetSummary]?
    /// The format of the package that contains the requested package version assets.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version that contains the requested package version assets. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    public var namespace: Swift.String?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the requested package version assets.
    public var package: Swift.String?
    /// The version of the package associated with the requested assets.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init(
        assets: [CodeartifactClientTypes.AssetSummary]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.assets = assets
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionAssetsOutputBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let nextToken: Swift.String?
    let assets: [CodeartifactClientTypes.AssetSummary]?
}

extension ListPackageVersionAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assets
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let assetsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.AssetSummary?].self, forKey: .assets)
        var assetsDecoded0:[CodeartifactClientTypes.AssetSummary]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [CodeartifactClientTypes.AssetSummary]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
    }
}

enum ListPackageVersionAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackageVersionDependenciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension ListPackageVersionDependenciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/dependencies"
    }
}

public struct ListPackageVersionDependenciesInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the requested package version dependencies.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package with the requested dependencies.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version with the requested dependencies. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package versions' package.
    /// This member is required.
    public var package: Swift.String?
    /// A string that contains the package version (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that contains the requested package version.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
    }
}

struct ListPackageVersionDependenciesInputBody: Swift.Equatable {
}

extension ListPackageVersionDependenciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionDependenciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackageVersionDependenciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.dependencies = output.dependencies
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.dependencies = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct ListPackageVersionDependenciesOutput: Swift.Equatable {
    /// The returned list of [PackageDependency](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageDependency.html) objects.
    public var dependencies: [CodeartifactClientTypes.PackageDependency]?
    /// A format that specifies the type of the package that contains the returned dependencies.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version that contains the returned dependencies. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package that contains the returned package versions dependencies.
    public var package: Swift.String?
    /// The version of the package that is specified in the request.
    public var version: Swift.String?
    /// The current revision associated with the package version.
    public var versionRevision: Swift.String?

    public init(
        dependencies: [CodeartifactClientTypes.PackageDependency]? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.dependencies = dependencies
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct ListPackageVersionDependenciesOutputBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let nextToken: Swift.String?
    let dependencies: [CodeartifactClientTypes.PackageDependency]?
}

extension ListPackageVersionDependenciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencies
        case format
        case namespace
        case nextToken
        case package
        case version
        case versionRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dependenciesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageDependency?].self, forKey: .dependencies)
        var dependenciesDecoded0:[CodeartifactClientTypes.PackageDependency]? = nil
        if let dependenciesContainer = dependenciesContainer {
            dependenciesDecoded0 = [CodeartifactClientTypes.PackageDependency]()
            for structure0 in dependenciesContainer {
                if let structure0 = structure0 {
                    dependenciesDecoded0?.append(structure0)
                }
            }
        }
        dependencies = dependenciesDecoded0
    }
}

enum ListPackageVersionDependenciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackageVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let originType = originType {
                let originTypeQueryItem = ClientRuntime.URLQueryItem(name: "originType".urlPercentEncoding(), value: Swift.String(originType.rawValue).urlPercentEncoding())
                items.append(originTypeQueryItem)
            }
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            if let sortBy = sortBy {
                let sortByQueryItem = ClientRuntime.URLQueryItem(name: "sortBy".urlPercentEncoding(), value: Swift.String(sortBy.rawValue).urlPercentEncoding())
                items.append(sortByQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListPackageVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions"
    }
}

public struct ListPackageVersionsInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the requested package versions.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format of the package versions you want to list.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The originType used to filter package versions. Only package versions with the provided originType will be returned.
    public var originType: CodeartifactClientTypes.PackageVersionOriginType?
    /// The name of the package for which you want to request package versions.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the requested package versions.
    /// This member is required.
    public var repository: Swift.String?
    /// How to sort the requested list of package versions.
    public var sortBy: CodeartifactClientTypes.PackageVersionSortType?
    /// A string that filters the requested package versions by status.
    public var status: CodeartifactClientTypes.PackageVersionStatus?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        originType: CodeartifactClientTypes.PackageVersionOriginType? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        sortBy: CodeartifactClientTypes.PackageVersionSortType? = nil,
        status: CodeartifactClientTypes.PackageVersionStatus? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.originType = originType
        self.package = package
        self.repository = repository
        self.sortBy = sortBy
        self.status = status
    }
}

struct ListPackageVersionsInputBody: Swift.Equatable {
}

extension ListPackageVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackageVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackageVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.defaultDisplayVersion = output.defaultDisplayVersion
            self.format = output.format
            self.namespace = output.namespace
            self.nextToken = output.nextToken
            self.package = output.package
            self.versions = output.versions
        } else {
            self.defaultDisplayVersion = nil
            self.format = nil
            self.namespace = nil
            self.nextToken = nil
            self.package = nil
            self.versions = nil
        }
    }
}

public struct ListPackageVersionsOutput: Swift.Equatable {
    /// The default package version to display. This depends on the package format:
    ///
    /// * For Maven and PyPI packages, it's the most recently published package version.
    ///
    /// * For npm packages, it's the version referenced by the latest tag. If the latest tag is not set, it's the most recently published package version.
    public var defaultDisplayVersion: Swift.String?
    /// A format of the package.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package that contains the requested package versions. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
    public var namespace: Swift.String?
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The name of the package.
    public var package: Swift.String?
    /// The returned list of [PackageVersionSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionSummary.html) objects.
    public var versions: [CodeartifactClientTypes.PackageVersionSummary]?

    public init(
        defaultDisplayVersion: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        package: Swift.String? = nil,
        versions: [CodeartifactClientTypes.PackageVersionSummary]? = nil
    )
    {
        self.defaultDisplayVersion = defaultDisplayVersion
        self.format = format
        self.namespace = namespace
        self.nextToken = nextToken
        self.package = package
        self.versions = versions
    }
}

struct ListPackageVersionsOutputBody: Swift.Equatable {
    let defaultDisplayVersion: Swift.String?
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let versions: [CodeartifactClientTypes.PackageVersionSummary]?
    let nextToken: Swift.String?
}

extension ListPackageVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultDisplayVersion
        case format
        case namespace
        case nextToken
        case package
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultDisplayVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultDisplayVersion)
        defaultDisplayVersion = defaultDisplayVersionDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageVersionSummary?].self, forKey: .versions)
        var versionsDecoded0:[CodeartifactClientTypes.PackageVersionSummary]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [CodeartifactClientTypes.PackageVersionSummary]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackageVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPackagesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let upstream = upstream {
                let upstreamQueryItem = ClientRuntime.URLQueryItem(name: "upstream".urlPercentEncoding(), value: Swift.String(upstream.rawValue).urlPercentEncoding())
                items.append(upstreamQueryItem)
            }
            if let packagePrefix = packagePrefix {
                let packagePrefixQueryItem = ClientRuntime.URLQueryItem(name: "package-prefix".urlPercentEncoding(), value: Swift.String(packagePrefix).urlPercentEncoding())
                items.append(packagePrefixQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let publish = publish {
                let publishQueryItem = ClientRuntime.URLQueryItem(name: "publish".urlPercentEncoding(), value: Swift.String(publish.rawValue).urlPercentEncoding())
                items.append(publishQueryItem)
            }
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            if let format = format {
                let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
                items.append(formatQueryItem)
            }
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension ListPackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/packages"
    }
}

public struct ListPackagesInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the requested packages.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The format used to filter requested packages. Only packages from the provided format will be returned.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The namespace prefix used to filter requested packages. Only packages with a namespace that starts with the provided string value are returned. Note that although this option is called --namespace and not --namespace-prefix, it has prefix-matching behavior. Each package format uses namespace as follows:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter requested packages. Only packages with names that start with packagePrefix are returned.
    public var packagePrefix: Swift.String?
    /// The value of the Publish package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see [PackageOriginRestrictions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html).
    public var publish: CodeartifactClientTypes.AllowPublish?
    /// The name of the repository that contains the requested packages.
    /// This member is required.
    public var repository: Swift.String?
    /// The value of the Upstream package origin control restriction used to filter requested packages. Only packages with the provided restriction are returned. For more information, see [PackageOriginRestrictions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html).
    public var upstream: CodeartifactClientTypes.AllowUpstream?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        maxResults: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        packagePrefix: Swift.String? = nil,
        publish: CodeartifactClientTypes.AllowPublish? = nil,
        repository: Swift.String? = nil,
        upstream: CodeartifactClientTypes.AllowUpstream? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
        self.packagePrefix = packagePrefix
        self.publish = publish
        self.repository = repository
        self.upstream = upstream
    }
}

struct ListPackagesInputBody: Swift.Equatable {
}

extension ListPackagesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPackagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPackagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.packages = output.packages
        } else {
            self.nextToken = nil
            self.packages = nil
        }
    }
}

public struct ListPackagesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The list of returned [PackageSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageSummary.html) objects.
    public var packages: [CodeartifactClientTypes.PackageSummary]?

    public init(
        nextToken: Swift.String? = nil,
        packages: [CodeartifactClientTypes.PackageSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.packages = packages
    }
}

struct ListPackagesOutputBody: Swift.Equatable {
    let packages: [CodeartifactClientTypes.PackageSummary]?
    let nextToken: Swift.String?
}

extension ListPackagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case packages
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.PackageSummary?].self, forKey: .packages)
        var packagesDecoded0:[CodeartifactClientTypes.PackageSummary]? = nil
        if let packagesContainer = packagesContainer {
            packagesDecoded0 = [CodeartifactClientTypes.PackageSummary]()
            for structure0 in packagesContainer {
                if let structure0 = structure0 {
                    packagesDecoded0?.append(structure0)
                }
            }
        }
        packages = packagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPackagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositoriesInDomainInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let repositoryPrefix = repositoryPrefix {
                let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
                items.append(repositoryPrefixQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            if let administratorAccount = administratorAccount {
                let administratorAccountQueryItem = ClientRuntime.URLQueryItem(name: "administrator-account".urlPercentEncoding(), value: Swift.String(administratorAccount).urlPercentEncoding())
                items.append(administratorAccountQueryItem)
            }
            return items
        }
    }
}

extension ListRepositoriesInDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/repositories"
    }
}

public struct ListRepositoriesInDomainInput: Swift.Equatable {
    /// Filter the list of repositories to only include those that are managed by the Amazon Web Services account ID.
    public var administratorAccount: Swift.String?
    /// The name of the domain that contains the returned list of repositories.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
    public var repositoryPrefix: Swift.String?

    public init(
        administratorAccount: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.administratorAccount = administratorAccount
        self.domain = domain
        self.domainOwner = domainOwner
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInDomainInputBody: Swift.Equatable {
}

extension ListRepositoriesInDomainInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesInDomainOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositoriesInDomainOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesInDomainOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of repositories.
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesInDomainOutputBody: Swift.Equatable {
    let repositories: [CodeartifactClientTypes.RepositorySummary]?
    let nextToken: Swift.String?
}

extension ListRepositoriesInDomainOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRepositoriesInDomainOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRepositoriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let repositoryPrefix = repositoryPrefix {
                let repositoryPrefixQueryItem = ClientRuntime.URLQueryItem(name: "repository-prefix".urlPercentEncoding(), value: Swift.String(repositoryPrefix).urlPercentEncoding())
                items.append(repositoryPrefixQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repositories"
    }
}

public struct ListRepositoriesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A prefix used to filter returned repositories. Only repositories with names that start with repositoryPrefix are returned.
    public var repositoryPrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        repositoryPrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.repositoryPrefix = repositoryPrefix
    }
}

struct ListRepositoriesInputBody: Swift.Equatable {
}

extension ListRepositoriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct ListRepositoriesOutput: Swift.Equatable {
    /// If there are additional results, this is the token for the next set of results.
    public var nextToken: Swift.String?
    /// The returned list of [RepositorySummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_RepositorySummary.html) objects.
    public var repositories: [CodeartifactClientTypes.RepositorySummary]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [CodeartifactClientTypes.RepositorySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct ListRepositoriesOutputBody: Swift.Equatable {
    let repositories: [CodeartifactClientTypes.RepositorySummary]?
    let nextToken: Swift.String?
}

extension ListRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositorySummary?].self, forKey: .repositories)
        var repositoriesDecoded0:[CodeartifactClientTypes.RepositorySummary]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [CodeartifactClientTypes.RepositorySummary]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init(
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [CodeartifactClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeartifactClientTypes.PackageDependency: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependencyType
        case namespace
        case package
        case versionRequirement
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependencyType = self.dependencyType {
            try encodeContainer.encode(dependencyType, forKey: .dependencyType)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let package = self.package {
            try encodeContainer.encode(package, forKey: .package)
        }
        if let versionRequirement = self.versionRequirement {
            try encodeContainer.encode(versionRequirement, forKey: .versionRequirement)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let dependencyTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dependencyType)
        dependencyType = dependencyTypeDecoded
        let versionRequirementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRequirement)
        versionRequirement = versionRequirementDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package dependency.
    public struct PackageDependency: Swift.Equatable {
        /// The type of a package dependency. The possible values depend on the package type.
        ///
        /// * npm: regular, dev, peer, optional
        ///
        /// * maven: optional, parent, compile, runtime, test, system, provided. Note that parent is not a regular Maven dependency type; instead this is extracted from the  element if one is defined in the package version's POM file.
        ///
        /// * nuget: The dependencyType field is never set for NuGet packages.
        ///
        /// * pypi: Requires-Dist
        public var dependencyType: Swift.String?
        /// The namespace of the package that this package depends on. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
        public var namespace: Swift.String?
        /// The name of the package that this package depends on.
        public var package: Swift.String?
        /// The required version, or version range, of the package that this package depends on. The version format is specific to the package type. For example, the following are possible valid required versions: 1.2.3, ^2.3.4, or 4.x.
        public var versionRequirement: Swift.String?

        public init(
            dependencyType: Swift.String? = nil,
            namespace: Swift.String? = nil,
            package: Swift.String? = nil,
            versionRequirement: Swift.String? = nil
        )
        {
            self.dependencyType = dependencyType
            self.namespace = namespace
            self.package = package
            self.versionRequirement = versionRequirement
        }
    }

}

extension CodeartifactClientTypes.PackageDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case name
        case namespace
        case originConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let originConfiguration = self.originConfiguration {
            try encodeContainer.encode(originConfiguration, forKey: .originConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let originConfigurationDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageOriginConfiguration.self, forKey: .originConfiguration)
        originConfiguration = originConfigurationDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package.
    public struct PackageDescription: Swift.Equatable {
        /// A format that specifies the type of the package.
        public var format: CodeartifactClientTypes.PackageFormat?
        /// The name of the package.
        public var name: Swift.String?
        /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
        ///
        /// * The namespace of a generic package is its namespace.
        public var namespace: Swift.String?
        /// The package origin configuration for the package.
        public var originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration?

        public init(
            format: CodeartifactClientTypes.PackageFormat? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration? = nil
        )
        {
            self.format = format
            self.name = name
            self.namespace = namespace
            self.originConfiguration = originConfiguration
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generic
        case maven
        case npm
        case nuget
        case pypi
        case swift
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageFormat] {
            return [
                .generic,
                .maven,
                .npm,
                .nuget,
                .pypi,
                .swift,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generic: return "generic"
            case .maven: return "maven"
            case .npm: return "npm"
            case .nuget: return "nuget"
            case .pypi: return "pypi"
            case .swift: return "swift"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageFormat(rawValue: rawValue) ?? PackageFormat.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageOriginConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restrictions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionsDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageOriginRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about the package origin configuration of a package.
    public struct PackageOriginConfiguration: Swift.Equatable {
        /// A PackageOriginRestrictions object that contains information about the upstream and publish package origin configuration for the package.
        public var restrictions: CodeartifactClientTypes.PackageOriginRestrictions?

        public init(
            restrictions: CodeartifactClientTypes.PackageOriginRestrictions? = nil
        )
        {
            self.restrictions = restrictions
        }
    }

}

extension CodeartifactClientTypes.PackageOriginRestrictions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case publish
        case upstream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publish = self.publish {
            try encodeContainer.encode(publish.rawValue, forKey: .publish)
        }
        if let upstream = self.upstream {
            try encodeContainer.encode(upstream.rawValue, forKey: .upstream)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.AllowPublish.self, forKey: .publish)
        publish = publishDecoded
        let upstreamDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.AllowUpstream.self, forKey: .upstream)
        upstream = upstreamDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about the origin restrictions set on the package. The package origin restrictions determine how new versions of a package can be added to a specific repository.
    public struct PackageOriginRestrictions: Swift.Equatable {
        /// The package origin configuration that determines if new versions of the package can be published directly to the repository.
        /// This member is required.
        public var publish: CodeartifactClientTypes.AllowPublish?
        /// The package origin configuration that determines if new versions of the package can be added to the repository from an external connection or upstream source.
        /// This member is required.
        public var upstream: CodeartifactClientTypes.AllowUpstream?

        public init(
            publish: CodeartifactClientTypes.AllowPublish? = nil,
            upstream: CodeartifactClientTypes.AllowUpstream? = nil
        )
        {
            self.publish = publish
            self.upstream = upstream
        }
    }

}

extension CodeartifactClientTypes.PackageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case namespace
        case originConfiguration
        case package
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let originConfiguration = self.originConfiguration {
            try encodeContainer.encode(originConfiguration, forKey: .originConfiguration)
        }
        if let package = self.package {
            try encodeContainer.encode(package, forKey: .package)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let originConfigurationDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageOriginConfiguration.self, forKey: .originConfiguration)
        originConfiguration = originConfigurationDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package, including its format, namespace, and name.
    public struct PackageSummary: Swift.Equatable {
        /// The format of the package.
        public var format: CodeartifactClientTypes.PackageFormat?
        /// The namespace of the package. The package component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package is its groupId.
        ///
        /// * The namespace of an npm package is its scope.
        ///
        /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
        ///
        /// * The namespace of a generic package is its namespace.
        public var namespace: Swift.String?
        /// A [PackageOriginConfiguration](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginConfiguration.html) object that contains a [PackageOriginRestrictions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html) object that contains information about the upstream and publish package origin restrictions.
        public var originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration?
        /// The name of the package.
        public var package: Swift.String?

        public init(
            format: CodeartifactClientTypes.PackageFormat? = nil,
            namespace: Swift.String? = nil,
            originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration? = nil,
            package: Swift.String? = nil
        )
        {
            self.format = format
            self.namespace = namespace
            self.originConfiguration = originConfiguration
            self.package = package
        }
    }

}

extension CodeartifactClientTypes.PackageVersionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName
        case format
        case homePage
        case licenses
        case namespace
        case origin
        case packageName
        case publishedTime
        case revision
        case sourceCodeRepository
        case status
        case summary
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let homePage = self.homePage {
            try encodeContainer.encode(homePage, forKey: .homePage)
        }
        if let licenses = licenses {
            var licensesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenses)
            for licenseinfo0 in licenses {
                try licensesContainer.encode(licenseinfo0)
            }
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let publishedTime = self.publishedTime {
            try encodeContainer.encodeTimestamp(publishedTime, format: .epochSeconds, forKey: .publishedTime)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let sourceCodeRepository = self.sourceCodeRepository {
            try encodeContainer.encode(sourceCodeRepository, forKey: .sourceCodeRepository)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = self.summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let homePageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .homePage)
        homePage = homePageDecoded
        let sourceCodeRepositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceCodeRepository)
        sourceCodeRepository = sourceCodeRepositoryDecoded
        let publishedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .publishedTime)
        publishedTime = publishedTimeDecoded
        let licensesContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.LicenseInfo?].self, forKey: .licenses)
        var licensesDecoded0:[CodeartifactClientTypes.LicenseInfo]? = nil
        if let licensesContainer = licensesContainer {
            licensesDecoded0 = [CodeartifactClientTypes.LicenseInfo]()
            for structure0 in licensesContainer {
                if let structure0 = structure0 {
                    licensesDecoded0?.append(structure0)
                }
            }
        }
        licenses = licensesDecoded0
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let originDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionOrigin.self, forKey: .origin)
        origin = originDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package version.
    public struct PackageVersionDescription: Swift.Equatable {
        /// The name of the package that is displayed. The displayName varies depending on the package version's format. For example, if an npm package is named ui, is in the namespace vue, and has the format npm, then the displayName is @vue/ui.
        public var displayName: Swift.String?
        /// The format of the package version.
        public var format: CodeartifactClientTypes.PackageFormat?
        /// The homepage associated with the package.
        public var homePage: Swift.String?
        /// Information about licenses associated with the package version.
        public var licenses: [CodeartifactClientTypes.LicenseInfo]?
        /// The namespace of the package version. The package version component that specifies its namespace depends on its type. For example:
        ///
        /// * The namespace of a Maven package version is its groupId.
        ///
        /// * The namespace of an npm package version is its scope.
        ///
        /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
        ///
        /// * The namespace of a generic package is its namespace.
        public var namespace: Swift.String?
        /// A [PackageVersionOrigin](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionOrigin.html) object that contains information about how the package version was added to the repository.
        public var origin: CodeartifactClientTypes.PackageVersionOrigin?
        /// The name of the requested package.
        public var packageName: Swift.String?
        /// A timestamp that contains the date and time the package version was published.
        public var publishedTime: ClientRuntime.Date?
        /// The revision of the package version.
        public var revision: Swift.String?
        /// The repository for the source code in the package version, or the source code used to build it.
        public var sourceCodeRepository: Swift.String?
        /// A string that contains the status of the package version.
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        /// A summary of the package version. The summary is extracted from the package. The information in and detail level of the summary depends on the package version's format.
        public var summary: Swift.String?
        /// The version of the package.
        public var version: Swift.String?

        public init(
            displayName: Swift.String? = nil,
            format: CodeartifactClientTypes.PackageFormat? = nil,
            homePage: Swift.String? = nil,
            licenses: [CodeartifactClientTypes.LicenseInfo]? = nil,
            namespace: Swift.String? = nil,
            origin: CodeartifactClientTypes.PackageVersionOrigin? = nil,
            packageName: Swift.String? = nil,
            publishedTime: ClientRuntime.Date? = nil,
            revision: Swift.String? = nil,
            sourceCodeRepository: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            summary: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.displayName = displayName
            self.format = format
            self.homePage = homePage
            self.licenses = licenses
            self.namespace = namespace
            self.origin = origin
            self.packageName = packageName
            self.publishedTime = publishedTime
            self.revision = revision
            self.sourceCodeRepository = sourceCodeRepository
            self.status = status
            self.summary = summary
            self.version = version
        }
    }

}

extension CodeartifactClientTypes.PackageVersionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension CodeartifactClientTypes {
    /// l An error associated with package.
    public struct PackageVersionError: Swift.Equatable {
        /// The error code associated with the error. Valid error codes are:
        ///
        /// * ALREADY_EXISTS
        ///
        /// * MISMATCHED_REVISION
        ///
        /// * MISMATCHED_STATUS
        ///
        /// * NOT_ALLOWED
        ///
        /// * NOT_FOUND
        ///
        /// * SKIPPED
        public var errorCode: CodeartifactClientTypes.PackageVersionErrorCode?
        /// The error message associated with the error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: CodeartifactClientTypes.PackageVersionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageVersionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case mismatchedRevision
        case mismatchedStatus
        case notAllowed
        case notFound
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionErrorCode] {
            return [
                .alreadyExists,
                .mismatchedRevision,
                .mismatchedStatus,
                .notAllowed,
                .notFound,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .mismatchedRevision: return "MISMATCHED_REVISION"
            case .mismatchedStatus: return "MISMATCHED_STATUS"
            case .notAllowed: return "NOT_ALLOWED"
            case .notFound: return "NOT_FOUND"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionErrorCode(rawValue: rawValue) ?? PackageVersionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageVersionOrigin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainEntryPoint
        case originType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainEntryPoint = self.domainEntryPoint {
            try encodeContainer.encode(domainEntryPoint, forKey: .domainEntryPoint)
        }
        if let originType = self.originType {
            try encodeContainer.encode(originType.rawValue, forKey: .originType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainEntryPointDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.DomainEntryPoint.self, forKey: .domainEntryPoint)
        domainEntryPoint = domainEntryPointDecoded
        let originTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionOriginType.self, forKey: .originType)
        originType = originTypeDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about how a package version was added to a repository.
    public struct PackageVersionOrigin: Swift.Equatable {
        /// A [DomainEntryPoint](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_DomainEntryPoint.html) object that contains information about from which repository or external connection the package version was added to the domain.
        public var domainEntryPoint: CodeartifactClientTypes.DomainEntryPoint?
        /// Describes how the package version was originally added to the domain. An INTERNAL origin type means the package version was published directly to a repository in the domain. An EXTERNAL origin type means the package version was ingested from an external connection.
        public var originType: CodeartifactClientTypes.PackageVersionOriginType?

        public init(
            domainEntryPoint: CodeartifactClientTypes.DomainEntryPoint? = nil,
            originType: CodeartifactClientTypes.PackageVersionOriginType? = nil
        )
        {
            self.domainEntryPoint = domainEntryPoint
            self.originType = originType
        }
    }

}

extension CodeartifactClientTypes {
    public enum PackageVersionOriginType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case external
        case `internal`
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionOriginType] {
            return [
                .external,
                .internal,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .external: return "EXTERNAL"
            case .internal: return "INTERNAL"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionOriginType(rawValue: rawValue) ?? PackageVersionOriginType.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionSortType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case publishedTime
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionSortType] {
            return [
                .publishedTime,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .publishedTime: return "PUBLISHED_TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionSortType(rawValue: rawValue) ?? PackageVersionSortType.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes {
    public enum PackageVersionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case deleted
        case disposed
        case published
        case unfinished
        case unlisted
        case sdkUnknown(Swift.String)

        public static var allCases: [PackageVersionStatus] {
            return [
                .archived,
                .deleted,
                .disposed,
                .published,
                .unfinished,
                .unlisted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "Archived"
            case .deleted: return "Deleted"
            case .disposed: return "Disposed"
            case .published: return "Published"
            case .unfinished: return "Unfinished"
            case .unlisted: return "Unlisted"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PackageVersionStatus(rawValue: rawValue) ?? PackageVersionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodeartifactClientTypes.PackageVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case origin
        case revision
        case status
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let origin = self.origin {
            try encodeContainer.encode(origin, forKey: .origin)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let originDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionOrigin.self, forKey: .origin)
        origin = originDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a package version, including its status, version, and revision. The [ListPackageVersions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListPackageVersions.html) operation returns a list of PackageVersionSummary objects.
    public struct PackageVersionSummary: Swift.Equatable {
        /// A [PackageVersionOrigin](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageVersionOrigin.html) object that contains information about how the package version was added to the repository.
        public var origin: CodeartifactClientTypes.PackageVersionOrigin?
        /// The revision associated with a package version.
        public var revision: Swift.String?
        /// A string that contains the status of the package version. It can be one of the following:
        /// This member is required.
        public var status: CodeartifactClientTypes.PackageVersionStatus?
        /// Information about a package version.
        /// This member is required.
        public var version: Swift.String?

        public init(
            origin: CodeartifactClientTypes.PackageVersionOrigin? = nil,
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.origin = origin
            self.revision = revision
            self.status = status
            self.version = version
        }
    }

}

public struct PublishPackageVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PublishPackageVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PublishPackageVersionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PublishPackageVersionOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let assetContent = input.operationInput.assetContent {
            let assetContentBody = ClientRuntime.HttpBody(byteStream: assetContent)
            input.builder.withBody(assetContentBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PublishPackageVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PublishPackageVersionOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension PublishPackageVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetContent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetContent = self.assetContent {
            try encodeContainer.encode(assetContent, forKey: .assetContent)
        }
    }
}

extension PublishPackageVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let assetSHA256 = assetSHA256 {
            items.add(Header(name: "x-amz-content-sha256", value: Swift.String(assetSHA256)))
        }
        return items
    }
}

extension PublishPackageVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let assetName = assetName else {
                let message = "Creating a URL Query Item failed. assetName is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assetNameQueryItem = ClientRuntime.URLQueryItem(name: "asset".urlPercentEncoding(), value: Swift.String(assetName).urlPercentEncoding())
            items.append(assetNameQueryItem)
            guard let packageVersion = packageVersion else {
                let message = "Creating a URL Query Item failed. packageVersion is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageVersionQueryItem = ClientRuntime.URLQueryItem(name: "version".urlPercentEncoding(), value: Swift.String(packageVersion).urlPercentEncoding())
            items.append(packageVersionQueryItem)
            if let unfinished = unfinished {
                let unfinishedQueryItem = ClientRuntime.URLQueryItem(name: "unfinished".urlPercentEncoding(), value: Swift.String(unfinished).urlPercentEncoding())
                items.append(unfinishedQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension PublishPackageVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/version/publish"
    }
}

public struct PublishPackageVersionInput: Swift.Equatable {
    /// The content of the asset to publish.
    /// This member is required.
    public var assetContent: ClientRuntime.ByteStream?
    /// The name of the asset to publish. Asset names can include Unicode letters and numbers, and the following special characters: ~ ! @ ^ & ( ) - ` _ + [ ] { } ; , . `
    /// This member is required.
    public var assetName: Swift.String?
    /// The SHA256 hash of the assetContent to publish. This value must be calculated by the caller and provided with the request (see [Publishing a generic package](https://docs.aws.amazon.com/codeartifact/latest/ug/using-generic.html#publishing-generic-packages) in the CodeArtifact User Guide). This value is used as an integrity check to verify that the assetContent has not changed after it was originally sent.
    /// This member is required.
    public var assetSHA256: Swift.String?
    /// The name of the domain that contains the repository that contains the package version to publish.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the AWS account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package version with the requested asset file. The only supported value is generic.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version to publish.
    public var namespace: Swift.String?
    /// The name of the package version to publish.
    /// This member is required.
    public var package: Swift.String?
    /// The package version to publish (for example, 3.5.2).
    /// This member is required.
    public var packageVersion: Swift.String?
    /// The name of the repository that the package version will be published to.
    /// This member is required.
    public var repository: Swift.String?
    /// Specifies whether the package version should remain in the unfinished state. If omitted, the package version status will be set to Published (see [Package version status](https://docs.aws.amazon.com/codeartifact/latest/ug/packages-overview.html#package-version-status) in the CodeArtifact User Guide). Valid values: unfinished
    public var unfinished: Swift.Bool?

    public init(
        assetContent: ClientRuntime.ByteStream? = nil,
        assetName: Swift.String? = nil,
        assetSHA256: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        packageVersion: Swift.String? = nil,
        repository: Swift.String? = nil,
        unfinished: Swift.Bool? = nil
    )
    {
        self.assetContent = assetContent
        self.assetName = assetName
        self.assetSHA256 = assetSHA256
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.packageVersion = packageVersion
        self.repository = repository
        self.unfinished = unfinished
    }
}

struct PublishPackageVersionInputBody: Swift.Equatable {
    let assetContent: ClientRuntime.ByteStream?
}

extension PublishPackageVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetContentDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .assetContent)
        assetContent = assetContentDecoded
    }
}

extension PublishPackageVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PublishPackageVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.asset = output.asset
            self.format = output.format
            self.namespace = output.namespace
            self.package = output.package
            self.status = output.status
            self.version = output.version
            self.versionRevision = output.versionRevision
        } else {
            self.asset = nil
            self.format = nil
            self.namespace = nil
            self.package = nil
            self.status = nil
            self.version = nil
            self.versionRevision = nil
        }
    }
}

public struct PublishPackageVersionOutput: Swift.Equatable {
    /// An [AssetSummary](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_AssetSummary.html) for the published asset.
    public var asset: CodeartifactClientTypes.AssetSummary?
    /// The format of the package version.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version.
    public var namespace: Swift.String?
    /// The name of the package.
    public var package: Swift.String?
    /// A string that contains the status of the package version. For more information, see [Package version status](https://docs.aws.amazon.com/codeartifact/latest/ug/packages-overview.html#package-version-status.html#package-version-status) in the CodeArtifact User Guide.
    public var status: CodeartifactClientTypes.PackageVersionStatus?
    /// The version of the package.
    public var version: Swift.String?
    /// The revision of the package version.
    public var versionRevision: Swift.String?

    public init(
        asset: CodeartifactClientTypes.AssetSummary? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        status: CodeartifactClientTypes.PackageVersionStatus? = nil,
        version: Swift.String? = nil,
        versionRevision: Swift.String? = nil
    )
    {
        self.asset = asset
        self.format = format
        self.namespace = namespace
        self.package = package
        self.status = status
        self.version = version
        self.versionRevision = versionRevision
    }
}

struct PublishPackageVersionOutputBody: Swift.Equatable {
    let format: CodeartifactClientTypes.PackageFormat?
    let namespace: Swift.String?
    let package: Swift.String?
    let version: Swift.String?
    let versionRevision: Swift.String?
    let status: CodeartifactClientTypes.PackageVersionStatus?
    let asset: CodeartifactClientTypes.AssetSummary?
}

extension PublishPackageVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asset
        case format
        case namespace
        case package
        case status
        case version
        case versionRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .format)
        format = formatDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let packageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .package)
        package = packageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let versionRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionRevision)
        versionRevision = versionRevisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
        let assetDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.AssetSummary.self, forKey: .asset)
        asset = assetDecoded
    }
}

enum PublishPackageVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutDomainPermissionsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let domainOwner = self.domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = self.policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

extension PutDomainPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/domain/permissions/policy"
    }
}

public struct PutDomainPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain on which to set the resource policy.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy.
    public var policyRevision: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
    }
}

struct PutDomainPermissionsPolicyInputBody: Swift.Equatable {
    let domain: Swift.String?
    let domainOwner: Swift.String?
    let policyRevision: Swift.String?
    let policyDocument: Swift.String?
}

extension PutDomainPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain
        case domainOwner
        case policyDocument
        case policyRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutDomainPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutDomainPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutDomainPermissionsPolicyOutput: Swift.Equatable {
    /// The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutDomainPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutDomainPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutDomainPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutPackageOriginConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restrictions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let restrictions = self.restrictions {
            try encodeContainer.encode(restrictions, forKey: .restrictions)
        }
    }
}

extension PutPackageOriginConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension PutPackageOriginConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package"
    }
}

public struct PutPackageOriginConfigurationInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A format that specifies the type of the package to be updated.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package to be updated. The package component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package is its groupId.
    ///
    /// * The namespace of an npm package is its scope.
    ///
    /// * Python and NuGet packages do not contain a corresponding component, packages of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package to be updated.
    /// This member is required.
    public var package: Swift.String?
    /// The name of the repository that contains the package.
    /// This member is required.
    public var repository: Swift.String?
    /// A [PackageOriginRestrictions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html) object that contains information about the upstream and publish package origin restrictions. The upstream restriction determines if new package versions can be ingested or retained from external connections or upstream repositories. The publish restriction determines if new package versions can be published directly to the repository. You must include both the desired upstream and publish restrictions.
    /// This member is required.
    public var restrictions: CodeartifactClientTypes.PackageOriginRestrictions?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        restrictions: CodeartifactClientTypes.PackageOriginRestrictions? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.restrictions = restrictions
    }
}

struct PutPackageOriginConfigurationInputBody: Swift.Equatable {
    let restrictions: CodeartifactClientTypes.PackageOriginRestrictions?
}

extension PutPackageOriginConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case restrictions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restrictionsDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageOriginRestrictions.self, forKey: .restrictions)
        restrictions = restrictionsDecoded
    }
}

extension PutPackageOriginConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutPackageOriginConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.originConfiguration = output.originConfiguration
        } else {
            self.originConfiguration = nil
        }
    }
}

public struct PutPackageOriginConfigurationOutput: Swift.Equatable {
    /// A [PackageOriginConfiguration](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginConfiguration.html) object that describes the origin configuration set for the package. It contains a [PackageOriginRestrictions](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_PackageOriginRestrictions.html) object that describes how new versions of the package can be introduced to the repository.
    public var originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration?

    public init(
        originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration? = nil
    )
    {
        self.originConfiguration = originConfiguration
    }
}

struct PutPackageOriginConfigurationOutputBody: Swift.Equatable {
    let originConfiguration: CodeartifactClientTypes.PackageOriginConfiguration?
}

extension PutPackageOriginConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originConfigurationDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageOriginConfiguration.self, forKey: .originConfiguration)
        originConfiguration = originConfigurationDecoded
    }
}

enum PutPackageOriginConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRepositoryPermissionsPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyRevision = self.policyRevision {
            try encodeContainer.encode(policyRevision, forKey: .policyRevision)
        }
    }
}

extension PutRepositoryPermissionsPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension PutRepositoryPermissionsPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository/permissions/policy"
    }
}

public struct PutRepositoryPermissionsPolicyInput: Swift.Equatable {
    /// The name of the domain containing the repository to set the resource policy on.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy.
    public var policyRevision: Swift.String?
    /// The name of the repository to set the resource policy on.
    /// This member is required.
    public var repository: Swift.String?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyRevision: Swift.String? = nil,
        repository: Swift.String? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.policyDocument = policyDocument
        self.policyRevision = policyRevision
        self.repository = repository
    }
}

struct PutRepositoryPermissionsPolicyInputBody: Swift.Equatable {
    let policyRevision: Swift.String?
    let policyDocument: Swift.String?
}

extension PutRepositoryPermissionsPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyDocument
        case policyRevision
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyRevisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyRevision)
        policyRevision = policyRevisionDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
    }
}

extension PutRepositoryPermissionsPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRepositoryPermissionsPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct PutRepositoryPermissionsPolicyOutput: Swift.Equatable {
    /// The resource policy that was set after processing the request.
    public var policy: CodeartifactClientTypes.ResourcePolicy?

    public init(
        policy: CodeartifactClientTypes.ResourcePolicy? = nil
    )
    {
        self.policy = policy
    }
}

struct PutRepositoryPermissionsPolicyOutputBody: Swift.Equatable {
    let policy: CodeartifactClientTypes.ResourcePolicy?
}

extension PutRepositoryPermissionsPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourcePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum PutRepositoryPermissionsPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeartifactClientTypes.RepositoryDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case createdTime
        case description
        case domainName
        case domainOwner
        case externalConnections
        case name
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = self.administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = self.domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let externalConnections = externalConnections {
            var externalConnectionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .externalConnections)
            for repositoryexternalconnectioninfo0 in externalConnections {
                try externalConnectionsContainer.encode(repositoryexternalconnectioninfo0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepositoryinfo0 in upstreams {
                try upstreamsContainer.encode(upstreamrepositoryinfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepositoryInfo?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepositoryInfo]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
        let externalConnectionsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.RepositoryExternalConnectionInfo?].self, forKey: .externalConnections)
        var externalConnectionsDecoded0:[CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil
        if let externalConnectionsContainer = externalConnectionsContainer {
            externalConnectionsDecoded0 = [CodeartifactClientTypes.RepositoryExternalConnectionInfo]()
            for structure0 in externalConnectionsContainer {
                if let structure0 = structure0 {
                    externalConnectionsDecoded0?.append(structure0)
                }
            }
        }
        externalConnections = externalConnectionsDecoded0
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CodeartifactClientTypes {
    /// The details of a repository stored in CodeArtifact. A CodeArtifact repository contains a set of package versions, each of which maps to a set of assets. Repositories are polyglota single repository can contain packages of any supported type. Each repository exposes endpoints for fetching and publishing packages using tools like the npm CLI, the Maven CLI (mvn), and pip. You can create up to 100 repositories per Amazon Web Services account.
    public struct RepositoryDescription: Swift.Equatable {
        /// The 12-digit account number of the Amazon Web Services account that manages the repository.
        public var administratorAccount: Swift.String?
        /// The Amazon Resource Name (ARN) of the repository.
        public var arn: Swift.String?
        /// A timestamp that represents the date and time the repository was created.
        public var createdTime: ClientRuntime.Date?
        /// A text description of the repository.
        public var description: Swift.String?
        /// The name of the domain that contains the repository.
        public var domainName: Swift.String?
        /// The 12-digit account number of the Amazon Web Services account that owns the domain that contains the repository. It does not include dashes or spaces.
        public var domainOwner: Swift.String?
        /// An array of external connections associated with the repository.
        public var externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]?
        /// The name of the repository.
        public var name: Swift.String?
        /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
        public var upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]?

        public init(
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            externalConnections: [CodeartifactClientTypes.RepositoryExternalConnectionInfo]? = nil,
            name: Swift.String? = nil,
            upstreams: [CodeartifactClientTypes.UpstreamRepositoryInfo]? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.externalConnections = externalConnections
            self.name = name
            self.upstreams = upstreams
        }
    }

}

extension CodeartifactClientTypes.RepositoryExternalConnectionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalConnectionName
        case packageFormat
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalConnectionName = self.externalConnectionName {
            try encodeContainer.encode(externalConnectionName, forKey: .externalConnectionName)
        }
        if let packageFormat = self.packageFormat {
            try encodeContainer.encode(packageFormat.rawValue, forKey: .packageFormat)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalConnectionName)
        externalConnectionName = externalConnectionNameDecoded
        let packageFormatDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageFormat.self, forKey: .packageFormat)
        packageFormat = packageFormatDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ExternalConnectionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Contains information about the external connection of a repository.
    public struct RepositoryExternalConnectionInfo: Swift.Equatable {
        /// The name of the external connection associated with a repository.
        public var externalConnectionName: Swift.String?
        /// The package format associated with a repository's external connection. The valid package formats are:
        ///
        /// * npm: A Node Package Manager (npm) package.
        ///
        /// * pypi: A Python Package Index (PyPI) package.
        ///
        /// * maven: A Maven package that contains compiled code in a distributable format, such as a JAR file.
        ///
        /// * nuget: A NuGet package.
        public var packageFormat: CodeartifactClientTypes.PackageFormat?
        /// The status of the external connection of a repository. There is one valid value, Available.
        public var status: CodeartifactClientTypes.ExternalConnectionStatus?

        public init(
            externalConnectionName: Swift.String? = nil,
            packageFormat: CodeartifactClientTypes.PackageFormat? = nil,
            status: CodeartifactClientTypes.ExternalConnectionStatus? = nil
        )
        {
            self.externalConnectionName = externalConnectionName
            self.packageFormat = packageFormat
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.RepositorySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorAccount
        case arn
        case createdTime
        case description
        case domainName
        case domainOwner
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorAccount = self.administratorAccount {
            try encodeContainer.encode(administratorAccount, forKey: .administratorAccount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = self.createdTime {
            try encodeContainer.encodeTimestamp(createdTime, format: .epochSeconds, forKey: .createdTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let domainOwner = self.domainOwner {
            try encodeContainer.encode(domainOwner, forKey: .domainOwner)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let administratorAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorAccount)
        administratorAccount = administratorAccountDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let domainOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainOwner)
        domainOwner = domainOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension CodeartifactClientTypes {
    /// Details about a repository, including its Amazon Resource Name (ARN), description, and domain information. The [ListRepositories](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_ListRepositories.html) operation returns a list of RepositorySummary objects.
    public struct RepositorySummary: Swift.Equatable {
        /// The Amazon Web Services account ID that manages the repository.
        public var administratorAccount: Swift.String?
        /// The ARN of the repository.
        public var arn: Swift.String?
        /// A timestamp that represents the date and time the repository was created.
        public var createdTime: ClientRuntime.Date?
        /// The description of the repository.
        public var description: Swift.String?
        /// The name of the domain that contains the repository.
        public var domainName: Swift.String?
        /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
        public var domainOwner: Swift.String?
        /// The name of the repository.
        public var name: Swift.String?

        public init(
            administratorAccount: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            domainName: Swift.String? = nil,
            domainOwner: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.administratorAccount = administratorAccount
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.domainName = domainName
            self.domainOwner = domainOwner
            self.name = name
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because the resource requested is not found in the service.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Amazon Web Services resource.
        public internal(set) var resourceType: CodeartifactClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.ResourcePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case document
        case resourceArn
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let document = self.document {
            try encodeContainer.encode(document, forKey: .document)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let documentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .document)
        document = documentDecoded
    }
}

extension CodeartifactClientTypes {
    /// An CodeArtifact resource policy that contains a resource ARN, document details, and a revision.
    public struct ResourcePolicy: Swift.Equatable {
        /// The resource policy formatted in JSON.
        public var document: Swift.String?
        /// The ARN of the resource associated with the resource policy
        public var resourceArn: Swift.String?
        /// The current revision of the resource policy.
        public var revision: Swift.String?

        public init(
            document: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.document = document
            self.resourceArn = resourceArn
            self.revision = revision
        }
    }

}

extension CodeartifactClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asset
        case domain
        case package
        case packageVersion
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .asset,
                .domain,
                .package,
                .packageVersion,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asset: return "asset"
            case .domain: return "domain"
            case .package: return "package"
            case .packageVersion: return "package-version"
            case .repository: return "repository"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Amazon Web Services resource.
        public internal(set) var resourceType: CodeartifactClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CodeartifactClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CodeartifactClientTypes.ResourceType?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeartifactClientTypes.SuccessfulPackageVersionInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case revision
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let revision = self.revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodeartifactClientTypes {
    /// Contains the revision and status of a package version.
    public struct SuccessfulPackageVersionInfo: Swift.Equatable {
        /// The revision of a package version.
        public var revision: Swift.String?
        /// The status of a package version.
        public var status: CodeartifactClientTypes.PackageVersionStatus?

        public init(
            revision: Swift.String? = nil,
            status: CodeartifactClientTypes.PackageVersionStatus? = nil
        )
        {
            self.revision = revision
            self.status = status
        }
    }

}

extension CodeartifactClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodeartifactClientTypes {
    /// A tag is a key-value pair that can be used to manage, search for, or filter resources in CodeArtifact.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/tag"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags you want to modify or add to the resource.
    /// This member is required.
    public var tags: [CodeartifactClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [CodeartifactClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [CodeartifactClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodeartifactClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodeartifactClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because too many requests are sent to the service.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The time period, in seconds, to wait before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/untag"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePackageVersionsStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expectedStatus = self.expectedStatus {
            try encodeContainer.encode(expectedStatus.rawValue, forKey: .expectedStatus)
        }
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
        if let versionRevisions = versionRevisions {
            var versionRevisionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .versionRevisions)
            for (dictKey0, packageVersionRevisionMap0) in versionRevisions {
                try versionRevisionsContainer.encode(packageVersionRevisionMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let versions = versions {
            var versionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versions)
            for packageversion0 in versions {
                try versionsContainer.encode(packageversion0)
            }
        }
    }
}

extension UpdatePackageVersionsStatusInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let package = package else {
                let message = "Creating a URL Query Item failed. package is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let packageQueryItem = ClientRuntime.URLQueryItem(name: "package".urlPercentEncoding(), value: Swift.String(package).urlPercentEncoding())
            items.append(packageQueryItem)
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let format = format else {
                let message = "Creating a URL Query Item failed. format is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let formatQueryItem = ClientRuntime.URLQueryItem(name: "format".urlPercentEncoding(), value: Swift.String(format.rawValue).urlPercentEncoding())
            items.append(formatQueryItem)
            if let namespace = namespace {
                let namespaceQueryItem = ClientRuntime.URLQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
                items.append(namespaceQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension UpdatePackageVersionsStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/package/versions/update_status"
    }
}

public struct UpdatePackageVersionsStatusInput: Swift.Equatable {
    /// The name of the domain that contains the repository that contains the package versions with a status to be updated.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The package versions expected status before it is updated. If expectedStatus is provided, the package version's status is updated only if its status at the time UpdatePackageVersionsStatus is called matches expectedStatus.
    public var expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A format that specifies the type of the package with the statuses to update.
    /// This member is required.
    public var format: CodeartifactClientTypes.PackageFormat?
    /// The namespace of the package version to be updated. The package version component that specifies its namespace depends on its type. For example:
    ///
    /// * The namespace of a Maven package version is its groupId.
    ///
    /// * The namespace of an npm package version is its scope.
    ///
    /// * Python and NuGet package versions do not contain a corresponding component, package versions of those formats do not have a namespace.
    ///
    /// * The namespace of a generic package is its namespace.
    public var namespace: Swift.String?
    /// The name of the package with the version statuses to update.
    /// This member is required.
    public var package: Swift.String?
    /// The repository that contains the package versions with the status you want to update.
    /// This member is required.
    public var repository: Swift.String?
    /// The status you want to change the package version status to.
    /// This member is required.
    public var targetStatus: CodeartifactClientTypes.PackageVersionStatus?
    /// A map of package versions and package version revisions. The map key is the package version (for example, 3.5.2), and the map value is the package version revision.
    public var versionRevisions: [Swift.String:Swift.String]?
    /// An array of strings that specify the versions of the package with the statuses to update.
    /// This member is required.
    public var versions: [Swift.String]?

    public init(
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        expectedStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        format: CodeartifactClientTypes.PackageFormat? = nil,
        namespace: Swift.String? = nil,
        package: Swift.String? = nil,
        repository: Swift.String? = nil,
        targetStatus: CodeartifactClientTypes.PackageVersionStatus? = nil,
        versionRevisions: [Swift.String:Swift.String]? = nil,
        versions: [Swift.String]? = nil
    )
    {
        self.domain = domain
        self.domainOwner = domainOwner
        self.expectedStatus = expectedStatus
        self.format = format
        self.namespace = namespace
        self.package = package
        self.repository = repository
        self.targetStatus = targetStatus
        self.versionRevisions = versionRevisions
        self.versions = versions
    }
}

struct UpdatePackageVersionsStatusInputBody: Swift.Equatable {
    let versions: [Swift.String]?
    let versionRevisions: [Swift.String:Swift.String]?
    let expectedStatus: CodeartifactClientTypes.PackageVersionStatus?
    let targetStatus: CodeartifactClientTypes.PackageVersionStatus?
}

extension UpdatePackageVersionsStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expectedStatus
        case targetStatus
        case versionRevisions
        case versions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .versions)
        var versionsDecoded0:[Swift.String]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [Swift.String]()
            for string0 in versionsContainer {
                if let string0 = string0 {
                    versionsDecoded0?.append(string0)
                }
            }
        }
        versions = versionsDecoded0
        let versionRevisionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .versionRevisions)
        var versionRevisionsDecoded0: [Swift.String:Swift.String]? = nil
        if let versionRevisionsContainer = versionRevisionsContainer {
            versionRevisionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, packageversionrevision0) in versionRevisionsContainer {
                if let packageversionrevision0 = packageversionrevision0 {
                    versionRevisionsDecoded0?[key0] = packageversionrevision0
                }
            }
        }
        versionRevisions = versionRevisionsDecoded0
        let expectedStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .expectedStatus)
        expectedStatus = expectedStatusDecoded
        let targetStatusDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.PackageVersionStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension UpdatePackageVersionsStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePackageVersionsStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedVersions = output.failedVersions
            self.successfulVersions = output.successfulVersions
        } else {
            self.failedVersions = nil
            self.successfulVersions = nil
        }
    }
}

public struct UpdatePackageVersionsStatusOutput: Swift.Equatable {
    /// A list of SuccessfulPackageVersionInfo objects, one for each package version with a status that successfully updated.
    public var failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
    /// A list of PackageVersionError objects, one for each package version with a status that failed to update.
    public var successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?

    public init(
        failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil,
        successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
    )
    {
        self.failedVersions = failedVersions
        self.successfulVersions = successfulVersions
    }
}

struct UpdatePackageVersionsStatusOutputBody: Swift.Equatable {
    let successfulVersions: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]?
    let failedVersions: [Swift.String:CodeartifactClientTypes.PackageVersionError]?
}

extension UpdatePackageVersionsStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedVersions
        case successfulVersions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.SuccessfulPackageVersionInfo?].self, forKey: .successfulVersions)
        var successfulVersionsDecoded0: [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]? = nil
        if let successfulVersionsContainer = successfulVersionsContainer {
            successfulVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.SuccessfulPackageVersionInfo]()
            for (key0, successfulpackageversioninfo0) in successfulVersionsContainer {
                if let successfulpackageversioninfo0 = successfulpackageversioninfo0 {
                    successfulVersionsDecoded0?[key0] = successfulpackageversioninfo0
                }
            }
        }
        successfulVersions = successfulVersionsDecoded0
        let failedVersionsContainer = try containerValues.decodeIfPresent([Swift.String: CodeartifactClientTypes.PackageVersionError?].self, forKey: .failedVersions)
        var failedVersionsDecoded0: [Swift.String:CodeartifactClientTypes.PackageVersionError]? = nil
        if let failedVersionsContainer = failedVersionsContainer {
            failedVersionsDecoded0 = [Swift.String:CodeartifactClientTypes.PackageVersionError]()
            for (key0, packageversionerror0) in failedVersionsContainer {
                if let packageversionerror0 = packageversionerror0 {
                    failedVersionsDecoded0?[key0] = packageversionerror0
                }
            }
        }
        failedVersions = failedVersionsDecoded0
    }
}

enum UpdatePackageVersionsStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let upstreams = upstreams {
            var upstreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .upstreams)
            for upstreamrepository0 in upstreams {
                try upstreamsContainer.encode(upstreamrepository0)
            }
        }
    }
}

extension UpdateRepositoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let domain = domain else {
                let message = "Creating a URL Query Item failed. domain is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let domainQueryItem = ClientRuntime.URLQueryItem(name: "domain".urlPercentEncoding(), value: Swift.String(domain).urlPercentEncoding())
            items.append(domainQueryItem)
            if let domainOwner = domainOwner {
                let domainOwnerQueryItem = ClientRuntime.URLQueryItem(name: "domain-owner".urlPercentEncoding(), value: Swift.String(domainOwner).urlPercentEncoding())
                items.append(domainOwnerQueryItem)
            }
            guard let repository = repository else {
                let message = "Creating a URL Query Item failed. repository is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let repositoryQueryItem = ClientRuntime.URLQueryItem(name: "repository".urlPercentEncoding(), value: Swift.String(repository).urlPercentEncoding())
            items.append(repositoryQueryItem)
            return items
        }
    }
}

extension UpdateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/repository"
    }
}

public struct UpdateRepositoryInput: Swift.Equatable {
    /// An updated repository description.
    public var description: Swift.String?
    /// The name of the domain associated with the repository to update.
    /// This member is required.
    public var domain: Swift.String?
    /// The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces.
    public var domainOwner: Swift.String?
    /// The name of the repository to update.
    /// This member is required.
    public var repository: Swift.String?
    /// A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see [Working with upstream repositories](https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html).
    public var upstreams: [CodeartifactClientTypes.UpstreamRepository]?

    public init(
        description: Swift.String? = nil,
        domain: Swift.String? = nil,
        domainOwner: Swift.String? = nil,
        repository: Swift.String? = nil,
        upstreams: [CodeartifactClientTypes.UpstreamRepository]? = nil
    )
    {
        self.description = description
        self.domain = domain
        self.domainOwner = domainOwner
        self.repository = repository
        self.upstreams = upstreams
    }
}

struct UpdateRepositoryInputBody: Swift.Equatable {
    let description: Swift.String?
    let upstreams: [CodeartifactClientTypes.UpstreamRepository]?
}

extension UpdateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case upstreams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let upstreamsContainer = try containerValues.decodeIfPresent([CodeartifactClientTypes.UpstreamRepository?].self, forKey: .upstreams)
        var upstreamsDecoded0:[CodeartifactClientTypes.UpstreamRepository]? = nil
        if let upstreamsContainer = upstreamsContainer {
            upstreamsDecoded0 = [CodeartifactClientTypes.UpstreamRepository]()
            for structure0 in upstreamsContainer {
                if let structure0 = structure0 {
                    upstreamsDecoded0?.append(structure0)
                }
            }
        }
        upstreams = upstreamsDecoded0
    }
}

extension UpdateRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct UpdateRepositoryOutput: Swift.Equatable {
    /// The updated repository.
    public var repository: CodeartifactClientTypes.RepositoryDescription?

    public init(
        repository: CodeartifactClientTypes.RepositoryDescription? = nil
    )
    {
        self.repository = repository
    }
}

struct UpdateRepositoryOutputBody: Swift.Equatable {
    let repository: CodeartifactClientTypes.RepositoryDescription?
}

extension UpdateRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.RepositoryDescription.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum UpdateRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeartifactClientTypes.UpstreamRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about an upstream repository. A list of UpstreamRepository objects is an input parameter to [CreateRepository](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_CreateRepository.html) and [UpdateRepository](https://docs.aws.amazon.com/codeartifact/latest/APIReference/API_UpdateRepository.html).
    public struct UpstreamRepository: Swift.Equatable {
        /// The name of an upstream repository.
        /// This member is required.
        public var repositoryName: Swift.String?

        public init(
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension CodeartifactClientTypes.UpstreamRepositoryInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension CodeartifactClientTypes {
    /// Information about an upstream repository.
    public struct UpstreamRepositoryInfo: Swift.Equatable {
        /// The name of an upstream repository.
        public var repositoryName: Swift.String?

        public init(
            repositoryName: Swift.String? = nil
        )
        {
            self.repositoryName = repositoryName
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because a parameter in the request was sent with an invalid value.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        ///
        public internal(set) var reason: CodeartifactClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: CodeartifactClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: CodeartifactClientTypes.ValidationExceptionReason?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CodeartifactClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodeartifactClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case encryptionKeyError
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .encryptionKeyError,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .encryptionKeyError: return "ENCRYPTION_KEY_ERROR"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
