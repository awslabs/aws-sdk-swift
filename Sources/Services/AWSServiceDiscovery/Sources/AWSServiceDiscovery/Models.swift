//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox

public struct UpdateInstanceCustomHealthStatusOutput {

    public init() { }
}

/// The operation is already in progress.
public struct DuplicateRequest: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The ID of the operation that's already in progress.
        public internal(set) var duplicateOperationId: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRequest" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        duplicateOperationId: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.duplicateOperationId = duplicateOperationId
        self.properties.message = message
    }
}

/// One or more specified values aren't valid. For example, a required value might be missing, a numeric value might be outside the allowed range, or a string value might exceed length constraints.
public struct InvalidInput: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidInput" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The namespace that you're trying to create already exists.
public struct NamespaceAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The CreatorRequestId that was used to create the namespace.
        public internal(set) var creatorRequestId: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the existing namespace.
        public internal(set) var namespaceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NamespaceAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        namespaceId: Swift.String? = nil
    )
    {
        self.properties.creatorRequestId = creatorRequestId
        self.properties.message = message
        self.properties.namespaceId = namespaceId
    }
}

/// The resource can't be created because you've reached the quota on the number of resources.
public struct ResourceLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The list of tags on the resource is over the quota. The maximum number of tags that can be applied to a resource is 50.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension ServiceDiscoveryClientTypes {
    /// A custom key-value pair that's associated with a resource.
    public struct Tag {
        /// The key identifier, or name, of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The string value that's associated with the key of the tag. You can set the value of a tag to an empty string, but you can't set the value of a tag to null.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateHttpNamespaceInput {
    /// A unique string that identifies the request and that allows failed CreateHttpNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/time stamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.tags = tags
    }
}

public struct CreateHttpNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension ServiceDiscoveryClientTypes {
    /// Start of Authority (SOA) properties for a public or private DNS namespace.
    public struct SOA {
        /// The time to live (TTL) for purposes of negative caching.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ttl: Swift.Int? = nil
        )
        {
            self.ttl = ttl
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS namespace.
    public struct PrivateDnsPropertiesMutable {
        /// Fields for the Start of Authority (SOA) record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public var soa: ServiceDiscoveryClientTypes.SOA?

        public init(
            soa: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.soa = soa
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the private DNS namespace.
    public struct PrivateDnsNamespaceProperties {
        /// DNS properties for the private DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable?

        public init(
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

public struct CreatePrivateDnsNamespaceInput {
    /// A unique string that identifies the request and that allows failed CreatePrivateDnsNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace. When you create a private DNS namespace, Cloud Map automatically creates an Amazon Route 53 private hosted zone that has the same name as the namespace.
    /// This member is required.
    public var name: Swift.String?
    /// Properties for the private DNS namespace.
    public var properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?
    /// The ID of the Amazon VPC that you want to associate the namespace with.
    /// This member is required.
    public var vpc: Swift.String?

    public init(
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        vpc: Swift.String? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
        self.vpc = vpc
    }
}

public struct CreatePrivateDnsNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS namespace.
    public struct PublicDnsPropertiesMutable {
        /// Start of Authority (SOA) record for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var soa: ServiceDiscoveryClientTypes.SOA?

        public init(
            soa: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.soa = soa
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// DNS properties for the public DNS namespace.
    public struct PublicDnsNamespaceProperties {
        /// DNS properties for the public DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable?

        public init(
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

public struct CreatePublicDnsNamespaceInput {
    /// A unique string that identifies the request and that allows failed CreatePublicDnsNamespace requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the namespace.
    public var description: Swift.String?
    /// The name that you want to assign to this namespace. Do not include sensitive information in the name. The name is publicly available using DNS queries.
    /// This member is required.
    public var name: Swift.String?
    /// Properties for the public DNS namespace.
    public var properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?
    /// The tags to add to the namespace. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init(
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        properties: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.name = name
        self.properties = properties
        self.tags = tags
    }
}

public struct CreatePublicDnsNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// No namespace exists with the specified ID.
public struct NamespaceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NamespaceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service can't be created because a service with the same name already exists.
public struct ServiceAlreadyExists: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The CreatorRequestId that was used to create the service.
        public internal(set) var creatorRequestId: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the existing service.
        public internal(set) var serviceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        creatorRequestId: Swift.String? = nil,
        message: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.properties.creatorRequestId = creatorRequestId
        self.properties.message = message
        self.properties.serviceId = serviceId
    }
}

extension ServiceDiscoveryClientTypes {

    public enum RecordType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case a
        case aaaa
        case cname
        case srv
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordType] {
            return [
                .a,
                .aaaa,
                .cname,
                .srv
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .a: return "A"
            case .aaaa: return "AAAA"
            case .cname: return "CNAME"
            case .srv: return "SRV"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
    public struct DnsRecord {
        /// The amount of time, in seconds, that you want DNS resolvers to cache the settings for this record. Alias records don't include a TTL because Route 53 uses the TTL for the Amazon Web Services resource that an alias record routes traffic to. If you include the AWS_ALIAS_DNS_NAME attribute when you submit a [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request, the TTL value is ignored. Always specify a TTL for the service; you can use a service to register instances that create either alias or non-alias records.
        /// This member is required.
        public var ttl: Swift.Int?
        /// The type of the resource, which indicates the type of value that Route 53 returns in response to DNS queries. You can specify values for Type in the following combinations:
        ///
        /// * A
        ///
        /// * AAAA
        ///
        /// * A and AAAA
        ///
        /// * SRV
        ///
        /// * CNAME
        ///
        ///
        /// If you want Cloud Map to create a Route 53 alias record when you register an instance, specify A or AAAA for Type. You specify other settings, such as the IP address for A and AAAA records, when you register an instance. For more information, see [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html). The following values are supported: A Route 53 returns the IP address of the resource in IPv4 format, such as 192.0.2.44. AAAA Route 53 returns the IP address of the resource in IPv6 format, such as 2001:0db8:85a3:0000:0000:abcd:0001:2345. CNAME Route 53 returns the domain name of the resource, such as www.example.com. Note the following:
        ///
        /// * You specify the domain name that you want to route traffic to when you register an instance. For more information, see [Attributes](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html#cloudmap-RegisterInstance-request-Attributes) in the topic [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html).
        ///
        /// * You must specify WEIGHTED for the value of RoutingPolicy.
        ///
        /// * You can't specify both CNAME for Type and settings for HealthCheckConfig. If you do, the request will fail with an InvalidInput error.
        ///
        ///
        /// SRV Route 53 returns the value for an SRV record. The value for an SRV record uses the following values: priority weight port service-hostname Note the following about the values:
        ///
        /// * The values of priority and weight are both set to 1 and can't be changed.
        ///
        /// * The value of port comes from the value that you specify for the AWS_INSTANCE_PORT attribute when you submit a [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request.
        ///
        /// * The value of service-hostname is a concatenation of the following values:
        ///
        /// * The value that you specify for InstanceId when you register an instance.
        ///
        /// * The name of the service.
        ///
        /// * The name of the namespace.
        ///
        ///
        /// For example, if the value of InstanceId is test, the name of the service is backend, and the name of the namespace is example.com, the value of service-hostname is the following: test.backend.example.com
        ///
        ///
        /// If you specify settings for an SRV record, note the following:
        ///
        /// * If you specify values for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both in the RegisterInstance request, Cloud Map automatically creates A and/or AAAA records that have the same name as the value of service-hostname in the SRV record. You can ignore these records.
        ///
        /// * If you're using a system that requires a specific SRV format, such as HAProxy, see the [Name](https://docs.aws.amazon.com/cloud-map/latest/api/API_CreateService.html#cloudmap-CreateService-request-Name) element in the documentation about CreateService for information about how to specify the correct name format.
        /// This member is required.
        public var type: ServiceDiscoveryClientTypes.RecordType?

        public init(
            ttl: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.RecordType? = nil
        )
        {
            self.ttl = ttl
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {

    public enum RoutingPolicy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multivalue
        case weighted
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingPolicy] {
            return [
                .multivalue,
                .weighted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multivalue: return "MULTIVALUE"
            case .weighted: return "WEIGHTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the Amazon Route 53 DNS records that you want Cloud Map to create when you register an instance. The record types of a service can only be changed by deleting the service and recreating it with a new Dnsconfig.
    public struct DnsConfig {
        /// An array that contains one DnsRecord object for each Route 53 DNS record that you want Cloud Map to create when you register an instance.
        /// This member is required.
        public var dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?
        /// Use NamespaceId in [Service](https://docs.aws.amazon.com/cloud-map/latest/api/API_Service.html) instead. The ID of the namespace to use for DNS configuration.
        @available(*, deprecated, message: "Top level attribute in request should be used to reference namespace-id")
        public var namespaceId: Swift.String?
        /// The routing policy that you want to apply to all Route 53 DNS records that Cloud Map creates when you register an instance and specify this service. If you want to use this service to register instances that create alias records, specify WEIGHTED for the routing policy. You can specify the following values: MULTIVALUE If you define a health check for the service and the health check is healthy, Route 53 returns the applicable value for up to eight instances. For example, suppose that the service includes configurations for one A record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with IP addresses for up to eight healthy instances. If fewer than eight instances are healthy, Route 53 responds to every DNS query with the IP addresses for all of the healthy instances. If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns the values for up to eight instances. For more information about the multivalue routing policy, see [Multivalue Answer Routing](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-multivalue) in the Route 53 Developer Guide. WEIGHTED Route 53 returns the applicable value from one randomly selected instance from among the instances that you registered using the same service. Currently, all records have the same weight, so you can't route more or less traffic to any instances. For example, suppose that the service includes configurations for one A record and a health check. You use the service to register 10 instances. Route 53 responds to DNS queries with the IP address for one randomly selected instance from among the healthy instances. If no instances are healthy, Route 53 responds to DNS queries as if all of the instances were healthy. If you don't define a health check for the service, Route 53 assumes that all instances are healthy and returns the applicable value for one randomly selected instance. For more information about the weighted routing policy, see [Weighted Routing](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy.html#routing-policy-weighted) in the Route 53 Developer Guide.
        public var routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy?

        public init(
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil,
            namespaceId: Swift.String? = nil,
            routingPolicy: ServiceDiscoveryClientTypes.RoutingPolicy? = nil
        )
        {
            self.dnsRecords = dnsRecords
            self.namespaceId = namespaceId
            self.routingPolicy = routingPolicy
        }
    }

}

extension ServiceDiscoveryClientTypes {

    public enum HealthCheckType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case https
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckType] {
            return [
                .http,
                .https,
                .tcp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .https: return "HTTPS"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/). Note the following about configuring health checks. A and AAAA records If DnsConfig includes configurations for both A and AAAA records, Cloud Map creates a health check that uses the IPv4 address to check the health of the resource. If the endpoint tthat's specified by the IPv4 address is unhealthy, Route 53 considers both the A and AAAA records to be unhealthy. CNAME records You can't specify settings for HealthCheckConfig when the DNSConfig includes CNAME for the value of Type. If you do, the CreateService request will fail with an InvalidInput error. Request interval A Route 53 health checker in each health-checking Amazon Web Services Region sends a health check request to an endpoint every 30 seconds. On average, your endpoint receives a health check request about every two seconds. However, health checkers don't coordinate with one another. Therefore, you might sometimes see several requests in one second that's followed by a few seconds with no health checks at all. Health checking regions Health checkers perform checks from all Route 53 health-checking Regions. For a list of the current Regions, see [Regions](https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions). Alias records When you register an instance, if you include the AWS_ALIAS_DNS_NAME attribute, Cloud Map creates a Route 53 alias record. Note the following:
    ///
    /// * Route 53 automatically sets EvaluateTargetHealth to true for alias records. When EvaluateTargetHealth is true, the alias record inherits the health of the referenced Amazon Web Services resource. such as an ELB load balancer. For more information, see [EvaluateTargetHealth](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-EvaluateTargetHealth).
    ///
    /// * If you include HealthCheckConfig and then use the service to register an instance that creates an alias record, Route 53 doesn't create the health check.
    ///
    ///
    /// Charges for health checks Health checks are basic Route 53 health checks that monitor an Amazon Web Services endpoint. For information about pricing for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/).
    public struct HealthCheckConfig {
        /// The number of consecutive health checks that an endpoint must pass or fail for Route 53 to change the current status of the endpoint from unhealthy to healthy or the other way around. For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the Route 53 Developer Guide.
        public var failureThreshold: Swift.Int?
        /// The path that you want Route 53 to request when performing health checks. The path can be any value that your endpoint returns an HTTP status code of a 2xx or 3xx format for when the endpoint is healthy. An example file is /docs/route53-health-check.html. Route 53 automatically adds the DNS name for the service. If you don't specify a value for ResourcePath, the default value is /. If you specify TCP for Type, you must not specify a value for ResourcePath.
        public var resourcePath: Swift.String?
        /// The type of health check that you want to create, which indicates how Route 53 determines whether an endpoint is healthy. You can't change the value of Type after you create a health check. You can create the following types of health checks:
        ///
        /// * HTTP: Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTP request and waits for an HTTP status code of 200 or greater and less than 400.
        ///
        /// * HTTPS: Route 53 tries to establish a TCP connection. If successful, Route 53 submits an HTTPS request and waits for an HTTP status code of 200 or greater and less than 400. If you specify HTTPS for the value of Type, the endpoint must support TLS v1.0 or later.
        ///
        /// * TCP: Route 53 tries to establish a TCP connection. If you specify TCP for Type, don't specify a value for ResourcePath.
        ///
        ///
        /// For more information, see [How Route 53 Determines Whether an Endpoint Is Healthy](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html) in the Route 53 Developer Guide.
        /// This member is required.
        public var type: ServiceDiscoveryClientTypes.HealthCheckType?

        public init(
            failureThreshold: Swift.Int? = nil,
            resourcePath: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.HealthCheckType? = nil
        )
        {
            self.failureThreshold = failureThreshold
            self.resourcePath = resourcePath
            self.type = type
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an optional custom health check. A custom health check, which requires that you use a third-party health checker to evaluate the health of your resources, is useful in the following circumstances:
    ///
    /// * You can't use a health check that's defined by HealthCheckConfig because the resource isn't available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC. (To check the health of resources in a VPC, the health checker must also be in the VPC.)
    ///
    /// * You want to use a third-party health checker regardless of where your resources are located.
    ///
    ///
    /// If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. To change the status of a custom health check, submit an UpdateInstanceCustomHealthStatus request. Cloud Map doesn't monitor the status of the resource, it just keeps a record of the status specified in the most recent UpdateInstanceCustomHealthStatus request. Here's how custom health checks work:
    ///
    /// * You create a service.
    ///
    /// * You register an instance.
    ///
    /// * You configure a third-party health checker to monitor the resource that's associated with the new instance. Cloud Map doesn't check the health of the resource directly.
    ///
    /// * The third-party health-checker determines that the resource is unhealthy and notifies your application.
    ///
    /// * Your application submits an UpdateInstanceCustomHealthStatus request.
    ///
    /// * Cloud Map waits for 30 seconds.
    ///
    /// * If another UpdateInstanceCustomHealthStatus request doesn't arrive during that time to change the status back to healthy, Cloud Map stops routing traffic to the resource.
    public struct HealthCheckCustomConfig {
        /// This parameter is no longer supported and is always set to 1. Cloud Map waits for approximately 30 seconds after receiving an UpdateInstanceCustomHealthStatus request before changing the status of the service instance. The number of 30-second intervals that you want Cloud Map to wait after receiving an UpdateInstanceCustomHealthStatus request before it changes the health status of a service instance. Sending a second or subsequent UpdateInstanceCustomHealthStatus request with the same value before 30 seconds has passed doesn't accelerate the change. Cloud Map still waits 30 seconds after the first request to make the change.
        @available(*, deprecated, message: "Configurable FailureThreshold of HealthCheckCustomConfig is deprecated.  It will always have value 1.")
        public var failureThreshold: Swift.Int?

        public init(
            failureThreshold: Swift.Int? = nil
        )
        {
            self.failureThreshold = failureThreshold
        }
    }

}

extension ServiceDiscoveryClientTypes {

    public enum ServiceTypeOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceTypeOption] {
            return [
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateServiceInput {
    /// A unique string that identifies the request and that allows failed CreateService requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
    public var creatorRequestId: Swift.String?
    /// A description for the service.
    public var description: Swift.String?
    /// A complex type that contains information about the Amazon Route 53 records that you want Cloud Map to create when you register an instance.
    public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
    /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional Route 53 health check. If you specify settings for a health check, Cloud Map associates the health check with all the Route 53 DNS records that you specify in DnsConfig. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. For information about the charges for health checks, see [Cloud Map Pricing](http://aws.amazon.com/cloud-map/pricing/).
    public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
    /// A complex type that contains information about an optional custom health check. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both. You can't add, update, or delete a HealthCheckCustomConfig configuration from an existing service.
    public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
    /// The name that you want to assign to the service. Do not include sensitive information in the name if the namespace is discoverable by public DNS queries. If you want Cloud Map to create an SRV record when you register an instance and you're using a system that requires a specific SRV format, such as [HAProxy](http://www.haproxy.org/), specify the following for Name:
    ///
    /// * Start the name with an underscore (_), such as _exampleservice.
    ///
    /// * End the name with ._protocol, such as ._tcp.
    ///
    ///
    /// When you register an instance, Cloud Map creates an SRV record and assigns a name to the record by concatenating the service name and the namespace name (for example, _exampleservice._tcp.example.com). For services that are accessible by DNS queries, you can't create multiple services with names that differ only by case (such as EXAMPLE and example). Otherwise, these services have the same DNS name and can't be distinguished. However, if you use a namespace that's only accessible by API calls, then you can create services that with names that differ only by case.
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the namespace that you want to use to create the service. The namespace ID must be specified, but it can be specified either here or in the DnsConfig object.
    public var namespaceId: Swift.String?
    /// The tags to add to the service. Each tag consists of a key and an optional value that you define. Tags keys can be up to 128 characters in length, and tag values can be up to 256 characters in length.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?
    /// If present, specifies that the service instances are only discoverable using the DiscoverInstances API operation. No DNS records is registered for the service instances. The only valid value is HTTP.
    public var type: ServiceDiscoveryClientTypes.ServiceTypeOption?

    public init(
        creatorRequestId: Swift.String? = nil,
        description: Swift.String? = nil,
        dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
        healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
        healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
        name: Swift.String? = nil,
        namespaceId: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil,
        type: ServiceDiscoveryClientTypes.ServiceTypeOption? = nil
    )
    {
        self.creatorRequestId = creatorRequestId
        self.description = description
        self.dnsConfig = dnsConfig
        self.healthCheckConfig = healthCheckConfig
        self.healthCheckCustomConfig = healthCheckCustomConfig
        self.name = name
        self.namespaceId = namespaceId
        self.tags = tags
        self.type = type
    }
}

extension ServiceDiscoveryClientTypes {

    public enum ServiceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dns
        case dnsHttp
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceType] {
            return [
                .dns,
                .dnsHttp,
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dns: return "DNS"
            case .dnsHttp: return "DNS_HTTP"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the specified service.
    public struct Service {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public var arn: Swift.String?
        /// The date and time that the service was created, in Unix format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: Foundation.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running the operation twice. CreatorRequestId can be any unique string (for example, a date/timestamp).
        public var creatorRequestId: Swift.String?
        /// The description of the service.
        public var description: Swift.String?
        /// A complex type that contains information about the Route 53 DNS records that you want Cloud Map to create when you register an instance. The record types of a service can only be changed by deleting the service and recreating it with a new Dnsconfig.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// Public DNS and HTTP namespaces only. A complex type that contains settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig. For information about the charges for health checks, see [Amazon Route 53 Pricing](http://aws.amazon.com/route53/pricing/).
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// A complex type that contains information about an optional custom health check. If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
        public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public var id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously associated with the service but that are deleted aren't included in the count. The count might not reflect pending registrations and deregistrations.
        public var instanceCount: Swift.Int?
        /// The name of the service.
        public var name: Swift.String?
        /// The ID of the namespace that was used to create the service.
        public var namespaceId: Swift.String?
        /// Describes the systems that can be used to discover the service instances. DNS_HTTP The service instances can be discovered using either DNS queries or the DiscoverInstances API operation. HTTP The service instances can only be discovered using the DiscoverInstances API operation. DNS Reserved.
        public var type: ServiceDiscoveryClientTypes.ServiceType?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            namespaceId: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.namespaceId = namespaceId
            self.type = type
        }
    }

}

public struct CreateServiceOutput {
    /// A complex type that contains information about the new service.
    public var service: ServiceDiscoveryClientTypes.Service?

    public init(
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

/// The health check for the instance that's specified by ServiceId and InstanceId isn't a custom health check.
public struct CustomHealthNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CustomHealthNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceDiscoveryClientTypes {

    public enum CustomHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomHealthStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource can't be deleted because it contains other resources. For example, you can't delete a service that contains any instances.
public struct ResourceInUse: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUse" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteNamespaceInput {
    /// The ID of the namespace that you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// No service exists with the specified ID.
public struct ServiceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteServiceInput {
    /// The ID of the service that you want to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct DeleteServiceOutput {

    public init() { }
}

/// No instance exists with the specified ID, or the instance was recently registered, and information about the instance hasn't propagated yet.
public struct InstanceNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InstanceNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeregisterInstanceInput {
    /// The value that you specified for Id in the [RegisterInstance](https://docs.aws.amazon.com/cloud-map/latest/api/API_RegisterInstance.html) request.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

public struct DeregisterInstanceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

/// The operation can't be completed because you've reached the quota for the number of requests. For more information, see [Cloud Map API request throttling quota](https://docs.aws.amazon.com/cloud-map/latest/dg/throttling.html) in the Cloud Map Developer Guide.
public struct RequestLimitExceeded: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ServiceDiscoveryClientTypes {

    public enum HealthStatusFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case healthy
        case healthyOrElseAll
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatusFilter] {
            return [
                .all,
                .healthy,
                .healthyOrElseAll,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .healthy: return "HEALTHY"
            case .healthyOrElseAll: return "HEALTHY_OR_ELSE_ALL"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DiscoverInstancesInput {
    /// The health status of the instances that you want to discover. This parameter is ignored for services that don't have a health check configured, and all instances are returned. HEALTHY Returns healthy instances. UNHEALTHY Returns unhealthy instances. ALL Returns all instances. HEALTHY_OR_ELSE_ALL Returns healthy instances, unless none are reporting a healthy state. In that case, return all instances. This is also called failing open.
    public var healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter?
    /// The maximum number of instances that you want Cloud Map to return in the response to a DiscoverInstances request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// The HttpName name of the namespace. It's found in the HttpProperties member of the Properties member of the namespace. In most cases, Name and HttpName match. However, if you reuse Name for namespace creation, a generated hash is added to HttpName to distinguish the two.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// Opportunistic filters to scope the results based on custom attributes. If there are instances that match both the filters specified in both the QueryParameters parameter and this parameter, all of these instances are returned. Otherwise, the filters are ignored, and only instances that match the filters that are specified in the QueryParameters parameter are returned.
    public var optionalParameters: [Swift.String: Swift.String]?
    /// Filters to scope the results based on custom attributes for the instance (for example, {version=v1, az=1a}). Only instances that match all the specified key-value pairs are returned.
    public var queryParameters: [Swift.String: Swift.String]?
    /// The name of the service that you specified when you registered the instance.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        healthStatus: ServiceDiscoveryClientTypes.HealthStatusFilter? = nil,
        maxResults: Swift.Int? = nil,
        namespaceName: Swift.String? = nil,
        optionalParameters: [Swift.String: Swift.String]? = nil,
        queryParameters: [Swift.String: Swift.String]? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.healthStatus = healthStatus
        self.maxResults = maxResults
        self.namespaceName = namespaceName
        self.optionalParameters = optionalParameters
        self.queryParameters = queryParameters
        self.serviceName = serviceName
    }
}

extension ServiceDiscoveryClientTypes {

    public enum HealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthStatus] {
            return [
                .healthy,
                .unhealthy,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// In a response to a [DiscoverInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_DiscoverInstances.html) request, HttpInstanceSummary contains information about one instance that matches the values that you specified in the request.
    public struct HttpInstanceSummary {
        /// If you included any attributes when you registered the instance, the values of those attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// If you configured health checking in the service, the current health status of the service instance.
        public var healthStatus: ServiceDiscoveryClientTypes.HealthStatus?
        /// The ID of an instance that matches the values that you specified in the request.
        public var instanceId: Swift.String?
        /// The HttpName name of the namespace. It's found in the HttpProperties member of the Properties member of the namespace.
        public var namespaceName: Swift.String?
        /// The name of the service that you specified when you registered the instance.
        public var serviceName: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            healthStatus: ServiceDiscoveryClientTypes.HealthStatus? = nil,
            instanceId: Swift.String? = nil,
            namespaceName: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.healthStatus = healthStatus
            self.instanceId = instanceId
            self.namespaceName = namespaceName
            self.serviceName = serviceName
        }
    }

}

public struct DiscoverInstancesOutput {
    /// A complex type that contains one HttpInstanceSummary for each registered instance.
    public var instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]?
    /// The increasing revision associated to the response Instances list. If a new instance is registered or deregistered, the InstancesRevision updates. The health status updates don't update InstancesRevision.
    public var instancesRevision: Swift.Int?

    public init(
        instances: [ServiceDiscoveryClientTypes.HttpInstanceSummary]? = nil,
        instancesRevision: Swift.Int? = nil
    )
    {
        self.instances = instances
        self.instancesRevision = instancesRevision
    }
}

public struct DiscoverInstancesRevisionInput {
    /// The HttpName name of the namespace. It's found in the HttpProperties member of the Properties member of the namespace.
    /// This member is required.
    public var namespaceName: Swift.String?
    /// The name of the service that you specified when you registered the instance.
    /// This member is required.
    public var serviceName: Swift.String?

    public init(
        namespaceName: Swift.String? = nil,
        serviceName: Swift.String? = nil
    )
    {
        self.namespaceName = namespaceName
        self.serviceName = serviceName
    }
}

public struct DiscoverInstancesRevisionOutput {
    /// The increasing revision associated to the response Instances list. If a new instance is registered or deregistered, the InstancesRevision updates. The health status updates don't update InstancesRevision.
    public var instancesRevision: Swift.Int?

    public init(
        instancesRevision: Swift.Int? = nil
    )
    {
        self.instancesRevision = instancesRevision
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about changes to the Route 53 DNS records that Cloud Map creates when you register an instance.
    public struct DnsConfigChange {
        /// An array that contains one DnsRecord object for each Route 53 record that you want Cloud Map to create when you register an instance.
        /// This member is required.
        public var dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]?

        public init(
            dnsRecords: [ServiceDiscoveryClientTypes.DnsRecord]? = nil
        )
        {
            self.dnsRecords = dnsRecords
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
    public struct DnsProperties {
        /// The ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
        public var hostedZoneId: Swift.String?
        /// Start of Authority (SOA) record for the hosted zone.
        public var soa: ServiceDiscoveryClientTypes.SOA?

        public init(
            hostedZoneId: Swift.String? = nil,
            soa: ServiceDiscoveryClientTypes.SOA? = nil
        )
        {
            self.hostedZoneId = hostedZoneId
            self.soa = soa
        }
    }

}

extension ServiceDiscoveryClientTypes {

    public enum FilterCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case between
        case eq
        case `in`
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterCondition] {
            return [
                .beginsWith,
                .between,
                .eq,
                .in
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case .between: return "BETWEEN"
            case .eq: return "EQ"
            case .in: return "IN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetInstanceInput {
    /// The ID of the instance that you want to get information about.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an instance that Cloud Map creates when you submit a RegisterInstance request.
    public struct Instance {
        /// A string map that contains the following information for the service that you specify in ServiceId:
        ///
        /// * The attributes that apply to the records that are defined in the service.
        ///
        /// * For each attribute, the applicable value.
        ///
        ///
        /// Do not include sensitive information in the attributes if the namespace is discoverable by public DNS queries. Supported attribute keys include the following: AWS_ALIAS_DNS_NAME If you want Cloud Map to create a Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see [AliasTarget->DNSName](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html#Route53-Type-AliasTarget-DNSName) in the Route 53 API Reference. Note the following:
        ///
        /// * The configuration for the service that's specified by ServiceId must include settings for an A record, an AAAA record, or both.
        ///
        /// * In the service that's specified by ServiceId, the value of RoutingPolicy must be WEIGHTED.
        ///
        /// * If the service that's specified by ServiceId includes HealthCheckConfig settings, Cloud Map creates the health check, but it won't associate the health check with the alias record.
        ///
        /// * Auto naming currently doesn't support creating alias records that route traffic to Amazon Web Services resources other than ELB load balancers.
        ///
        /// * If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the AWS_INSTANCE attributes.
        ///
        ///
        /// AWS_EC2_INSTANCE_ID HTTP namespaces only. The Amazon EC2 instance ID for the instance. The AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries (for example, example.com). This value is required if the service specified by ServiceId includes settings for an CNAME record. AWS_INSTANCE_IPV4 If the service configuration includes an A record, the IPv4 address that you want Route 53 to return in response to DNS queries (for example, 192.0.2.44). This value is required if the service specified by ServiceId includes settings for an A record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_IPV6 If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). This value is required if the service specified by ServiceId includes settings for an AAAA record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_PORT If the service includes an SRV record, the value that you want Route 53 to return for the port. If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an SRV record or a Route 53 health check when you created the service.
        public var attributes: [Swift.String: Swift.String]?
        /// A unique string that identifies the request and that allows failed RegisterInstance requests to be retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string every time you submit a RegisterInstance request if you're registering additional instances for the same namespace and service. CreatorRequestId can be any unique string (for example, a date/time stamp).
        public var creatorRequestId: Swift.String?
        /// An identifier that you want to associate with the instance. Note the following:
        ///
        /// * If the service that's specified by ServiceId includes settings for an SRV record, the value of InstanceId is automatically included as part of the value for the SRV record. For more information, see [DnsRecord > Type](https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type).
        ///
        /// * You can use this value to update an existing instance.
        ///
        /// * To register a new instance, you must specify a value that's unique among instances that you register by using the same service.
        ///
        /// * If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing DNS records. If there's also an existing health check, Cloud Map deletes the old health check and creates a new one. The health check isn't deleted immediately, so it will still appear for a while if you submit a ListHealthChecks request, for example.
        /// This member is required.
        public var id: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            creatorRequestId: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.creatorRequestId = creatorRequestId
            self.id = id
        }
    }

}

public struct GetInstanceOutput {
    /// A complex type that contains information about a specified instance.
    public var instance: ServiceDiscoveryClientTypes.Instance?

    public init(
        instance: ServiceDiscoveryClientTypes.Instance? = nil
    )
    {
        self.instance = instance
    }
}

public struct GetInstancesHealthStatusInput {
    /// An array that contains the IDs of all the instances that you want to get the health status for. If you omit Instances, Cloud Map returns the health status for all the instances that are associated with the specified service. To get the IDs for the instances that you've registered by using a specified service, submit a [ListInstances](https://docs.aws.amazon.com/cloud-map/latest/api/API_ListInstances.html) request.
    public var instances: [Swift.String]?
    /// The maximum number of instances that you want Cloud Map to return in the response to a GetInstancesHealthStatus request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// For the first GetInstancesHealthStatus request, omit this value. If more than MaxResults instances match the specified criteria, you can submit another GetInstancesHealthStatus request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// The ID of the service that the instance is associated with.
    /// This member is required.
    public var serviceId: Swift.String?

    public init(
        instances: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.instances = instances
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

public struct GetInstancesHealthStatusOutput {
    /// If more than MaxResults instances match the specified criteria, you can submit another GetInstancesHealthStatus request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// A complex type that contains the IDs and the health status of the instances that you specified in the GetInstancesHealthStatus request.
    public var status: [Swift.String: ServiceDiscoveryClientTypes.HealthStatus]?

    public init(
        nextToken: Swift.String? = nil,
        status: [Swift.String: ServiceDiscoveryClientTypes.HealthStatus]? = nil
    )
    {
        self.nextToken = nextToken
        self.status = status
    }
}

public struct GetNamespaceInput {
    /// The ID of the namespace that you want to get information about.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains the name of an HTTP namespace.
    public struct HttpProperties {
        /// The name of an HTTP namespace.
        public var httpName: Swift.String?

        public init(
            httpName: Swift.String? = nil
        )
        {
            self.httpName = httpName
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information that's specific to the namespace type.
    public struct NamespaceProperties {
        /// A complex type that contains the ID for the Route 53 hosted zone that Cloud Map creates when you create a namespace.
        public var dnsProperties: ServiceDiscoveryClientTypes.DnsProperties?
        /// A complex type that contains the name of an HTTP namespace.
        public var httpProperties: ServiceDiscoveryClientTypes.HttpProperties?

        public init(
            dnsProperties: ServiceDiscoveryClientTypes.DnsProperties? = nil,
            httpProperties: ServiceDiscoveryClientTypes.HttpProperties? = nil
        )
        {
            self.dnsProperties = dnsProperties
            self.httpProperties = httpProperties
        }
    }

}

extension ServiceDiscoveryClientTypes {

    public enum NamespaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dnsPrivate
        case dnsPublic
        case http
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceType] {
            return [
                .dnsPrivate,
                .dnsPublic,
                .http
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dnsPrivate: return "DNS_PRIVATE"
            case .dnsPublic: return "DNS_PUBLIC"
            case .http: return "HTTP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified namespace.
    public struct Namespace {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public var arn: Swift.String?
        /// The date that the namespace was created, in Unix date/time format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: Foundation.Date?
        /// A unique string that identifies the request and that allows failed requests to be retried without the risk of running an operation twice.
        public var creatorRequestId: Swift.String?
        /// The description that you specify for the namespace when you create it.
        public var description: Swift.String?
        /// The ID of a namespace.
        public var id: Swift.String?
        /// The name of the namespace, such as example.com.
        public var name: Swift.String?
        /// A complex type that contains information that's specific to the type of the namespace.
        public var properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that are associated with the namespace.
        public var serviceCount: Swift.Int?
        /// The type of the namespace. The methods for discovering instances depends on the value that you specify: HTTP Instances can be discovered only programmatically, using the Cloud Map DiscoverInstances API. DNS_PUBLIC Instances can be discovered using public DNS queries and using the DiscoverInstances API. DNS_PRIVATE Instances can be discovered using DNS queries in VPCs and using the DiscoverInstances API.
        public var type: ServiceDiscoveryClientTypes.NamespaceType?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            creatorRequestId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.creatorRequestId = creatorRequestId
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

public struct GetNamespaceOutput {
    /// A complex type that contains information about the specified namespace.
    public var namespace: ServiceDiscoveryClientTypes.Namespace?

    public init(
        namespace: ServiceDiscoveryClientTypes.Namespace? = nil
    )
    {
        self.namespace = namespace
    }
}

/// No operation exists with the specified ID.
public struct OperationNotFound: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetOperationInput {
    /// The ID of the operation that you want to get more information about.
    /// This member is required.
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension ServiceDiscoveryClientTypes {

    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fail
        case pending
        case submitted
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .fail,
                .pending,
                .submitted,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fail: return "FAIL"
            case .pending: return "PENDING"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {

    public enum OperationTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instance
        case namespace
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationTargetType] {
            return [
                .instance,
                .namespace,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instance: return "INSTANCE"
            case .namespace: return "NAMESPACE"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {

    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createNamespace
        case deleteNamespace
        case deregisterInstance
        case registerInstance
        case updateNamespace
        case updateService
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createNamespace,
                .deleteNamespace,
                .deregisterInstance,
                .registerInstance,
                .updateNamespace,
                .updateService
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createNamespace: return "CREATE_NAMESPACE"
            case .deleteNamespace: return "DELETE_NAMESPACE"
            case .deregisterInstance: return "DEREGISTER_INSTANCE"
            case .registerInstance: return "REGISTER_INSTANCE"
            case .updateNamespace: return "UPDATE_NAMESPACE"
            case .updateService: return "UPDATE_SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified operation.
    public struct Operation {
        /// The date and time that the request was submitted, in Unix date/time format and Coordinated Universal Time (UTC). The value of CreateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var createDate: Foundation.Date?
        /// The code associated with ErrorMessage. Values for ErrorCode include the following:
        ///
        /// * ACCESS_DENIED
        ///
        /// * CANNOT_CREATE_HOSTED_ZONE
        ///
        /// * EXPIRED_TOKEN
        ///
        /// * HOSTED_ZONE_NOT_FOUND
        ///
        /// * INTERNAL_FAILURE
        ///
        /// * INVALID_CHANGE_BATCH
        ///
        /// * THROTTLED_REQUEST
        public var errorCode: Swift.String?
        /// If the value of Status is FAIL, the reason that the operation failed.
        public var errorMessage: Swift.String?
        /// The ID of the operation that you want to get information about.
        public var id: Swift.String?
        /// The status of the operation. Values include the following: SUBMITTED This is the initial state that occurs immediately after you submit a request. PENDING Cloud Map is performing the operation. SUCCESS The operation succeeded. FAIL The operation failed. For the failure reason, see ErrorMessage.
        public var status: ServiceDiscoveryClientTypes.OperationStatus?
        /// The name of the target entity that's associated with the operation: NAMESPACE The namespace ID is returned in the ResourceId property. SERVICE The service ID is returned in the ResourceId property. INSTANCE The instance ID is returned in the ResourceId property.
        public var targets: [Swift.String: Swift.String]?
        /// The name of the operation that's associated with the specified ID.
        public var type: ServiceDiscoveryClientTypes.OperationType?
        /// The date and time that the value of Status changed to the current value, in Unix date/time format and Coordinated Universal Time (UTC). The value of UpdateDate is accurate to milliseconds. For example, the value 1516925490.087 represents Friday, January 26, 2018 12:11:30.087 AM.
        public var updateDate: Foundation.Date?

        public init(
            createDate: Foundation.Date? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil,
            targets: [Swift.String: Swift.String]? = nil,
            type: ServiceDiscoveryClientTypes.OperationType? = nil,
            updateDate: Foundation.Date? = nil
        )
        {
            self.createDate = createDate
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
            self.status = status
            self.targets = targets
            self.type = type
            self.updateDate = updateDate
        }
    }

}

public struct GetOperationOutput {
    /// A complex type that contains information about the operation.
    public var operation: ServiceDiscoveryClientTypes.Operation?

    public init(
        operation: ServiceDiscoveryClientTypes.Operation? = nil
    )
    {
        self.operation = operation
    }
}

public struct GetServiceInput {
    /// The ID of the service that you want to get settings for.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetServiceOutput {
    /// A complex type that contains information about the service.
    public var service: ServiceDiscoveryClientTypes.Service?

    public init(
        service: ServiceDiscoveryClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the HTTP namespace.
    public struct HttpNamespaceChange {
        /// An updated description for the HTTP namespace.
        /// This member is required.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        )
        {
            self.description = description
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about the instances that you registered by using a specified service.
    public struct InstanceSummary {
        /// A string map that contains the following information:
        ///
        /// * The attributes that are associated with the instance.
        ///
        /// * For each attribute, the applicable value.
        ///
        ///
        /// Supported attribute keys include the following: AWS_ALIAS_DNS_NAME For an alias record that routes traffic to an Elastic Load Balancing load balancer, the DNS name that's associated with the load balancer. AWS_EC2_INSTANCE_ID (HTTP namespaces only) The Amazon EC2 instance ID for the instance. When the AWS_EC2_INSTANCE_ID attribute is specified, then the AWS_INSTANCE_IPV4 attribute contains the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME For a CNAME record, the domain name that Route 53 returns in response to DNS queries (for example, example.com). AWS_INSTANCE_IPV4 For an A record, the IPv4 address that Route 53 returns in response to DNS queries (for example, 192.0.2.44). AWS_INSTANCE_IPV6 For an AAAA record, the IPv6 address that Route 53 returns in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). AWS_INSTANCE_PORT For an SRV record, the value that Route 53 returns for the port. In addition, if the service includes HealthCheckConfig, the port on the endpoint that Route 53 sends requests to.
        public var attributes: [Swift.String: Swift.String]?
        /// The ID for an instance that you created by using a specified service.
        public var id: Swift.String?

        public init(
            attributes: [Swift.String: Swift.String]? = nil,
            id: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.id = id
        }
    }

}

public struct ListInstancesInput {
    /// The maximum number of instances that you want Cloud Map to return in the response to a ListInstances request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 instances.
    public var maxResults: Swift.Int?
    /// For the first ListInstances request, omit this value. If more than MaxResults instances match the specified criteria, you can submit another ListInstances request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?
    /// The ID of the service that you want to list instances for.
    /// This member is required.
    public var serviceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceId = serviceId
    }
}

public struct ListInstancesOutput {
    /// Summary information about the instances that are associated with the specified service.
    public var instances: [ServiceDiscoveryClientTypes.InstanceSummary]?
    /// If more than MaxResults instances match the specified criteria, you can submit another ListInstances request to get the next group of results. Specify the value of NextToken from the previous response in the next request.
    public var nextToken: Swift.String?

    public init(
        instances: [ServiceDiscoveryClientTypes.InstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

extension ServiceDiscoveryClientTypes {

    public enum NamespaceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case httpName
        case name
        case type
        case sdkUnknown(Swift.String)

        public static var allCases: [NamespaceFilterName] {
            return [
                .httpName,
                .name,
                .type
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .httpName: return "HTTP_NAME"
            case .name: return "NAME"
            case .type: return "TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that identifies the namespaces that you want to list. You can choose to list public or private namespaces.
    public struct NamespaceFilter {
        /// Specify the operator that you want to use to determine whether a namespace matches the specified value. Valid values for Condition are one of the following.
        ///
        /// * EQ: When you specify EQ for Condition, you can specify only one value. EQ is supported for TYPE, NAME, and HTTP_NAME. EQ is the default condition and can be omitted.
        ///
        /// * BEGINS_WITH: When you specify BEGINS_WITH for Condition, you can specify only one value. BEGINS_WITH is supported for TYPE, NAME, and HTTP_NAME.
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify the namespaces that you want to get using one of the following.
        ///
        /// * TYPE: Gets the namespaces of the specified type.
        ///
        /// * NAME: Gets the namespaces with the specified name.
        ///
        /// * HTTP_NAME: Gets the namespaces with the specified HTTP name.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.NamespaceFilterName?
        /// Specify the values that are applicable to the value that you specify for Name.
        ///
        /// * TYPE: Specify HTTP, DNS_PUBLIC, or DNS_PRIVATE.
        ///
        /// * NAME: Specify the name of the namespace, which is found in Namespace.Name.
        ///
        /// * HTTP_NAME: Specify the HTTP name of the namespace, which is found in Namespace.Properties.HttpProperties.HttpName.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.NamespaceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

public struct ListNamespacesInput {
    /// A complex type that contains specifications for the namespaces that you want to list. If you specify more than one filter, a namespace must match all filters to be returned by ListNamespaces.
    public var filters: [ServiceDiscoveryClientTypes.NamespaceFilter]?
    /// The maximum number of namespaces that you want Cloud Map to return in the response to a ListNamespaces request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 namespaces.
    public var maxResults: Swift.Int?
    /// For the first ListNamespaces request, omit this value. If the response contains NextToken, submit another ListNamespaces request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    public var nextToken: Swift.String?

    public init(
        filters: [ServiceDiscoveryClientTypes.NamespaceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a namespace.
    public struct NamespaceSummary {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the namespace when you create it.
        public var arn: Swift.String?
        /// The date and time that the namespace was created.
        public var createDate: Foundation.Date?
        /// A description for the namespace.
        public var description: Swift.String?
        /// The ID of the namespace.
        public var id: Swift.String?
        /// The name of the namespace. When you create a namespace, Cloud Map automatically creates a Route 53 hosted zone that has the same name as the namespace.
        public var name: Swift.String?
        /// The properties of the namespace.
        public var properties: ServiceDiscoveryClientTypes.NamespaceProperties?
        /// The number of services that were created using the namespace.
        public var serviceCount: Swift.Int?
        /// The type of the namespace, either public or private.
        public var type: ServiceDiscoveryClientTypes.NamespaceType?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.NamespaceProperties? = nil,
            serviceCount: Swift.Int? = nil,
            type: ServiceDiscoveryClientTypes.NamespaceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.serviceCount = serviceCount
            self.type = type
        }
    }

}

public struct ListNamespacesOutput {
    /// An array that contains one NamespaceSummary object for each namespace that matches the specified filter criteria.
    public var namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]?
    /// If the response contains NextToken, submit another ListNamespaces request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults namespaces and then filters them based on the specified criteria. It's possible that no namespaces in the first MaxResults namespaces matched the specified criteria but that subsequent groups of MaxResults namespaces do contain namespaces that match the criteria.
    public var nextToken: Swift.String?

    public init(
        namespaces: [ServiceDiscoveryClientTypes.NamespaceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

extension ServiceDiscoveryClientTypes {

    public enum OperationFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case namespaceId
        case serviceId
        case status
        case type
        case updateDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationFilterName] {
            return [
                .namespaceId,
                .serviceId,
                .status,
                .type,
                .updateDate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case .serviceId: return "SERVICE_ID"
            case .status: return "STATUS"
            case .type: return "TYPE"
            case .updateDate: return "UPDATE_DATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you select the operations that you want to list.
    public struct OperationFilter {
        /// The operator that you want to use to determine whether an operation matches the specified value. Valid values for condition include:
        ///
        /// * EQ: When you specify EQ for the condition, you can specify only one value. EQ is supported for NAMESPACE_ID, SERVICE_ID, STATUS, and TYPE. EQ is the default condition and can be omitted.
        ///
        /// * IN: When you specify IN for the condition, you can specify a list of one or more values. IN is supported for STATUS and TYPE. An operation must match one of the specified values to be returned in the response.
        ///
        /// * BETWEEN: Specify a start date and an end date in Unix date/time format and Coordinated Universal Time (UTC). The start date must be the first value. BETWEEN is supported for UPDATE_DATE.
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify the operations that you want to get:
        ///
        /// * NAMESPACE_ID: Gets operations related to specified namespaces.
        ///
        /// * SERVICE_ID: Gets operations related to specified services.
        ///
        /// * STATUS: Gets operations based on the status of the operations: SUBMITTED, PENDING, SUCCEED, or FAIL.
        ///
        /// * TYPE: Gets specified types of operation.
        ///
        /// * UPDATE_DATE: Gets operations that changed status during a specified date/time range.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.OperationFilterName?
        /// Specify values that are applicable to the value that you specify for Name:
        ///
        /// * NAMESPACE_ID: Specify one namespace ID.
        ///
        /// * SERVICE_ID: Specify one service ID.
        ///
        /// * STATUS: Specify one or more statuses: SUBMITTED, PENDING, SUCCEED, or FAIL.
        ///
        /// * TYPE: Specify one or more of the following types: CREATE_NAMESPACE, DELETE_NAMESPACE, UPDATE_SERVICE, REGISTER_INSTANCE, or DEREGISTER_INSTANCE.
        ///
        /// * UPDATE_DATE: Specify a start date and an end date in Unix date/time format and Coordinated Universal Time (UTC). The start date must be the first value.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.OperationFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

public struct ListOperationsInput {
    /// A complex type that contains specifications for the operations that you want to list, for example, operations that you started between a specified start date and end date. If you specify more than one filter, an operation must match all filters to be returned by ListOperations.
    public var filters: [ServiceDiscoveryClientTypes.OperationFilter]?
    /// The maximum number of items that you want Cloud Map to return in the response to a ListOperations request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 operations.
    public var maxResults: Swift.Int?
    /// For the first ListOperations request, omit this value. If the response contains NextToken, submit another ListOperations request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's possible that no operations in the first MaxResults operations matched the specified criteria but that subsequent groups of MaxResults operations do contain operations that match the criteria.
    public var nextToken: Swift.String?

    public init(
        filters: [ServiceDiscoveryClientTypes.OperationFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about an operation that matches the criteria that you specified in a [ListOperations](https://docs.aws.amazon.com/cloud-map/latest/api/API_ListOperations.html) request.
    public struct OperationSummary {
        /// The ID for an operation.
        public var id: Swift.String?
        /// The status of the operation. Values include the following:
        ///
        /// * SUBMITTED: This is the initial state immediately after you submit a request.
        ///
        /// * PENDING: Cloud Map is performing the operation.
        ///
        /// * SUCCESS: The operation succeeded.
        ///
        /// * FAIL: The operation failed. For the failure reason, see ErrorMessage.
        public var status: ServiceDiscoveryClientTypes.OperationStatus?

        public init(
            id: Swift.String? = nil,
            status: ServiceDiscoveryClientTypes.OperationStatus? = nil
        )
        {
            self.id = id
            self.status = status
        }
    }

}

public struct ListOperationsOutput {
    /// If the response contains NextToken, submit another ListOperations request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults operations and then filters them based on the specified criteria. It's possible that no operations in the first MaxResults operations matched the specified criteria but that subsequent groups of MaxResults operations do contain operations that match the criteria.
    public var nextToken: Swift.String?
    /// Summary information about the operations that match the specified criteria.
    public var operations: [ServiceDiscoveryClientTypes.OperationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        operations: [ServiceDiscoveryClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operations = operations
    }
}

extension ServiceDiscoveryClientTypes {

    public enum ServiceFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case namespaceId
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceFilterName] {
            return [
                .namespaceId
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .namespaceId: return "NAMESPACE_ID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that lets you specify the namespaces that you want to list services for.
    public struct ServiceFilter {
        /// The operator that you want to use to determine whether a service is returned by ListServices. Valid values for Condition include the following:
        ///
        /// * EQ: When you specify EQ, specify one namespace ID for Values. EQ is the default condition and can be omitted.
        public var condition: ServiceDiscoveryClientTypes.FilterCondition?
        /// Specify NAMESPACE_ID.
        /// This member is required.
        public var name: ServiceDiscoveryClientTypes.ServiceFilterName?
        /// The values that are applicable to the value that you specify for Condition to filter the list of services.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: ServiceDiscoveryClientTypes.FilterCondition? = nil,
            name: ServiceDiscoveryClientTypes.ServiceFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

public struct ListServicesInput {
    /// A complex type that contains specifications for the namespaces that you want to list services for. If you specify more than one filter, an operation must match all filters to be returned by ListServices.
    public var filters: [ServiceDiscoveryClientTypes.ServiceFilter]?
    /// The maximum number of services that you want Cloud Map to return in the response to a ListServices request. If you don't specify a value for MaxResults, Cloud Map returns up to 100 services.
    public var maxResults: Swift.Int?
    /// For the first ListServices request, omit this value. If the response contains NextToken, submit another ListServices request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's possible that no services in the first MaxResults services matched the specified criteria but that subsequent groups of MaxResults services do contain services that match the criteria.
    public var nextToken: Swift.String?

    public init(
        filters: [ServiceDiscoveryClientTypes.ServiceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains information about a specified service.
    public struct ServiceSummary {
        /// The Amazon Resource Name (ARN) that Cloud Map assigns to the service when you create it.
        public var arn: Swift.String?
        /// The date and time that the service was created.
        public var createDate: Foundation.Date?
        /// The description that you specify when you create the service.
        public var description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfig?
        /// Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig.
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?
        /// Information about an optional custom health check. A custom health check, which requires that you use a third-party health checker to evaluate the health of your resources, is useful in the following circumstances:
        ///
        /// * You can't use a health check that's defined by HealthCheckConfig because the resource isn't available over the internet. For example, you can use a custom health check when the instance is in an Amazon VPC. (To check the health of resources in a VPC, the health checker must also be in the VPC.)
        ///
        /// * You want to use a third-party health checker regardless of where your resources are located.
        ///
        ///
        /// If you specify a health check configuration, you can specify either HealthCheckCustomConfig or HealthCheckConfig but not both.
        public var healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?
        /// The ID that Cloud Map assigned to the service when you created it.
        public var id: Swift.String?
        /// The number of instances that are currently associated with the service. Instances that were previously associated with the service but that are deleted aren't included in the count. The count might not reflect pending registrations and deregistrations.
        public var instanceCount: Swift.Int?
        /// The name of the service.
        public var name: Swift.String?
        /// Describes the systems that can be used to discover the service instances. DNS_HTTP The service instances can be discovered using either DNS queries or the DiscoverInstances API operation. HTTP The service instances can only be discovered using the DiscoverInstances API operation. DNS Reserved.
        public var type: ServiceDiscoveryClientTypes.ServiceType?

        public init(
            arn: Swift.String? = nil,
            createDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfig? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil,
            healthCheckCustomConfig: ServiceDiscoveryClientTypes.HealthCheckCustomConfig? = nil,
            id: Swift.String? = nil,
            instanceCount: Swift.Int? = nil,
            name: Swift.String? = nil,
            type: ServiceDiscoveryClientTypes.ServiceType? = nil
        )
        {
            self.arn = arn
            self.createDate = createDate
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
            self.healthCheckCustomConfig = healthCheckCustomConfig
            self.id = id
            self.instanceCount = instanceCount
            self.name = name
            self.type = type
        }
    }

}

public struct ListServicesOutput {
    /// If the response contains NextToken, submit another ListServices request to get the next group of results. Specify the value of NextToken from the previous response in the next request. Cloud Map gets MaxResults services and then filters them based on the specified criteria. It's possible that no services in the first MaxResults services matched the specified criteria but that subsequent groups of MaxResults services do contain services that match the criteria.
    public var nextToken: Swift.String?
    /// An array that contains one ServiceSummary object for each service that matches the specified filter criteria.
    public var services: [ServiceDiscoveryClientTypes.ServiceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        services: [ServiceDiscoveryClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.services = services
    }
}

/// The operation can't be completed because the resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The tags that are assigned to the resource.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init(
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension ServiceDiscoveryClientTypes {
    /// Updated Start of Authority (SOA) properties for a public or private DNS namespace.
    public struct SOAChange {
        /// The updated time to live (TTL) for purposes of negative caching.
        /// This member is required.
        public var ttl: Swift.Int?

        public init(
            ttl: Swift.Int? = nil
        )
        {
            self.ttl = ttl
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the private DNS namespace.
    public struct PrivateDnsPropertiesMutableChange {
        /// Updated fields for the Start of Authority (SOA) record for the hosted zone for the private DNS namespace.
        /// This member is required.
        public var soa: ServiceDiscoveryClientTypes.SOAChange?

        public init(
            soa: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.soa = soa
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS namespace.
    public struct PrivateDnsNamespacePropertiesChange {
        /// Updated DNS properties for the private DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange?

        public init(
            dnsProperties: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the private DNS namespace.
    public struct PrivateDnsNamespaceChange {
        /// An updated description for the private DNS namespace.
        public var description: Swift.String?
        /// Properties to be updated in the private DNS namespace.
        public var properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange?

        public init(
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated DNS properties for the public DNS namespace.
    public struct PublicDnsPropertiesMutableChange {
        /// Updated fields for the Start of Authority (SOA) record for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var soa: ServiceDiscoveryClientTypes.SOAChange?

        public init(
            soa: ServiceDiscoveryClientTypes.SOAChange? = nil
        )
        {
            self.soa = soa
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS namespace.
    public struct PublicDnsNamespacePropertiesChange {
        /// Updated DNS properties for the hosted zone for the public DNS namespace.
        /// This member is required.
        public var dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange?

        public init(
            dnsProperties: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange? = nil
        )
        {
            self.dnsProperties = dnsProperties
        }
    }

}

extension ServiceDiscoveryClientTypes {
    /// Updated properties for the public DNS namespace.
    public struct PublicDnsNamespaceChange {
        /// An updated description for the public DNS namespace.
        public var description: Swift.String?
        /// Properties to be updated in the public DNS namespace.
        public var properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange?

        public init(
            description: Swift.String? = nil,
            properties: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange? = nil
        )
        {
            self.description = description
            self.properties = properties
        }
    }

}

public struct RegisterInstanceInput {
    /// A string map that contains the following information for the service that you specify in ServiceId:
    ///
    /// * The attributes that apply to the records that are defined in the service.
    ///
    /// * For each attribute, the applicable value.
    ///
    ///
    /// Do not include sensitive information in the attributes if the namespace is discoverable by public DNS queries. The following are the supported attribute keys. AWS_ALIAS_DNS_NAME If you want Cloud Map to create an Amazon Route 53 alias record that routes traffic to an Elastic Load Balancing load balancer, specify the DNS name that's associated with the load balancer. For information about how to get the DNS name, see "DNSName" in the topic [AliasTarget](https://docs.aws.amazon.com/Route53/latest/APIReference/API_AliasTarget.html) in the Route 53 API Reference. Note the following:
    ///
    /// * The configuration for the service that's specified by ServiceId must include settings for an A record, an AAAA record, or both.
    ///
    /// * In the service that's specified by ServiceId, the value of RoutingPolicy must be WEIGHTED.
    ///
    /// * If the service that's specified by ServiceId includes HealthCheckConfig settings, Cloud Map will create the Route 53 health check, but it doesn't associate the health check with the alias record.
    ///
    /// * Cloud Map currently doesn't support creating alias records that route traffic to Amazon Web Services resources other than Elastic Load Balancing load balancers.
    ///
    /// * If you specify a value for AWS_ALIAS_DNS_NAME, don't specify values for any of the AWS_INSTANCE attributes.
    ///
    /// * The AWS_ALIAS_DNS_NAME is not supported in the GovCloud (US) Regions.
    ///
    ///
    /// AWS_EC2_INSTANCE_ID HTTP namespaces only. The Amazon EC2 instance ID for the instance. If the AWS_EC2_INSTANCE_ID attribute is specified, then the only other attribute that can be specified is AWS_INIT_HEALTH_STATUS. When the AWS_EC2_INSTANCE_ID attribute is specified, then the AWS_INSTANCE_IPV4 attribute will be filled out with the primary private IPv4 address. AWS_INIT_HEALTH_STATUS If the service configuration includes HealthCheckCustomConfig, you can optionally use AWS_INIT_HEALTH_STATUS to specify the initial status of the custom health check, HEALTHY or UNHEALTHY. If you don't specify a value for AWS_INIT_HEALTH_STATUS, the initial status is HEALTHY. AWS_INSTANCE_CNAME If the service configuration includes a CNAME record, the domain name that you want Route 53 to return in response to DNS queries (for example, example.com). This value is required if the service specified by ServiceId includes settings for an CNAME record. AWS_INSTANCE_IPV4 If the service configuration includes an A record, the IPv4 address that you want Route 53 to return in response to DNS queries (for example, 192.0.2.44). This value is required if the service specified by ServiceId includes settings for an A record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_IPV6 If the service configuration includes an AAAA record, the IPv6 address that you want Route 53 to return in response to DNS queries (for example, 2001:0db8:85a3:0000:0000:abcd:0001:2345). This value is required if the service specified by ServiceId includes settings for an AAAA record. If the service includes settings for an SRV record, you must specify a value for AWS_INSTANCE_IPV4, AWS_INSTANCE_IPV6, or both. AWS_INSTANCE_PORT If the service includes an SRV record, the value that you want Route 53 to return for the port. If the service includes HealthCheckConfig, the port on the endpoint that you want Route 53 to send requests to. This value is required if you specified settings for an SRV record or a Route 53 health check when you created the service. Custom attributes You can add up to 30 custom attributes. For each key-value pair, the maximum length of the attribute name is 255 characters, and the maximum length of the attribute value is 1,024 characters. The total size of all provided attributes (sum of all keys and values) must not exceed 5,000 characters.
    /// This member is required.
    public var attributes: [Swift.String: Swift.String]?
    /// A unique string that identifies the request and that allows failed RegisterInstance requests to be retried without the risk of executing the operation twice. You must use a unique CreatorRequestId string every time you submit a RegisterInstance request if you're registering additional instances for the same namespace and service. CreatorRequestId can be any unique string (for example, a date/time stamp).
    public var creatorRequestId: Swift.String?
    /// An identifier that you want to associate with the instance. Note the following:
    ///
    /// * If the service that's specified by ServiceId includes settings for an SRV record, the value of InstanceId is automatically included as part of the value for the SRV record. For more information, see [DnsRecord > Type](https://docs.aws.amazon.com/cloud-map/latest/api/API_DnsRecord.html#cloudmap-Type-DnsRecord-Type).
    ///
    /// * You can use this value to update an existing instance.
    ///
    /// * To register a new instance, you must specify a value that's unique among instances that you register by using the same service.
    ///
    /// * If you specify an existing InstanceId and ServiceId, Cloud Map updates the existing DNS records, if any. If there's also an existing health check, Cloud Map deletes the old health check and creates a new one. The health check isn't deleted immediately, so it will still appear for a while if you submit a ListHealthChecks request, for example.
    ///
    ///
    /// Do not include sensitive information in InstanceId if the namespace is discoverable by public DNS queries and any Type member of DnsRecord for the service contains SRV because the InstanceId is discoverable by public DNS queries.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that you want to use for settings for the instance.
    /// This member is required.
    public var serviceId: Swift.String?

    public init(
        attributes: [Swift.String: Swift.String]? = nil,
        creatorRequestId: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.creatorRequestId = creatorRequestId
        self.instanceId = instanceId
        self.serviceId = serviceId
    }
}

public struct RegisterInstanceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to add to the specified resource. Specifying the tag key is required. You can set the value of a tag to an empty string, but you can't set the value of a tag to null.
    /// This member is required.
    public var tags: [ServiceDiscoveryClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ServiceDiscoveryClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to retrieve tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateHttpNamespaceInput {
    /// The ID of the namespace that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the the HTTP namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdateHttpNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init(
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.HttpNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

public struct UpdateHttpNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct UpdateInstanceCustomHealthStatusInput {
    /// The ID of the instance that you want to change the health status for.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The ID of the service that includes the configuration for the custom health check that you want to change the status for.
    /// This member is required.
    public var serviceId: Swift.String?
    /// The new status of the instance, HEALTHY or UNHEALTHY.
    /// This member is required.
    public var status: ServiceDiscoveryClientTypes.CustomHealthStatus?

    public init(
        instanceId: Swift.String? = nil,
        serviceId: Swift.String? = nil,
        status: ServiceDiscoveryClientTypes.CustomHealthStatus? = nil
    )
    {
        self.instanceId = instanceId
        self.serviceId = serviceId
        self.status = status
    }
}

public struct UpdatePrivateDnsNamespaceInput {
    /// The ID of the namespace that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the private DNS namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdatePrivateDnsNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init(
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

public struct UpdatePrivateDnsNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

public struct UpdatePublicDnsNamespaceInput {
    /// The ID of the namespace being updated.
    /// This member is required.
    public var id: Swift.String?
    /// Updated properties for the public DNS namespace.
    /// This member is required.
    public var namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?
    /// A unique string that identifies the request and that allows failed UpdatePublicDnsNamespace requests to be retried without the risk of running the operation twice. UpdaterRequestId can be any unique string (for example, a date/timestamp).
    public var updaterRequestId: Swift.String?

    public init(
        id: Swift.String? = nil,
        namespace: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange? = nil,
        updaterRequestId: Swift.String? = nil
    )
    {
        self.id = id
        self.namespace = namespace
        self.updaterRequestId = updaterRequestId
    }
}

public struct UpdatePublicDnsNamespaceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension ServiceDiscoveryClientTypes {
    /// A complex type that contains changes to an existing service.
    public struct ServiceChange {
        /// A description for the service.
        public var description: Swift.String?
        /// Information about the Route 53 DNS records that you want Cloud Map to create when you register an instance.
        public var dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange?
        /// Public DNS and HTTP namespaces only. Settings for an optional health check. If you specify settings for a health check, Cloud Map associates the health check with the records that you specify in DnsConfig.
        public var healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig?

        public init(
            description: Swift.String? = nil,
            dnsConfig: ServiceDiscoveryClientTypes.DnsConfigChange? = nil,
            healthCheckConfig: ServiceDiscoveryClientTypes.HealthCheckConfig? = nil
        )
        {
            self.description = description
            self.dnsConfig = dnsConfig
            self.healthCheckConfig = healthCheckConfig
        }
    }

}

public struct UpdateServiceInput {
    /// The ID of the service that you want to update.
    /// This member is required.
    public var id: Swift.String?
    /// A complex type that contains the new settings for the service.
    /// This member is required.
    public var service: ServiceDiscoveryClientTypes.ServiceChange?

    public init(
        id: Swift.String? = nil,
        service: ServiceDiscoveryClientTypes.ServiceChange? = nil
    )
    {
        self.id = id
        self.service = service
    }
}

public struct UpdateServiceOutput {
    /// A value that you can use to determine whether the request completed successfully. To get the status of the operation, see [GetOperation](https://docs.aws.amazon.com/cloud-map/latest/api/API_GetOperation.html).
    public var operationId: Swift.String?

    public init(
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

extension CreateHttpNamespaceInput {

    static func urlPathProvider(_ value: CreateHttpNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePrivateDnsNamespaceInput {

    static func urlPathProvider(_ value: CreatePrivateDnsNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePublicDnsNamespaceInput {

    static func urlPathProvider(_ value: CreatePublicDnsNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateServiceInput {

    static func urlPathProvider(_ value: CreateServiceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServiceInput {

    static func urlPathProvider(_ value: DeleteServiceInput) -> Swift.String? {
        return "/"
    }
}

extension DeregisterInstanceInput {

    static func urlPathProvider(_ value: DeregisterInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DiscoverInstancesInput {

    static func urlPathProvider(_ value: DiscoverInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension DiscoverInstancesRevisionInput {

    static func urlPathProvider(_ value: DiscoverInstancesRevisionInput) -> Swift.String? {
        return "/"
    }
}

extension GetInstanceInput {

    static func urlPathProvider(_ value: GetInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetInstancesHealthStatusInput {

    static func urlPathProvider(_ value: GetInstancesHealthStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetNamespaceInput {

    static func urlPathProvider(_ value: GetNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension GetOperationInput {

    static func urlPathProvider(_ value: GetOperationInput) -> Swift.String? {
        return "/"
    }
}

extension GetServiceInput {

    static func urlPathProvider(_ value: GetServiceInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListNamespacesInput {

    static func urlPathProvider(_ value: ListNamespacesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOperationsInput {

    static func urlPathProvider(_ value: ListOperationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListServicesInput {

    static func urlPathProvider(_ value: ListServicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RegisterInstanceInput {

    static func urlPathProvider(_ value: RegisterInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateHttpNamespaceInput {

    static func urlPathProvider(_ value: UpdateHttpNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInstanceCustomHealthStatusInput {

    static func urlPathProvider(_ value: UpdateInstanceCustomHealthStatusInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePrivateDnsNamespaceInput {

    static func urlPathProvider(_ value: UpdatePrivateDnsNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePublicDnsNamespaceInput {

    static func urlPathProvider(_ value: UpdatePublicDnsNamespaceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateServiceInput {

    static func urlPathProvider(_ value: UpdateServiceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateHttpNamespaceInput {

    static func write(value: CreateHttpNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreatePrivateDnsNamespaceInput {

    static func write(value: CreatePrivateDnsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Properties"].write(value.properties, with: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Vpc"].write(value.vpc)
    }
}

extension CreatePublicDnsNamespaceInput {

    static func write(value: CreatePublicDnsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["Properties"].write(value.properties, with: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateServiceInput {

    static func write(value: CreateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["Description"].write(value.description)
        try writer["DnsConfig"].write(value.dnsConfig, with: ServiceDiscoveryClientTypes.DnsConfig.write(value:to:))
        try writer["HealthCheckConfig"].write(value.healthCheckConfig, with: ServiceDiscoveryClientTypes.HealthCheckConfig.write(value:to:))
        try writer["HealthCheckCustomConfig"].write(value.healthCheckCustomConfig, with: ServiceDiscoveryClientTypes.HealthCheckCustomConfig.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["NamespaceId"].write(value.namespaceId)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension DeleteNamespaceInput {

    static func write(value: DeleteNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension DeleteServiceInput {

    static func write(value: DeleteServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension DeregisterInstanceInput {

    static func write(value: DeregisterInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["ServiceId"].write(value.serviceId)
    }
}

extension DiscoverInstancesInput {

    static func write(value: DiscoverInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HealthStatus"].write(value.healthStatus)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NamespaceName"].write(value.namespaceName)
        try writer["OptionalParameters"].writeMap(value.optionalParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["QueryParameters"].writeMap(value.queryParameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["ServiceName"].write(value.serviceName)
    }
}

extension DiscoverInstancesRevisionInput {

    static func write(value: DiscoverInstancesRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NamespaceName"].write(value.namespaceName)
        try writer["ServiceName"].write(value.serviceName)
    }
}

extension GetInstanceInput {

    static func write(value: GetInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["ServiceId"].write(value.serviceId)
    }
}

extension GetInstancesHealthStatusInput {

    static func write(value: GetInstancesHealthStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Instances"].writeList(value.instances, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceId"].write(value.serviceId)
    }
}

extension GetNamespaceInput {

    static func write(value: GetNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension GetOperationInput {

    static func write(value: GetOperationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OperationId"].write(value.operationId)
    }
}

extension GetServiceInput {

    static func write(value: GetServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
    }
}

extension ListInstancesInput {

    static func write(value: ListInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ServiceId"].write(value.serviceId)
    }
}

extension ListNamespacesInput {

    static func write(value: ListNamespacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ServiceDiscoveryClientTypes.NamespaceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListOperationsInput {

    static func write(value: ListOperationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ServiceDiscoveryClientTypes.OperationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListServicesInput {

    static func write(value: ListServicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: ServiceDiscoveryClientTypes.ServiceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension RegisterInstanceInput {

    static func write(value: RegisterInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Attributes"].writeMap(value.attributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CreatorRequestId"].write(value.creatorRequestId)
        try writer["InstanceId"].write(value.instanceId)
        try writer["ServiceId"].write(value.serviceId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: ServiceDiscoveryClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateHttpNamespaceInput {

    static func write(value: UpdateHttpNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Namespace"].write(value.namespace, with: ServiceDiscoveryClientTypes.HttpNamespaceChange.write(value:to:))
        try writer["UpdaterRequestId"].write(value.updaterRequestId)
    }
}

extension UpdateInstanceCustomHealthStatusInput {

    static func write(value: UpdateInstanceCustomHealthStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceId"].write(value.instanceId)
        try writer["ServiceId"].write(value.serviceId)
        try writer["Status"].write(value.status)
    }
}

extension UpdatePrivateDnsNamespaceInput {

    static func write(value: UpdatePrivateDnsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Namespace"].write(value.namespace, with: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange.write(value:to:))
        try writer["UpdaterRequestId"].write(value.updaterRequestId)
    }
}

extension UpdatePublicDnsNamespaceInput {

    static func write(value: UpdatePublicDnsNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Namespace"].write(value.namespace, with: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange.write(value:to:))
        try writer["UpdaterRequestId"].write(value.updaterRequestId)
    }
}

extension UpdateServiceInput {

    static func write(value: UpdateServiceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Service"].write(value.service, with: ServiceDiscoveryClientTypes.ServiceChange.write(value:to:))
    }
}

extension CreateHttpNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateHttpNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateHttpNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension CreatePrivateDnsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePrivateDnsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePrivateDnsNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension CreatePublicDnsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePublicDnsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePublicDnsNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension CreateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateServiceOutput()
        value.service = try reader["Service"].readIfPresent(with: ServiceDiscoveryClientTypes.Service.read(from:))
        return value
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DeleteServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServiceOutput {
        return DeleteServiceOutput()
    }
}

extension DeregisterInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeregisterInstanceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension DiscoverInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DiscoverInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DiscoverInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.HttpInstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.instancesRevision = try reader["InstancesRevision"].readIfPresent()
        return value
    }
}

extension DiscoverInstancesRevisionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DiscoverInstancesRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DiscoverInstancesRevisionOutput()
        value.instancesRevision = try reader["InstancesRevision"].readIfPresent()
        return value
    }
}

extension GetInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInstanceOutput()
        value.instance = try reader["Instance"].readIfPresent(with: ServiceDiscoveryClientTypes.Instance.read(from:))
        return value
    }
}

extension GetInstancesHealthStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInstancesHealthStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInstancesHealthStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.status = try reader["Status"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosureBox<ServiceDiscoveryClientTypes.HealthStatus>().read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamespaceOutput()
        value.namespace = try reader["Namespace"].readIfPresent(with: ServiceDiscoveryClientTypes.Namespace.read(from:))
        return value
    }
}

extension GetOperationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOperationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOperationOutput()
        value.operation = try reader["Operation"].readIfPresent(with: ServiceDiscoveryClientTypes.Operation.read(from:))
        return value
    }
}

extension GetServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceOutput()
        value.service = try reader["Service"].readIfPresent(with: ServiceDiscoveryClientTypes.Service.read(from:))
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.InstanceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamespacesOutput()
        value.namespaces = try reader["Namespaces"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.NamespaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOperationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOperationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOperationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.operations = try reader["Operations"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.OperationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServicesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.services = try reader["Services"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.ServiceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RegisterInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RegisterInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RegisterInstanceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateHttpNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateHttpNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateHttpNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateInstanceCustomHealthStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceCustomHealthStatusOutput {
        return UpdateInstanceCustomHealthStatusOutput()
    }
}

extension UpdatePrivateDnsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePrivateDnsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePrivateDnsNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdatePublicDnsNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePublicDnsNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePublicDnsNamespaceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

extension UpdateServiceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServiceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateServiceOutput()
        value.operationId = try reader["OperationId"].readIfPresent()
        return value
    }
}

enum CreateHttpNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceAlreadyExists": return try NamespaceAlreadyExists.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceeded.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePrivateDnsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceAlreadyExists": return try NamespaceAlreadyExists.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceeded.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePublicDnsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceAlreadyExists": return try NamespaceAlreadyExists.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceeded.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceeded.makeError(baseError: baseError)
            case "ServiceAlreadyExists": return try ServiceAlreadyExists.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InstanceNotFound": return try InstanceNotFound.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DiscoverInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "RequestLimitExceeded": return try RequestLimitExceeded.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DiscoverInstancesRevisionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "RequestLimitExceeded": return try RequestLimitExceeded.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InstanceNotFound": return try InstanceNotFound.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInstancesHealthStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InstanceNotFound": return try InstanceNotFound.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOperationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "OperationNotFound": return try OperationNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOperationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RegisterInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            case "ResourceLimitExceeded": return try ResourceLimitExceeded.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateHttpNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceCustomHealthStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "CustomHealthNotFound": return try CustomHealthNotFound.makeError(baseError: baseError)
            case "InstanceNotFound": return try InstanceNotFound.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePrivateDnsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePublicDnsNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "NamespaceNotFound": return try NamespaceNotFound.makeError(baseError: baseError)
            case "ResourceInUse": return try ResourceInUse.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServiceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DuplicateRequest": return try DuplicateRequest.makeError(baseError: baseError)
            case "InvalidInput": return try InvalidInput.makeError(baseError: baseError)
            case "ServiceNotFound": return try ServiceNotFound.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidInput {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidInput {
        let reader = baseError.errorBodyReader
        var value = InvalidInput()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = ResourceLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NamespaceAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NamespaceAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = NamespaceAlreadyExists()
        value.properties.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.namespaceId = try reader["NamespaceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateRequest {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateRequest {
        let reader = baseError.errorBodyReader
        var value = DuplicateRequest()
        value.properties.duplicateOperationId = try reader["DuplicateOperationId"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NamespaceNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NamespaceNotFound {
        let reader = baseError.errorBodyReader
        var value = NamespaceNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceAlreadyExists {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceAlreadyExists {
        let reader = baseError.errorBodyReader
        var value = ServiceAlreadyExists()
        value.properties.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.serviceId = try reader["ServiceId"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUse {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceInUse {
        let reader = baseError.errorBodyReader
        var value = ResourceInUse()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceNotFound {
        let reader = baseError.errorBodyReader
        var value = ServiceNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InstanceNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InstanceNotFound {
        let reader = baseError.errorBodyReader
        var value = InstanceNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestLimitExceeded {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> RequestLimitExceeded {
        let reader = baseError.errorBodyReader
        var value = RequestLimitExceeded()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension OperationNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotFound {
        let reader = baseError.errorBodyReader
        var value = OperationNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CustomHealthNotFound {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CustomHealthNotFound {
        let reader = baseError.errorBodyReader
        var value = CustomHealthNotFound()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceDiscoveryClientTypes.Service {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.Service()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.namespaceId = try reader["NamespaceId"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.dnsConfig = try reader["DnsConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.DnsConfig.read(from:))
        value.type = try reader["Type"].readIfPresent()
        value.healthCheckConfig = try reader["HealthCheckConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.HealthCheckConfig.read(from:))
        value.healthCheckCustomConfig = try reader["HealthCheckCustomConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.HealthCheckCustomConfig.read(from:))
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckCustomConfig {

    static func write(value: ServiceDiscoveryClientTypes.HealthCheckCustomConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureThreshold"].write(value.failureThreshold)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.HealthCheckCustomConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.HealthCheckCustomConfig()
        value.failureThreshold = try reader["FailureThreshold"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.HealthCheckConfig {

    static func write(value: ServiceDiscoveryClientTypes.HealthCheckConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FailureThreshold"].write(value.failureThreshold)
        try writer["ResourcePath"].write(value.resourcePath)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.HealthCheckConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.HealthCheckConfig()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.resourcePath = try reader["ResourcePath"].readIfPresent()
        value.failureThreshold = try reader["FailureThreshold"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.DnsConfig {

    static func write(value: ServiceDiscoveryClientTypes.DnsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsRecords"].writeList(value.dnsRecords, memberWritingClosure: ServiceDiscoveryClientTypes.DnsRecord.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NamespaceId"].write(value.namespaceId)
        try writer["RoutingPolicy"].write(value.routingPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.DnsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.DnsConfig()
        value.namespaceId = try reader["NamespaceId"].readIfPresent()
        value.routingPolicy = try reader["RoutingPolicy"].readIfPresent()
        value.dnsRecords = try reader["DnsRecords"].readListIfPresent(memberReadingClosure: ServiceDiscoveryClientTypes.DnsRecord.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ServiceDiscoveryClientTypes.DnsRecord {

    static func write(value: ServiceDiscoveryClientTypes.DnsRecord?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TTL"].write(value.ttl)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.DnsRecord {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.DnsRecord()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.ttl = try reader["TTL"].readIfPresent() ?? 0
        return value
    }
}

extension ServiceDiscoveryClientTypes.HttpInstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.HttpInstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.HttpInstanceSummary()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        value.namespaceName = try reader["NamespaceName"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.healthStatus = try reader["HealthStatus"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceDiscoveryClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.Instance()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceDiscoveryClientTypes.Namespace {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.Namespace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.Namespace()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.serviceCount = try reader["ServiceCount"].readIfPresent()
        value.properties = try reader["Properties"].readIfPresent(with: ServiceDiscoveryClientTypes.NamespaceProperties.read(from:))
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.creatorRequestId = try reader["CreatorRequestId"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.NamespaceProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.NamespaceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.NamespaceProperties()
        value.dnsProperties = try reader["DnsProperties"].readIfPresent(with: ServiceDiscoveryClientTypes.DnsProperties.read(from:))
        value.httpProperties = try reader["HttpProperties"].readIfPresent(with: ServiceDiscoveryClientTypes.HttpProperties.read(from:))
        return value
    }
}

extension ServiceDiscoveryClientTypes.HttpProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.HttpProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.HttpProperties()
        value.httpName = try reader["HttpName"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.DnsProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.DnsProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.DnsProperties()
        value.hostedZoneId = try reader["HostedZoneId"].readIfPresent()
        value.soa = try reader["SOA"].readIfPresent(with: ServiceDiscoveryClientTypes.SOA.read(from:))
        return value
    }
}

extension ServiceDiscoveryClientTypes.SOA {

    static func write(value: ServiceDiscoveryClientTypes.SOA?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TTL"].write(value.ttl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.SOA {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.SOA()
        value.ttl = try reader["TTL"].readIfPresent() ?? 0
        return value
    }
}

extension ServiceDiscoveryClientTypes.Operation {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.Operation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.Operation()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateDate = try reader["UpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.targets = try reader["Targets"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceDiscoveryClientTypes.InstanceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.InstanceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.InstanceSummary()
        value.id = try reader["Id"].readIfPresent()
        value.attributes = try reader["Attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ServiceDiscoveryClientTypes.NamespaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.NamespaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.NamespaceSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.serviceCount = try reader["ServiceCount"].readIfPresent()
        value.properties = try reader["Properties"].readIfPresent(with: ServiceDiscoveryClientTypes.NamespaceProperties.read(from:))
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ServiceDiscoveryClientTypes.OperationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.OperationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.OperationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension ServiceDiscoveryClientTypes.ServiceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.ServiceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.ServiceSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.instanceCount = try reader["InstanceCount"].readIfPresent()
        value.dnsConfig = try reader["DnsConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.DnsConfig.read(from:))
        value.healthCheckConfig = try reader["HealthCheckConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.HealthCheckConfig.read(from:))
        value.healthCheckCustomConfig = try reader["HealthCheckCustomConfig"].readIfPresent(with: ServiceDiscoveryClientTypes.HealthCheckCustomConfig.read(from:))
        value.createDate = try reader["CreateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ServiceDiscoveryClientTypes.Tag {

    static func write(value: ServiceDiscoveryClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ServiceDiscoveryClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ServiceDiscoveryClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties {

    static func write(value: ServiceDiscoveryClientTypes.PrivateDnsNamespaceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsProperties"].write(value.dnsProperties, with: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable {

    static func write(value: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SOA"].write(value.soa, with: ServiceDiscoveryClientTypes.SOA.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties {

    static func write(value: ServiceDiscoveryClientTypes.PublicDnsNamespaceProperties?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsProperties"].write(value.dnsProperties, with: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable {

    static func write(value: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SOA"].write(value.soa, with: ServiceDiscoveryClientTypes.SOA.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.NamespaceFilter {

    static func write(value: ServiceDiscoveryClientTypes.NamespaceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ServiceDiscoveryClientTypes.OperationFilter {

    static func write(value: ServiceDiscoveryClientTypes.OperationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ServiceDiscoveryClientTypes.ServiceFilter {

    static func write(value: ServiceDiscoveryClientTypes.ServiceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Condition"].write(value.condition)
        try writer["Name"].write(value.name)
        try writer["Values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ServiceDiscoveryClientTypes.HttpNamespaceChange {

    static func write(value: ServiceDiscoveryClientTypes.HttpNamespaceChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange {

    static func write(value: ServiceDiscoveryClientTypes.PrivateDnsNamespaceChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Properties"].write(value.properties, with: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange {

    static func write(value: ServiceDiscoveryClientTypes.PrivateDnsNamespacePropertiesChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsProperties"].write(value.dnsProperties, with: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange {

    static func write(value: ServiceDiscoveryClientTypes.PrivateDnsPropertiesMutableChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SOA"].write(value.soa, with: ServiceDiscoveryClientTypes.SOAChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.SOAChange {

    static func write(value: ServiceDiscoveryClientTypes.SOAChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TTL"].write(value.ttl)
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespaceChange {

    static func write(value: ServiceDiscoveryClientTypes.PublicDnsNamespaceChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["Properties"].write(value.properties, with: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange {

    static func write(value: ServiceDiscoveryClientTypes.PublicDnsNamespacePropertiesChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsProperties"].write(value.dnsProperties, with: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange {

    static func write(value: ServiceDiscoveryClientTypes.PublicDnsPropertiesMutableChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SOA"].write(value.soa, with: ServiceDiscoveryClientTypes.SOAChange.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.ServiceChange {

    static func write(value: ServiceDiscoveryClientTypes.ServiceChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DnsConfig"].write(value.dnsConfig, with: ServiceDiscoveryClientTypes.DnsConfigChange.write(value:to:))
        try writer["HealthCheckConfig"].write(value.healthCheckConfig, with: ServiceDiscoveryClientTypes.HealthCheckConfig.write(value:to:))
    }
}

extension ServiceDiscoveryClientTypes.DnsConfigChange {

    static func write(value: ServiceDiscoveryClientTypes.DnsConfigChange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DnsRecords"].writeList(value.dnsRecords, memberWritingClosure: ServiceDiscoveryClientTypes.DnsRecord.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum ServiceDiscoveryClientTypes {}
