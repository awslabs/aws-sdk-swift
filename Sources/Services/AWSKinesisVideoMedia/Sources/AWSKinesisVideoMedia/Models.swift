//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.
public struct ClientLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client connections.
public struct ConnectionLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectionLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The value for this input parameter is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Status Code: 400, Caller used wrong endpoint to write data to a stream. On receiving such an exception, the user must call GetDataEndpoint with AccessMode set to "READ" and use the endpoint Kinesis Video returns in the next GetMedia call.
public struct InvalidEndpointException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidEndpointException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Status Code: 403, The caller is not authorized to perform an operation on the given stream, or the token has expired.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Status Code: 404, The stream with the given name does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisVideoMediaClientTypes {

    public enum StartSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case continuationToken
        case earliest
        case fragmentNumber
        case now
        case producerTimestamp
        case serverTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [StartSelectorType] {
            return [
                .continuationToken,
                .earliest,
                .fragmentNumber,
                .now,
                .producerTimestamp,
                .serverTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .continuationToken: return "CONTINUATION_TOKEN"
            case .earliest: return "EARLIEST"
            case .fragmentNumber: return "FRAGMENT_NUMBER"
            case .now: return "NOW"
            case .producerTimestamp: return "PRODUCER_TIMESTAMP"
            case .serverTimestamp: return "SERVER_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoMediaClientTypes {
    /// Identifies the chunk on the Kinesis video stream where you want the GetMedia API to start returning media data. You have the following options to identify the starting chunk:
    ///
    /// * Choose the latest (or oldest) chunk.
    ///
    /// * Identify a specific chunk. You can identify a specific chunk either by providing a fragment number or timestamp (server or producer).
    ///
    /// * Each chunk's metadata includes a continuation token as a Matroska (MKV) tag (AWS_KINESISVIDEO_CONTINUATION_TOKEN). If your previous GetMedia request terminated, you can use this tag value in your next GetMedia request. The API then starts returning chunks starting where the last API ended.
    public struct StartSelector {
        /// Specifies the fragment number from where you want the GetMedia API to start returning the fragments.
        public var afterFragmentNumber: Swift.String?
        /// Continuation token that Kinesis Video Streams returned in the previous GetMedia response. The GetMedia API then starts with the chunk identified by the continuation token.
        public var continuationToken: Swift.String?
        /// Identifies the fragment on the Kinesis video stream where you want to start getting the data from.
        ///
        /// * NOW - Start with the latest chunk on the stream.
        ///
        /// * EARLIEST - Start with earliest available chunk on the stream.
        ///
        /// * FRAGMENT_NUMBER - Start with the chunk after a specific fragment. You must also specify the AfterFragmentNumber parameter.
        ///
        /// * PRODUCER_TIMESTAMP or SERVER_TIMESTAMP - Start with the chunk containing a fragment with the specified producer or server timestamp. You specify the timestamp by adding StartTimestamp.
        ///
        /// * CONTINUATION_TOKEN - Read using the specified continuation token.
        ///
        ///
        /// If you choose the NOW, EARLIEST, or CONTINUATION_TOKEN as the startSelectorType, you don't provide any additional information in the startSelector.
        /// This member is required.
        public var startSelectorType: KinesisVideoMediaClientTypes.StartSelectorType?
        /// A timestamp value. This value is required if you choose the PRODUCER_TIMESTAMP or the SERVER_TIMESTAMP as the startSelectorType. The GetMedia API then starts with the chunk containing the fragment that has the specified timestamp.
        public var startTimestamp: Foundation.Date?

        public init(
            afterFragmentNumber: Swift.String? = nil,
            continuationToken: Swift.String? = nil,
            startSelectorType: KinesisVideoMediaClientTypes.StartSelectorType? = nil,
            startTimestamp: Foundation.Date? = nil
        )
        {
            self.afterFragmentNumber = afterFragmentNumber
            self.continuationToken = continuationToken
            self.startSelectorType = startSelectorType
            self.startTimestamp = startTimestamp
        }
    }

}

public struct GetMediaInput {
    /// Identifies the starting chunk to get from the specified stream.
    /// This member is required.
    public var startSelector: KinesisVideoMediaClientTypes.StartSelector?
    /// The ARN of the stream from where you want to get the media content. If you don't specify the streamARN, you must specify the streamName.
    public var streamARN: Swift.String?
    /// The Kinesis video stream name from where you want to get the media content. If you don't specify the streamName, you must specify the streamARN.
    public var streamName: Swift.String?

    public init(
        startSelector: KinesisVideoMediaClientTypes.StartSelector? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.startSelector = startSelector
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct GetMediaOutput {
    /// The content type of the requested media.
    public var contentType: Swift.String?
    /// The payload Kinesis Video Streams returns is a sequence of chunks from the specified stream. For information about the chunks, see . The chunks that Kinesis Video Streams returns in the GetMedia call also include the following additional Matroska (MKV) tags:
    ///
    /// * AWS_KINESISVIDEO_CONTINUATION_TOKEN (UTF-8 string) - In the event your GetMedia call terminates, you can use this continuation token in your next request to get the next chunk where the last request terminated.
    ///
    /// * AWS_KINESISVIDEO_MILLIS_BEHIND_NOW (UTF-8 string) - Client applications can use this tag value to determine how far behind the chunk returned in the response is from the latest chunk on the stream.
    ///
    /// * AWS_KINESISVIDEO_FRAGMENT_NUMBER - Fragment number returned in the chunk.
    ///
    /// * AWS_KINESISVIDEO_SERVER_TIMESTAMP - Server timestamp of the fragment.
    ///
    /// * AWS_KINESISVIDEO_PRODUCER_TIMESTAMP - Producer timestamp of the fragment.
    ///
    ///
    /// The following tags will be present if an error occurs:
    ///
    /// * AWS_KINESISVIDEO_ERROR_CODE - String description of an error that caused GetMedia to stop.
    ///
    /// * AWS_KINESISVIDEO_ERROR_ID: Integer code of the error.
    ///
    ///
    /// The error codes are as follows:
    ///
    /// * 3002 - Error writing to the stream
    ///
    /// * 4000 - Requested fragment is not found
    ///
    /// * 4500 - Access denied for the stream's KMS key
    ///
    /// * 4501 - Stream's KMS key is disabled
    ///
    /// * 4502 - Validation error on the stream's KMS key
    ///
    /// * 4503 - KMS key specified in the stream is unavailable
    ///
    /// * 4504 - Invalid usage of the KMS key specified in the stream
    ///
    /// * 4505 - Invalid state of the KMS key specified in the stream
    ///
    /// * 4506 - Unable to find the KMS key specified in the stream
    ///
    /// * 5000 - Internal error
    public var payload: Smithy.ByteStream?

    public init(
        contentType: Swift.String? = nil,
        payload: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data("".utf8))
    )
    {
        self.contentType = contentType
        self.payload = payload
    }
}

extension GetMediaInput {

    static func urlPathProvider(_ value: GetMediaInput) -> Swift.String? {
        return "/getMedia"
    }
}

extension GetMediaInput {

    static func write(value: GetMediaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StartSelector"].write(value.startSelector, with: KinesisVideoMediaClientTypes.StartSelector.write(value:to:))
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension GetMediaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMediaOutput {
        var value = GetMediaOutput()
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        switch httpResponse.body {
        case .data(let data):
            value.payload = .data(data)
        case .stream(let stream):
            value.payload = .stream(stream)
        case .noStream:
            value.payload = nil
        }
        return value
    }
}

enum GetMediaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "ConnectionLimitExceededException": return try ConnectionLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidEndpointException": return try InvalidEndpointException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidEndpointException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidEndpointException {
        let reader = baseError.errorBodyReader
        var value = InvalidEndpointException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClientLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ClientLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ClientLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotAuthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotAuthorizedException {
        let reader = baseError.errorBodyReader
        var value = NotAuthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectionLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConnectionLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ConnectionLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KinesisVideoMediaClientTypes.StartSelector {

    static func write(value: KinesisVideoMediaClientTypes.StartSelector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterFragmentNumber"].write(value.afterFragmentNumber)
        try writer["ContinuationToken"].write(value.continuationToken)
        try writer["StartSelectorType"].write(value.startSelectorType)
        try writer["StartTimestamp"].writeTimestamp(value.startTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

public enum KinesisVideoMediaClientTypes {}
