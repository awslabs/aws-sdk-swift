// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct DeleteReportDefinitionInput: Swift.Equatable {
    /// Required. ID of the report to delete.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionInputBody: Swift.Equatable {
}

extension DeleteReportDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteReportDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct DeleteReportDefinitionOutput: Swift.Equatable {
    /// ID of the report that was deleted.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension DeleteReportDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum DeleteReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct GetReportDefinitionInput: Swift.Equatable {
    /// ID of the report to retrieve.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetReportDefinitionInputBody: Swift.Equatable {
}

extension GetReportDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReportDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.destinationS3Location = output.destinationS3Location
            self.format = output.format
            self.lastUpdated = output.lastUpdated
            self.reportDescription = output.reportDescription
            self.reportFrequency = output.reportFrequency
            self.reportId = output.reportId
        } else {
            self.createdAt = nil
            self.destinationS3Location = nil
            self.format = nil
            self.lastUpdated = nil
            self.reportDescription = nil
            self.reportFrequency = nil
            self.reportId = nil
        }
    }
}

public struct GetReportDefinitionOutput: Swift.Equatable {
    /// Timestamp (milliseconds) when this report definition was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Amazon Simple Storage Service (Amazon S3) location where the report is uploaded.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Format of the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Timestamp (milliseconds) when this report definition was last updated.
    /// This member is required.
    public var lastUpdated: ClientRuntime.Date?
    /// Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Cadence used to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// ID of the report retrieved.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        lastUpdated: ClientRuntime.Date? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.lastUpdated = lastUpdated
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct GetReportDefinitionOutputBody: Swift.Equatable {
    let reportId: Swift.String?
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    let createdAt: ClientRuntime.Date?
    let lastUpdated: ClientRuntime.Date?
}

extension GetReportDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdated
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

enum GetReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportApplicationUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3Location = self.sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
    }
}

extension ImportApplicationUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/importApplicationUsage"
    }
}

public struct ImportApplicationUsageInput: Swift.Equatable {
    /// Amazon S3 location to import application usage data from.
    /// This member is required.
    public var sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?

    public init(
        sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location? = nil
    )
    {
        self.sourceS3Location = sourceS3Location
    }
}

struct ImportApplicationUsageInputBody: Swift.Equatable {
    let sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?
}

extension ImportApplicationUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.SourceS3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
    }
}

extension ImportApplicationUsageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportApplicationUsageOutputBody = try responseDecoder.decode(responseBody: data)
            self.importId = output.importId
        } else {
            self.importId = nil
        }
    }
}

public struct ImportApplicationUsageOutput: Swift.Equatable {
    /// ID of the import request.
    /// This member is required.
    public var importId: Swift.String?

    public init(
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct ImportApplicationUsageOutputBody: Swift.Equatable {
    let importId: Swift.String?
}

extension ImportApplicationUsageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

enum ImportApplicationUsageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListReportDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReportDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reportDefinition"
    }
}

public struct ListReportDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token value from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportDefinitionsInputBody: Swift.Equatable {
}

extension ListReportDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListReportDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListReportDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

public struct ListReportDefinitionsOutput: Swift.Equatable {
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?
    /// The retrieved reports.
    public var reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?

    public init(
        nextToken: Swift.String? = nil,
        reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct ListReportDefinitionsOutputBody: Swift.Equatable {
    let reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?
    let nextToken: Swift.String?
}

extension ListReportDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportDefinitions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([ApplicationCostProfilerClientTypes.ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [ApplicationCostProfilerClientTypes.ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListReportDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension PutReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reportDefinition"
    }
}

public struct PutReportDefinitionInput: Swift.Equatable {
    /// Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the report.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Required. The format to use for the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Required. Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Required. The cadence to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// Required. ID of the report. You can choose any valid string matching the pattern for the ID.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct PutReportDefinitionInputBody: Swift.Equatable {
    let reportId: Swift.String?
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension PutReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension PutReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutReportDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct PutReportDefinitionOutput: Swift.Equatable {
    /// ID of the report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct PutReportDefinitionOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension PutReportDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum PutReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ApplicationCostProfilerClientTypes.ReportDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdatedAt
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// The configuration of a report in AWS Application Cost Profiler.
    public struct ReportDefinition: Swift.Equatable {
        /// Timestamp (milliseconds) when this report definition was created.
        public var createdAt: ClientRuntime.Date?
        /// The location in Amazon Simple Storage Service (Amazon S3) the reports should be saved to.
        public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
        /// The format used for the generated reports.
        public var format: ApplicationCostProfilerClientTypes.Format?
        /// Timestamp (milliseconds) when this report definition was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Description of the report
        public var reportDescription: Swift.String?
        /// The cadence at which the report is generated.
        public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
        /// The ID of the report.
        public var reportId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
            format: ApplicationCostProfilerClientTypes.Format? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            reportDescription: Swift.String? = nil,
            reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
            reportId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.destinationS3Location = destinationS3Location
            self.format = format
            self.lastUpdatedAt = lastUpdatedAt
            self.reportDescription = reportDescription
            self.reportFrequency = reportFrequency
            self.reportId = reportId
        }
    }

}

extension ApplicationCostProfilerClientTypes {
    public enum ReportFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case daily
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequency] {
            return [
                .all,
                .daily,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFrequency(rawValue: rawValue) ?? ReportFrequency.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum S3BucketRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afSouth1
        case apEast1
        case euSouth1
        case meSouth1
        case sdkUnknown(Swift.String)

        public static var allCases: [S3BucketRegion] {
            return [
                .afSouth1,
                .apEast1,
                .euSouth1,
                .meSouth1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .euSouth1: return "eu-south-1"
            case .meSouth1: return "me-south-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3BucketRegion(rawValue: rawValue) ?? S3BucketRegion.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// Represents the Amazon Simple Storage Service (Amazon S3) location where AWS Application Cost Profiler reports are generated and then written to.
    public struct S3Location: Swift.Equatable {
        /// Name of the S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Prefix for the location to write to.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeds one or more of the service quotas.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationCostProfilerClientTypes.SourceS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3BucketRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// Represents the Amazon Simple Storage Service (Amazon S3) location where usage data is read from.
    public struct SourceS3Location: Swift.Equatable {
        /// Name of the bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Key of the object.
        /// This member is required.
        public var key: Swift.String?
        /// Region of the bucket. Only required for Regions that are disabled by default. For more infomration about Regions that are disabled by default, see [ Enabling a Region](https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable) in the AWS General Reference guide.
        public var region: ApplicationCostProfilerClientTypes.S3BucketRegion?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            region: ApplicationCostProfilerClientTypes.S3BucketRegion? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.region = region
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The calls to AWS Application Cost Profiler API are throttled. The request was denied.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
    }
}

extension UpdateReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct UpdateReportDefinitionInput: Swift.Equatable {
    /// Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the report.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Required. The format to use for the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Required. Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Required. The cadence to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// Required. ID of the report to update.
    /// This member is required.
    public var reportId: Swift.String?

    public init(
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionInputBody: Swift.Equatable {
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension UpdateReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension UpdateReportDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReportDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct UpdateReportDefinitionOutput: Swift.Equatable {
    /// ID of the report.
    public var reportId: Swift.String?

    public init(
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionOutputBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension UpdateReportDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

enum UpdateReportDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints for the API.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
