// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct DeleteReportDefinitionInput: Swift.Equatable {
    /// Required. ID of the report to delete.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionInputBody: Swift.Equatable {
}

extension DeleteReportDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct DeleteReportDefinitionOutputResponse: Swift.Equatable {
    /// ID of the report that was deleted.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct DeleteReportDefinitionOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension DeleteReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct GetReportDefinitionInput: Swift.Equatable {
    /// ID of the report to retrieve.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct GetReportDefinitionInputBody: Swift.Equatable {
}

extension GetReportDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.destinationS3Location = output.destinationS3Location
            self.format = output.format
            self.lastUpdated = output.lastUpdated
            self.reportDescription = output.reportDescription
            self.reportFrequency = output.reportFrequency
            self.reportId = output.reportId
        } else {
            self.createdAt = nil
            self.destinationS3Location = nil
            self.format = nil
            self.lastUpdated = nil
            self.reportDescription = nil
            self.reportFrequency = nil
            self.reportId = nil
        }
    }
}

public struct GetReportDefinitionOutputResponse: Swift.Equatable {
    /// Timestamp (milliseconds) when this report definition was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Amazon Simple Storage Service (Amazon S3) location where the report is uploaded.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Format of the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Timestamp (milliseconds) when this report definition was last updated.
    /// This member is required.
    public var lastUpdated: ClientRuntime.Date?
    /// Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Cadence used to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// ID of the report retrieved.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        lastUpdated: ClientRuntime.Date? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.lastUpdated = lastUpdated
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct GetReportDefinitionOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    let createdAt: ClientRuntime.Date?
    let lastUpdated: ClientRuntime.Date?
}

extension GetReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdated
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension ImportApplicationUsageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceS3Location = self.sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
    }
}

extension ImportApplicationUsageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/importApplicationUsage"
    }
}

public struct ImportApplicationUsageInput: Swift.Equatable {
    /// Amazon S3 location to import application usage data from.
    /// This member is required.
    public var sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?

    public init (
        sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location? = nil
    )
    {
        self.sourceS3Location = sourceS3Location
    }
}

struct ImportApplicationUsageInputBody: Swift.Equatable {
    let sourceS3Location: ApplicationCostProfilerClientTypes.SourceS3Location?
}

extension ImportApplicationUsageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceS3Location
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.SourceS3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
    }
}

extension ImportApplicationUsageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportApplicationUsageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportApplicationUsageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportApplicationUsageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportApplicationUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importId = output.importId
        } else {
            self.importId = nil
        }
    }
}

public struct ImportApplicationUsageOutputResponse: Swift.Equatable {
    /// ID of the import request.
    /// This member is required.
    public var importId: Swift.String?

    public init (
        importId: Swift.String? = nil
    )
    {
        self.importId = importId
    }
}

struct ImportApplicationUsageOutputResponseBody: Swift.Equatable {
    let importId: Swift.String?
}

extension ImportApplicationUsageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importId)
        importId = importIdDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListReportDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListReportDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reportDefinition"
    }
}

public struct ListReportDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return.
    public var maxResults: Swift.Int?
    /// The token value from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReportDefinitionsInputBody: Swift.Equatable {
}

extension ListReportDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReportDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReportDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReportDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReportDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReportDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reportDefinitions = output.reportDefinitions
        } else {
            self.nextToken = nil
            self.reportDefinitions = nil
        }
    }
}

public struct ListReportDefinitionsOutputResponse: Swift.Equatable {
    /// The value of the next token, if it exists. Null if there are no more results.
    public var nextToken: Swift.String?
    /// The retrieved reports.
    public var reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?

    public init (
        nextToken: Swift.String? = nil,
        reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportDefinitions = reportDefinitions
    }
}

struct ListReportDefinitionsOutputResponseBody: Swift.Equatable {
    let reportDefinitions: [ApplicationCostProfilerClientTypes.ReportDefinition]?
    let nextToken: Swift.String?
}

extension ListReportDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case reportDefinitions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDefinitionsContainer = try containerValues.decodeIfPresent([ApplicationCostProfilerClientTypes.ReportDefinition?].self, forKey: .reportDefinitions)
        var reportDefinitionsDecoded0:[ApplicationCostProfilerClientTypes.ReportDefinition]? = nil
        if let reportDefinitionsContainer = reportDefinitionsContainer {
            reportDefinitionsDecoded0 = [ApplicationCostProfilerClientTypes.ReportDefinition]()
            for structure0 in reportDefinitionsContainer {
                if let structure0 = structure0 {
                    reportDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        reportDefinitions = reportDefinitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PutReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }
}

extension PutReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/reportDefinition"
    }
}

public struct PutReportDefinitionInput: Swift.Equatable {
    /// Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the report.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Required. The format to use for the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Required. Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Required. The cadence to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// Required. ID of the report. You can choose any valid string matching the pattern for the ID.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct PutReportDefinitionInputBody: Swift.Equatable {
    let reportId: Swift.String?
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension PutReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension PutReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct PutReportDefinitionOutputResponse: Swift.Equatable {
    /// ID of the report.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct PutReportDefinitionOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension PutReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ApplicationCostProfilerClientTypes.ReportDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case destinationS3Location
        case format
        case lastUpdatedAt
        case reportDescription
        case reportFrequency
        case reportId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .epochSeconds, forKey: .lastUpdatedAt)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
        if let reportId = self.reportId {
            try encodeContainer.encode(reportId, forKey: .reportId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// The configuration of a report in AWS Application Cost Profiler.
    public struct ReportDefinition: Swift.Equatable {
        /// Timestamp (milliseconds) when this report definition was created.
        public var createdAt: ClientRuntime.Date?
        /// The location in Amazon Simple Storage Service (Amazon S3) the reports should be saved to.
        public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
        /// The format used for the generated reports.
        public var format: ApplicationCostProfilerClientTypes.Format?
        /// Timestamp (milliseconds) when this report definition was last updated.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Description of the report
        public var reportDescription: Swift.String?
        /// The cadence at which the report is generated.
        public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
        /// The ID of the report.
        public var reportId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
            format: ApplicationCostProfilerClientTypes.Format? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            reportDescription: Swift.String? = nil,
            reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
            reportId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.destinationS3Location = destinationS3Location
            self.format = format
            self.lastUpdatedAt = lastUpdatedAt
            self.reportDescription = reportDescription
            self.reportFrequency = reportFrequency
            self.reportId = reportId
        }
    }

}

extension ApplicationCostProfilerClientTypes {
    public enum ReportFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case daily
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [ReportFrequency] {
            return [
                .all,
                .daily,
                .monthly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReportFrequency(rawValue: rawValue) ?? ReportFrequency.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes {
    public enum S3BucketRegion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afSouth1
        case apEast1
        case euSouth1
        case meSouth1
        case sdkUnknown(Swift.String)

        public static var allCases: [S3BucketRegion] {
            return [
                .afSouth1,
                .apEast1,
                .euSouth1,
                .meSouth1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afSouth1: return "af-south-1"
            case .apEast1: return "ap-east-1"
            case .euSouth1: return "eu-south-1"
            case .meSouth1: return "me-south-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3BucketRegion(rawValue: rawValue) ?? S3BucketRegion.sdkUnknown(rawValue)
        }
    }
}

extension ApplicationCostProfilerClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// Represents the Amazon Simple Storage Service (Amazon S3) location where AWS Application Cost Profiler reports are generated and then written to.
    public struct S3Location: Swift.Equatable {
        /// Name of the S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Prefix for the location to write to.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request exceeds one or more of the service quotas.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationCostProfilerClientTypes.SourceS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let region = self.region {
            try encodeContainer.encode(region.rawValue, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let regionDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3BucketRegion.self, forKey: .region)
        region = regionDecoded
    }
}

extension ApplicationCostProfilerClientTypes {
    /// Represents the Amazon Simple Storage Service (Amazon S3) location where usage data is read from.
    public struct SourceS3Location: Swift.Equatable {
        /// Name of the bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// Key of the object.
        /// This member is required.
        public var key: Swift.String?
        /// Region of the bucket. Only required for Regions that are disabled by default. For more infomration about Regions that are disabled by default, see [ Enabling a Region](https://docs.aws.amazon.com/general/latest/gr/rande-manage.html#rande-manage-enable) in the AWS General Reference guide.
        public var region: ApplicationCostProfilerClientTypes.S3BucketRegion?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            region: ApplicationCostProfilerClientTypes.S3BucketRegion? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.region = region
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The calls to AWS Application Cost Profiler API are throttled. The request was denied.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateReportDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationS3Location = self.destinationS3Location {
            try encodeContainer.encode(destinationS3Location, forKey: .destinationS3Location)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let reportDescription = self.reportDescription {
            try encodeContainer.encode(reportDescription, forKey: .reportDescription)
        }
        if let reportFrequency = self.reportFrequency {
            try encodeContainer.encode(reportFrequency.rawValue, forKey: .reportFrequency)
        }
    }
}

extension UpdateReportDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reportId = reportId else {
            return nil
        }
        return "/reportDefinition/\(reportId.urlPercentEncoding())"
    }
}

public struct UpdateReportDefinitionInput: Swift.Equatable {
    /// Required. Amazon Simple Storage Service (Amazon S3) location where Application Cost Profiler uploads the report.
    /// This member is required.
    public var destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
    /// Required. The format to use for the generated report.
    /// This member is required.
    public var format: ApplicationCostProfilerClientTypes.Format?
    /// Required. Description of the report.
    /// This member is required.
    public var reportDescription: Swift.String?
    /// Required. The cadence to generate the report.
    /// This member is required.
    public var reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    /// Required. ID of the report to update.
    /// This member is required.
    public var reportId: Swift.String?

    public init (
        destinationS3Location: ApplicationCostProfilerClientTypes.S3Location? = nil,
        format: ApplicationCostProfilerClientTypes.Format? = nil,
        reportDescription: Swift.String? = nil,
        reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency? = nil,
        reportId: Swift.String? = nil
    )
    {
        self.destinationS3Location = destinationS3Location
        self.format = format
        self.reportDescription = reportDescription
        self.reportFrequency = reportFrequency
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionInputBody: Swift.Equatable {
    let reportDescription: Swift.String?
    let reportFrequency: ApplicationCostProfilerClientTypes.ReportFrequency?
    let format: ApplicationCostProfilerClientTypes.Format?
    let destinationS3Location: ApplicationCostProfilerClientTypes.S3Location?
}

extension UpdateReportDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationS3Location
        case format
        case reportDescription
        case reportFrequency
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportDescription)
        reportDescription = reportDescriptionDecoded
        let reportFrequencyDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.ReportFrequency.self, forKey: .reportFrequency)
        reportFrequency = reportFrequencyDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let destinationS3LocationDecoded = try containerValues.decodeIfPresent(ApplicationCostProfilerClientTypes.S3Location.self, forKey: .destinationS3Location)
        destinationS3Location = destinationS3LocationDecoded
    }
}

extension UpdateReportDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReportDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReportDefinitionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReportDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReportDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reportId = output.reportId
        } else {
            self.reportId = nil
        }
    }
}

public struct UpdateReportDefinitionOutputResponse: Swift.Equatable {
    /// ID of the report.
    public var reportId: Swift.String?

    public init (
        reportId: Swift.String? = nil
    )
    {
        self.reportId = reportId
    }
}

struct UpdateReportDefinitionOutputResponseBody: Swift.Equatable {
    let reportId: Swift.String?
}

extension UpdateReportDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reportId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reportId)
        reportId = reportIdDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints for the API.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
