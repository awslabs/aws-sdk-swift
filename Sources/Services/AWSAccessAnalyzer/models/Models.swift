// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.AccessPreview: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case configurations
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, configurationsMap0) in configurations {
                try configurationsContainer.encode(configurationsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about an access preview.
    public struct AccessPreview: Swift.Equatable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// A map of resource ARNs for the proposed resource configuration.
        /// This member is required.
        public var configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        /// * Creating - The access preview creation is in progress.
        ///
        /// * Completed - The access preview is complete. You can preview findings for external access to the resource.
        ///
        /// * Failed - The access preview creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init (
            analyzerArn: Swift.String? = nil,
            configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.configurations = configurations
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension AccessAnalyzerClientTypes.AccessPreviewFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case changeType
        case condition
        case createdAt
        case error
        case existingFindingId
        case existingFindingStatus
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for string0 in action {
                try actionContainer.encode(string0)
            }
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionKeyMap0) in condition {
                try conditionContainer.encode(conditionKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let existingFindingId = self.existingFindingId {
            try encodeContainer.encode(existingFindingId, forKey: .existingFindingId)
        }
        if let existingFindingStatus = self.existingFindingStatus {
            try encodeContainer.encode(existingFindingStatus.rawValue, forKey: .existingFindingStatus)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = self.isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalMap0) in principal {
                try principalContainer.encode(principalMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsource0 in sources {
                try sourcesContainer.encode(findingsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let existingFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingFindingId)
        existingFindingId = existingFindingIdDecoded
        let existingFindingStatusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .existingFindingStatus)
        existingFindingStatus = existingFindingStatusDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// An access preview finding generated by the access preview.
    public struct AccessPreviewFinding: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to perform.
        public var action: [Swift.String]?
        /// Provides context on how the access preview finding compares to existing access identified in IAM Access Analyzer.
        ///
        /// * New - The finding is for newly-introduced access.
        ///
        /// * Unchanged - The preview finding is an existing finding that would remain unchanged.
        ///
        /// * Changed - The preview finding is an existing finding with a change in status.
        ///
        ///
        /// For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        /// This member is required.
        public var changeType: AccessAnalyzerClientTypes.FindingChangeType?
        /// The condition in the analyzed policy statement that resulted in a finding.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the access preview finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error.
        public var error: Swift.String?
        /// The existing ID of the finding in IAM Access Analyzer, provided only for existing findings.
        public var existingFindingId: Swift.String?
        /// The existing status of the finding, provided only for existing findings.
        public var existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus?
        /// The ID of the access preview finding. This ID uniquely identifies the element in the list of access preview findings and is not related to the finding ID in Access Analyzer.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that an external principal has access to. This is the resource associated with the access preview.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that can be accessed in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The preview status of the finding. This is what the status of the finding would be after permissions deployment. For example, a Changed finding with preview status Resolved and existing status Active indicates the existing Active finding would become Resolved as a result of the proposed permissions change.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?

        public init (
            action: [Swift.String]? = nil,
            changeType: AccessAnalyzerClientTypes.FindingChangeType? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            existingFindingId: Swift.String? = nil,
            existingFindingStatus: AccessAnalyzerClientTypes.FindingStatus? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil
        )
        {
            self.action = action
            self.changeType = changeType
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.existingFindingId = existingFindingId
            self.existingFindingStatus = existingFindingStatus
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AccessPreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatus] {
            return [
                .completed,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPreviewStatus(rawValue: rawValue) ?? AccessPreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewStatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
    public struct AccessPreviewStatusReason: Swift.Equatable {
        /// The reason code for the current status of the access preview.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode?

        public init (
            code: AccessAnalyzerClientTypes.AccessPreviewStatusReasonCode? = nil
        )
        {
            self.code = code
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AccessPreviewStatusReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalError
        case invalidConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessPreviewStatusReasonCode] {
            return [
                .internalError,
                .invalidConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "INTERNAL_ERROR"
            case .invalidConfiguration: return "INVALID_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessPreviewStatusReasonCode(rawValue: rawValue) ?? AccessPreviewStatusReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AccessPreviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains a summary of information about an access preview.
    public struct AccessPreviewSummary: Swift.Equatable {
        /// The ARN of the analyzer used to generate the access preview.
        /// This member is required.
        public var analyzerArn: Swift.String?
        /// The time at which the access preview was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The unique ID for the access preview.
        /// This member is required.
        public var id: Swift.String?
        /// The status of the access preview.
        ///
        /// * Creating - The access preview creation is in progress.
        ///
        /// * Completed - The access preview is complete and previews the findings for external access to the resource.
        ///
        /// * Failed - The access preview creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AccessPreviewStatus?
        /// Provides more details about the current status of the access preview. For example, if the creation of the access preview fails, a Failed status is returned. This failure can be due to an internal issue with the analysis or due to an invalid proposed resource configuration.
        public var statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason?

        public init (
            analyzerArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AccessPreviewStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.AccessPreviewStatusReason? = nil
        )
        {
            self.analyzerArn = analyzerArn
            self.createdAt = createdAt
            self.id = id
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension AccessAnalyzerClientTypes.AclGrantee: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case sdkUnknown
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .id(id):
                try container.encode(id, forKey: .id)
            case let .uri(uri):
                try container.encode(uri, forKey: .uri)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .id)
        if let id = idDecoded {
            self = .id(id)
            return
        }
        let uriDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .uri)
        if let uri = uriDecoded {
            self = .uri(uri)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// You specify each grantee as a type-value pair using one of these types. You can specify only one type of grantee. For more information, see [PutBucketAcl](https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketAcl.html).
    public enum AclGrantee: Swift.Equatable, Swift.Hashable {
        /// The value specified is the canonical user ID of an Amazon Web Services account.
        case id(Swift.String)
        /// Used for granting permissions to a predefined group.
        case uri(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes {
    public enum AclPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullControl
        case read
        case readAcp
        case write
        case writeAcp
        case sdkUnknown(Swift.String)

        public static var allCases: [AclPermission] {
            return [
                .fullControl,
                .read,
                .readAcp,
                .write,
                .writeAcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullControl: return "FULL_CONTROL"
            case .read: return "READ"
            case .readAcp: return "READ_ACP"
            case .write: return "WRITE"
            case .writeAcp: return "WRITE_ACP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AclPermission(rawValue: rawValue) ?? AclPermission.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AnalyzedResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case analyzedAt
        case createdAt
        case error
        case isPublic
        case resourceArn
        case resourceOwnerAccount
        case resourceType
        case sharedVia
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for string0 in actions {
                try actionsContainer.encode(string0)
            }
        }
        if let analyzedAt = self.analyzedAt {
            try encodeContainer.encodeTimestamp(analyzedAt, format: .dateTime, forKey: .analyzedAt)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let isPublic = self.isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sharedVia = sharedVia {
            var sharedViaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedVia)
            for string0 in sharedVia {
                try sharedViaContainer.encode(string0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let sharedViaContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedVia)
        var sharedViaDecoded0:[Swift.String]? = nil
        if let sharedViaContainer = sharedViaContainer {
            sharedViaDecoded0 = [Swift.String]()
            for string0 in sharedViaContainer {
                if let string0 = string0 {
                    sharedViaDecoded0?.append(string0)
                }
            }
        }
        sharedVia = sharedViaDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the analyzed resource.
    public struct AnalyzedResource: Swift.Equatable {
        /// The actions that an external principal is granted permission to use by the policy that generated the finding.
        public var actions: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error message.
        public var error: Swift.String?
        /// Indicates whether the policy that generated the finding grants public access to the resource.
        /// This member is required.
        public var isPublic: Swift.Bool?
        /// The ARN of the resource that was analyzed.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// Indicates how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public var sharedVia: [Swift.String]?
        /// The current status of the finding generated from the analyzed resource.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            actions: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sharedVia: [Swift.String]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.actions = actions
            self.analyzedAt = analyzedAt
            self.createdAt = createdAt
            self.error = error
            self.isPublic = isPublic
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sharedVia = sharedVia
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes.AnalyzedResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case resourceOwnerAccount
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the ARN of the analyzed resource.
    public struct AnalyzedResourceSummary: Swift.Equatable {
        /// The ARN of the analyzed resource.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of resource that was analyzed.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?

        public init (
            resourceArn: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
        )
        {
            self.resourceArn = resourceArn
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum AnalyzerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case disabled
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyzerStatus] {
            return [
                .active,
                .creating,
                .disabled,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalyzerStatus(rawValue: rawValue) ?? AnalyzerStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.AnalyzerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case lastResourceAnalyzed
        case lastResourceAnalyzedAt
        case name
        case status
        case statusReason
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let lastResourceAnalyzed = self.lastResourceAnalyzed {
            try encodeContainer.encode(lastResourceAnalyzed, forKey: .lastResourceAnalyzed)
        }
        if let lastResourceAnalyzedAt = self.lastResourceAnalyzedAt {
            try encodeContainer.encodeTimestamp(lastResourceAnalyzedAt, format: .dateTime, forKey: .lastResourceAnalyzedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastResourceAnalyzedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastResourceAnalyzed)
        lastResourceAnalyzed = lastResourceAnalyzedDecoded
        let lastResourceAnalyzedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastResourceAnalyzedAt)
        lastResourceAnalyzedAt = lastResourceAnalyzedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.StatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about the analyzer.
    public struct AnalyzerSummary: Swift.Equatable {
        /// The ARN of the analyzer.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp for the time at which the analyzer was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The resource that was most recently analyzed by the analyzer.
        public var lastResourceAnalyzed: Swift.String?
        /// The time at which the most recently analyzed resource was analyzed.
        public var lastResourceAnalyzedAt: ClientRuntime.Date?
        /// The name of the analyzer.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the analyzer. An Active analyzer successfully monitors supported resources and generates new findings. The analyzer is Disabled when a user action, such as removing trusted access for Identity and Access Management Access Analyzer from Organizations, causes the analyzer to stop generating new findings. The status is Creating when the analyzer creation is in progress and Failed when the analyzer creation has failed.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.AnalyzerStatus?
        /// The statusReason provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
        public var statusReason: AccessAnalyzerClientTypes.StatusReason?
        /// The tags added to the analyzer.
        public var tags: [Swift.String:Swift.String]?
        /// The type of analyzer, which corresponds to the zone of trust chosen for the analyzer.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.ModelType?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            lastResourceAnalyzed: Swift.String? = nil,
            lastResourceAnalyzedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: AccessAnalyzerClientTypes.AnalyzerStatus? = nil,
            statusReason: AccessAnalyzerClientTypes.StatusReason? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: AccessAnalyzerClientTypes.ModelType? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.lastResourceAnalyzed = lastResourceAnalyzed
            self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
            self.name = name
            self.status = status
            self.statusReason = statusReason
            self.tags = tags
            self.type = type
        }
    }

}

extension ApplyArchiveRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

extension ApplyArchiveRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/archive-rule"
    }
}

/// Retroactively applies an archive rule.
public struct ApplyArchiveRuleInput: Swift.Equatable {
    /// The Amazon resource name (ARN) of the analyzer.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to apply.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct ApplyArchiveRuleInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let ruleName: Swift.String?
    let clientToken: Swift.String?
}

extension ApplyArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ApplyArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ApplyArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ApplyArchiveRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.ArchiveRuleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case filter
        case ruleName
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about an archive rule.
    public struct ArchiveRuleSummary: Swift.Equatable {
        /// The time at which the archive rule was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// A filter used to define the archive rule.
        /// This member is required.
        public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
        /// The name of the archive rule.
        /// This member is required.
        public var ruleName: Swift.String?
        /// The time at which the archive rule was last updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.filter = filter
            self.ruleName = ruleName
            self.updatedAt = updatedAt
        }
    }

}

extension CancelPolicyGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/policy/generation/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelPolicyGenerationInput: Swift.Equatable {
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelPolicyGenerationInputBody: Swift.Equatable {
}

extension CancelPolicyGenerationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelPolicyGenerationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelPolicyGenerationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelPolicyGenerationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelPolicyGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelPolicyGenerationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.CloudTrailDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRole
        case endTime
        case startTime
        case trails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = self.accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let trails = trails {
            var trailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trails)
            for trail0 in trails {
                try trailsContainer.encode(trail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.Trail?].self, forKey: .trails)
        var trailsDecoded0:[AccessAnalyzerClientTypes.Trail]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [AccessAnalyzerClientTypes.Trail]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let accessRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about CloudTrail access.
    public struct CloudTrailDetails: Swift.Equatable {
        /// The ARN of the service role that IAM Access Analyzer uses to access your CloudTrail trail and service last accessed information.
        /// This member is required.
        public var accessRole: Swift.String?
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A Trail object that contains settings for a trail.
        /// This member is required.
        public var trails: [AccessAnalyzerClientTypes.Trail]?

        public init (
            accessRole: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            trails: [AccessAnalyzerClientTypes.Trail]? = nil
        )
        {
            self.accessRole = accessRole
            self.endTime = endTime
            self.startTime = startTime
            self.trails = trails
        }
    }

}

extension AccessAnalyzerClientTypes.CloudTrailProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case startTime
        case trailProperties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let trailProperties = trailProperties {
            var trailPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailProperties)
            for trailproperties0 in trailProperties {
                try trailPropertiesContainer.encode(trailproperties0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailPropertiesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.TrailProperties?].self, forKey: .trailProperties)
        var trailPropertiesDecoded0:[AccessAnalyzerClientTypes.TrailProperties]? = nil
        if let trailPropertiesContainer = trailPropertiesContainer {
            trailPropertiesDecoded0 = [AccessAnalyzerClientTypes.TrailProperties]()
            for structure0 in trailPropertiesContainer {
                if let structure0 = structure0 {
                    trailPropertiesDecoded0?.append(structure0)
                }
            }
        }
        trailProperties = trailPropertiesDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about CloudTrail access.
    public struct CloudTrailProperties: Swift.Equatable {
        /// The end of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp after this time are not considered to generate a policy. If this is not included in the request, the default value is the current time.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range for which IAM Access Analyzer reviews your CloudTrail events. Events with a timestamp before this time are not considered to generate a policy.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// A TrailProperties object that contains settings for trail properties.
        /// This member is required.
        public var trailProperties: [AccessAnalyzerClientTypes.TrailProperties]?

        public init (
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil,
            trailProperties: [AccessAnalyzerClientTypes.TrailProperties]? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
            self.trailProperties = trailProperties
        }
    }

}

extension AccessAnalyzerClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebssnapshot = "ebsSnapshot"
        case ecrrepository = "ecrRepository"
        case efsfilesystem = "efsFileSystem"
        case iamrole = "iamRole"
        case kmskey = "kmsKey"
        case rdsdbclustersnapshot = "rdsDbClusterSnapshot"
        case rdsdbsnapshot = "rdsDbSnapshot"
        case s3bucket = "s3Bucket"
        case sdkUnknown
        case secretsmanagersecret = "secretsManagerSecret"
        case snstopic = "snsTopic"
        case sqsqueue = "sqsQueue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ebssnapshot(ebssnapshot):
                try container.encode(ebssnapshot, forKey: .ebssnapshot)
            case let .ecrrepository(ecrrepository):
                try container.encode(ecrrepository, forKey: .ecrrepository)
            case let .efsfilesystem(efsfilesystem):
                try container.encode(efsfilesystem, forKey: .efsfilesystem)
            case let .iamrole(iamrole):
                try container.encode(iamrole, forKey: .iamrole)
            case let .kmskey(kmskey):
                try container.encode(kmskey, forKey: .kmskey)
            case let .rdsdbclustersnapshot(rdsdbclustersnapshot):
                try container.encode(rdsdbclustersnapshot, forKey: .rdsdbclustersnapshot)
            case let .rdsdbsnapshot(rdsdbsnapshot):
                try container.encode(rdsdbsnapshot, forKey: .rdsdbsnapshot)
            case let .s3bucket(s3bucket):
                try container.encode(s3bucket, forKey: .s3bucket)
            case let .secretsmanagersecret(secretsmanagersecret):
                try container.encode(secretsmanagersecret, forKey: .secretsmanagersecret)
            case let .snstopic(snstopic):
                try container.encode(snstopic, forKey: .snstopic)
            case let .sqsqueue(sqsqueue):
                try container.encode(sqsqueue, forKey: .sqsqueue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ebssnapshotDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.EbsSnapshotConfiguration.self, forKey: .ebssnapshot)
        if let ebssnapshot = ebssnapshotDecoded {
            self = .ebssnapshot(ebssnapshot)
            return
        }
        let ecrrepositoryDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.EcrRepositoryConfiguration.self, forKey: .ecrrepository)
        if let ecrrepository = ecrrepositoryDecoded {
            self = .ecrrepository(ecrrepository)
            return
        }
        let iamroleDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.IamRoleConfiguration.self, forKey: .iamrole)
        if let iamrole = iamroleDecoded {
            self = .iamrole(iamrole)
            return
        }
        let efsfilesystemDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.EfsFileSystemConfiguration.self, forKey: .efsfilesystem)
        if let efsfilesystem = efsfilesystemDecoded {
            self = .efsfilesystem(efsfilesystem)
            return
        }
        let kmskeyDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.KmsKeyConfiguration.self, forKey: .kmskey)
        if let kmskey = kmskeyDecoded {
            self = .kmskey(kmskey)
            return
        }
        let rdsdbclustersnapshotDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration.self, forKey: .rdsdbclustersnapshot)
        if let rdsdbclustersnapshot = rdsdbclustersnapshotDecoded {
            self = .rdsdbclustersnapshot(rdsdbclustersnapshot)
            return
        }
        let rdsdbsnapshotDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration.self, forKey: .rdsdbsnapshot)
        if let rdsdbsnapshot = rdsdbsnapshotDecoded {
            self = .rdsdbsnapshot(rdsdbsnapshot)
            return
        }
        let secretsmanagersecretDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration.self, forKey: .secretsmanagersecret)
        if let secretsmanagersecret = secretsmanagersecretDecoded {
            self = .secretsmanagersecret(secretsmanagersecret)
            return
        }
        let s3bucketDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.S3BucketConfiguration.self, forKey: .s3bucket)
        if let s3bucket = s3bucketDecoded {
            self = .s3bucket(s3bucket)
            return
        }
        let snstopicDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.SnsTopicConfiguration.self, forKey: .snstopic)
        if let snstopic = snstopicDecoded {
            self = .snstopic(snstopic)
            return
        }
        let sqsqueueDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.SqsQueueConfiguration.self, forKey: .sqsqueue)
        if let sqsqueue = sqsqueueDecoded {
            self = .sqsqueue(sqsqueue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// Access control configuration structures for your resource. You specify the configuration as a type-value pair. You can specify only one type of access control configuration.
    public enum Configuration: Swift.Equatable {
        /// The access control configuration is for an Amazon EBS volume snapshot.
        case ebssnapshot(AccessAnalyzerClientTypes.EbsSnapshotConfiguration)
        /// The access control configuration is for an Amazon ECR repository.
        case ecrrepository(AccessAnalyzerClientTypes.EcrRepositoryConfiguration)
        /// The access control configuration is for an IAM role.
        case iamrole(AccessAnalyzerClientTypes.IamRoleConfiguration)
        /// The access control configuration is for an Amazon EFS file system.
        case efsfilesystem(AccessAnalyzerClientTypes.EfsFileSystemConfiguration)
        /// The access control configuration is for a KMS key.
        case kmskey(AccessAnalyzerClientTypes.KmsKeyConfiguration)
        /// The access control configuration is for an Amazon RDS DB cluster snapshot.
        case rdsdbclustersnapshot(AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration)
        /// The access control configuration is for an Amazon RDS DB snapshot.
        case rdsdbsnapshot(AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration)
        /// The access control configuration is for a Secrets Manager secret.
        case secretsmanagersecret(AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration)
        /// The access control configuration is for an Amazon S3 Bucket.
        case s3bucket(AccessAnalyzerClientTypes.S3BucketConfiguration)
        /// The access control configuration is for an Amazon SNS topic
        case snstopic(AccessAnalyzerClientTypes.SnsTopicConfiguration)
        /// The access control configuration is for an Amazon SQS queue.
        case sqsqueue(AccessAnalyzerClientTypes.SqsQueueConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A conflict exception error.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateAccessPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configurations)
            for (dictKey0, configurationsMap0) in configurations {
                try configurationsContainer.encode(configurationsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAccessPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-preview"
    }
}

public struct CreateAccessPreviewInput: Swift.Equatable {
    /// The [ARN of the account analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview. You can only create an access preview for analyzers with an Account type and Active status.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// Access control configuration for your resource that is used to generate the access preview. The access preview includes findings for external access allowed to the resource with the proposed access control configuration. The configuration must contain exactly one element.
    /// This member is required.
    public var configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.configurations = configurations
    }
}

struct CreateAccessPreviewInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let configurations: [Swift.String:AccessAnalyzerClientTypes.Configuration]?
    let clientToken: Swift.String?
}

extension CreateAccessPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [Swift.String:AccessAnalyzerClientTypes.Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAccessPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateAccessPreviewOutputResponse: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CreateAccessPreviewOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
}

extension CreateAccessPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateAnalyzerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerName = self.analyzerName {
            try encodeContainer.encode(analyzerName, forKey: .analyzerName)
        }
        if let archiveRules = archiveRules {
            var archiveRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .archiveRules)
            for inlinearchiverule0 in archiveRules {
                try archiveRulesContainer.encode(inlinearchiverule0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateAnalyzerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/analyzer"
    }
}

/// Creates an analyzer.
public struct CreateAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer to create.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// Specifies the archive rules to add for the analyzer. Archive rules automatically archive findings that meet the criteria you define for the rule.
    public var archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]?
    /// A client token.
    public var clientToken: Swift.String?
    /// The tags to apply to the analyzer.
    public var tags: [Swift.String:Swift.String]?
    /// The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported. You can create only one analyzer per account per Region. You can create up to 5 analyzers per organization per Region.
    /// This member is required.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init (
        analyzerName: Swift.String? = nil,
        archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.analyzerName = analyzerName
        self.archiveRules = archiveRules
        self.clientToken = clientToken
        self.tags = tags
        self.type = type
    }
}

struct CreateAnalyzerInputBody: Swift.Equatable {
    let analyzerName: Swift.String?
    let type: AccessAnalyzerClientTypes.ModelType?
    let archiveRules: [AccessAnalyzerClientTypes.InlineArchiveRule]?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateAnalyzerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerName)
        analyzerName = analyzerNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ModelType.self, forKey: .type)
        type = typeDecoded
        let archiveRulesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.InlineArchiveRule?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[AccessAnalyzerClientTypes.InlineArchiveRule]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [AccessAnalyzerClientTypes.InlineArchiveRule]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

/// The response to the request to create an analyzer.
public struct CreateAnalyzerOutputResponse: Swift.Equatable {
    /// The ARN of the analyzer that was created by the request.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateAnalyzerOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
}

extension CreateAnalyzerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateArchiveRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

extension CreateArchiveRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
    }
}

/// Creates an archive rule.
public struct CreateArchiveRuleInput: Swift.Equatable {
    /// The name of the created analyzer.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The criteria for the rule.
    /// This member is required.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to create.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct CreateArchiveRuleInputBody: Swift.Equatable {
    let ruleName: Swift.String?
    let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    let clientToken: Swift.String?
}

extension CreateArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateArchiveRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.Criterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contains
        case eq
        case exists
        case neq
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contains = contains {
            var containsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contains)
            for string0 in contains {
                try containsContainer.encode(string0)
            }
        }
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for string0 in eq {
                try eqContainer.encode(string0)
            }
        }
        if let exists = self.exists {
            try encodeContainer.encode(exists, forKey: .exists)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for string0 in neq {
                try neqContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let containsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contains)
        var containsDecoded0:[Swift.String]? = nil
        if let containsContainer = containsContainer {
            containsDecoded0 = [Swift.String]()
            for string0 in containsContainer {
                if let string0 = string0 {
                    containsDecoded0?.append(string0)
                }
            }
        }
        contains = containsDecoded0
        let existsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .exists)
        exists = existsDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The criteria to use in the filter that defines the archive rule. For more information on available filter keys, see [IAM Access Analyzer filter keys](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html).
    public struct Criterion: Swift.Equatable {
        /// A "contains" operator to match for the filter used to create the rule.
        public var contains: [Swift.String]?
        /// An "equals" operator to match for the filter used to create the rule.
        public var eq: [Swift.String]?
        /// An "exists" operator to match for the filter used to create the rule.
        public var exists: Swift.Bool?
        /// A "not equals" operator to match for the filter used to create the rule.
        public var neq: [Swift.String]?

        public init (
            contains: [Swift.String]? = nil,
            eq: [Swift.String]? = nil,
            exists: Swift.Bool? = nil,
            neq: [Swift.String]? = nil
        )
        {
            self.contains = contains
            self.eq = eq
            self.exists = exists
            self.neq = neq
        }
    }

}

extension DeleteAnalyzerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAnalyzerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())"
    }
}

/// Deletes an analyzer.
public struct DeleteAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
    }
}

struct DeleteAnalyzerInputBody: Swift.Equatable {
}

extension DeleteAnalyzerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnalyzerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteArchiveRuleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteArchiveRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        guard let ruleName = ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

/// Deletes an archive rule.
public struct DeleteArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer that associated with the archive rule to delete.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The name of the rule to delete.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct DeleteArchiveRuleInputBody: Swift.Equatable {
}

extension DeleteArchiveRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.EbsSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups
        case kmsKeyId
        case userIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for ebsgroup0 in groups {
                try groupsContainer.encode(ebsgroup0)
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for ebsuserid0 in userIds {
                try userIdsContainer.encode(ebsuserid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon EBS volume snapshot. You can propose a configuration for a new Amazon EBS volume snapshot or an Amazon EBS volume snapshot that you own by specifying the user IDs, groups, and optional KMS encryption key. For more information, see [ModifySnapshotAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySnapshotAttribute.html).
    public struct EbsSnapshotConfiguration: Swift.Equatable {
        /// The groups that have access to the Amazon EBS volume snapshot. If the value all is specified, then the Amazon EBS volume snapshot is public.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the groups, then the access preview uses the existing shared groups for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the groups, then the access preview considers the snapshot without any groups.
        ///
        /// * To propose deletion of existing shared groups, you can specify an empty list for groups.
        public var groups: [Swift.String]?
        /// The KMS key identifier for an encrypted Amazon EBS volume snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the kmsKeyId, the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?
        /// The IDs of the Amazon Web Services accounts that have access to the Amazon EBS volume snapshot.
        ///
        /// * If the configuration is for an existing Amazon EBS volume snapshot and you do not specify the userIds, then the access preview uses the existing shared userIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the userIds, then the access preview considers the snapshot without any userIds.
        ///
        /// * To propose deletion of existing shared accountIds, you can specify an empty list for userIds.
        public var userIds: [Swift.String]?

        public init (
            groups: [Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.kmsKeyId = kmsKeyId
            self.userIds = userIds
        }
    }

}

extension AccessAnalyzerClientTypes.EcrRepositoryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryPolicy = self.repositoryPolicy {
            try encodeContainer.encode(repositoryPolicy, forKey: .repositoryPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryPolicy)
        repositoryPolicy = repositoryPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon ECR repository. You can propose a configuration for a new Amazon ECR repository or an existing Amazon ECR repository that you own by specifying the Amazon ECR policy. For more information, see [Repository](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_Repository.html).
    ///
    /// * If the configuration is for an existing Amazon ECR repository and you do not specify the Amazon ECR policy, then the access preview uses the existing Amazon ECR policy for the repository.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon ECR repository without a policy.
    ///
    /// * To propose deletion of an existing Amazon ECR repository policy, you can specify an empty string for the Amazon ECR policy.
    public struct EcrRepositoryConfiguration: Swift.Equatable {
        /// The JSON repository policy text to apply to the Amazon ECR repository. For more information, see [Private repository policy examples](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the Amazon ECR User Guide.
        public var repositoryPolicy: Swift.String?

        public init (
            repositoryPolicy: Swift.String? = nil
        )
        {
            self.repositoryPolicy = repositoryPolicy
        }
    }

}

extension AccessAnalyzerClientTypes.EfsFileSystemConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileSystemPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileSystemPolicy = self.fileSystemPolicy {
            try encodeContainer.encode(fileSystemPolicy, forKey: .fileSystemPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileSystemPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemPolicy)
        fileSystemPolicy = fileSystemPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon EFS file system. You can propose a configuration for a new Amazon EFS file system or an existing Amazon EFS file system that you own by specifying the Amazon EFS policy. For more information, see [Using file systems in Amazon EFS](https://docs.aws.amazon.com/efs/latest/ug/using-fs.html).
    ///
    /// * If the configuration is for an existing Amazon EFS file system and you do not specify the Amazon EFS policy, then the access preview uses the existing Amazon EFS policy for the file system.
    ///
    /// * If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon EFS file system without a policy.
    ///
    /// * To propose deletion of an existing Amazon EFS file system policy, you can specify an empty string for the Amazon EFS policy.
    public struct EfsFileSystemConfiguration: Swift.Equatable {
        /// The JSON policy definition to apply to the Amazon EFS file system. For more information on the elements that make up a file system policy, see [Amazon EFS Resource-based policies](https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies).
        public var fileSystemPolicy: Swift.String?

        public init (
            fileSystemPolicy: Swift.String? = nil
        )
        {
            self.fileSystemPolicy = fileSystemPolicy
        }
    }

}

extension AccessAnalyzerClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for string0 in action {
                try actionContainer.encode(string0)
            }
        }
        if let analyzedAt = self.analyzedAt {
            try encodeContainer.encodeTimestamp(analyzedAt, format: .dateTime, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionKeyMap0) in condition {
                try conditionContainer.encode(conditionKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = self.isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalMap0) in principal {
                try principalContainer.encode(principalMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsource0 in sources {
                try sourcesContainer.encode(findingsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a finding.
    public struct Finding: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public var action: [Swift.String]?
        /// The time at which the resource was analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the finding was generated.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// An error.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the policy that generated the finding allows public access to the resource.
        public var isPublic: Swift.Bool?
        /// The external principal that access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that an external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource identified in the finding.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The current status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum FindingChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case changed
        case new
        case unchanged
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingChangeType] {
            return [
                .changed,
                .new,
                .unchanged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .changed: return "CHANGED"
            case .new: return "NEW"
            case .unchanged: return "UNCHANGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingChangeType(rawValue: rawValue) ?? FindingChangeType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.FindingSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detail
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = self.detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingSourceType.self, forKey: .type)
        type = typeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingSourceDetail.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The source of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
    public struct FindingSource: Swift.Equatable {
        /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
        public var detail: AccessAnalyzerClientTypes.FindingSourceDetail?
        /// Indicates the type of access that generated the finding.
        /// This member is required.
        public var type: AccessAnalyzerClientTypes.FindingSourceType?

        public init (
            detail: AccessAnalyzerClientTypes.FindingSourceDetail? = nil,
            type: AccessAnalyzerClientTypes.FindingSourceType? = nil
        )
        {
            self.detail = detail
            self.type = type
        }
    }

}

extension AccessAnalyzerClientTypes.FindingSourceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointAccount
        case accessPointArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointAccount = self.accessPointAccount {
            try encodeContainer.encode(accessPointAccount, forKey: .accessPointAccount)
        }
        if let accessPointArn = self.accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
        let accessPointAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointAccount)
        accessPointAccount = accessPointAccountDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Includes details about how the access that generated the finding is granted. This is populated for Amazon S3 bucket findings.
    public struct FindingSourceDetail: Swift.Equatable {
        /// The account of the cross-account access point that generated the finding.
        public var accessPointAccount: Swift.String?
        /// The ARN of the access point that generated the finding. The ARN format depends on whether the ARN represents an access point or a multi-region access point.
        public var accessPointArn: Swift.String?

        public init (
            accessPointAccount: Swift.String? = nil,
            accessPointArn: Swift.String? = nil
        )
        {
            self.accessPointAccount = accessPointAccount
            self.accessPointArn = accessPointArn
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum FindingSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bucketAcl
        case policy
        case s3AccessPoint
        case s3AccessPointAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingSourceType] {
            return [
                .bucketAcl,
                .policy,
                .s3AccessPoint,
                .s3AccessPointAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bucketAcl: return "BUCKET_ACL"
            case .policy: return "POLICY"
            case .s3AccessPoint: return "S3_ACCESS_POINT"
            case .s3AccessPointAccount: return "S3_ACCESS_POINT_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingSourceType(rawValue: rawValue) ?? FindingSourceType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum FindingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatus] {
            return [
                .active,
                .archived,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .resolved: return "RESOLVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatus(rawValue: rawValue) ?? FindingStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum FindingStatusUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case archived
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatusUpdate] {
            return [
                .active,
                .archived,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatusUpdate(rawValue: rawValue) ?? FindingStatusUpdate.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.FindingSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for string0 in action {
                try actionContainer.encode(string0)
            }
        }
        if let analyzedAt = self.analyzedAt {
            try encodeContainer.encodeTimestamp(analyzedAt, format: .dateTime, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .condition)
            for (dictKey0, conditionKeyMap0) in condition {
                try conditionContainer.encode(conditionKeyMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = self.isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .principal)
            for (dictKey0, principalMap0) in principal {
                try principalContainer.encode(principalMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsource0 in sources {
                try sourcesContainer.encode(findingsource0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .dateTime, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .principal)
        var principalDecoded0: [Swift.String:Swift.String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .action)
        var actionDecoded0:[Swift.String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [Swift.String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .condition)
        var conditionDecoded0: [Swift.String:Swift.String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[AccessAnalyzerClientTypes.FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [AccessAnalyzerClientTypes.FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a finding.
    public struct FindingSummary: Swift.Equatable {
        /// The action in the analyzed policy statement that an external principal has permission to use.
        public var action: [Swift.String]?
        /// The time at which the resource-based policy that generated the finding was analyzed.
        /// This member is required.
        public var analyzedAt: ClientRuntime.Date?
        /// The condition in the analyzed policy statement that resulted in a finding.
        /// This member is required.
        public var condition: [Swift.String:Swift.String]?
        /// The time at which the finding was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The error that resulted in an Error finding.
        public var error: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates whether the finding reports a resource that has a policy that allows public access.
        public var isPublic: Swift.Bool?
        /// The external principal that has access to a resource within the zone of trust.
        public var principal: [Swift.String:Swift.String]?
        /// The resource that the external principal has access to.
        public var resource: Swift.String?
        /// The Amazon Web Services account ID that owns the resource.
        /// This member is required.
        public var resourceOwnerAccount: Swift.String?
        /// The type of the resource that the external principal has access to.
        /// This member is required.
        public var resourceType: AccessAnalyzerClientTypes.ResourceType?
        /// The sources of the finding. This indicates how the access that generated the finding is granted. It is populated for Amazon S3 bucket findings.
        public var sources: [AccessAnalyzerClientTypes.FindingSource]?
        /// The status of the finding.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.FindingStatus?
        /// The time at which the finding was most recently updated.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            action: [Swift.String]? = nil,
            analyzedAt: ClientRuntime.Date? = nil,
            condition: [Swift.String:Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            error: Swift.String? = nil,
            id: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            principal: [Swift.String:Swift.String]? = nil,
            resource: Swift.String? = nil,
            resourceOwnerAccount: Swift.String? = nil,
            resourceType: AccessAnalyzerClientTypes.ResourceType? = nil,
            sources: [AccessAnalyzerClientTypes.FindingSource]? = nil,
            status: AccessAnalyzerClientTypes.FindingStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.action = action
            self.analyzedAt = analyzedAt
            self.condition = condition
            self.createdAt = createdAt
            self.error = error
            self.id = id
            self.isPublic = isPublic
            self.principal = principal
            self.resource = resource
            self.resourceOwnerAccount = resourceOwnerAccount
            self.resourceType = resourceType
            self.sources = sources
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the text for the generated policy.
    public struct GeneratedPolicy: Swift.Equatable {
        /// The text to use as the content for the new policy. The policy is created using the [CreatePolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html) action.
        /// This member is required.
        public var policy: Swift.String?

        public init (
            policy: Swift.String? = nil
        )
        {
            self.policy = policy
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicyProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrailProperties
        case isComplete
        case principalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrailProperties = self.cloudTrailProperties {
            try encodeContainer.encode(cloudTrailProperties, forKey: .cloudTrailProperties)
        }
        if let isComplete = self.isComplete {
            try encodeContainer.encode(isComplete, forKey: .isComplete)
        }
        if let principalArn = self.principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCompleteDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isComplete)
        isComplete = isCompleteDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let cloudTrailPropertiesDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.CloudTrailProperties.self, forKey: .cloudTrailProperties)
        cloudTrailProperties = cloudTrailPropertiesDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the generated policy details.
    public struct GeneratedPolicyProperties: Swift.Equatable {
        /// Lists details about the Trail used to generated policy.
        public var cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties?
        /// This value is set to true if the generated policy contains all possible actions for a service that IAM Access Analyzer identified from the CloudTrail trail that you specified, and false otherwise.
        public var isComplete: Swift.Bool?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init (
            cloudTrailProperties: AccessAnalyzerClientTypes.CloudTrailProperties? = nil,
            isComplete: Swift.Bool? = nil,
            principalArn: Swift.String? = nil
        )
        {
            self.cloudTrailProperties = cloudTrailProperties
            self.isComplete = isComplete
            self.principalArn = principalArn
        }
    }

}

extension AccessAnalyzerClientTypes.GeneratedPolicyResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedPolicies
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedPolicies = generatedPolicies {
            var generatedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedPolicies)
            for generatedpolicy0 in generatedPolicies {
                try generatedPoliciesContainer.encode(generatedpolicy0)
            }
        }
        if let properties = self.properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.GeneratedPolicyProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let generatedPoliciesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.GeneratedPolicy?].self, forKey: .generatedPolicies)
        var generatedPoliciesDecoded0:[AccessAnalyzerClientTypes.GeneratedPolicy]? = nil
        if let generatedPoliciesContainer = generatedPoliciesContainer {
            generatedPoliciesDecoded0 = [AccessAnalyzerClientTypes.GeneratedPolicy]()
            for structure0 in generatedPoliciesContainer {
                if let structure0 = structure0 {
                    generatedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        generatedPolicies = generatedPoliciesDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the text for the generated policy and its details.
    public struct GeneratedPolicyResult: Swift.Equatable {
        /// The text to use as the content for the new policy. The policy is created using the [CreatePolicy](https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html) action.
        public var generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]?
        /// A GeneratedPolicyProperties object that contains properties of the generated policy.
        /// This member is required.
        public var properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties?

        public init (
            generatedPolicies: [AccessAnalyzerClientTypes.GeneratedPolicy]? = nil,
            properties: AccessAnalyzerClientTypes.GeneratedPolicyProperties? = nil
        )
        {
            self.generatedPolicies = generatedPolicies
            self.properties = properties
        }
    }

}

extension GetAccessPreviewInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let analyzerArn = analyzerArn else {
                let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            items.append(analyzerArnQueryItem)
            return items
        }
    }
}

extension GetAccessPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPreviewId = accessPreviewId else {
            return nil
        }
        return "/access-preview/\(accessPreviewId.urlPercentEncoding())"
    }
}

public struct GetAccessPreviewInput: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?

    public init (
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
    }
}

struct GetAccessPreviewInputBody: Swift.Equatable {
}

extension GetAccessPreviewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccessPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccessPreviewOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPreview = output.accessPreview
        } else {
            self.accessPreview = nil
        }
    }
}

public struct GetAccessPreviewOutputResponse: Swift.Equatable {
    /// An object that contains information about the access preview.
    /// This member is required.
    public var accessPreview: AccessAnalyzerClientTypes.AccessPreview?

    public init (
        accessPreview: AccessAnalyzerClientTypes.AccessPreview? = nil
    )
    {
        self.accessPreview = accessPreview
    }
}

struct GetAccessPreviewOutputResponseBody: Swift.Equatable {
    let accessPreview: AccessAnalyzerClientTypes.AccessPreview?
}

extension GetAccessPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPreview
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AccessPreview.self, forKey: .accessPreview)
        accessPreview = accessPreviewDecoded
    }
}

extension GetAnalyzedResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            guard let analyzerArn = analyzerArn else {
                let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            items.append(analyzerArnQueryItem)
            return items
        }
    }
}

extension GetAnalyzedResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/analyzed-resource"
    }
}

/// Retrieves an analyzed resource.
public struct GetAnalyzedResourceInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve information from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to retrieve information about.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

struct GetAnalyzedResourceInputBody: Swift.Equatable {
}

extension GetAnalyzedResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnalyzedResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzedResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAnalyzedResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzedResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAnalyzedResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resource = output.resource
        } else {
            self.resource = nil
        }
    }
}

/// The response to the request.
public struct GetAnalyzedResourceOutputResponse: Swift.Equatable {
    /// An AnalyzedResource object that contains information that IAM Access Analyzer found when it analyzed the resource.
    public var resource: AccessAnalyzerClientTypes.AnalyzedResource?

    public init (
        resource: AccessAnalyzerClientTypes.AnalyzedResource? = nil
    )
    {
        self.resource = resource
    }
}

struct GetAnalyzedResourceOutputResponseBody: Swift.Equatable {
    let resource: AccessAnalyzerClientTypes.AnalyzedResource?
}

extension GetAnalyzedResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzedResource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension GetAnalyzerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())"
    }
}

/// Retrieves an analyzer.
public struct GetAnalyzerInput: Swift.Equatable {
    /// The name of the analyzer retrieved.
    /// This member is required.
    public var analyzerName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
    }
}

struct GetAnalyzerInputBody: Swift.Equatable {
}

extension GetAnalyzerInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnalyzerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAnalyzerOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzer = output.analyzer
        } else {
            self.analyzer = nil
        }
    }
}

/// The response to the request.
public struct GetAnalyzerOutputResponse: Swift.Equatable {
    /// An AnalyzerSummary object that contains information about the analyzer.
    /// This member is required.
    public var analyzer: AccessAnalyzerClientTypes.AnalyzerSummary?

    public init (
        analyzer: AccessAnalyzerClientTypes.AnalyzerSummary? = nil
    )
    {
        self.analyzer = analyzer
    }
}

struct GetAnalyzerOutputResponseBody: Swift.Equatable {
    let analyzer: AccessAnalyzerClientTypes.AnalyzerSummary?
}

extension GetAnalyzerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AnalyzerSummary.self, forKey: .analyzer)
        analyzer = analyzerDecoded
    }
}

extension GetArchiveRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        guard let ruleName = ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

/// Retrieves an archive rule.
public struct GetArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The name of the rule to retrieve.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.ruleName = ruleName
    }
}

struct GetArchiveRuleInputBody: Swift.Equatable {
}

extension GetArchiveRuleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetArchiveRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveRule = output.archiveRule
        } else {
            self.archiveRule = nil
        }
    }
}

/// The response to the request.
public struct GetArchiveRuleOutputResponse: Swift.Equatable {
    /// Contains information about an archive rule.
    /// This member is required.
    public var archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary?

    public init (
        archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary? = nil
    )
    {
        self.archiveRule = archiveRule
    }
}

struct GetArchiveRuleOutputResponseBody: Swift.Equatable {
    let archiveRule: AccessAnalyzerClientTypes.ArchiveRuleSummary?
}

extension GetArchiveRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveRule
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRuleDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ArchiveRuleSummary.self, forKey: .archiveRule)
        archiveRule = archiveRuleDecoded
    }
}

extension GetFindingInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let analyzerArn = analyzerArn else {
                let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            items.append(analyzerArnQueryItem)
            return items
        }
    }
}

extension GetFindingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/finding/\(id.urlPercentEncoding())"
    }
}

/// Retrieves a finding.
public struct GetFindingInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) that generated the finding.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ID of the finding to retrieve.
    /// This member is required.
    public var id: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
    }
}

struct GetFindingInputBody: Swift.Equatable {
}

extension GetFindingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFindingOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFindingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.finding = output.finding
        } else {
            self.finding = nil
        }
    }
}

/// The response to the request.
public struct GetFindingOutputResponse: Swift.Equatable {
    /// A finding object that contains finding details.
    public var finding: AccessAnalyzerClientTypes.Finding?

    public init (
        finding: AccessAnalyzerClientTypes.Finding? = nil
    )
    {
        self.finding = finding
    }
}

struct GetFindingOutputResponseBody: Swift.Equatable {
    let finding: AccessAnalyzerClientTypes.Finding?
}

extension GetFindingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finding
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Finding.self, forKey: .finding)
        finding = findingDecoded
    }
}

extension GetGeneratedPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let includeResourcePlaceholders = includeResourcePlaceholders {
                let includeResourcePlaceholdersQueryItem = ClientRuntime.URLQueryItem(name: "includeResourcePlaceholders".urlPercentEncoding(), value: Swift.String(includeResourcePlaceholders).urlPercentEncoding())
                items.append(includeResourcePlaceholdersQueryItem)
            }
            if let includeServiceLevelTemplate = includeServiceLevelTemplate {
                let includeServiceLevelTemplateQueryItem = ClientRuntime.URLQueryItem(name: "includeServiceLevelTemplate".urlPercentEncoding(), value: Swift.String(includeServiceLevelTemplate).urlPercentEncoding())
                items.append(includeServiceLevelTemplateQueryItem)
            }
            return items
        }
    }
}

extension GetGeneratedPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/policy/generation/\(jobId.urlPercentEncoding())"
    }
}

public struct GetGeneratedPolicyInput: Swift.Equatable {
    /// The level of detail that you want to generate. You can specify whether to generate policies with placeholders for resource ARNs for actions that support resource level granularity in policies. For example, in the resource section of a policy, you can receive a placeholder such as "Resource":"arn:aws:s3:::${BucketName}" instead of "*".
    public var includeResourcePlaceholders: Swift.Bool?
    /// The level of detail that you want to generate. You can specify whether to generate service-level policies. IAM Access Analyzer uses iam:servicelastaccessed to identify services that have been used recently to create this service-level template.
    public var includeServiceLevelTemplate: Swift.Bool?
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        includeResourcePlaceholders: Swift.Bool? = nil,
        includeServiceLevelTemplate: Swift.Bool? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.includeResourcePlaceholders = includeResourcePlaceholders
        self.includeServiceLevelTemplate = includeServiceLevelTemplate
        self.jobId = jobId
    }
}

struct GetGeneratedPolicyInputBody: Swift.Equatable {
}

extension GetGeneratedPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetGeneratedPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeneratedPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetGeneratedPolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeneratedPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetGeneratedPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.generatedPolicyResult = output.generatedPolicyResult
            self.jobDetails = output.jobDetails
        } else {
            self.generatedPolicyResult = nil
            self.jobDetails = nil
        }
    }
}

public struct GetGeneratedPolicyOutputResponse: Swift.Equatable {
    /// A GeneratedPolicyResult object that contains the generated policies and associated details.
    /// This member is required.
    public var generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult?
    /// A GeneratedPolicyDetails object that contains details about the generated policy.
    /// This member is required.
    public var jobDetails: AccessAnalyzerClientTypes.JobDetails?

    public init (
        generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult? = nil,
        jobDetails: AccessAnalyzerClientTypes.JobDetails? = nil
    )
    {
        self.generatedPolicyResult = generatedPolicyResult
        self.jobDetails = jobDetails
    }
}

struct GetGeneratedPolicyOutputResponseBody: Swift.Equatable {
    let jobDetails: AccessAnalyzerClientTypes.JobDetails?
    let generatedPolicyResult: AccessAnalyzerClientTypes.GeneratedPolicyResult?
}

extension GetGeneratedPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedPolicyResult
        case jobDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let generatedPolicyResultDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.GeneratedPolicyResult.self, forKey: .generatedPolicyResult)
        generatedPolicyResult = generatedPolicyResultDecoded
    }
}

extension AccessAnalyzerClientTypes.IamRoleConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustPolicy = self.trustPolicy {
            try encodeContainer.encode(trustPolicy, forKey: .trustPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustPolicy)
        trustPolicy = trustPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an IAM role. You can propose a configuration for a new IAM role or an existing IAM role that you own by specifying the trust policy. If the configuration is for a new IAM role, you must specify the trust policy. If the configuration is for an existing IAM role that you own and you do not propose the trust policy, the access preview uses the existing trust policy for the role. The proposed trust policy cannot be an empty string. For more information about role trust policy limits, see [IAM and STS quotas](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html).
    public struct IamRoleConfiguration: Swift.Equatable {
        /// The proposed trust policy for the IAM role.
        public var trustPolicy: Swift.String?

        public init (
            trustPolicy: Swift.String? = nil
        )
        {
            self.trustPolicy = trustPolicy
        }
    }

}

extension AccessAnalyzerClientTypes.InlineArchiveRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ruleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let ruleName = self.ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// An criterion statement in an archive rule. Each archive rule may have multiple criteria.
    public struct InlineArchiveRule: Swift.Equatable {
        /// The condition and values for a criterion.
        /// This member is required.
        public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
        /// The name of the rule.
        /// This member is required.
        public var ruleName: Swift.String?

        public init (
            filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
            ruleName: Swift.String? = nil
        )
        {
            self.filter = filter
            self.ruleName = ruleName
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal server error.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The seconds to wait to retry.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.InternetConfiguration: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension AccessAnalyzerClientTypes {
    /// This configuration sets the network origin for the Amazon S3 access point or multi-region access point to Internet.
    public struct InternetConfiguration: Swift.Equatable {

        public init () { }
    }

}

extension AccessAnalyzerClientTypes.JobDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedOn
        case jobError
        case jobId
        case startedOn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = self.completedOn {
            try encodeContainer.encodeTimestamp(completedOn, format: .dateTime, forKey: .completedOn)
        }
        if let jobError = self.jobError {
            try encodeContainer.encode(jobError, forKey: .jobError)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startedOn = self.startedOn {
            try encodeContainer.encodeTimestamp(startedOn, format: .dateTime, forKey: .startedOn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedOn)
        completedOn = completedOnDecoded
        let jobErrorDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobError.self, forKey: .jobError)
        jobError = jobErrorDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the policy generation request.
    public struct JobDetails: Swift.Equatable {
        /// A timestamp of when the job was completed.
        public var completedOn: ClientRuntime.Date?
        /// The job error for the policy generation request.
        public var jobError: AccessAnalyzerClientTypes.JobError?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// A timestamp of when the job was started.
        /// This member is required.
        public var startedOn: ClientRuntime.Date?
        /// The status of the job request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init (
            completedOn: ClientRuntime.Date? = nil,
            jobError: AccessAnalyzerClientTypes.JobError? = nil,
            jobId: Swift.String? = nil,
            startedOn: ClientRuntime.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobError = jobError
            self.jobId = jobId
            self.startedOn = startedOn
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes.JobError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the details about the policy generation error.
    public struct JobError: Swift.Equatable {
        /// The job error code.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.JobErrorCode?
        /// Specific information about the error. For example, which service quota was exceeded or which resource was not found.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: AccessAnalyzerClientTypes.JobErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum JobErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizationError
        case resourceNotFoundError
        case serviceError
        case serviceQuotaExceededError
        case sdkUnknown(Swift.String)

        public static var allCases: [JobErrorCode] {
            return [
                .authorizationError,
                .resourceNotFoundError,
                .serviceError,
                .serviceQuotaExceededError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizationError: return "AUTHORIZATION_ERROR"
            case .resourceNotFoundError: return "RESOURCE_NOT_FOUND_ERROR"
            case .serviceError: return "SERVICE_ERROR"
            case .serviceQuotaExceededError: return "SERVICE_QUOTA_EXCEEDED_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobErrorCode(rawValue: rawValue) ?? JobErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.KmsGrantConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraints
        case granteePrincipal
        case issuingAccount
        case operations
        case retiringPrincipal
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = self.constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let granteePrincipal = self.granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let issuingAccount = self.issuingAccount {
            try encodeContainer.encode(issuingAccount, forKey: .issuingAccount)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for kmsgrantoperation0 in operations {
                try operationsContainer.encode(kmsgrantoperation0.rawValue)
            }
        }
        if let retiringPrincipal = self.retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.KmsGrantOperation?].self, forKey: .operations)
        var operationsDecoded0:[AccessAnalyzerClientTypes.KmsGrantOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [AccessAnalyzerClientTypes.KmsGrantOperation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.KmsGrantConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let issuingAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuingAccount)
        issuingAccount = issuingAccountDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A proposed grant configuration for a KMS key. For more information, see [CreateGrant](https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateGrant.html).
    public struct KmsGrantConfiguration: Swift.Equatable {
        /// Use this structure to propose allowing [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) in the grant only when the operation request includes the specified [encryption context](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context).
        public var constraints: AccessAnalyzerClientTypes.KmsGrantConstraints?
        /// The principal that is given permission to perform the operations that the grant permits.
        /// This member is required.
        public var granteePrincipal: Swift.String?
        /// The Amazon Web Services account under which the grant was issued. The account is used to propose KMS grants issued by accounts other than the owner of the key.
        /// This member is required.
        public var issuingAccount: Swift.String?
        /// A list of operations that the grant permits.
        /// This member is required.
        public var operations: [AccessAnalyzerClientTypes.KmsGrantOperation]?
        /// The principal that is given permission to retire the grant by using [RetireGrant](https://docs.aws.amazon.com/kms/latest/APIReference/API_RetireGrant.html) operation.
        public var retiringPrincipal: Swift.String?

        public init (
            constraints: AccessAnalyzerClientTypes.KmsGrantConstraints? = nil,
            granteePrincipal: Swift.String? = nil,
            issuingAccount: Swift.String? = nil,
            operations: [AccessAnalyzerClientTypes.KmsGrantOperation]? = nil,
            retiringPrincipal: Swift.String? = nil
        )
        {
            self.constraints = constraints
            self.granteePrincipal = granteePrincipal
            self.issuingAccount = issuingAccount
            self.operations = operations
            self.retiringPrincipal = retiringPrincipal
        }
    }

}

extension AccessAnalyzerClientTypes.KmsGrantConstraints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionContextEquals
        case encryptionContextSubset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContextEquals = encryptionContextEquals {
            var encryptionContextEqualsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .encryptionContextEquals)
            for (dictKey0, kmsConstraintsMap0) in encryptionContextEquals {
                try encryptionContextEqualsContainer.encode(kmsConstraintsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let encryptionContextSubset = encryptionContextSubset {
            var encryptionContextSubsetContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .encryptionContextSubset)
            for (dictKey0, kmsConstraintsMap0) in encryptionContextSubset {
                try encryptionContextSubsetContainer.encode(kmsConstraintsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextEqualsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .encryptionContextEquals)
        var encryptionContextEqualsDecoded0: [Swift.String:Swift.String]? = nil
        if let encryptionContextEqualsContainer = encryptionContextEqualsContainer {
            encryptionContextEqualsDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextEqualsContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextEqualsDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextEquals = encryptionContextEqualsDecoded0
        let encryptionContextSubsetContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .encryptionContextSubset)
        var encryptionContextSubsetDecoded0: [Swift.String:Swift.String]? = nil
        if let encryptionContextSubsetContainer = encryptionContextSubsetContainer {
            encryptionContextSubsetDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextSubsetContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextSubsetDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextSubset = encryptionContextSubsetDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Use this structure to propose allowing [cryptographic operations](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) in the grant only when the operation request includes the specified [encryption context](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context). You can specify only one type of encryption context. An empty map is treated as not specified. For more information, see [GrantConstraints](https://docs.aws.amazon.com/kms/latest/APIReference/API_GrantConstraints.html).
    public struct KmsGrantConstraints: Swift.Equatable {
        /// A list of key-value pairs that must match the encryption context in the [cryptographic operation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) request. The grant allows the operation only when the encryption context in the request is the same as the encryption context specified in this constraint.
        public var encryptionContextEquals: [Swift.String:Swift.String]?
        /// A list of key-value pairs that must be included in the encryption context of the [cryptographic operation](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations) request. The grant allows the cryptographic operation only when the encryption context in the request includes the key-value pairs specified in this constraint, although it can include additional key-value pairs.
        public var encryptionContextSubset: [Swift.String:Swift.String]?

        public init (
            encryptionContextEquals: [Swift.String:Swift.String]? = nil,
            encryptionContextSubset: [Swift.String:Swift.String]? = nil
        )
        {
            self.encryptionContextEquals = encryptionContextEquals
            self.encryptionContextSubset = encryptionContextSubset
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum KmsGrantOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createGrant
        case decrypt
        case describeKey
        case encrypt
        case generateDataKey
        case generateDataKeyPair
        case generateDataKeyPairWithoutPlaintext
        case generateDataKeyWithoutPlaintext
        case getPublicKey
        case reencryptFrom
        case reencryptTo
        case retireGrant
        case sign
        case verify
        case sdkUnknown(Swift.String)

        public static var allCases: [KmsGrantOperation] {
            return [
                .createGrant,
                .decrypt,
                .describeKey,
                .encrypt,
                .generateDataKey,
                .generateDataKeyPair,
                .generateDataKeyPairWithoutPlaintext,
                .generateDataKeyWithoutPlaintext,
                .getPublicKey,
                .reencryptFrom,
                .reencryptTo,
                .retireGrant,
                .sign,
                .verify,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createGrant: return "CreateGrant"
            case .decrypt: return "Decrypt"
            case .describeKey: return "DescribeKey"
            case .encrypt: return "Encrypt"
            case .generateDataKey: return "GenerateDataKey"
            case .generateDataKeyPair: return "GenerateDataKeyPair"
            case .generateDataKeyPairWithoutPlaintext: return "GenerateDataKeyPairWithoutPlaintext"
            case .generateDataKeyWithoutPlaintext: return "GenerateDataKeyWithoutPlaintext"
            case .getPublicKey: return "GetPublicKey"
            case .reencryptFrom: return "ReEncryptFrom"
            case .reencryptTo: return "ReEncryptTo"
            case .retireGrant: return "RetireGrant"
            case .sign: return "Sign"
            case .verify: return "Verify"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KmsGrantOperation(rawValue: rawValue) ?? KmsGrantOperation.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.KmsKeyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants
        case keyPolicies
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grants = grants {
            var grantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grants)
            for kmsgrantconfiguration0 in grants {
                try grantsContainer.encode(kmsgrantconfiguration0)
            }
        }
        if let keyPolicies = keyPolicies {
            var keyPoliciesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .keyPolicies)
            for (dictKey0, kmsKeyPoliciesMap0) in keyPolicies {
                try keyPoliciesContainer.encode(kmsKeyPoliciesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPoliciesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .keyPolicies)
        var keyPoliciesDecoded0: [Swift.String:Swift.String]? = nil
        if let keyPoliciesContainer = keyPoliciesContainer {
            keyPoliciesDecoded0 = [Swift.String:Swift.String]()
            for (key0, kmskeypolicy0) in keyPoliciesContainer {
                if let kmskeypolicy0 = kmskeypolicy0 {
                    keyPoliciesDecoded0?[key0] = kmskeypolicy0
                }
            }
        }
        keyPolicies = keyPoliciesDecoded0
        let grantsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.KmsGrantConfiguration?].self, forKey: .grants)
        var grantsDecoded0:[AccessAnalyzerClientTypes.KmsGrantConfiguration]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [AccessAnalyzerClientTypes.KmsGrantConfiguration]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Proposed access control configuration for a KMS key. You can propose a configuration for a new KMS key or an existing KMS key that you own by specifying the key policy and KMS grant configuration. If the configuration is for an existing key and you do not specify the key policy, the access preview uses the existing policy for the key. If the access preview is for a new resource and you do not specify the key policy, then the access preview uses the default key policy. The proposed key policy cannot be an empty string. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default). For more information about key policy limits, see [Resource quotas](https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html).
    public struct KmsKeyConfiguration: Swift.Equatable {
        /// A list of proposed grant configurations for the KMS key. If the proposed grant configuration is for an existing key, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the key.
        public var grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]?
        /// Resource policy configuration for the KMS key. The only valid value for the name of the key policy is default. For more information, see [Default key policy](https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default).
        public var keyPolicies: [Swift.String:Swift.String]?

        public init (
            grants: [AccessAnalyzerClientTypes.KmsGrantConfiguration]? = nil,
            keyPolicies: [Swift.String:Swift.String]? = nil
        )
        {
            self.grants = grants
            self.keyPolicies = keyPolicies
        }
    }

}

extension ListAccessPreviewFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccessPreviewFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPreviewId = accessPreviewId else {
            return nil
        }
        return "/access-preview/\(accessPreviewId.urlPercentEncoding())"
    }
}

public struct ListAccessPreviewFindingsInput: Swift.Equatable {
    /// The unique ID for the access preview.
    /// This member is required.
    public var accessPreviewId: Swift.String?
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// Criteria to filter the returned findings.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        accessPreviewId: Swift.String? = nil,
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAccessPreviewFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccessPreviewFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessPreviewFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessPreviewFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewFindingsOutputResponse: Swift.Equatable {
    /// A list of access preview findings that match the specified filter criteria.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsOutputResponseBody: Swift.Equatable {
    let findings: [AccessAnalyzerClientTypes.AccessPreviewFinding]?
    let nextToken: Swift.String?
}

extension ListAccessPreviewFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AccessPreviewFinding?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.AccessPreviewFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.AccessPreviewFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessPreviewsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let analyzerArn = analyzerArn else {
                let message = "Creating a URL Query Item failed. analyzerArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let analyzerArnQueryItem = ClientRuntime.URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: Swift.String(analyzerArn).urlPercentEncoding())
            items.append(analyzerArnQueryItem)
            return items
        }
    }
}

extension ListAccessPreviewsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-preview"
    }
}

public struct ListAccessPreviewsInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) used to generate the access preview.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsInputBody: Swift.Equatable {
}

extension ListAccessPreviewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPreviewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessPreviewsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessPreviewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPreviews = output.accessPreviews
            self.nextToken = output.nextToken
        } else {
            self.accessPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewsOutputResponse: Swift.Equatable {
    /// A list of access previews retrieved for the analyzer.
    /// This member is required.
    public var accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPreviews = accessPreviews
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsOutputResponseBody: Swift.Equatable {
    let accessPreviews: [AccessAnalyzerClientTypes.AccessPreviewSummary]?
    let nextToken: Swift.String?
}

extension ListAccessPreviewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPreviews
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AccessPreviewSummary?].self, forKey: .accessPreviews)
        var accessPreviewsDecoded0:[AccessAnalyzerClientTypes.AccessPreviewSummary]? = nil
        if let accessPreviewsContainer = accessPreviewsContainer {
            accessPreviewsDecoded0 = [AccessAnalyzerClientTypes.AccessPreviewSummary]()
            for structure0 in accessPreviewsContainer {
                if let structure0 = structure0 {
                    accessPreviewsDecoded0?.append(structure0)
                }
            }
        }
        accessPreviews = accessPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnalyzedResourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension ListAnalyzedResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/analyzed-resource"
    }
}

/// Retrieves a list of resources that have been analyzed.
public struct ListAnalyzedResourcesInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve a list of analyzed resources from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of resource.
    public var resourceType: AccessAnalyzerClientTypes.ResourceType?

    public init (
        analyzerArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceType: AccessAnalyzerClientTypes.ResourceType? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListAnalyzedResourcesInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let resourceType: AccessAnalyzerClientTypes.ResourceType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAnalyzedResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAnalyzedResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzedResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnalyzedResourcesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzedResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnalyzedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzedResources = output.analyzedResources
            self.nextToken = output.nextToken
        } else {
            self.analyzedResources = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListAnalyzedResourcesOutputResponse: Swift.Equatable {
    /// A list of resources that were analyzed.
    /// This member is required.
    public var analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzedResources = analyzedResources
        self.nextToken = nextToken
    }
}

struct ListAnalyzedResourcesOutputResponseBody: Swift.Equatable {
    let analyzedResources: [AccessAnalyzerClientTypes.AnalyzedResourceSummary]?
    let nextToken: Swift.String?
}

extension ListAnalyzedResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzedResources
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzedResourcesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AnalyzedResourceSummary?].self, forKey: .analyzedResources)
        var analyzedResourcesDecoded0:[AccessAnalyzerClientTypes.AnalyzedResourceSummary]? = nil
        if let analyzedResourcesContainer = analyzedResourcesContainer {
            analyzedResourcesDecoded0 = [AccessAnalyzerClientTypes.AnalyzedResourceSummary]()
            for structure0 in analyzedResourcesContainer {
                if let structure0 = structure0 {
                    analyzedResourcesDecoded0?.append(structure0)
                }
            }
        }
        analyzedResources = analyzedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnalyzersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension ListAnalyzersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/analyzer"
    }
}

/// Retrieves a list of analyzers.
public struct ListAnalyzersInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The type of analyzer.
    public var type: AccessAnalyzerClientTypes.ModelType?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: AccessAnalyzerClientTypes.ModelType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListAnalyzersInputBody: Swift.Equatable {
}

extension ListAnalyzersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalyzersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnalyzersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnalyzersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.analyzers = output.analyzers
            self.nextToken = output.nextToken
        } else {
            self.analyzers = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListAnalyzersOutputResponse: Swift.Equatable {
    /// The analyzers retrieved.
    /// This member is required.
    public var analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzers = analyzers
        self.nextToken = nextToken
    }
}

struct ListAnalyzersOutputResponseBody: Swift.Equatable {
    let analyzers: [AccessAnalyzerClientTypes.AnalyzerSummary]?
    let nextToken: Swift.String?
}

extension ListAnalyzersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzers
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzersContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.AnalyzerSummary?].self, forKey: .analyzers)
        var analyzersDecoded0:[AccessAnalyzerClientTypes.AnalyzerSummary]? = nil
        if let analyzersContainer = analyzersContainer {
            analyzersDecoded0 = [AccessAnalyzerClientTypes.AnalyzerSummary]()
            for structure0 in analyzersContainer {
                if let structure0 = structure0 {
                    analyzersDecoded0?.append(structure0)
                }
            }
        }
        analyzers = analyzersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArchiveRulesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListArchiveRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule"
    }
}

/// Retrieves a list of archive rules created for the specified analyzer.
public struct ListArchiveRulesInput: Swift.Equatable {
    /// The name of the analyzer to retrieve rules from.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// The maximum number of results to return in the request.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesInputBody: Swift.Equatable {
}

extension ListArchiveRulesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListArchiveRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchiveRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListArchiveRulesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchiveRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListArchiveRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.archiveRules = output.archiveRules
            self.nextToken = output.nextToken
        } else {
            self.archiveRules = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListArchiveRulesOutputResponse: Swift.Equatable {
    /// A list of archive rules created for the specified analyzer.
    /// This member is required.
    public var archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.archiveRules = archiveRules
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesOutputResponseBody: Swift.Equatable {
    let archiveRules: [AccessAnalyzerClientTypes.ArchiveRuleSummary]?
    let nextToken: Swift.String?
}

extension ListArchiveRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case archiveRules
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRulesContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ArchiveRuleSummary?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[AccessAnalyzerClientTypes.ArchiveRuleSummary]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [AccessAnalyzerClientTypes.ArchiveRuleSummary]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/finding"
    }
}

/// Retrieves a list of findings generated by the specified analyzer.
public struct ListFindingsInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to retrieve findings from.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A filter to match for the findings to return.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The sort order for the findings returned.
    public var sort: AccessAnalyzerClientTypes.SortCriteria?

    public init (
        analyzerArn: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: AccessAnalyzerClientTypes.SortCriteria? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    let sort: AccessAnalyzerClientTypes.SortCriteria?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.SortCriteria.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

/// The response to the request.
public struct ListFindingsOutputResponse: Swift.Equatable {
    /// A list of findings retrieved from the analyzer that match the filter criteria specified, if any.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.FindingSummary]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.FindingSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    let findings: [AccessAnalyzerClientTypes.FindingSummary]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.FindingSummary?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.FindingSummary]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.FindingSummary]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPolicyGenerationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let principalArn = principalArn {
                let principalArnQueryItem = ClientRuntime.URLQueryItem(name: "principalArn".urlPercentEncoding(), value: Swift.String(principalArn).urlPercentEncoding())
                items.append(principalArnQueryItem)
            }
            return items
        }
    }
}

extension ListPolicyGenerationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/policy/generation"
    }
}

public struct ListPolicyGenerationsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The ARN of the IAM entity (user or role) for which you are generating a policy. Use this with ListGeneratedPolicies to filter the results to only include results for a specific principal.
    public var principalArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalArn = principalArn
    }
}

struct ListPolicyGenerationsInputBody: Swift.Equatable {
}

extension ListPolicyGenerationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPolicyGenerationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyGenerationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPolicyGenerationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyGenerationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPolicyGenerationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.policyGenerations = output.policyGenerations
        } else {
            self.nextToken = nil
            self.policyGenerations = nil
        }
    }
}

public struct ListPolicyGenerationsOutputResponse: Swift.Equatable {
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// A PolicyGeneration object that contains details about the generated policy.
    /// This member is required.
    public var policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]?

    public init (
        nextToken: Swift.String? = nil,
        policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyGenerations = policyGenerations
    }
}

struct ListPolicyGenerationsOutputResponseBody: Swift.Equatable {
    let policyGenerations: [AccessAnalyzerClientTypes.PolicyGeneration]?
    let nextToken: Swift.String?
}

extension ListPolicyGenerationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case policyGenerations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.PolicyGeneration?].self, forKey: .policyGenerations)
        var policyGenerationsDecoded0:[AccessAnalyzerClientTypes.PolicyGeneration]? = nil
        if let policyGenerationsContainer = policyGenerationsContainer {
            policyGenerationsDecoded0 = [AccessAnalyzerClientTypes.PolicyGeneration]()
            for structure0 in policyGenerationsContainer {
                if let structure0 = structure0 {
                    policyGenerationsDecoded0?.append(structure0)
                }
            }
        }
        policyGenerations = policyGenerationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Retrieves a list of tags applied to the specified resource.
public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to retrieve tags from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// The response to the request.
public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags that are applied to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case de
        case en
        case es
        case fr
        case it
        case ja
        case ko
        case ptBr
        case zhCn
        case zhTw
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .de,
                .en,
                .es,
                .fr,
                .it,
                .ja,
                .ko,
                .ptBr,
                .zhCn,
                .zhTw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .de: return "DE"
            case .en: return "EN"
            case .es: return "ES"
            case .fr: return "FR"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .ptBr: return "PT_BR"
            case .zhCn: return "ZH_CN"
            case .zhTw: return "ZH_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path
        case span
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            var pathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .path)
            for pathelement0 in path {
                try pathContainer.encode(pathelement0)
            }
        }
        if let span = self.span {
            try encodeContainer.encode(span, forKey: .span)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.PathElement?].self, forKey: .path)
        var pathDecoded0:[AccessAnalyzerClientTypes.PathElement]? = nil
        if let pathContainer = pathContainer {
            pathDecoded0 = [AccessAnalyzerClientTypes.PathElement]()
            for union0 in pathContainer {
                if let union0 = union0 {
                    pathDecoded0?.append(union0)
                }
            }
        }
        path = pathDecoded0
        let spanDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Span.self, forKey: .span)
        span = spanDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A location in a policy that is represented as a path through the JSON representation and a corresponding span.
    public struct Location: Swift.Equatable {
        /// A path in a policy, represented as a sequence of path elements.
        /// This member is required.
        public var path: [AccessAnalyzerClientTypes.PathElement]?
        /// A span in a policy.
        /// This member is required.
        public var span: AccessAnalyzerClientTypes.Span?

        public init (
            path: [AccessAnalyzerClientTypes.PathElement]? = nil,
            span: AccessAnalyzerClientTypes.Span? = nil
        )
        {
            self.path = path
            self.span = span
        }
    }

}

extension AccessAnalyzerClientTypes.NetworkOriginConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case internetconfiguration = "internetConfiguration"
        case sdkUnknown
        case vpcconfiguration = "vpcConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internetconfiguration(internetconfiguration):
                try container.encode(internetconfiguration, forKey: .internetconfiguration)
            case let .vpcconfiguration(vpcconfiguration):
                try container.encode(vpcconfiguration, forKey: .vpcconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vpcconfigurationDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.VpcConfiguration.self, forKey: .vpcconfiguration)
        if let vpcconfiguration = vpcconfigurationDecoded {
            self = .vpcconfiguration(vpcconfiguration)
            return
        }
        let internetconfigurationDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.InternetConfiguration.self, forKey: .internetconfiguration)
        if let internetconfiguration = internetconfigurationDecoded {
            self = .internetconfiguration(internetconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed InternetConfiguration or VpcConfiguration to apply to the Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. You can make the access point accessible from the internet, or you can specify that all requests made through that access point must originate from a specific virtual private cloud (VPC). You can specify only one type of network configuration. For more information, see [Creating access points](https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html).
    public enum NetworkOriginConfiguration: Swift.Equatable {
        /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see [VpcConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html).
        case vpcconfiguration(AccessAnalyzerClientTypes.VpcConfiguration)
        /// The configuration for the Amazon S3 access point or multi-region access point with an Internet origin.
        case internetconfiguration(AccessAnalyzerClientTypes.InternetConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.PathElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case key
        case sdkUnknown
        case substring
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .index(index):
                try container.encode(index, forKey: .index)
            case let .key(key):
                try container.encode(key, forKey: .key)
            case let .substring(substring):
                try container.encode(substring, forKey: .substring)
            case let .value(value):
                try container.encode(value, forKey: .value)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .index)
        if let index = indexDecoded {
            self = .index(index)
            return
        }
        let keyDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .key)
        if let key = keyDecoded {
            self = .key(key)
            return
        }
        let substringDecoded = try values.decodeIfPresent(AccessAnalyzerClientTypes.Substring.self, forKey: .substring)
        if let substring = substringDecoded {
            self = .substring(substring)
            return
        }
        let valueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .value)
        if let value = valueDecoded {
            self = .value(value)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// A single element in a path through the JSON representation of a policy.
    public enum PathElement: Swift.Equatable {
        /// Refers to an index in a JSON array.
        case index(Swift.Int)
        /// Refers to a key in a JSON object.
        case key(Swift.String)
        /// Refers to a substring of a literal string in a JSON object.
        case substring(AccessAnalyzerClientTypes.Substring)
        /// Refers to the value associated with a given key in a JSON object.
        case value(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes.PolicyGeneration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedOn
        case jobId
        case principalArn
        case startedOn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = self.completedOn {
            try encodeContainer.encodeTimestamp(completedOn, format: .dateTime, forKey: .completedOn)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let principalArn = self.principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
        if let startedOn = self.startedOn {
            try encodeContainer.encodeTimestamp(startedOn, format: .dateTime, forKey: .startedOn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completedOn)
        completedOn = completedOnDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the policy generation status and properties.
    public struct PolicyGeneration: Swift.Equatable {
        /// A timestamp of when the policy generation was completed.
        public var completedOn: ClientRuntime.Date?
        /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
        /// This member is required.
        public var jobId: Swift.String?
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?
        /// A timestamp of when the policy generation started.
        /// This member is required.
        public var startedOn: ClientRuntime.Date?
        /// The status of the policy generation request.
        /// This member is required.
        public var status: AccessAnalyzerClientTypes.JobStatus?

        public init (
            completedOn: ClientRuntime.Date? = nil,
            jobId: Swift.String? = nil,
            principalArn: Swift.String? = nil,
            startedOn: ClientRuntime.Date? = nil,
            status: AccessAnalyzerClientTypes.JobStatus? = nil
        )
        {
            self.completedOn = completedOn
            self.jobId = jobId
            self.principalArn = principalArn
            self.startedOn = startedOn
            self.status = status
        }
    }

}

extension AccessAnalyzerClientTypes.PolicyGenerationDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalArn = self.principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains the ARN details about the IAM entity for which the policy is generated.
    public struct PolicyGenerationDetails: Swift.Equatable {
        /// The ARN of the IAM entity (user or role) for which you are generating a policy.
        /// This member is required.
        public var principalArn: Swift.String?

        public init (
            principalArn: Swift.String? = nil
        )
        {
            self.principalArn = principalArn
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum PolicyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case identityPolicy
        case resourcePolicy
        case serviceControlPolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [PolicyType] {
            return [
                .identityPolicy,
                .resourcePolicy,
                .serviceControlPolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .identityPolicy: return "IDENTITY_POLICY"
            case .resourcePolicy: return "RESOURCE_POLICY"
            case .serviceControlPolicy: return "SERVICE_CONTROL_POLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.Position: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case column
        case line
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = self.column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let line = self.line {
            try encodeContainer.encode(line, forKey: .line)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .line)
        line = lineDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .column)
        column = columnDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A position in a policy.
    public struct Position: Swift.Equatable {
        /// The column of the position, starting from 0.
        /// This member is required.
        public var column: Swift.Int?
        /// The line of the position, starting from 1.
        /// This member is required.
        public var line: Swift.Int?
        /// The offset within the policy that corresponds to the position, starting from 0.
        /// This member is required.
        public var offset: Swift.Int?

        public init (
            column: Swift.Int? = nil,
            line: Swift.Int? = nil,
            offset: Swift.Int? = nil
        )
        {
            self.column = column
            self.line = line
            self.offset = offset
        }
    }

}

extension AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountids = "accountIds"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountids(accountids):
                var accountidsContainer = container.nestedUnkeyedContainer(forKey: .accountids)
                for rdsdbclustersnapshotaccountid0 in accountids {
                    try accountidsContainer.encode(rdsdbclustersnapshotaccountid0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountidsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .accountids)
        var accountidsDecoded0:[Swift.String]? = nil
        if let accountidsContainer = accountidsContainer {
            accountidsDecoded0 = [Swift.String]()
            for string0 in accountidsContainer {
                if let string0 = string0 {
                    accountidsDecoded0?.append(string0)
                }
            }
        }
        if let accountids = accountidsDecoded0 {
            self = .accountids(accountids)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// The values for a manual Amazon RDS DB cluster snapshot attribute.
    public enum RdsDbClusterSnapshotAttributeValue: Swift.Equatable {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB cluster snapshot. If the value all is specified, then the Amazon RDS DB cluster snapshot is public and can be copied or restored by all Amazon Web Services accounts.
        ///
        /// * If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbClusterSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.
        ///
        /// * To propose deletion of existing shared accountIds, you can specify an empty list for accountIds in the RdsDbClusterSnapshotAttributeValue.
        case accountids([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes.RdsDbClusterSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, rdsDbClusterSnapshotAttributesMap0) in attributes {
                try attributesContainer.encode(rdsDbClusterSnapshotAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]()
            for (key0, rdsdbclustersnapshotattributevalue0) in attributesContainer {
                if let rdsdbclustersnapshotattributevalue0 = rdsdbclustersnapshotattributevalue0 {
                    attributesDecoded0?[key0] = rdsdbclustersnapshotattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon RDS DB cluster snapshot. You can propose a configuration for a new Amazon RDS DB cluster snapshot or an Amazon RDS DB cluster snapshot that you own by specifying the RdsDbClusterSnapshotAttributeValue and optional KMS encryption key. For more information, see [ModifyDBClusterSnapshotAttribute](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBClusterSnapshotAttribute.html).
    public struct RdsDbClusterSnapshotConfiguration: Swift.Equatable {
        /// The names and values of manual DB cluster snapshot attributes. Manual DB cluster snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB cluster snapshot. The only valid value for AttributeName for the attribute map is restore
        public var attributes: [Swift.String:AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB cluster snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon RDS DB cluster snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?

        public init (
            attributes: [Swift.String:AccessAnalyzerClientTypes.RdsDbClusterSnapshotAttributeValue]? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountids = "accountIds"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .accountids(accountids):
                var accountidsContainer = container.nestedUnkeyedContainer(forKey: .accountids)
                for rdsdbsnapshotaccountid0 in accountids {
                    try accountidsContainer.encode(rdsdbsnapshotaccountid0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let accountidsContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .accountids)
        var accountidsDecoded0:[Swift.String]? = nil
        if let accountidsContainer = accountidsContainer {
            accountidsDecoded0 = [Swift.String]()
            for string0 in accountidsContainer {
                if let string0 = string0 {
                    accountidsDecoded0?.append(string0)
                }
            }
        }
        if let accountids = accountidsDecoded0 {
            self = .accountids(accountids)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AccessAnalyzerClientTypes {
    /// The name and values of a manual Amazon RDS DB snapshot attribute. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot.
    public enum RdsDbSnapshotAttributeValue: Swift.Equatable {
        /// The Amazon Web Services account IDs that have access to the manual Amazon RDS DB snapshot. If the value all is specified, then the Amazon RDS DB snapshot is public and can be copied or restored by all Amazon Web Services accounts.
        ///
        /// * If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview uses the existing shared accountIds for the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the accountIds in RdsDbSnapshotAttributeValue, then the access preview considers the snapshot without any attributes.
        ///
        /// * To propose deletion of an existing shared accountIds, you can specify an empty list for accountIds in the RdsDbSnapshotAttributeValue.
        case accountids([Swift.String])
        case sdkUnknown(Swift.String)
    }

}

extension AccessAnalyzerClientTypes.RdsDbSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, rdsDbSnapshotAttributesMap0) in attributes {
                try attributesContainer.encode(rdsDbSnapshotAttributesMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]()
            for (key0, rdsdbsnapshotattributevalue0) in attributesContainer {
                if let rdsdbsnapshotattributevalue0 = rdsdbsnapshotattributevalue0 {
                    attributesDecoded0?[key0] = rdsdbsnapshotattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon RDS DB snapshot. You can propose a configuration for a new Amazon RDS DB snapshot or an Amazon RDS DB snapshot that you own by specifying the RdsDbSnapshotAttributeValue and optional KMS encryption key. For more information, see [ModifyDBSnapshotAttribute](https://docs.aws.amazon.com/AmazonRDS/latest/APIReference/API_ModifyDBSnapshotAttribute.html).
    public struct RdsDbSnapshotConfiguration: Swift.Equatable {
        /// The names and values of manual DB snapshot attributes. Manual DB snapshot attributes are used to authorize other Amazon Web Services accounts to restore a manual DB snapshot. The only valid value for attributeName for the attribute map is restore.
        public var attributes: [Swift.String:AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]?
        /// The KMS key identifier for an encrypted Amazon RDS DB snapshot. The KMS key identifier is the key ARN, key ID, alias ARN, or alias name for the KMS key.
        ///
        /// * If the configuration is for an existing Amazon RDS DB snapshot and you do not specify the kmsKeyId, or you specify an empty string, then the access preview uses the existing kmsKeyId of the snapshot.
        ///
        /// * If the access preview is for a new resource and you do not specify the specify the kmsKeyId, then the access preview considers the snapshot as unencrypted.
        public var kmsKeyId: Swift.String?

        public init (
            attributes: [Swift.String:AccessAnalyzerClientTypes.RdsDbSnapshotAttributeValue]? = nil,
            kmsKeyId: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.kmsKeyId = kmsKeyId
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsServiceAccessDisabled
        case delegatedAdministratorDeregistered
        case organizationDeleted
        case serviceLinkedRoleCreationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ReasonCode] {
            return [
                .awsServiceAccessDisabled,
                .delegatedAdministratorDeregistered,
                .organizationDeleted,
                .serviceLinkedRoleCreationFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsServiceAccessDisabled: return "AWS_SERVICE_ACCESS_DISABLED"
            case .delegatedAdministratorDeregistered: return "DELEGATED_ADMINISTRATOR_DEREGISTERED"
            case .organizationDeleted: return "ORGANIZATION_DELETED"
            case .serviceLinkedRoleCreationFailed: return "SERVICE_LINKED_ROLE_CREATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReasonCode(rawValue: rawValue) ?? ReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ID of the resource.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The type of the resource.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsEc2Snapshot
        case awsEcrRepository
        case awsEfsFilesystem
        case awsIamRole
        case awsKmsKey
        case awsLambdaFunction
        case awsLambdaLayerversion
        case awsRdsDbclustersnapshot
        case awsRdsDbsnapshot
        case awsS3Bucket
        case awsSecretsmanagerSecret
        case awsSnsTopic
        case awsSqsQueue
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .awsEc2Snapshot,
                .awsEcrRepository,
                .awsEfsFilesystem,
                .awsIamRole,
                .awsKmsKey,
                .awsLambdaFunction,
                .awsLambdaLayerversion,
                .awsRdsDbclustersnapshot,
                .awsRdsDbsnapshot,
                .awsS3Bucket,
                .awsSecretsmanagerSecret,
                .awsSnsTopic,
                .awsSqsQueue,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsEc2Snapshot: return "AWS::EC2::Snapshot"
            case .awsEcrRepository: return "AWS::ECR::Repository"
            case .awsEfsFilesystem: return "AWS::EFS::FileSystem"
            case .awsIamRole: return "AWS::IAM::Role"
            case .awsKmsKey: return "AWS::KMS::Key"
            case .awsLambdaFunction: return "AWS::Lambda::Function"
            case .awsLambdaLayerversion: return "AWS::Lambda::LayerVersion"
            case .awsRdsDbclustersnapshot: return "AWS::RDS::DBClusterSnapshot"
            case .awsRdsDbsnapshot: return "AWS::RDS::DBSnapshot"
            case .awsS3Bucket: return "AWS::S3::Bucket"
            case .awsSecretsmanagerSecret: return "AWS::SecretsManager::Secret"
            case .awsSnsTopic: return "AWS::SNS::Topic"
            case .awsSqsQueue: return "AWS::SQS::Queue"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.S3AccessPointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPointPolicy
        case networkOrigin
        case publicAccessBlock
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointPolicy = self.accessPointPolicy {
            try encodeContainer.encode(accessPointPolicy, forKey: .accessPointPolicy)
        }
        if let networkOrigin = self.networkOrigin {
            try encodeContainer.encode(networkOrigin, forKey: .networkOrigin)
        }
        if let publicAccessBlock = self.publicAccessBlock {
            try encodeContainer.encode(publicAccessBlock, forKey: .publicAccessBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPointPolicy)
        accessPointPolicy = accessPointPolicyDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.NetworkOriginConfiguration.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The configuration for an Amazon S3 access point or multi-region access point for the bucket. You can propose up to 10 access points or multi-region access points per bucket. If the proposed Amazon S3 access point configuration is for an existing bucket, the access preview uses the proposed access point configuration in place of the existing access points. To propose an access point without a policy, you can provide an empty string as the access point policy. For more information, see [Creating access points](https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html). For more information about access point policy limits, see [Access points restrictions and limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-points-restrictions-limitations.html).
    public struct S3AccessPointConfiguration: Swift.Equatable {
        /// The access point or multi-region access point policy.
        public var accessPointPolicy: Swift.String?
        /// The proposed Internet and VpcConfiguration to apply to this Amazon S3 access point. VpcConfiguration does not apply to multi-region access points. If the access preview is for a new resource and neither is specified, the access preview uses Internet for the network origin. If the access preview is for an existing resource and neither is specified, the access preview uses the exiting network origin.
        public var networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration?
        /// The proposed S3PublicAccessBlock configuration to apply to this Amazon S3 access point or multi-region access point.
        public var publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init (
            accessPointPolicy: Swift.String? = nil,
            networkOrigin: AccessAnalyzerClientTypes.NetworkOriginConfiguration? = nil,
            publicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPointPolicy = accessPointPolicy
            self.networkOrigin = networkOrigin
            self.publicAccessBlock = publicAccessBlock
        }
    }

}

extension AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grantee
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = self.grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AclPermission.self, forKey: .permission)
        permission = permissionDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.AclGrantee.self, forKey: .grantee)
        grantee = granteeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A proposed access control list grant configuration for an Amazon S3 bucket. For more information, see [How to Specify an ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#setting-acls).
    public struct S3BucketAclGrantConfiguration: Swift.Equatable {
        /// The grantee to whom you’re assigning access rights.
        /// This member is required.
        public var grantee: AccessAnalyzerClientTypes.AclGrantee?
        /// The permissions being granted.
        /// This member is required.
        public var permission: AccessAnalyzerClientTypes.AclPermission?

        public init (
            grantee: AccessAnalyzerClientTypes.AclGrantee? = nil,
            permission: AccessAnalyzerClientTypes.AclPermission? = nil
        )
        {
            self.grantee = grantee
            self.permission = permission
        }
    }

}

extension AccessAnalyzerClientTypes.S3BucketConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPoints
        case bucketAclGrants
        case bucketPolicy
        case bucketPublicAccessBlock
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPoints = accessPoints {
            var accessPointsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .accessPoints)
            for (dictKey0, s3AccessPointConfigurationsMap0) in accessPoints {
                try accessPointsContainer.encode(s3AccessPointConfigurationsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let bucketAclGrants = bucketAclGrants {
            var bucketAclGrantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketAclGrants)
            for s3bucketaclgrantconfiguration0 in bucketAclGrants {
                try bucketAclGrantsContainer.encode(s3bucketaclgrantconfiguration0)
            }
        }
        if let bucketPolicy = self.bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
        if let bucketPublicAccessBlock = self.bucketPublicAccessBlock {
            try encodeContainer.encode(bucketPublicAccessBlock, forKey: .bucketPublicAccessBlock)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let bucketAclGrantsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration?].self, forKey: .bucketAclGrants)
        var bucketAclGrantsDecoded0:[AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]? = nil
        if let bucketAclGrantsContainer = bucketAclGrantsContainer {
            bucketAclGrantsDecoded0 = [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]()
            for structure0 in bucketAclGrantsContainer {
                if let structure0 = structure0 {
                    bucketAclGrantsDecoded0?.append(structure0)
                }
            }
        }
        bucketAclGrants = bucketAclGrantsDecoded0
        let bucketPublicAccessBlockDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration.self, forKey: .bucketPublicAccessBlock)
        bucketPublicAccessBlock = bucketPublicAccessBlockDecoded
        let accessPointsContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.S3AccessPointConfiguration?].self, forKey: .accessPoints)
        var accessPointsDecoded0: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]()
            for (key0, s3accesspointconfiguration0) in accessPointsContainer {
                if let s3accesspointconfiguration0 = s3accesspointconfiguration0 {
                    accessPointsDecoded0?[key0] = s3accesspointconfiguration0
                }
            }
        }
        accessPoints = accessPointsDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// Proposed access control configuration for an Amazon S3 bucket. You can propose a configuration for a new Amazon S3 bucket or an existing Amazon S3 bucket that you own by specifying the Amazon S3 bucket policy, bucket ACLs, bucket BPA settings, Amazon S3 access points, and multi-region access points attached to the bucket. If the configuration is for an existing Amazon S3 bucket and you do not specify the Amazon S3 bucket policy, the access preview uses the existing policy attached to the bucket. If the access preview is for a new resource and you do not specify the Amazon S3 bucket policy, the access preview assumes a bucket without a policy. To propose deletion of an existing bucket policy, you can specify an empty string. For more information about bucket policy limits, see [Bucket Policy Examples](https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html).
    public struct S3BucketConfiguration: Swift.Equatable {
        /// The configuration of Amazon S3 access points or multi-region access points for the bucket. You can propose up to 10 new access points per bucket.
        public var accessPoints: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]?
        /// The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL grants per bucket. If the proposed grant configuration is for an existing bucket, the access preview uses the proposed list of grant configurations in place of the existing grants. Otherwise, the access preview uses the existing grants for the bucket.
        public var bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]?
        /// The proposed bucket policy for the Amazon S3 bucket.
        public var bucketPolicy: Swift.String?
        /// The proposed block public access configuration for the Amazon S3 bucket.
        public var bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration?

        public init (
            accessPoints: [Swift.String:AccessAnalyzerClientTypes.S3AccessPointConfiguration]? = nil,
            bucketAclGrants: [AccessAnalyzerClientTypes.S3BucketAclGrantConfiguration]? = nil,
            bucketPolicy: Swift.String? = nil,
            bucketPublicAccessBlock: AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration? = nil
        )
        {
            self.accessPoints = accessPoints
            self.bucketAclGrants = bucketAclGrants
            self.bucketPolicy = bucketPolicy
            self.bucketPublicAccessBlock = bucketPublicAccessBlock
        }
    }

}

extension AccessAnalyzerClientTypes.S3PublicAccessBlockConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignorePublicAcls
        case restrictPublicBuckets
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignorePublicAcls = self.ignorePublicAcls {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if let restrictPublicBuckets = self.restrictPublicBuckets {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The PublicAccessBlock configuration to apply to this Amazon S3 bucket. If the proposed configuration is for an existing Amazon S3 bucket and the configuration is not specified, the access preview uses the existing setting. If the proposed configuration is for a new bucket and the configuration is not specified, the access preview uses false. If the proposed configuration is for a new access point or multi-region access point and the access point BPA configuration is not specified, the access preview uses true. For more information, see [PublicAccessBlockConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html).
    public struct S3PublicAccessBlockConfiguration: Swift.Equatable {
        /// Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket.
        /// This member is required.
        public var ignorePublicAcls: Swift.Bool?
        /// Specifies whether Amazon S3 should restrict public bucket policies for this bucket.
        /// This member is required.
        public var restrictPublicBuckets: Swift.Bool?

        public init (
            ignorePublicAcls: Swift.Bool? = nil,
            restrictPublicBuckets: Swift.Bool? = nil
        )
        {
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension AccessAnalyzerClientTypes.SecretsManagerSecretConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyId
        case secretPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretPolicy = self.secretPolicy {
            try encodeContainer.encode(secretPolicy, forKey: .secretPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretPolicy)
        secretPolicy = secretPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The configuration for a Secrets Manager secret. For more information, see [CreateSecret](https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html). You can propose a configuration for a new secret or an existing secret that you own by specifying the secret policy and optional KMS encryption key. If the configuration is for an existing secret and you do not specify the secret policy, the access preview uses the existing policy for the secret. If the access preview is for a new resource and you do not specify the policy, the access preview assumes a secret without a policy. To propose deletion of an existing policy, you can specify an empty string. If the proposed configuration is for a new secret and you do not specify the KMS key ID, the access preview uses the Amazon Web Services managed key aws/secretsmanager. If you specify an empty string for the KMS key ID, the access preview uses the Amazon Web Services managed key of the Amazon Web Services account. For more information about secret policy limits, see [Quotas for Secrets Manager.](https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html).
    public struct SecretsManagerSecretConfiguration: Swift.Equatable {
        /// The proposed ARN, key ID, or alias of the KMS key.
        public var kmsKeyId: Swift.String?
        /// The proposed resource policy defining who can access or manage the secret.
        public var secretPolicy: Swift.String?

        public init (
            kmsKeyId: Swift.String? = nil,
            secretPolicy: Swift.String? = nil
        )
        {
            self.kmsKeyId = kmsKeyId
            self.secretPolicy = secretPolicy
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Service quote met error.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The resource ID.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The resource type.
    /// This member is required.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AccessAnalyzerClientTypes.SnsTopicConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicPolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicPolicy = self.topicPolicy {
            try encodeContainer.encode(topicPolicy, forKey: .topicPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicPolicy)
        topicPolicy = topicPolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon SNS topic. You can propose a configuration for a new Amazon SNS topic or an existing Amazon SNS topic that you own by specifying the policy. If the configuration is for an existing Amazon SNS topic and you do not specify the Amazon SNS policy, then the access preview uses the existing Amazon SNS policy for the topic. If the access preview is for a new resource and you do not specify the policy, then the access preview assumes an Amazon SNS topic without a policy. To propose deletion of an existing Amazon SNS topic policy, you can specify an empty string for the Amazon SNS policy. For more information, see [Topic](https://docs.aws.amazon.com/sns/latest/api/API_Topic.html).
    public struct SnsTopicConfiguration: Swift.Equatable {
        /// The JSON policy text that defines who can access an Amazon SNS topic. For more information, see [Example cases for Amazon SNS access control](https://docs.aws.amazon.com/sns/latest/dg/sns-access-policy-use-cases.html) in the Amazon SNS Developer Guide.
        public var topicPolicy: Swift.String?

        public init (
            topicPolicy: Swift.String? = nil
        )
        {
            self.topicPolicy = topicPolicy
        }
    }

}

extension AccessAnalyzerClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The criteria used to sort.
    public struct SortCriteria: Swift.Equatable {
        /// The name of the attribute to sort on.
        public var attributeName: Swift.String?
        /// The sort order, ascending or descending.
        public var orderBy: AccessAnalyzerClientTypes.OrderBy?

        public init (
            attributeName: Swift.String? = nil,
            orderBy: AccessAnalyzerClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension AccessAnalyzerClientTypes.Span: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Position.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Position.self, forKey: .end)
        end = endDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A span in a policy. The span consists of a start position (inclusive) and end position (exclusive).
    public struct Span: Swift.Equatable {
        /// The end position of the span (exclusive).
        /// This member is required.
        public var end: AccessAnalyzerClientTypes.Position?
        /// The start position of the span (inclusive).
        /// This member is required.
        public var start: AccessAnalyzerClientTypes.Position?

        public init (
            end: AccessAnalyzerClientTypes.Position? = nil,
            start: AccessAnalyzerClientTypes.Position? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension AccessAnalyzerClientTypes.SqsQueueConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queuePolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuePolicy = self.queuePolicy {
            try encodeContainer.encode(queuePolicy, forKey: .queuePolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queuePolicy)
        queuePolicy = queuePolicyDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed access control configuration for an Amazon SQS queue. You can propose a configuration for a new Amazon SQS queue or an existing Amazon SQS queue that you own by specifying the Amazon SQS policy. If the configuration is for an existing Amazon SQS queue and you do not specify the Amazon SQS policy, the access preview uses the existing Amazon SQS policy for the queue. If the access preview is for a new resource and you do not specify the policy, the access preview assumes an Amazon SQS queue without a policy. To propose deletion of an existing Amazon SQS queue policy, you can specify an empty string for the Amazon SQS policy. For more information about Amazon SQS policy limits, see [Quotas related to policies](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-policies.html).
    public struct SqsQueueConfiguration: Swift.Equatable {
        /// The proposed resource policy for the Amazon SQS queue.
        public var queuePolicy: Swift.String?

        public init (
            queuePolicy: Swift.String? = nil
        )
        {
            self.queuePolicy = queuePolicy
        }
    }

}

extension StartPolicyGenerationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cloudTrailDetails = self.cloudTrailDetails {
            try encodeContainer.encode(cloudTrailDetails, forKey: .cloudTrailDetails)
        }
        if let policyGenerationDetails = self.policyGenerationDetails {
            try encodeContainer.encode(policyGenerationDetails, forKey: .policyGenerationDetails)
        }
    }
}

extension StartPolicyGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/policy/generation"
    }
}

public struct StartPolicyGenerationInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. Idempotency ensures that an API request completes only once. With an idempotent request, if the original request completes successfully, the subsequent retries with the same client token return the result from the original successful request and they have no additional effect. If you do not specify a client token, one is automatically generated by the Amazon Web Services SDK.
    public var clientToken: Swift.String?
    /// A CloudTrailDetails object that contains details about a Trail that you want to analyze to generate policies.
    public var cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails?
    /// Contains the ARN of the IAM entity (user or role) for which you are generating a policy.
    /// This member is required.
    public var policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails?

    public init (
        clientToken: Swift.String? = nil,
        cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails? = nil,
        policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudTrailDetails = cloudTrailDetails
        self.policyGenerationDetails = policyGenerationDetails
    }
}

struct StartPolicyGenerationInputBody: Swift.Equatable {
    let policyGenerationDetails: AccessAnalyzerClientTypes.PolicyGenerationDetails?
    let cloudTrailDetails: AccessAnalyzerClientTypes.CloudTrailDetails?
    let clientToken: Swift.String?
}

extension StartPolicyGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.PolicyGenerationDetails.self, forKey: .policyGenerationDetails)
        policyGenerationDetails = policyGenerationDetailsDecoded
        let cloudTrailDetailsDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.CloudTrailDetails.self, forKey: .cloudTrailDetails)
        cloudTrailDetails = cloudTrailDetailsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartPolicyGenerationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPolicyGenerationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartPolicyGenerationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPolicyGenerationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartPolicyGenerationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPolicyGenerationOutputResponse: Swift.Equatable {
    /// The JobId that is returned by the StartPolicyGeneration operation. The JobId can be used with GetGeneratedPolicy to retrieve the generated policies or used with CancelPolicyGeneration to cancel the policy generation request.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPolicyGenerationOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartPolicyGenerationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartResourceScanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case resourceArn
        case resourceOwnerAccount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = self.resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
    }
}

extension StartResourceScanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/resource/scan"
    }
}

/// Starts a scan of the policies applied to the specified resource.
public struct StartResourceScanInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) to use to scan the policies applied to the specified resource.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// The ARN of the resource to scan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The Amazon Web Services account ID that owns the resource. For most Amazon Web Services resources, the owning account is the account in which the resource was created.
    public var resourceOwnerAccount: Swift.String?

    public init (
        analyzerArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceOwnerAccount: Swift.String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
        self.resourceOwnerAccount = resourceOwnerAccount
    }
}

struct StartResourceScanInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let resourceArn: Swift.String?
    let resourceOwnerAccount: Swift.String?
}

extension StartResourceScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case resourceArn
        case resourceOwnerAccount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
    }
}

extension StartResourceScanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartResourceScanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartResourceScanOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartResourceScanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartResourceScanOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.StatusReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Provides more details about the current status of the analyzer. For example, if the creation for the analyzer fails, a Failed status is returned. For an analyzer with organization as the type, this failure can be due to an issue with creating the service-linked roles required in the member accounts of the Amazon Web Services organization.
    public struct StatusReason: Swift.Equatable {
        /// The reason code for the current status of the analyzer.
        /// This member is required.
        public var code: AccessAnalyzerClientTypes.ReasonCode?

        public init (
            code: AccessAnalyzerClientTypes.ReasonCode? = nil
        )
        {
            self.code = code
        }
    }

}

extension AccessAnalyzerClientTypes.Substring: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case length
        case start
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let length = self.length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .start)
        start = startDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .length)
        length = lengthDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// A reference to a substring of a literal string in a JSON document.
    public struct Substring: Swift.Equatable {
        /// The length of the substring.
        /// This member is required.
        public var length: Swift.Int?
        /// The start index of the substring, starting from 0.
        /// This member is required.
        public var start: Swift.Int?

        public init (
            length: Swift.Int? = nil,
            start: Swift.Int? = nil
        )
        {
            self.length = length
            self.start = start
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Adds a tag to the specified resource.
public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to add the tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response to the request.
public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Throttling limit exceeded error.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The seconds to wait to retry.
    public var retryAfterSeconds: Swift.Int?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes.Trail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = self.allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = self.cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for string0 in regions {
                try regionsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct Trail: Swift.Equatable {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init (
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }

}

extension AccessAnalyzerClientTypes.TrailProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = self.allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = self.cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for string0 in regions {
                try regionsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains details about the CloudTrail trail being analyzed to generate a policy.
    public struct TrailProperties: Swift.Equatable {
        /// Possible values are true or false. If set to true, IAM Access Analyzer retrieves CloudTrail data from all regions to analyze and generate a policy.
        public var allRegions: Swift.Bool?
        /// Specifies the ARN of the trail. The format of a trail ARN is arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail.
        /// This member is required.
        public var cloudTrailArn: Swift.String?
        /// A list of regions to get CloudTrail data from and analyze to generate a policy.
        public var regions: [Swift.String]?

        public init (
            allRegions: Swift.Bool? = nil,
            cloudTrailArn: Swift.String? = nil,
            regions: [Swift.String]? = nil
        )
        {
            self.allRegions = allRegions
            self.cloudTrailArn = cloudTrailArn
            self.regions = regions
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ModelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .account,
                .organization,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelType(rawValue: rawValue) ?? ModelType.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// Removes a tag from the specified resource.
public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key for the tag to add.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// The response to the request.
public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateArchiveRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filter)
            for (dictKey0, filterCriteriaMap0) in filter {
                try filterContainer.encode(filterCriteriaMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateArchiveRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let analyzerName = analyzerName else {
            return nil
        }
        guard let ruleName = ruleName else {
            return nil
        }
        return "/analyzer/\(analyzerName.urlPercentEncoding())/archive-rule/\(ruleName.urlPercentEncoding())"
    }
}

/// Updates the specified archive rule.
public struct UpdateArchiveRuleInput: Swift.Equatable {
    /// The name of the analyzer to update the archive rules for.
    /// This member is required.
    public var analyzerName: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// A filter to match for the rules to update. Only rules that match the filter are updated.
    /// This member is required.
    public var filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    /// The name of the rule to update.
    /// This member is required.
    public var ruleName: Swift.String?

    public init (
        analyzerName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil,
        ruleName: Swift.String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct UpdateArchiveRuleInputBody: Swift.Equatable {
    let filter: [Swift.String:AccessAnalyzerClientTypes.Criterion]?
    let clientToken: Swift.String?
}

extension UpdateArchiveRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterContainer = try containerValues.decodeIfPresent([Swift.String: AccessAnalyzerClientTypes.Criterion?].self, forKey: .filter)
        var filterDecoded0: [Swift.String:AccessAnalyzerClientTypes.Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [Swift.String:AccessAnalyzerClientTypes.Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateArchiveRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateArchiveRuleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateArchiveRuleOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = self.analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for findingid0 in ids {
                try idsContainer.encode(findingid0)
            }
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/finding"
    }
}

/// Updates findings with the new values provided in the request.
public struct UpdateFindingsInput: Swift.Equatable {
    /// The [ARN of the analyzer](https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources) that generated the findings to update.
    /// This member is required.
    public var analyzerArn: Swift.String?
    /// A client token.
    public var clientToken: Swift.String?
    /// The IDs of the findings to update.
    public var ids: [Swift.String]?
    /// The ARN of the resource identified in the finding.
    public var resourceArn: Swift.String?
    /// The state represents the action to take to update the finding Status. Use ARCHIVE to change an Active finding to an Archived finding. Use ACTIVE to change an Archived finding to an Active finding.
    /// This member is required.
    public var status: AccessAnalyzerClientTypes.FindingStatusUpdate?

    public init (
        analyzerArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ids: [Swift.String]? = nil,
        resourceArn: Swift.String? = nil,
        status: AccessAnalyzerClientTypes.FindingStatusUpdate? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ids = ids
        self.resourceArn = resourceArn
        self.status = status
    }
}

struct UpdateFindingsInputBody: Swift.Equatable {
    let analyzerArn: Swift.String?
    let status: AccessAnalyzerClientTypes.FindingStatusUpdate?
    let ids: [Swift.String]?
    let resourceArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.FindingStatusUpdate.self, forKey: .status)
        status = statusDecoded
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFindingsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension AccessAnalyzerClientTypes.ValidatePolicyFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingDetails
        case findingType
        case issueCode
        case learnMoreLink
        case locations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingDetails = self.findingDetails {
            try encodeContainer.encode(findingDetails, forKey: .findingDetails)
        }
        if let findingType = self.findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let issueCode = self.issueCode {
            try encodeContainer.encode(issueCode, forKey: .issueCode)
        }
        if let learnMoreLink = self.learnMoreLink {
            try encodeContainer.encode(learnMoreLink, forKey: .learnMoreLink)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for location0 in locations {
                try locationsContainer.encode(location0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingDetails)
        findingDetails = findingDetailsDecoded
        let findingTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ValidatePolicyFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let issueCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issueCode)
        issueCode = issueCodeDecoded
        let learnMoreLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .learnMoreLink)
        learnMoreLink = learnMoreLinkDecoded
        let locationsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.Location?].self, forKey: .locations)
        var locationsDecoded0:[AccessAnalyzerClientTypes.Location]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [AccessAnalyzerClientTypes.Location]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension AccessAnalyzerClientTypes {
    /// A finding in a policy. Each finding is an actionable recommendation that can be used to improve the policy.
    public struct ValidatePolicyFinding: Swift.Equatable {
        /// A localized message that explains the finding and provides guidance on how to address it.
        /// This member is required.
        public var findingDetails: Swift.String?
        /// The impact of the finding. Security warnings report when the policy allows access that we consider overly permissive. Errors report when a part of the policy is not functional. Warnings report non-security issues when a policy does not conform to policy writing best practices. Suggestions recommend stylistic improvements in the policy that do not impact access.
        /// This member is required.
        public var findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType?
        /// The issue code provides an identifier of the issue associated with this finding.
        /// This member is required.
        public var issueCode: Swift.String?
        /// A link to additional documentation about the type of finding.
        /// This member is required.
        public var learnMoreLink: Swift.String?
        /// The list of locations in the policy document that are related to the finding. The issue code provides a summary of an issue identified by the finding.
        /// This member is required.
        public var locations: [AccessAnalyzerClientTypes.Location]?

        public init (
            findingDetails: Swift.String? = nil,
            findingType: AccessAnalyzerClientTypes.ValidatePolicyFindingType? = nil,
            issueCode: Swift.String? = nil,
            learnMoreLink: Swift.String? = nil,
            locations: [AccessAnalyzerClientTypes.Location]? = nil
        )
        {
            self.findingDetails = findingDetails
            self.findingType = findingType
            self.issueCode = issueCode
            self.learnMoreLink = learnMoreLink
            self.locations = locations
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ValidatePolicyFindingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case securityWarning
        case suggestion
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatePolicyFindingType] {
            return [
                .error,
                .securityWarning,
                .suggestion,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .securityWarning: return "SECURITY_WARNING"
            case .suggestion: return "SUGGESTION"
            case .warning: return "WARNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatePolicyFindingType(rawValue: rawValue) ?? ValidatePolicyFindingType.sdkUnknown(rawValue)
        }
    }
}

extension ValidatePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case policyDocument
        case policyType
        case validatePolicyResourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let policyDocument = self.policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyType = self.policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
        if let validatePolicyResourceType = self.validatePolicyResourceType {
            try encodeContainer.encode(validatePolicyResourceType.rawValue, forKey: .validatePolicyResourceType)
        }
    }
}

extension ValidatePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ValidatePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/policy/validation"
    }
}

public struct ValidatePolicyInput: Swift.Equatable {
    /// The locale to use for localizing the findings.
    public var locale: AccessAnalyzerClientTypes.Locale?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?
    /// The JSON policy document to use as the content for the policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The type of policy to validate. Identity policies grant permissions to IAM principals. Identity policies include managed and inline policies for IAM roles, users, and groups. They also include service-control policies (SCPs) that are attached to an Amazon Web Services organization, organizational unit (OU), or an account. Resource policies grant permissions on Amazon Web Services resources. Resource policies include trust policies for IAM roles and bucket policies for Amazon S3 buckets. You can provide a generic input such as identity policy or resource policy or a specific input such as managed policy or Amazon S3 bucket policy.
    /// This member is required.
    public var policyType: AccessAnalyzerClientTypes.PolicyType?
    /// The type of resource to attach to your resource policy. Specify a value for the policy validation resource type only if the policy type is RESOURCE_POLICY. For example, to validate a resource policy to attach to an Amazon S3 bucket, you can choose AWS::S3::Bucket for the policy validation resource type. For resource types not supported as valid values, IAM Access Analyzer runs policy checks that apply to all resource policies. For example, to validate a resource policy to attach to a KMS key, do not specify a value for the policy validation resource type and IAM Access Analyzer will run policy checks that apply to all resource policies.
    public var validatePolicyResourceType: AccessAnalyzerClientTypes.ValidatePolicyResourceType?

    public init (
        locale: AccessAnalyzerClientTypes.Locale? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        policyDocument: Swift.String? = nil,
        policyType: AccessAnalyzerClientTypes.PolicyType? = nil,
        validatePolicyResourceType: AccessAnalyzerClientTypes.ValidatePolicyResourceType? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyDocument = policyDocument
        self.policyType = policyType
        self.validatePolicyResourceType = validatePolicyResourceType
    }
}

struct ValidatePolicyInputBody: Swift.Equatable {
    let locale: AccessAnalyzerClientTypes.Locale?
    let policyDocument: Swift.String?
    let policyType: AccessAnalyzerClientTypes.PolicyType?
    let validatePolicyResourceType: AccessAnalyzerClientTypes.ValidatePolicyResourceType?
}

extension ValidatePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case policyDocument
        case policyType
        case validatePolicyResourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
        let validatePolicyResourceTypeDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ValidatePolicyResourceType.self, forKey: .validatePolicyResourceType)
        validatePolicyResourceType = validatePolicyResourceTypeDecoded
    }
}

extension ValidatePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidatePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ValidatePolicyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidatePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ValidatePolicyOutputResponse: Swift.Equatable {
    /// The list of findings in a policy returned by IAM Access Analyzer based on its suite of policy checks.
    /// This member is required.
    public var findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]?
    /// A token used for pagination of results returned.
    public var nextToken: Swift.String?

    public init (
        findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ValidatePolicyOutputResponseBody: Swift.Equatable {
    let findings: [AccessAnalyzerClientTypes.ValidatePolicyFinding]?
    let nextToken: Swift.String?
}

extension ValidatePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ValidatePolicyFinding?].self, forKey: .findings)
        var findingsDecoded0:[AccessAnalyzerClientTypes.ValidatePolicyFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessAnalyzerClientTypes.ValidatePolicyFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AccessAnalyzerClientTypes {
    public enum ValidatePolicyResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case roleTrust
        case s3AccessPoint
        case s3Bucket
        case s3MultiRegionAccessPoint
        case s3ObjectLambdaAccessPoint
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatePolicyResourceType] {
            return [
                .roleTrust,
                .s3AccessPoint,
                .s3Bucket,
                .s3MultiRegionAccessPoint,
                .s3ObjectLambdaAccessPoint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .roleTrust: return "AWS::IAM::AssumeRolePolicyDocument"
            case .s3AccessPoint: return "AWS::S3::AccessPoint"
            case .s3Bucket: return "AWS::S3::Bucket"
            case .s3MultiRegionAccessPoint: return "AWS::S3::MultiRegionAccessPoint"
            case .s3ObjectLambdaAccessPoint: return "AWS::S3ObjectLambda::AccessPoint"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatePolicyResourceType(rawValue: rawValue) ?? ValidatePolicyResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Validation exception error.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A list of fields that didn't validate.
    public var fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]?
    /// This member is required.
    public var message: Swift.String?
    /// The reason for the exception.
    /// This member is required.
    public var reason: AccessAnalyzerClientTypes.ValidationExceptionReason?

    public init (
        fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: AccessAnalyzerClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AccessAnalyzerClientTypes.ValidationExceptionReason?
    let fieldList: [AccessAnalyzerClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AccessAnalyzerClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([AccessAnalyzerClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[AccessAnalyzerClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [AccessAnalyzerClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension AccessAnalyzerClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// Contains information about a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message about the validation exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the validation exception.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension AccessAnalyzerClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension AccessAnalyzerClientTypes.VpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension AccessAnalyzerClientTypes {
    /// The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. VPC configuration does not apply to multi-region access points. For more information, see [VpcConfiguration](https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html).
    public struct VpcConfiguration: Swift.Equatable {
        /// If this field is specified, this access point will only allow connections from the specified VPC ID.
        /// This member is required.
        public var vpcId: Swift.String?

        public init (
            vpcId: Swift.String? = nil
        )
        {
            self.vpcId = vpcId
        }
    }

}
