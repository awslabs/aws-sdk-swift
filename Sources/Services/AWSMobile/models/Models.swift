// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountActionRequiredException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountActionRequiredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Account Action is required in order to continue the request.
public struct AccountActionRequiredException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountActionRequiredException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountActionRequiredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountActionRequiredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request cannot be processed because some parameter is not valid or the project state prevents the operation from being performed.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes.BundleDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availablePlatforms
        case bundleId
        case description
        case iconUrl
        case title
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availablePlatforms = availablePlatforms {
            var availablePlatformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availablePlatforms)
            for platform0 in availablePlatforms {
                try availablePlatformsContainer.encode(platform0.rawValue)
            }
        }
        if let bundleId = self.bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iconUrl = self.iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let availablePlatformsContainer = try containerValues.decodeIfPresent([MobileClientTypes.Platform?].self, forKey: .availablePlatforms)
        var availablePlatformsDecoded0:[MobileClientTypes.Platform]? = nil
        if let availablePlatformsContainer = availablePlatformsContainer {
            availablePlatformsDecoded0 = [MobileClientTypes.Platform]()
            for enum0 in availablePlatformsContainer {
                if let enum0 = enum0 {
                    availablePlatformsDecoded0?.append(enum0)
                }
            }
        }
        availablePlatforms = availablePlatformsDecoded0
    }
}

extension MobileClientTypes {
    /// The details of the bundle.
    public struct BundleDetails: Swift.Equatable {
        /// Developer desktop or mobile app or website platforms.
        public var availablePlatforms: [MobileClientTypes.Platform]?
        /// Unique bundle identifier.
        public var bundleId: Swift.String?
        /// Description of the download bundle.
        public var description: Swift.String?
        /// Icon for the download bundle.
        public var iconUrl: Swift.String?
        /// Title of the download bundle.
        public var title: Swift.String?
        /// Version of the download bundle.
        public var version: Swift.String?

        public init(
            availablePlatforms: [MobileClientTypes.Platform]? = nil,
            bundleId: Swift.String? = nil,
            description: Swift.String? = nil,
            iconUrl: Swift.String? = nil,
            title: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.availablePlatforms = availablePlatforms
            self.bundleId = bundleId
            self.description = description
            self.iconUrl = iconUrl
            self.title = title
            self.version = version
        }
    }

}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateProjectOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let contents = input.operationInput.contents {
            let contentsData = contents
            let contentsBody = ClientRuntime.HttpBody.data(contentsData)
            input.builder.withBody(contentsBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = self.contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

extension CreateProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let snapshotId = snapshotId {
                let snapshotIdQueryItem = ClientRuntime.URLQueryItem(name: "snapshotId".urlPercentEncoding(), value: Swift.String(snapshotId).urlPercentEncoding())
                items.append(snapshotIdQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let region = region {
                let regionQueryItem = ClientRuntime.URLQueryItem(name: "region".urlPercentEncoding(), value: Swift.String(region).urlPercentEncoding())
                items.append(regionQueryItem)
            }
            return items
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

/// Request structure used to request a project be created.
public struct CreateProjectInput: Swift.Equatable {
    /// ZIP or YAML file which contains configuration settings to be used when creating the project. This may be the contents of the file downloaded from the URL provided in an export project operation.
    public var contents: ClientRuntime.Data?
    /// Name of the project.
    public var name: Swift.String?
    /// Default region where project resources should be created.
    public var region: Swift.String?
    /// Unique identifier for an exported snapshot of project configuration. This snapshot identifier is included in the share URL when a project is exported.
    public var snapshotId: Swift.String?

    public init(
        contents: ClientRuntime.Data? = nil,
        name: Swift.String? = nil,
        region: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.name = name
        self.region = region
        self.snapshotId = snapshotId
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let contents: ClientRuntime.Data?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used in response to a request to create a project.
public struct CreateProjectOutput: Swift.Equatable {
    /// Detailed information about the created AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init(
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

/// Request structure used to request a project be deleted.
public struct DeleteProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.deletedResources = output.deletedResources
            self.orphanedResources = output.orphanedResources
        } else {
            self.deletedResources = nil
            self.orphanedResources = nil
        }
    }
}

/// Result structure used in response to request to delete a project.
public struct DeleteProjectOutput: Swift.Equatable {
    /// Resources which were deleted.
    public var deletedResources: [MobileClientTypes.Resource]?
    /// Resources which were not deleted, due to a risk of losing potentially important data or files.
    public var orphanedResources: [MobileClientTypes.Resource]?

    public init(
        deletedResources: [MobileClientTypes.Resource]? = nil,
        orphanedResources: [MobileClientTypes.Resource]? = nil
    )
    {
        self.deletedResources = deletedResources
        self.orphanedResources = orphanedResources
    }
}

struct DeleteProjectOutputBody: Swift.Equatable {
    let deletedResources: [MobileClientTypes.Resource]?
    let orphanedResources: [MobileClientTypes.Resource]?
}

extension DeleteProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletedResources
        case orphanedResources
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .deletedResources)
        var deletedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let deletedResourcesContainer = deletedResourcesContainer {
            deletedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in deletedResourcesContainer {
                if let structure0 = structure0 {
                    deletedResourcesDecoded0?.append(structure0)
                }
            }
        }
        deletedResources = deletedResourcesDecoded0
        let orphanedResourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .orphanedResources)
        var orphanedResourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let orphanedResourcesContainer = orphanedResourcesContainer {
            orphanedResourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in orphanedResourcesContainer {
                if let structure0 = structure0 {
                    orphanedResourcesDecoded0?.append(structure0)
                }
            }
        }
        orphanedResources = orphanedResourcesDecoded0
    }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bundleId = bundleId else {
            return nil
        }
        return "/bundles/\(bundleId.urlPercentEncoding())"
    }
}

/// Request structure to request the details of a specific bundle.
public struct DescribeBundleInput: Swift.Equatable {
    /// Unique bundle identifier.
    /// This member is required.
    public var bundleId: Swift.String?

    public init(
        bundleId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
    }
}

struct DescribeBundleInputBody: Swift.Equatable {
}

extension DescribeBundleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBundleOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure contains the details of the bundle.
public struct DescribeBundleOutput: Swift.Equatable {
    /// The details of the bundle.
    public var details: MobileClientTypes.BundleDetails?

    public init(
        details: MobileClientTypes.BundleDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeBundleOutputBody: Swift.Equatable {
    let details: MobileClientTypes.BundleDetails?
}

extension DescribeBundleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.BundleDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum DescribeBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let syncFromResources = syncFromResources {
                let syncFromResourcesQueryItem = ClientRuntime.URLQueryItem(name: "syncFromResources".urlPercentEncoding(), value: Swift.String(syncFromResources).urlPercentEncoding())
                items.append(syncFromResourcesQueryItem)
            }
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/project"
    }
}

/// Request structure used to request details about a project.
public struct DescribeProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?
    /// If set to true, causes AWS Mobile Hub to synchronize information from other services, e.g., update state of AWS CloudFormation stacks in the AWS Mobile Hub project.
    public var syncFromResources: Swift.Bool?

    public init(
        projectId: Swift.String? = nil,
        syncFromResources: Swift.Bool? = nil
    )
    {
        self.projectId = projectId
        self.syncFromResources = syncFromResources
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used for requests of project details.
public struct DescribeProjectOutput: Swift.Equatable {
    /// Detailed information about an AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init(
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct DescribeProjectOutputBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension DescribeProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum DescribeProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportBundleInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let projectId = projectId {
                let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
                items.append(projectIdQueryItem)
            }
            if let platform = platform {
                let platformQueryItem = ClientRuntime.URLQueryItem(name: "platform".urlPercentEncoding(), value: Swift.String(platform.rawValue).urlPercentEncoding())
                items.append(platformQueryItem)
            }
            return items
        }
    }
}

extension ExportBundleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bundleId = bundleId else {
            return nil
        }
        return "/bundles/\(bundleId.urlPercentEncoding())"
    }
}

/// Request structure used to request generation of custom SDK and tool packages required to integrate mobile web or app clients with backed AWS resources.
public struct ExportBundleInput: Swift.Equatable {
    /// Unique bundle identifier.
    /// This member is required.
    public var bundleId: Swift.String?
    /// Developer desktop or target application platform.
    public var platform: MobileClientTypes.Platform?
    /// Unique project identifier.
    public var projectId: Swift.String?

    public init(
        bundleId: Swift.String? = nil,
        platform: MobileClientTypes.Platform? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.bundleId = bundleId
        self.platform = platform
        self.projectId = projectId
    }
}

struct ExportBundleInputBody: Swift.Equatable {
}

extension ExportBundleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportBundleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportBundleOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
        } else {
            self.downloadUrl = nil
        }
    }
}

/// Result structure which contains link to download custom-generated SDK and tool packages used to integrate mobile web or app clients with backed AWS resources.
public struct ExportBundleOutput: Swift.Equatable {
    /// URL which contains the custom-generated SDK and tool packages used to integrate the client mobile app or web app with the AWS resources created by the AWS Mobile Hub project.
    public var downloadUrl: Swift.String?

    public init(
        downloadUrl: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
    }
}

struct ExportBundleOutputBody: Swift.Equatable {
    let downloadUrl: Swift.String?
}

extension ExportBundleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

enum ExportBundleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ExportProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/exports/\(projectId.urlPercentEncoding())"
    }
}

/// Request structure used in requests to export project configuration details.
public struct ExportProjectInput: Swift.Equatable {
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct ExportProjectInputBody: Swift.Equatable {
}

extension ExportProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ExportProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
            self.shareUrl = output.shareUrl
            self.snapshotId = output.snapshotId
        } else {
            self.downloadUrl = nil
            self.shareUrl = nil
            self.snapshotId = nil
        }
    }
}

/// Result structure used for requests to export project configuration details.
public struct ExportProjectOutput: Swift.Equatable {
    /// URL which can be used to download the exported project configuation file(s).
    public var downloadUrl: Swift.String?
    /// URL which can be shared to allow other AWS users to create their own project in AWS Mobile Hub with the same configuration as the specified project. This URL pertains to a snapshot in time of the project configuration that is created when this API is called. If you want to share additional changes to your project configuration, then you will need to create and share a new snapshot by calling this method again.
    public var shareUrl: Swift.String?
    /// Unique identifier for the exported snapshot of the project configuration. This snapshot identifier is included in the share URL.
    public var snapshotId: Swift.String?

    public init(
        downloadUrl: Swift.String? = nil,
        shareUrl: Swift.String? = nil,
        snapshotId: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.shareUrl = shareUrl
        self.snapshotId = snapshotId
    }
}

struct ExportProjectOutputBody: Swift.Equatable {
    let downloadUrl: Swift.String?
    let shareUrl: Swift.String?
    let snapshotId: Swift.String?
}

extension ExportProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
        case shareUrl
        case snapshotId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let shareUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shareUrl)
        shareUrl = shareUrlDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
    }
}

enum ExportProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service has encountered an unexpected error condition which prevents it from servicing the request.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are too many AWS Mobile Hub projects in the account or the account has exceeded the maximum number of resources in some AWS service. You should create another sub-account using AWS Organizations or remove some resources and retry your request.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
        /// The Exception Error Message.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBundlesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListBundlesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/bundles"
    }
}

/// Request structure to request all available bundles.
public struct ListBundlesInput: Swift.Equatable {
    /// Maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// Pagination token. Set to null to start listing bundles from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more bundles.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBundlesInputBody: Swift.Equatable {
}

extension ListBundlesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBundlesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBundlesOutputBody = try responseDecoder.decode(responseBody: data)
            self.bundleList = output.bundleList
            self.nextToken = output.nextToken
        } else {
            self.bundleList = nil
            self.nextToken = nil
        }
    }
}

/// Result structure contains a list of all available bundles with details.
public struct ListBundlesOutput: Swift.Equatable {
    /// A list of bundles.
    public var bundleList: [MobileClientTypes.BundleDetails]?
    /// Pagination token. If non-null pagination token is returned in a result, then pass its value in another request to fetch more entries.
    public var nextToken: Swift.String?

    public init(
        bundleList: [MobileClientTypes.BundleDetails]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bundleList = bundleList
        self.nextToken = nextToken
    }
}

struct ListBundlesOutputBody: Swift.Equatable {
    let bundleList: [MobileClientTypes.BundleDetails]?
    let nextToken: Swift.String?
}

extension ListBundlesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bundleList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleListContainer = try containerValues.decodeIfPresent([MobileClientTypes.BundleDetails?].self, forKey: .bundleList)
        var bundleListDecoded0:[MobileClientTypes.BundleDetails]? = nil
        if let bundleListContainer = bundleListContainer {
            bundleListDecoded0 = [MobileClientTypes.BundleDetails]()
            for structure0 in bundleListContainer {
                if let structure0 = structure0 {
                    bundleListDecoded0?.append(structure0)
                }
            }
        }
        bundleList = bundleListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBundlesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

/// Request structure used to request projects list in AWS Mobile Hub.
public struct ListProjectsInput: Swift.Equatable {
    /// Maximum number of records to list in a single response.
    public var maxResults: Swift.Int?
    /// Pagination token. Set to null to start listing projects from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more projects.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

/// Result structure used for requests to list projects in AWS Mobile Hub.
public struct ListProjectsOutput: Swift.Equatable {
    /// Pagination token. Set to null to start listing records from start. If non-null pagination token is returned in a result, then pass its value in here in another request to list more entries.
    public var nextToken: Swift.String?
    /// List of projects.
    public var projects: [MobileClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [MobileClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projects: [MobileClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projects
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([MobileClientTypes.ProjectSummary?].self, forKey: .projects)
        var projectsDecoded0:[MobileClientTypes.ProjectSummary]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [MobileClientTypes.ProjectSummary]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// No entity can be found with the specified identifier.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MobileClientTypes {
    /// Developer desktop or target mobile app or website platform.
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case android
        case javascript
        case linux
        case objc
        case osx
        case swift
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .android,
                .javascript,
                .linux,
                .objc,
                .osx,
                .swift,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .javascript: return "JAVASCRIPT"
            case .linux: return "LINUX"
            case .objc: return "OBJC"
            case .osx: return "OSX"
            case .swift: return "SWIFT"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case consoleUrl
        case createdDate
        case lastUpdatedDate
        case name
        case projectId
        case region
        case resources
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let consoleUrl = self.consoleUrl {
            try encodeContainer.encode(consoleUrl, forKey: .consoleUrl)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let lastUpdatedDate = self.lastUpdatedDate {
            try encodeContainer.encodeTimestamp(lastUpdatedDate, format: .epochSeconds, forKey: .lastUpdatedDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectState.self, forKey: .state)
        state = stateDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let consoleUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .consoleUrl)
        consoleUrl = consoleUrlDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([MobileClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[MobileClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [MobileClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension MobileClientTypes {
    /// Detailed information about an AWS Mobile Hub project.
    public struct ProjectDetails: Swift.Equatable {
        /// Website URL for this project in the AWS Mobile Hub console.
        public var consoleUrl: Swift.String?
        /// Date the project was created.
        public var createdDate: ClientRuntime.Date?
        /// Date of the last modification of the project.
        public var lastUpdatedDate: ClientRuntime.Date?
        /// Name of the project.
        public var name: Swift.String?
        /// Unique project identifier.
        public var projectId: Swift.String?
        /// Default region to use for AWS resource creation in the AWS Mobile Hub project.
        public var region: Swift.String?
        /// List of AWS resources associated with a project.
        public var resources: [MobileClientTypes.Resource]?
        /// Synchronization state for a project.
        public var state: MobileClientTypes.ProjectState?

        public init(
            consoleUrl: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            lastUpdatedDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            projectId: Swift.String? = nil,
            region: Swift.String? = nil,
            resources: [MobileClientTypes.Resource]? = nil,
            state: MobileClientTypes.ProjectState? = nil
        )
        {
            self.consoleUrl = consoleUrl
            self.createdDate = createdDate
            self.lastUpdatedDate = lastUpdatedDate
            self.name = name
            self.projectId = projectId
            self.region = region
            self.resources = resources
            self.state = state
        }
    }

}

extension MobileClientTypes {
    /// Synchronization state for a project.
    public enum ProjectState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case importing
        case normal
        case syncing
        case sdkUnknown(Swift.String)

        public static var allCases: [ProjectState] {
            return [
                .importing,
                .normal,
                .syncing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .importing: return "IMPORTING"
            case .normal: return "NORMAL"
            case .syncing: return "SYNCING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProjectState(rawValue: rawValue) ?? ProjectState.sdkUnknown(rawValue)
        }
    }
}

extension MobileClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case projectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
    }
}

extension MobileClientTypes {
    /// Summary information about an AWS Mobile Hub project.
    public struct ProjectSummary: Swift.Equatable {
        /// Name of the project.
        public var name: Swift.String?
        /// Unique project identifier.
        public var projectId: Swift.String?

        public init(
            name: Swift.String? = nil,
            projectId: Swift.String? = nil
        )
        {
            self.name = name
            self.projectId = projectId
        }
    }

}

extension MobileClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case attributes
        case feature
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let feature = self.feature {
            try encodeContainer.encode(feature, forKey: .feature)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let featureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feature)
        feature = featureDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .attributes)
        var attributesDecoded0: [Swift.String:Swift.String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension MobileClientTypes {
    /// Information about an instance of an AWS resource associated with a project.
    public struct Resource: Swift.Equatable {
        /// AWS resource name which uniquely identifies the resource in AWS systems.
        public var arn: Swift.String?
        /// Key-value attribute pairs.
        public var attributes: [Swift.String:Swift.String]?
        /// Identifies which feature in AWS Mobile Hub is associated with this AWS resource.
        public var feature: Swift.String?
        /// Name of the AWS resource (e.g., for an Amazon S3 bucket this is the name of the bucket).
        public var name: Swift.String?
        /// Simplified name for type of AWS resource (e.g., bucket is an Amazon S3 bucket).
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String:Swift.String]? = nil,
            feature: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.feature = feature
            self.name = name
            self.type = type
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable. The request should be retried after some time delay.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
        /// The Exception Error Message.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many requests have been received for this AWS account in too short a time. The request should be retried after some time delay.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
        /// The Exception Error Message.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Credentials of the caller are insufficient to authorize the request.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The Exception Error Message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateProjectOutput>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let contents = input.operationInput.contents {
            let contentsData = contents
            let contentsBody = ClientRuntime.HttpBody.data(contentsData)
            input.builder.withBody(contentsBody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutput>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contents = self.contents {
            try encodeContainer.encode(contents.base64EncodedString(), forKey: .contents)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update"
    }
}

/// Request structure used for requests to update project configuration.
public struct UpdateProjectInput: Swift.Equatable {
    /// ZIP or YAML file which contains project configuration to be updated. This should be the contents of the file downloaded from the URL provided in an export project operation.
    public var contents: ClientRuntime.Data?
    /// Unique project identifier.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        contents: ClientRuntime.Data? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.contents = contents
        self.projectId = projectId
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let contents: ClientRuntime.Data?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contents
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentsDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .contents)
        contents = contentsDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
        } else {
            self.details = nil
        }
    }
}

/// Result structure used for requests to updated project configuration.
public struct UpdateProjectOutput: Swift.Equatable {
    /// Detailed information about the updated AWS Mobile Hub project.
    public var details: MobileClientTypes.ProjectDetails?

    public init(
        details: MobileClientTypes.ProjectDetails? = nil
    )
    {
        self.details = details
    }
}

struct UpdateProjectOutputBody: Swift.Equatable {
    let details: MobileClientTypes.ProjectDetails?
}

extension UpdateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(MobileClientTypes.ProjectDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccountActionRequiredException": return try await AccountActionRequiredException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
