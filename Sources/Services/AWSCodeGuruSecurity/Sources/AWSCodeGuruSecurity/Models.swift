//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource you don't have access to.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource you don't have access to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension CodeGuruSecurityClientTypes {
    /// A numeric value corresponding to the severity of a finding, such as the number of open findings or the average time it takes to close findings of a given severity.
    public struct FindingMetricsValuePerSeverity {
        /// A numeric value corresponding to a critical finding.
        public var critical: Swift.Double?
        /// A numeric value corresponding to a high severity finding.
        public var high: Swift.Double?
        /// A numeric value corresponding to an informational finding.
        public var info: Swift.Double?
        /// A numeric value corresponding to a low severity finding.
        public var low: Swift.Double?
        /// A numeric value corresponding to a medium severity finding.
        public var medium: Swift.Double?

        public init(
            critical: Swift.Double? = nil,
            high: Swift.Double? = nil,
            info: Swift.Double? = nil,
            low: Swift.Double? = nil,
            medium: Swift.Double? = nil
        )
        {
            self.critical = critical
            self.high = high
            self.info = info
            self.low = low
            self.medium = medium
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// A summary of findings metrics for an account on a specified date.
    public struct AccountFindingsMetric {
        /// The number of closed findings of each severity on the specified date.
        public var closedFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The date from which the findings metrics were retrieved.
        public var date: Foundation.Date?
        /// The average time in days it takes to close findings of each severity as of a specified date.
        public var meanTimeToClose: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The number of new findings of each severity on the specified date.
        public var newFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The number of open findings of each severity as of the specified date.
        public var openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?

        public init(
            closedFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            date: Foundation.Date? = nil,
            meanTimeToClose: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            newFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil
        )
        {
            self.closedFindings = closedFindings
            self.date = date
            self.meanTimeToClose = meanTimeToClose
            self.newFindings = newFindings
            self.openFindings = openFindings
        }
    }

}

extension CodeGuruSecurityClientTypes {

    public enum AnalysisType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case security
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisType] {
            return [
                .all,
                .security
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .security: return "Security"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The internal error encountered by the server.
        public internal(set) var error: Swift.String? = nil
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier for the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a validation exception.
    public struct ValidationExceptionField {
        /// Describes the exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension CodeGuruSecurityClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case lambdaCodeShaMismatch
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .lambdaCodeShaMismatch,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .lambdaCodeShaMismatch: return "lambdaCodeShaMisMatch"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [CodeGuruSecurityClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: CodeGuruSecurityClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        fieldList: [CodeGuruSecurityClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: CodeGuruSecurityClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension CodeGuruSecurityClientTypes {
    /// An object that contains information about a finding and the scan that generated it.
    public struct FindingIdentifier {
        /// The identifier for a finding.
        /// This member is required.
        public var findingId: Swift.String?
        /// The name of the scan that generated the finding.
        /// This member is required.
        public var scanName: Swift.String?

        public init(
            findingId: Swift.String? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.findingId = findingId
            self.scanName = scanName
        }
    }

}

public struct BatchGetFindingsInput {
    /// A list of finding identifiers. Each identifier consists of a scanName and a findingId. You retrieve the findingId when you call GetFindings.
    /// This member is required.
    public var findingIdentifiers: [CodeGuruSecurityClientTypes.FindingIdentifier]?

    public init(
        findingIdentifiers: [CodeGuruSecurityClientTypes.FindingIdentifier]? = nil
    )
    {
        self.findingIdentifiers = findingIdentifiers
    }
}

extension CodeGuruSecurityClientTypes {

    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case duplicateIdentifier
        case internalError
        case invalidFindingId
        case invalidScanName
        case itemDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .duplicateIdentifier,
                .internalError,
                .invalidFindingId,
                .invalidScanName,
                .itemDoesNotExist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .duplicateIdentifier: return "DUPLICATE_IDENTIFIER"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidFindingId: return "INVALID_FINDING_ID"
            case .invalidScanName: return "INVALID_SCAN_NAME"
            case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeGuruSecurityClientTypes {
    /// Contains information about the error that caused a finding to fail to be retrieved.
    public struct BatchGetFindingsError {
        /// A code associated with the type of error.
        /// This member is required.
        public var errorCode: CodeGuruSecurityClientTypes.ErrorCode?
        /// The finding ID of the finding that was not fetched.
        /// This member is required.
        public var findingId: Swift.String?
        /// Describes the error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the scan that generated the finding.
        /// This member is required.
        public var scanName: Swift.String?

        public init(
            errorCode: CodeGuruSecurityClientTypes.ErrorCode? = nil,
            findingId: Swift.String? = nil,
            message: Swift.String? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.scanName = scanName
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about the recommended course of action to remediate a finding.
    public struct Recommendation {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the recommendation for remediating the finding.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about the suggested code fix to remediate a finding.
    public struct SuggestedFix {
        /// The suggested code fix. If applicable, includes code patch to replace your source code.
        public var code: Swift.String?
        /// A description of the suggested code fix and why it is being suggested.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about how to remediate a finding.
    public struct Remediation {
        /// An object that contains information about the recommended course of action to remediate a finding.
        public var recommendation: CodeGuruSecurityClientTypes.Recommendation?
        /// A list of SuggestedFix objects. Each object contains information about a suggested code fix to remediate the finding.
        public var suggestedFixes: [CodeGuruSecurityClientTypes.SuggestedFix]?

        public init(
            recommendation: CodeGuruSecurityClientTypes.Recommendation? = nil,
            suggestedFixes: [CodeGuruSecurityClientTypes.SuggestedFix]? = nil
        )
        {
            self.recommendation = recommendation
            self.suggestedFixes = suggestedFixes
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about a resource that contains a finding.
    public struct Resource {
        /// The scanName of the scan that was run on the resource.
        public var id: Swift.String?
        /// The identifier for a section of the resource.
        public var subResourceId: Swift.String?

        public init(
            id: Swift.String? = nil,
            subResourceId: Swift.String? = nil
        )
        {
            self.id = id
            self.subResourceId = subResourceId
        }
    }

}

extension CodeGuruSecurityClientTypes {

    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case critical
        case high
        case info
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .high,
                .info,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .critical: return "Critical"
            case .high: return "High"
            case .info: return "Info"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeGuruSecurityClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .all,
                .closed,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .closed: return "Closed"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodeGuruSecurityClientTypes {
    /// The line of code where a finding was detected.
    public struct CodeLine {
        /// The code that contains a vulnerability.
        public var content: Swift.String?
        /// The code line number.
        public var number: Swift.Int?

        public init(
            content: Swift.String? = nil,
            number: Swift.Int? = nil
        )
        {
            self.content = content
            self.number = number
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about the location of security vulnerabilities that Amazon CodeGuru Security detected in your code.
    public struct FilePath {
        /// A list of CodeLine objects that describe where the security vulnerability appears in your code.
        public var codeSnippet: [CodeGuruSecurityClientTypes.CodeLine]?
        /// The last line number of the code snippet where the security vulnerability appears in your code.
        public var endLine: Swift.Int?
        /// The name of the file.
        public var name: Swift.String?
        /// The path to the resource with the security vulnerability.
        public var path: Swift.String?
        /// The first line number of the code snippet where the security vulnerability appears in your code.
        public var startLine: Swift.Int?

        public init(
            codeSnippet: [CodeGuruSecurityClientTypes.CodeLine]? = nil,
            endLine: Swift.Int? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.name = name
            self.path = path
            self.startLine = startLine
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about a security vulnerability that Amazon CodeGuru Security detected.
    public struct Vulnerability {
        /// An object that describes the location of the detected security vulnerability in your code.
        public var filePath: CodeGuruSecurityClientTypes.FilePath?
        /// The identifier for the vulnerability.
        public var id: Swift.String?
        /// The number of times the vulnerability appears in your code.
        @available(*, deprecated, message: "This shape is not used.")
        public var itemCount: Swift.Int?
        /// One or more URL addresses that contain details about a vulnerability.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities that are related to the vulnerability being described.
        public var relatedVulnerabilities: [Swift.String]?

        public init(
            filePath: CodeGuruSecurityClientTypes.FilePath? = nil,
            id: Swift.String? = nil,
            itemCount: Swift.Int? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil
        )
        {
            self.filePath = filePath
            self.id = id
            self.itemCount = itemCount
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about a finding that was detected in your code.
    public struct Finding {
        /// The time when the finding was created.
        public var createdAt: Foundation.Date?
        /// A description of the finding.
        public var description: Swift.String?
        /// The identifier for the detector that detected the finding in your code. A detector is a defined rule based on industry standards and AWS best practices.
        public var detectorId: Swift.String?
        /// The name of the detector that identified the security vulnerability in your code.
        public var detectorName: Swift.String?
        /// One or more tags or categorizations that are associated with a detector. These tags are defined by type, programming language, or other classification such as maintainability or consistency.
        public var detectorTags: [Swift.String]?
        /// The identifier for the component that generated a finding such as AmazonCodeGuruSecurity.
        public var generatorId: Swift.String?
        /// The identifier for a finding.
        public var id: Swift.String?
        /// An object that contains the details about how to remediate a finding.
        public var remediation: CodeGuruSecurityClientTypes.Remediation?
        /// The resource where Amazon CodeGuru Security detected a finding.
        public var resource: CodeGuruSecurityClientTypes.Resource?
        /// The identifier for the rule that generated the finding.
        public var ruleId: Swift.String?
        /// The severity of the finding. Severity can be critical, high, medium, low, or informational. For information on severity levels, see [Finding severity](https://docs.aws.amazon.com/codeguru/latest/security-ug/findings-overview.html#severity-distribution) in the Amazon CodeGuru Security User Guide.
        public var severity: CodeGuruSecurityClientTypes.Severity?
        /// The status of the finding. A finding status can be open or closed.
        public var status: CodeGuruSecurityClientTypes.Status?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of finding.
        public var type: Swift.String?
        /// The time when the finding was last updated. Findings are updated when you remediate them or when the finding code location changes.
        public var updatedAt: Foundation.Date?
        /// An object that describes the detected security vulnerability.
        public var vulnerability: CodeGuruSecurityClientTypes.Vulnerability?

        public init(
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorTags: [Swift.String]? = nil,
            generatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            remediation: CodeGuruSecurityClientTypes.Remediation? = nil,
            resource: CodeGuruSecurityClientTypes.Resource? = nil,
            ruleId: Swift.String? = nil,
            severity: CodeGuruSecurityClientTypes.Severity? = nil,
            status: CodeGuruSecurityClientTypes.Status? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil,
            vulnerability: CodeGuruSecurityClientTypes.Vulnerability? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.generatorId = generatorId
            self.id = id
            self.remediation = remediation
            self.resource = resource
            self.ruleId = ruleId
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.vulnerability = vulnerability
        }
    }

}

public struct BatchGetFindingsOutput {
    /// A list of errors for individual findings which were not fetched. Each BatchGetFindingsError contains the scanName, findingId, errorCode and error message.
    /// This member is required.
    public var failedFindings: [CodeGuruSecurityClientTypes.BatchGetFindingsError]?
    /// A list of all findings which were successfully fetched.
    /// This member is required.
    public var findings: [CodeGuruSecurityClientTypes.Finding]?

    public init(
        failedFindings: [CodeGuruSecurityClientTypes.BatchGetFindingsError]? = nil,
        findings: [CodeGuruSecurityClientTypes.Finding]? = nil
    )
    {
        self.failedFindings = failedFindings
        self.findings = findings
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the service resource associated with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource associated with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The resource specified in the request was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension CodeGuruSecurityClientTypes {
    /// The identifier for a resource object that contains resources to scan. Specifying a codeArtifactId is required to create a scan.
    public enum ResourceId {
        /// The identifier for the code file uploaded to the resource object. Returned by CreateUploadUrl when you upload resources to be scanned.
        case codeartifactid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension CodeGuruSecurityClientTypes {

    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case express
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .express,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .express: return "Express"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateScanInput {
    /// The type of analysis you want CodeGuru Security to perform in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings. Defaults to Security type if missing.
    public var analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    /// The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
    public var clientToken: Swift.String?
    /// The identifier for the resource object to be scanned.
    /// This member is required.
    public var resourceId: CodeGuruSecurityClientTypes.ResourceId?
    /// The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a STANDARD scan type.
    /// This member is required.
    public var scanName: Swift.String?
    /// The type of scan, either Standard or Express. Defaults to Standard type if missing. Express scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. Standard scans have standard resource limits and use the full set of detectors to analyze your code.
    public var scanType: CodeGuruSecurityClientTypes.ScanType?
    /// An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    public var tags: [Swift.String: Swift.String]?

    public init(
        analysisType: CodeGuruSecurityClientTypes.AnalysisType? = nil,
        clientToken: Swift.String? = nil,
        resourceId: CodeGuruSecurityClientTypes.ResourceId? = nil,
        scanName: Swift.String? = nil,
        scanType: CodeGuruSecurityClientTypes.ScanType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.analysisType = analysisType
        self.clientToken = clientToken
        self.resourceId = resourceId
        self.scanName = scanName
        self.scanType = scanType
        self.tags = tags
    }
}

extension CodeGuruSecurityClientTypes {

    public enum ScanState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanState] {
            return [
                .failed,
                .inProgress,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateScanOutput {
    /// The identifier for the resource object that contains resources that were scanned.
    /// This member is required.
    public var resourceId: CodeGuruSecurityClientTypes.ResourceId?
    /// UUID that identifies the individual scan run.
    /// This member is required.
    public var runId: Swift.String?
    /// The name of the scan.
    /// This member is required.
    public var scanName: Swift.String?
    /// The ARN for the scan name.
    public var scanNameArn: Swift.String?
    /// The current state of the scan. Returns either InProgress, Successful, or Failed.
    /// This member is required.
    public var scanState: CodeGuruSecurityClientTypes.ScanState?

    public init(
        resourceId: CodeGuruSecurityClientTypes.ResourceId? = nil,
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil,
        scanNameArn: Swift.String? = nil,
        scanState: CodeGuruSecurityClientTypes.ScanState? = nil
    )
    {
        self.resourceId = resourceId
        self.runId = runId
        self.scanName = scanName
        self.scanNameArn = scanNameArn
        self.scanState = scanState
    }
}

public struct CreateUploadUrlInput {
    /// The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this scanName when you call CreateScan on the code resource you upload to this URL.
    /// This member is required.
    public var scanName: Swift.String?

    public init(
        scanName: Swift.String? = nil
    )
    {
        self.scanName = scanName
    }
}

public struct CreateUploadUrlOutput {
    /// The identifier for the uploaded code resource. Pass this to CreateScan to use the uploaded resources.
    /// This member is required.
    public var codeArtifactId: Swift.String?
    /// A set of key-value pairs that contain the required headers when uploading your resource.
    /// This member is required.
    public var requestHeaders: [Swift.String: Swift.String]?
    /// A pre-signed S3 URL. You can upload the code file you want to scan with the required requestHeaders using any HTTP client.
    /// This member is required.
    public var s3Url: Swift.String?

    public init(
        codeArtifactId: Swift.String? = nil,
        requestHeaders: [Swift.String: Swift.String]? = nil,
        s3Url: Swift.String? = nil
    )
    {
        self.codeArtifactId = codeArtifactId
        self.requestHeaders = requestHeaders
        self.s3Url = s3Url
    }
}

extension CreateUploadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUploadUrlOutput(codeArtifactId: \(Swift.String(describing: codeArtifactId)), requestHeaders: \"CONTENT_REDACTED\", s3Url: \"CONTENT_REDACTED\")"}
}

public struct GetAccountConfigurationInput {

    public init() { }
}

extension CodeGuruSecurityClientTypes {
    /// Information about the encryption configuration for an account. Required to call UpdateAccountConfiguration.
    public struct EncryptionConfig {
        /// The KMS key ARN that is used for encryption. If an AWS-managed key is used for encryption, returns empty.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

public struct GetAccountConfigurationOutput {
    /// An EncryptionConfig object that contains the KMS key ARN that is used for encryption. By default, CodeGuru Security uses an AWS-managed key for encryption. To specify your own key, call UpdateAccountConfiguration. If you do not specify a customer-managed key, returns empty.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

public struct GetFindingsInput {
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The name of the scan you want to retrieve findings from.
    /// This member is required.
    public var scanName: Swift.String?
    /// The status of the findings you want to get. Pass either Open, Closed, or All.
    public var status: CodeGuruSecurityClientTypes.Status?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanName: Swift.String? = nil,
        status: CodeGuruSecurityClientTypes.Status? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanName = scanName
        self.status = status
    }
}

public struct GetFindingsOutput {
    /// A list of findings generated by the specified scan.
    public var findings: [CodeGuruSecurityClientTypes.Finding]?
    /// A pagination token. You can use this in future calls to GetFindings to continue listing results after the current page.
    public var nextToken: Swift.String?

    public init(
        findings: [CodeGuruSecurityClientTypes.Finding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

public struct GetMetricsSummaryInput {
    /// The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years.
    /// This member is required.
    public var date: Foundation.Date?

    public init(
        date: Foundation.Date? = nil
    )
    {
        self.date = date
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a finding category with open findings.
    public struct CategoryWithFindingNum {
        /// The name of the finding category. A finding category is determined by the detector that detected the finding.
        public var categoryName: Swift.String?
        /// The number of open findings in the category.
        public var findingNumber: Swift.Int?

        public init(
            categoryName: Swift.String? = nil,
            findingNumber: Swift.Int? = nil
        )
        {
            self.categoryName = categoryName
            self.findingNumber = findingNumber
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// Information about the number of findings generated by a scan.
    public struct ScanNameWithFindingNum {
        /// The number of findings generated by a scan.
        public var findingNumber: Swift.Int?
        /// The name of the scan.
        public var scanName: Swift.String?

        public init(
            findingNumber: Swift.Int? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.findingNumber = findingNumber
            self.scanName = scanName
        }
    }

}

extension CodeGuruSecurityClientTypes {
    /// A summary of metrics for an account as of a specified date.
    public struct MetricsSummary {
        /// A list of CategoryWithFindingNum objects for the top 5 finding categories with the most findings.
        public var categoriesWithMostFindings: [CodeGuruSecurityClientTypes.CategoryWithFindingNum]?
        /// The date from which the metrics summary information was retrieved.
        public var date: Foundation.Date?
        /// The number of open findings of each severity.
        public var openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open critical findings.
        public var scansWithMostOpenCriticalFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open findings.
        public var scansWithMostOpenFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]?

        public init(
            categoriesWithMostFindings: [CodeGuruSecurityClientTypes.CategoryWithFindingNum]? = nil,
            date: Foundation.Date? = nil,
            openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            scansWithMostOpenCriticalFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil,
            scansWithMostOpenFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil
        )
        {
            self.categoriesWithMostFindings = categoriesWithMostFindings
            self.date = date
            self.openFindings = openFindings
            self.scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindings
            self.scansWithMostOpenFindings = scansWithMostOpenFindings
        }
    }

}

public struct GetMetricsSummaryOutput {
    /// The summary metrics from the specified date.
    public var metricsSummary: CodeGuruSecurityClientTypes.MetricsSummary?

    public init(
        metricsSummary: CodeGuruSecurityClientTypes.MetricsSummary? = nil
    )
    {
        self.metricsSummary = metricsSummary
    }
}

public struct GetScanInput {
    /// UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the CreateScan operation. Defaults to the latest scan run if missing.
    public var runId: Swift.String?
    /// The name of the scan you want to view details about.
    /// This member is required.
    public var scanName: Swift.String?

    public init(
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil
    )
    {
        self.runId = runId
        self.scanName = scanName
    }
}

public struct GetScanOutput {
    /// The type of analysis CodeGuru Security performed in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings.
    /// This member is required.
    public var analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    /// The time the scan was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Details about the error that causes a scan to fail to be retrieved.
    public var errorMessage: Swift.String?
    /// The number of times a scan has been re-run on a revised resource.
    public var numberOfRevisions: Swift.Int?
    /// UUID that identifies the individual scan run.
    /// This member is required.
    public var runId: Swift.String?
    /// The name of the scan.
    /// This member is required.
    public var scanName: Swift.String?
    /// The ARN for the scan name.
    public var scanNameArn: Swift.String?
    /// The current state of the scan. Returns either InProgress, Successful, or Failed.
    /// This member is required.
    public var scanState: CodeGuruSecurityClientTypes.ScanState?
    /// The time when the scan was last updated. Only available for STANDARD scan types.
    public var updatedAt: Foundation.Date?

    public init(
        analysisType: CodeGuruSecurityClientTypes.AnalysisType? = nil,
        createdAt: Foundation.Date? = nil,
        errorMessage: Swift.String? = nil,
        numberOfRevisions: Swift.Int? = nil,
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil,
        scanNameArn: Swift.String? = nil,
        scanState: CodeGuruSecurityClientTypes.ScanState? = nil,
        updatedAt: Foundation.Date? = nil
    )
    {
        self.analysisType = analysisType
        self.createdAt = createdAt
        self.errorMessage = errorMessage
        self.numberOfRevisions = numberOfRevisions
        self.runId = runId
        self.scanName = scanName
        self.scanNameArn = scanNameArn
        self.scanState = scanState
        self.updatedAt = updatedAt
    }
}

public struct ListFindingsMetricsInput {
    /// The end date of the interval which you want to retrieve metrics from. Round to the nearest day.
    /// This member is required.
    public var endDate: Foundation.Date?
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 1000 results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The start date of the interval which you want to retrieve metrics from. Rounds to the nearest day.
    /// This member is required.
    public var startDate: Foundation.Date?

    public init(
        endDate: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startDate: Foundation.Date? = nil
    )
    {
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startDate = startDate
    }
}

public struct ListFindingsMetricsOutput {
    /// A list of AccountFindingsMetric objects retrieved from the specified time interval.
    public var findingsMetrics: [CodeGuruSecurityClientTypes.AccountFindingsMetric]?
    /// A pagination token. You can use this in future calls to ListFindingMetrics to continue listing results after the current page.
    public var nextToken: Swift.String?

    public init(
        findingsMetrics: [CodeGuruSecurityClientTypes.AccountFindingsMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingsMetrics = findingsMetrics
        self.nextToken = nextToken
    }
}

public struct ListScansInput {
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results. If not specified, returns 100 results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a scan.
    public struct ScanSummary {
        /// The time when the scan was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The identifier for the scan run.
        /// This member is required.
        public var runId: Swift.String?
        /// The name of the scan.
        /// This member is required.
        public var scanName: Swift.String?
        /// The ARN for the scan name.
        public var scanNameArn: Swift.String?
        /// The state of the scan. A scan can be In Progress, Complete, or Failed.
        /// This member is required.
        public var scanState: CodeGuruSecurityClientTypes.ScanState?
        /// The time the scan was last updated. A scan is updated when it is re-run.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            runId: Swift.String? = nil,
            scanName: Swift.String? = nil,
            scanNameArn: Swift.String? = nil,
            scanState: CodeGuruSecurityClientTypes.ScanState? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }
    }

}

public struct ListScansOutput {
    /// A pagination token. You can use this in future calls to ListScans to continue listing results after the current page.
    public var nextToken: Swift.String?
    /// A list of ScanSummary objects with information about all scans in an account.
    public var summaries: [CodeGuruSecurityClientTypes.ScanSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [CodeGuruSecurityClientTypes.ScanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

public struct ListTagsForResourceInput {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling CreateScan, ListScans, or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for each tag you want to remove from a scan.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateAccountConfigurationInput {
    /// The customer-managed KMS key ARN you want to use for encryption. If not specified, CodeGuru Security will use an AWS-managed key for encryption. If you previously specified a customer-managed KMS key and want CodeGuru Security to use an AWS-managed key for encryption instead, pass nothing.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

public struct UpdateAccountConfigurationOutput {
    /// An EncryptionConfig object that contains the KMS key ARN that is used for encryption. If you did not specify a customer-managed KMS key in the request, returns empty.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

extension BatchGetFindingsInput {

    static func urlPathProvider(_ value: BatchGetFindingsInput) -> Swift.String? {
        return "/batchGetFindings"
    }
}

extension CreateScanInput {

    static func urlPathProvider(_ value: CreateScanInput) -> Swift.String? {
        return "/scans"
    }
}

extension CreateUploadUrlInput {

    static func urlPathProvider(_ value: CreateUploadUrlInput) -> Swift.String? {
        return "/uploadUrl"
    }
}

extension GetAccountConfigurationInput {

    static func urlPathProvider(_ value: GetAccountConfigurationInput) -> Swift.String? {
        return "/accountConfiguration/get"
    }
}

extension GetFindingsInput {

    static func urlPathProvider(_ value: GetFindingsInput) -> Swift.String? {
        guard let scanName = value.scanName else {
            return nil
        }
        return "/findings/\(scanName.urlPercentEncoding())"
    }
}

extension GetFindingsInput {

    static func queryItemProvider(_ value: GetFindingsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension GetMetricsSummaryInput {

    static func urlPathProvider(_ value: GetMetricsSummaryInput) -> Swift.String? {
        return "/metrics/summary"
    }
}

extension GetMetricsSummaryInput {

    static func queryItemProvider(_ value: GetMetricsSummaryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let date = value.date else {
            let message = "Creating a URL Query Item failed. date is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let dateQueryItem = Smithy.URIQueryItem(name: "date".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: date)).urlPercentEncoding())
        items.append(dateQueryItem)
        return items
    }
}

extension GetScanInput {

    static func urlPathProvider(_ value: GetScanInput) -> Swift.String? {
        guard let scanName = value.scanName else {
            return nil
        }
        return "/scans/\(scanName.urlPercentEncoding())"
    }
}

extension GetScanInput {

    static func queryItemProvider(_ value: GetScanInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let runId = value.runId {
            let runIdQueryItem = Smithy.URIQueryItem(name: "runId".urlPercentEncoding(), value: Swift.String(runId).urlPercentEncoding())
            items.append(runIdQueryItem)
        }
        return items
    }
}

extension ListFindingsMetricsInput {

    static func urlPathProvider(_ value: ListFindingsMetricsInput) -> Swift.String? {
        return "/metrics/findings"
    }
}

extension ListFindingsMetricsInput {

    static func queryItemProvider(_ value: ListFindingsMetricsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let endDate = value.endDate else {
            let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endDateQueryItem = Smithy.URIQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
        items.append(endDateQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let startDate = value.startDate else {
            let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startDateQueryItem = Smithy.URIQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
        items.append(startDateQueryItem)
        return items
    }
}

extension ListScansInput {

    static func urlPathProvider(_ value: ListScansInput) -> Swift.String? {
        return "/scans"
    }
}

extension ListScansInput {

    static func queryItemProvider(_ value: ListScansInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAccountConfigurationInput {

    static func urlPathProvider(_ value: UpdateAccountConfigurationInput) -> Swift.String? {
        return "/updateAccountConfiguration"
    }
}

extension BatchGetFindingsInput {

    static func write(value: BatchGetFindingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingIdentifiers"].writeList(value.findingIdentifiers, memberWritingClosure: CodeGuruSecurityClientTypes.FindingIdentifier.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateScanInput {

    static func write(value: CreateScanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisType"].write(value.analysisType)
        try writer["clientToken"].write(value.clientToken)
        try writer["resourceId"].write(value.resourceId, with: CodeGuruSecurityClientTypes.ResourceId.write(value:to:))
        try writer["scanName"].write(value.scanName)
        try writer["scanType"].write(value.scanType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateUploadUrlInput {

    static func write(value: CreateUploadUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scanName"].write(value.scanName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccountConfigurationInput {

    static func write(value: UpdateAccountConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfig"].write(value.encryptionConfig, with: CodeGuruSecurityClientTypes.EncryptionConfig.write(value:to:))
    }
}

extension BatchGetFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetFindingsOutput()
        value.failedFindings = try reader["failedFindings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.BatchGetFindingsError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.Finding.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateScanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateScanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateScanOutput()
        value.resourceId = try reader["resourceId"].readIfPresent(with: CodeGuruSecurityClientTypes.ResourceId.read(from:))
        value.runId = try reader["runId"].readIfPresent() ?? ""
        value.scanName = try reader["scanName"].readIfPresent() ?? ""
        value.scanNameArn = try reader["scanNameArn"].readIfPresent()
        value.scanState = try reader["scanState"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateUploadUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUploadUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUploadUrlOutput()
        value.codeArtifactId = try reader["codeArtifactId"].readIfPresent() ?? ""
        value.requestHeaders = try reader["requestHeaders"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.s3Url = try reader["s3Url"].readIfPresent() ?? ""
        return value
    }
}

extension GetAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountConfigurationOutput()
        value.encryptionConfig = try reader["encryptionConfig"].readIfPresent(with: CodeGuruSecurityClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

extension GetFindingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFindingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFindingsOutput()
        value.findings = try reader["findings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.Finding.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetMetricsSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetricsSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetricsSummaryOutput()
        value.metricsSummary = try reader["metricsSummary"].readIfPresent(with: CodeGuruSecurityClientTypes.MetricsSummary.read(from:))
        return value
    }
}

extension GetScanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetScanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetScanOutput()
        value.analysisType = try reader["analysisType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.numberOfRevisions = try reader["numberOfRevisions"].readIfPresent()
        value.runId = try reader["runId"].readIfPresent() ?? ""
        value.scanName = try reader["scanName"].readIfPresent() ?? ""
        value.scanNameArn = try reader["scanNameArn"].readIfPresent()
        value.scanState = try reader["scanState"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ListFindingsMetricsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFindingsMetricsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFindingsMetricsOutput()
        value.findingsMetrics = try reader["findingsMetrics"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.AccountFindingsMetric.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListScansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScansOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.summaries = try reader["summaries"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.ScanSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccountConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccountConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccountConfigurationOutput()
        value.encryptionConfig = try reader["encryptionConfig"].readIfPresent(with: CodeGuruSecurityClientTypes.EncryptionConfig.read(from:))
        return value
    }
}

enum BatchGetFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateScanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUploadUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFindingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetricsSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetScanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFindingsMetricsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccountConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.error = try reader["error"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CodeGuruSecurityClientTypes.Finding {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.Finding {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.Finding()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.generatorId = try reader["generatorId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.resource = try reader["resource"].readIfPresent(with: CodeGuruSecurityClientTypes.Resource.read(from:))
        value.vulnerability = try reader["vulnerability"].readIfPresent(with: CodeGuruSecurityClientTypes.Vulnerability.read(from:))
        value.severity = try reader["severity"].readIfPresent()
        value.remediation = try reader["remediation"].readIfPresent(with: CodeGuruSecurityClientTypes.Remediation.read(from:))
        value.title = try reader["title"].readIfPresent()
        value.detectorTags = try reader["detectorTags"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.detectorId = try reader["detectorId"].readIfPresent()
        value.detectorName = try reader["detectorName"].readIfPresent()
        value.ruleId = try reader["ruleId"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.Remediation {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.Remediation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.Remediation()
        value.recommendation = try reader["recommendation"].readIfPresent(with: CodeGuruSecurityClientTypes.Recommendation.read(from:))
        value.suggestedFixes = try reader["suggestedFixes"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.SuggestedFix.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeGuruSecurityClientTypes.SuggestedFix {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.SuggestedFix {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.SuggestedFix()
        value.description = try reader["description"].readIfPresent()
        value.code = try reader["code"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.Recommendation()
        value.text = try reader["text"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.Vulnerability {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.Vulnerability {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.Vulnerability()
        value.referenceUrls = try reader["referenceUrls"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.relatedVulnerabilities = try reader["relatedVulnerabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.filePath = try reader["filePath"].readIfPresent(with: CodeGuruSecurityClientTypes.FilePath.read(from:))
        value.itemCount = try reader["itemCount"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.FilePath {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.FilePath {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.FilePath()
        value.name = try reader["name"].readIfPresent()
        value.path = try reader["path"].readIfPresent()
        value.startLine = try reader["startLine"].readIfPresent()
        value.endLine = try reader["endLine"].readIfPresent()
        value.codeSnippet = try reader["codeSnippet"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.CodeLine.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeGuruSecurityClientTypes.CodeLine {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.CodeLine {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.CodeLine()
        value.number = try reader["number"].readIfPresent()
        value.content = try reader["content"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.Resource {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.Resource()
        value.id = try reader["id"].readIfPresent()
        value.subResourceId = try reader["subResourceId"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.BatchGetFindingsError {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.BatchGetFindingsError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.BatchGetFindingsError()
        value.scanName = try reader["scanName"].readIfPresent() ?? ""
        value.findingId = try reader["findingId"].readIfPresent() ?? ""
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CodeGuruSecurityClientTypes.ResourceId {

    static func write(value: CodeGuruSecurityClientTypes.ResourceId?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .codeartifactid(codeartifactid):
                try writer["codeArtifactId"].write(codeartifactid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.ResourceId {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "codeArtifactId":
                return .codeartifactid(try reader["codeArtifactId"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CodeGuruSecurityClientTypes.EncryptionConfig {

    static func write(value: CodeGuruSecurityClientTypes.EncryptionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.EncryptionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.EncryptionConfig()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.MetricsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.MetricsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.MetricsSummary()
        value.date = try reader["date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.openFindings = try reader["openFindings"].readIfPresent(with: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.read(from:))
        value.categoriesWithMostFindings = try reader["categoriesWithMostFindings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.CategoryWithFindingNum.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scansWithMostOpenFindings = try reader["scansWithMostOpenFindings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.ScanNameWithFindingNum.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.scansWithMostOpenCriticalFindings = try reader["scansWithMostOpenCriticalFindings"].readListIfPresent(memberReadingClosure: CodeGuruSecurityClientTypes.ScanNameWithFindingNum.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CodeGuruSecurityClientTypes.ScanNameWithFindingNum {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.ScanNameWithFindingNum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.ScanNameWithFindingNum()
        value.scanName = try reader["scanName"].readIfPresent()
        value.findingNumber = try reader["findingNumber"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.CategoryWithFindingNum {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.CategoryWithFindingNum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.CategoryWithFindingNum()
        value.categoryName = try reader["categoryName"].readIfPresent()
        value.findingNumber = try reader["findingNumber"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity()
        value.info = try reader["info"].readIfPresent()
        value.low = try reader["low"].readIfPresent()
        value.medium = try reader["medium"].readIfPresent()
        value.high = try reader["high"].readIfPresent()
        value.critical = try reader["critical"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.AccountFindingsMetric {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.AccountFindingsMetric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.AccountFindingsMetric()
        value.date = try reader["date"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.newFindings = try reader["newFindings"].readIfPresent(with: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.read(from:))
        value.closedFindings = try reader["closedFindings"].readIfPresent(with: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.read(from:))
        value.openFindings = try reader["openFindings"].readIfPresent(with: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.read(from:))
        value.meanTimeToClose = try reader["meanTimeToClose"].readIfPresent(with: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.read(from:))
        return value
    }
}

extension CodeGuruSecurityClientTypes.ScanSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.ScanSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.ScanSummary()
        value.scanState = try reader["scanState"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.scanName = try reader["scanName"].readIfPresent() ?? ""
        value.runId = try reader["runId"].readIfPresent() ?? ""
        value.scanNameArn = try reader["scanNameArn"].readIfPresent()
        return value
    }
}

extension CodeGuruSecurityClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> CodeGuruSecurityClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodeGuruSecurityClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CodeGuruSecurityClientTypes.FindingIdentifier {

    static func write(value: CodeGuruSecurityClientTypes.FindingIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["findingId"].write(value.findingId)
        try writer["scanName"].write(value.scanName)
    }
}

public enum CodeGuruSecurityClientTypes {}
