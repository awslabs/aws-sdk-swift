// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource you don't have access to.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource you don't have access to.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeGuruSecurityClientTypes.AccountFindingsMetric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case closedFindings
        case date
        case meanTimeToClose
        case newFindings
        case openFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let closedFindings = self.closedFindings {
            try encodeContainer.encode(closedFindings, forKey: .closedFindings)
        }
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let meanTimeToClose = self.meanTimeToClose {
            try encodeContainer.encode(meanTimeToClose, forKey: .meanTimeToClose)
        }
        if let newFindings = self.newFindings {
            try encodeContainer.encode(newFindings, forKey: .newFindings)
        }
        if let openFindings = self.openFindings {
            try encodeContainer.encode(openFindings, forKey: .openFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let newFindingsDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.self, forKey: .newFindings)
        newFindings = newFindingsDecoded
        let closedFindingsDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.self, forKey: .closedFindings)
        closedFindings = closedFindingsDecoded
        let openFindingsDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.self, forKey: .openFindings)
        openFindings = openFindingsDecoded
        let meanTimeToCloseDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.self, forKey: .meanTimeToClose)
        meanTimeToClose = meanTimeToCloseDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// A summary of findings metrics in an account.
    public struct AccountFindingsMetric: Swift.Equatable {
        /// The number of closed findings of each severity in an account on the specified date.
        public var closedFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The date from which the finding metrics were retrieved.
        public var date: ClientRuntime.Date?
        /// The average time it takes to close findings of each severity in days.
        public var meanTimeToClose: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The number of new findings of each severity in account on the specified date.
        public var newFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// The number of open findings of each severity in an account as of the specified date.
        public var openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?

        public init(
            closedFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            date: ClientRuntime.Date? = nil,
            meanTimeToClose: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            newFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil
        )
        {
            self.closedFindings = closedFindings
            self.date = date
            self.meanTimeToClose = meanTimeToClose
            self.newFindings = newFindings
            self.openFindings = openFindings
        }
    }

}

extension CodeGuruSecurityClientTypes {
    public enum AnalysisType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case security
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisType] {
            return [
                .all,
                .security,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .security: return "Security"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisType(rawValue: rawValue) ?? AnalysisType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes.BatchGetFindingsError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case findingId
        case message
        case scanName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let findingId = self.findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let findingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingId)
        findingId = findingIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Contains information about the error that caused a finding to fail to be retrieved.
    public struct BatchGetFindingsError: Swift.Equatable {
        /// A code associated with the type of error.
        /// This member is required.
        public var errorCode: CodeGuruSecurityClientTypes.ErrorCode?
        /// The finding ID of the finding that was not fetched.
        /// This member is required.
        public var findingId: Swift.String?
        /// Describes the error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the scan that generated the finding.
        /// This member is required.
        public var scanName: Swift.String?

        public init(
            errorCode: CodeGuruSecurityClientTypes.ErrorCode? = nil,
            findingId: Swift.String? = nil,
            message: Swift.String? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.findingId = findingId
            self.message = message
            self.scanName = scanName
        }
    }

}

extension BatchGetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIdentifiers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIdentifiers = findingIdentifiers {
            var findingIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIdentifiers)
            for findingidentifier0 in findingIdentifiers {
                try findingIdentifiersContainer.encode(findingidentifier0)
            }
        }
    }
}

extension BatchGetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batchGetFindings"
    }
}

public struct BatchGetFindingsInput: Swift.Equatable {
    /// A list of finding identifiers. Each identifier consists of a scanName and a findingId. You retrieve the findingId when you call GetFindings.
    /// This member is required.
    public var findingIdentifiers: [CodeGuruSecurityClientTypes.FindingIdentifier]?

    public init(
        findingIdentifiers: [CodeGuruSecurityClientTypes.FindingIdentifier]? = nil
    )
    {
        self.findingIdentifiers = findingIdentifiers
    }
}

struct BatchGetFindingsInputBody: Swift.Equatable {
    let findingIdentifiers: [CodeGuruSecurityClientTypes.FindingIdentifier]?
}

extension BatchGetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIdentifiers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdentifiersContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.FindingIdentifier?].self, forKey: .findingIdentifiers)
        var findingIdentifiersDecoded0:[CodeGuruSecurityClientTypes.FindingIdentifier]? = nil
        if let findingIdentifiersContainer = findingIdentifiersContainer {
            findingIdentifiersDecoded0 = [CodeGuruSecurityClientTypes.FindingIdentifier]()
            for structure0 in findingIdentifiersContainer {
                if let structure0 = structure0 {
                    findingIdentifiersDecoded0?.append(structure0)
                }
            }
        }
        findingIdentifiers = findingIdentifiersDecoded0
    }
}

extension BatchGetFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedFindings = output.failedFindings
            self.findings = output.findings
        } else {
            self.failedFindings = nil
            self.findings = nil
        }
    }
}

public struct BatchGetFindingsOutput: Swift.Equatable {
    /// A list of errors for individual findings which were not fetched. Each BatchGetFindingsError contains the scanName, findingId, errorCode and error message.
    /// This member is required.
    public var failedFindings: [CodeGuruSecurityClientTypes.BatchGetFindingsError]?
    /// A list of all requested findings.
    /// This member is required.
    public var findings: [CodeGuruSecurityClientTypes.Finding]?

    public init(
        failedFindings: [CodeGuruSecurityClientTypes.BatchGetFindingsError]? = nil,
        findings: [CodeGuruSecurityClientTypes.Finding]? = nil
    )
    {
        self.failedFindings = failedFindings
        self.findings = findings
    }
}

struct BatchGetFindingsOutputBody: Swift.Equatable {
    let findings: [CodeGuruSecurityClientTypes.Finding]?
    let failedFindings: [CodeGuruSecurityClientTypes.BatchGetFindingsError]?
}

extension BatchGetFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedFindings
        case findings
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[CodeGuruSecurityClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [CodeGuruSecurityClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let failedFindingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.BatchGetFindingsError?].self, forKey: .failedFindings)
        var failedFindingsDecoded0:[CodeGuruSecurityClientTypes.BatchGetFindingsError]? = nil
        if let failedFindingsContainer = failedFindingsContainer {
            failedFindingsDecoded0 = [CodeGuruSecurityClientTypes.BatchGetFindingsError]()
            for structure0 in failedFindingsContainer {
                if let structure0 = structure0 {
                    failedFindingsDecoded0?.append(structure0)
                }
            }
        }
        failedFindings = failedFindingsDecoded0
    }
}

enum BatchGetFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruSecurityClientTypes.CategoryWithFindingNum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryName
        case findingNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryName = self.categoryName {
            try encodeContainer.encode(categoryName, forKey: .categoryName)
        }
        if let findingNumber = self.findingNumber {
            try encodeContainer.encode(findingNumber, forKey: .findingNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryName)
        categoryName = categoryNameDecoded
        let findingNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .findingNumber)
        findingNumber = findingNumberDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a finding category with open findings.
    public struct CategoryWithFindingNum: Swift.Equatable {
        /// The name of the finding category. A finding category is determined by the detector that detected the finding.
        public var categoryName: Swift.String?
        /// The number of open findings in the category.
        public var findingNumber: Swift.Int?

        public init(
            categoryName: Swift.String? = nil,
            findingNumber: Swift.Int? = nil
        )
        {
            self.categoryName = categoryName
            self.findingNumber = findingNumber
        }
    }

}

extension CodeGuruSecurityClientTypes.CodeLine: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content
        case number
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let number = self.number {
            try encodeContainer.encode(number, forKey: .number)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .number)
        number = numberDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// The line of code where a finding was detected.
    public struct CodeLine: Swift.Equatable {
        /// The code that contains a vulnerability.
        public var content: Swift.String?
        /// The code line number.
        public var number: Swift.Int?

        public init(
            content: Swift.String? = nil,
            number: Swift.Int? = nil
        )
        {
            self.content = content
            self.number = number
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the service resource associated with the request.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource associated with the request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateScanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisType
        case clientToken
        case resourceId
        case scanName
        case scanType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisType = self.analysisType {
            try encodeContainer.encode(analysisType.rawValue, forKey: .analysisType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateScanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/scans"
    }
}

public struct CreateScanInput: Swift.Equatable {
    /// The type of analysis you want CodeGuru Security to perform in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings. Defaults to Security type if missing.
    public var analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    /// The idempotency token for the request. Amazon CodeGuru Security uses this value to prevent the accidental creation of duplicate scans if there are failures and retries.
    public var clientToken: Swift.String?
    /// The identifier for an input resource used to create a scan.
    /// This member is required.
    public var resourceId: CodeGuruSecurityClientTypes.ResourceId?
    /// The unique name that CodeGuru Security uses to track revisions across multiple scans of the same resource. Only allowed for a STANDARD scan type. If not specified, it will be auto generated.
    /// This member is required.
    public var scanName: Swift.String?
    /// The type of scan, either Standard or Express. Defaults to Standard type if missing. Express scans run on limited resources and use a limited set of detectors to analyze your code in near-real time. Standard scans have standard resource limits and use the full set of detectors to analyze your code.
    public var scanType: CodeGuruSecurityClientTypes.ScanType?
    /// An array of key-value pairs used to tag a scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    public var tags: [Swift.String:Swift.String]?

    public init(
        analysisType: CodeGuruSecurityClientTypes.AnalysisType? = nil,
        clientToken: Swift.String? = nil,
        resourceId: CodeGuruSecurityClientTypes.ResourceId? = nil,
        scanName: Swift.String? = nil,
        scanType: CodeGuruSecurityClientTypes.ScanType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.analysisType = analysisType
        self.clientToken = clientToken
        self.resourceId = resourceId
        self.scanName = scanName
        self.scanType = scanType
        self.tags = tags
    }
}

struct CreateScanInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let resourceId: CodeGuruSecurityClientTypes.ResourceId?
    let scanName: Swift.String?
    let scanType: CodeGuruSecurityClientTypes.ScanType?
    let analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    let tags: [Swift.String:Swift.String]?
}

extension CreateScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisType
        case clientToken
        case resourceId
        case scanName
        case scanType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ResourceId.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let scanTypeDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let analysisTypeDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.AnalysisType.self, forKey: .analysisType)
        analysisType = analysisTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateScanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateScanOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceId = output.resourceId
            self.runId = output.runId
            self.scanName = output.scanName
            self.scanNameArn = output.scanNameArn
            self.scanState = output.scanState
        } else {
            self.resourceId = nil
            self.runId = nil
            self.scanName = nil
            self.scanNameArn = nil
            self.scanState = nil
        }
    }
}

public struct CreateScanOutput: Swift.Equatable {
    /// The identifier for the resource object that contains resources that were scanned.
    /// This member is required.
    public var resourceId: CodeGuruSecurityClientTypes.ResourceId?
    /// UUID that identifies the individual scan run.
    /// This member is required.
    public var runId: Swift.String?
    /// The name of the scan.
    /// This member is required.
    public var scanName: Swift.String?
    /// The ARN for the scan name.
    public var scanNameArn: Swift.String?
    /// The current state of the scan. Returns either InProgress, Successful, or Failed.
    /// This member is required.
    public var scanState: CodeGuruSecurityClientTypes.ScanState?

    public init(
        resourceId: CodeGuruSecurityClientTypes.ResourceId? = nil,
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil,
        scanNameArn: Swift.String? = nil,
        scanState: CodeGuruSecurityClientTypes.ScanState? = nil
    )
    {
        self.resourceId = resourceId
        self.runId = runId
        self.scanName = scanName
        self.scanNameArn = scanNameArn
        self.scanState = scanState
    }
}

struct CreateScanOutputBody: Swift.Equatable {
    let scanName: Swift.String?
    let runId: Swift.String?
    let resourceId: CodeGuruSecurityClientTypes.ResourceId?
    let scanState: CodeGuruSecurityClientTypes.ScanState?
    let scanNameArn: Swift.String?
}

extension CreateScanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId
        case runId
        case scanName
        case scanNameArn
        case scanState
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ResourceId.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let scanStateDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ScanState.self, forKey: .scanState)
        scanState = scanStateDecoded
        let scanNameArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanNameArn)
        scanNameArn = scanNameArnDecoded
    }
}

enum CreateScanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUploadUrlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
    }
}

extension CreateUploadUrlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/uploadUrl"
    }
}

public struct CreateUploadUrlInput: Swift.Equatable {
    /// The name of the scan that will use the uploaded resource. CodeGuru Security uses the unique scan name to track revisions across multiple scans of the same resource. Use this scanName when you call CreateScan on the code resource you upload to this URL.
    /// This member is required.
    public var scanName: Swift.String?

    public init(
        scanName: Swift.String? = nil
    )
    {
        self.scanName = scanName
    }
}

struct CreateUploadUrlInputBody: Swift.Equatable {
    let scanName: Swift.String?
}

extension CreateUploadUrlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
    }
}

extension CreateUploadUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUploadUrlOutput(codeArtifactId: \(Swift.String(describing: codeArtifactId)), requestHeaders: \"CONTENT_REDACTED\", s3Url: \"CONTENT_REDACTED\")"}
}

extension CreateUploadUrlOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUploadUrlOutputBody = try responseDecoder.decode(responseBody: data)
            self.codeArtifactId = output.codeArtifactId
            self.requestHeaders = output.requestHeaders
            self.s3Url = output.s3Url
        } else {
            self.codeArtifactId = nil
            self.requestHeaders = nil
            self.s3Url = nil
        }
    }
}

public struct CreateUploadUrlOutput: Swift.Equatable {
    /// The identifier for the uploaded code resource.
    /// This member is required.
    public var codeArtifactId: Swift.String?
    /// A set of key-value pairs that contain the required headers when uploading your resource.
    /// This member is required.
    public var requestHeaders: [Swift.String:Swift.String]?
    /// A pre-signed S3 URL. You can upload the code file you want to scan and add the required requestHeaders using any HTTP client.
    /// This member is required.
    public var s3Url: Swift.String?

    public init(
        codeArtifactId: Swift.String? = nil,
        requestHeaders: [Swift.String:Swift.String]? = nil,
        s3Url: Swift.String? = nil
    )
    {
        self.codeArtifactId = codeArtifactId
        self.requestHeaders = requestHeaders
        self.s3Url = s3Url
    }
}

struct CreateUploadUrlOutputBody: Swift.Equatable {
    let s3Url: Swift.String?
    let requestHeaders: [Swift.String:Swift.String]?
    let codeArtifactId: Swift.String?
}

extension CreateUploadUrlOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeArtifactId
        case requestHeaders
        case s3Url
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let requestHeadersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestHeaders)
        var requestHeadersDecoded0: [Swift.String:Swift.String]? = nil
        if let requestHeadersContainer = requestHeadersContainer {
            requestHeadersDecoded0 = [Swift.String:Swift.String]()
            for (key0, headervalue0) in requestHeadersContainer {
                if let headervalue0 = headervalue0 {
                    requestHeadersDecoded0?[key0] = headervalue0
                }
            }
        }
        requestHeaders = requestHeadersDecoded0
        let codeArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codeArtifactId)
        codeArtifactId = codeArtifactIdDecoded
    }
}

enum CreateUploadUrlOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruSecurityClientTypes.EncryptionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about account-level configuration.
    public struct EncryptionConfig: Swift.Equatable {
        /// The KMS key ARN to use for encryption. This must be provided as a header when uploading your code resource.
        public var kmsKeyArn: Swift.String?

        public init(
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension CodeGuruSecurityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case duplicateIdentifier
        case internalError
        case invalidFindingId
        case invalidScanName
        case itemDoesNotExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .duplicateIdentifier,
                .internalError,
                .invalidFindingId,
                .invalidScanName,
                .itemDoesNotExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .duplicateIdentifier: return "DUPLICATE_IDENTIFIER"
            case .internalError: return "INTERNAL_ERROR"
            case .invalidFindingId: return "INVALID_FINDING_ID"
            case .invalidScanName: return "INVALID_SCAN_NAME"
            case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes.FilePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeSnippet
        case endLine
        case name
        case path
        case startLine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSnippet = codeSnippet {
            var codeSnippetContainer = encodeContainer.nestedUnkeyedContainer(forKey: .codeSnippet)
            for codeline0 in codeSnippet {
                try codeSnippetContainer.encode(codeline0)
            }
        }
        if let endLine = self.endLine {
            try encodeContainer.encode(endLine, forKey: .endLine)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let startLine = self.startLine {
            try encodeContainer.encode(startLine, forKey: .startLine)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let startLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startLine)
        startLine = startLineDecoded
        let endLineDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endLine)
        endLine = endLineDecoded
        let codeSnippetContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.CodeLine?].self, forKey: .codeSnippet)
        var codeSnippetDecoded0:[CodeGuruSecurityClientTypes.CodeLine]? = nil
        if let codeSnippetContainer = codeSnippetContainer {
            codeSnippetDecoded0 = [CodeGuruSecurityClientTypes.CodeLine]()
            for structure0 in codeSnippetContainer {
                if let structure0 = structure0 {
                    codeSnippetDecoded0?.append(structure0)
                }
            }
        }
        codeSnippet = codeSnippetDecoded0
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about the location of security vulnerabilities that Amazon CodeGuru Security detected in your code.
    public struct FilePath: Swift.Equatable {
        /// A list of CodeLine objects that describe where the security vulnerability appears in your code.
        public var codeSnippet: [CodeGuruSecurityClientTypes.CodeLine]?
        /// The last line number of the code snippet where the security vulnerability appears in your code.
        public var endLine: Swift.Int?
        /// The name of the file.
        public var name: Swift.String?
        /// The path to the resource with the security vulnerability.
        public var path: Swift.String?
        /// The first line number of the code snippet where the security vulnerability appears in your code.
        public var startLine: Swift.Int?

        public init(
            codeSnippet: [CodeGuruSecurityClientTypes.CodeLine]? = nil,
            endLine: Swift.Int? = nil,
            name: Swift.String? = nil,
            path: Swift.String? = nil,
            startLine: Swift.Int? = nil
        )
        {
            self.codeSnippet = codeSnippet
            self.endLine = endLine
            self.name = name
            self.path = path
            self.startLine = startLine
        }
    }

}

extension CodeGuruSecurityClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case description
        case detectorId
        case detectorName
        case detectorTags
        case generatorId
        case id
        case remediation
        case resource
        case ruleId
        case severity
        case status
        case title
        case type
        case updatedAt
        case vulnerability
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let detectorName = self.detectorName {
            try encodeContainer.encode(detectorName, forKey: .detectorName)
        }
        if let detectorTags = detectorTags {
            var detectorTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .detectorTags)
            for string0 in detectorTags {
                try detectorTagsContainer.encode(string0)
            }
        }
        if let generatorId = self.generatorId {
            try encodeContainer.encode(generatorId, forKey: .generatorId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let ruleId = self.ruleId {
            try encodeContainer.encode(ruleId, forKey: .ruleId)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
        if let vulnerability = self.vulnerability {
            try encodeContainer.encode(vulnerability, forKey: .vulnerability)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let generatorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatorId)
        generatorId = generatorIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let vulnerabilityDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Vulnerability.self, forKey: .vulnerability)
        vulnerability = vulnerabilityDecoded
        let severityDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let detectorTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectorTags)
        var detectorTagsDecoded0:[Swift.String]? = nil
        if let detectorTagsContainer = detectorTagsContainer {
            detectorTagsDecoded0 = [Swift.String]()
            for string0 in detectorTagsContainer {
                if let string0 = string0 {
                    detectorTagsDecoded0?.append(string0)
                }
            }
        }
        detectorTags = detectorTagsDecoded0
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let detectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorName)
        detectorName = detectorNameDecoded
        let ruleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ruleId)
        ruleId = ruleIdDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a finding that was detected in your code.
    public struct Finding: Swift.Equatable {
        /// The time when the finding was created.
        public var createdAt: ClientRuntime.Date?
        /// A description of the finding.
        public var description: Swift.String?
        /// The identifier for the detector that detected the finding in your code. A detector is a defined rule based on industry standards and AWS best practices.
        public var detectorId: Swift.String?
        /// The name of the detector that identified the security vulnerability in your code.
        public var detectorName: Swift.String?
        /// One or more tags or categorizations that are associated with a detector. These tags are defined by type, programming language, or other classification such as maintainability or consistency.
        public var detectorTags: [Swift.String]?
        /// The identifier for the component that generated a finding such as AWSCodeGuruSecurity or AWSInspector.
        public var generatorId: Swift.String?
        /// The identifier for a finding.
        public var id: Swift.String?
        /// An object that contains the details about how to remediate a finding.
        public var remediation: CodeGuruSecurityClientTypes.Remediation?
        /// The resource where Amazon CodeGuru Security detected a finding.
        public var resource: CodeGuruSecurityClientTypes.Resource?
        /// The identifier for the rule that generated the finding.
        public var ruleId: Swift.String?
        /// The severity of the finding.
        public var severity: CodeGuruSecurityClientTypes.Severity?
        /// The status of the finding. A finding status can be open or closed.
        public var status: CodeGuruSecurityClientTypes.Status?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of finding.
        public var type: Swift.String?
        /// The time when the finding was last updated. Findings are updated when you remediate them or when the finding code location changes.
        public var updatedAt: ClientRuntime.Date?
        /// An object that describes the detected security vulnerability.
        public var vulnerability: CodeGuruSecurityClientTypes.Vulnerability?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            detectorName: Swift.String? = nil,
            detectorTags: [Swift.String]? = nil,
            generatorId: Swift.String? = nil,
            id: Swift.String? = nil,
            remediation: CodeGuruSecurityClientTypes.Remediation? = nil,
            resource: CodeGuruSecurityClientTypes.Resource? = nil,
            ruleId: Swift.String? = nil,
            severity: CodeGuruSecurityClientTypes.Severity? = nil,
            status: CodeGuruSecurityClientTypes.Status? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil,
            vulnerability: CodeGuruSecurityClientTypes.Vulnerability? = nil
        )
        {
            self.createdAt = createdAt
            self.description = description
            self.detectorId = detectorId
            self.detectorName = detectorName
            self.detectorTags = detectorTags
            self.generatorId = generatorId
            self.id = id
            self.remediation = remediation
            self.resource = resource
            self.ruleId = ruleId
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
            self.vulnerability = vulnerability
        }
    }

}

extension CodeGuruSecurityClientTypes.FindingIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingId
        case scanName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingId = self.findingId {
            try encodeContainer.encode(findingId, forKey: .findingId)
        }
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let findingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingId)
        findingId = findingIdDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// An object that contains information about a finding and the scan that generated it.
    public struct FindingIdentifier: Swift.Equatable {
        /// The identifier for a finding.
        /// This member is required.
        public var findingId: Swift.String?
        /// The name of the scan that generated the finding.
        /// This member is required.
        public var scanName: Swift.String?

        public init(
            findingId: Swift.String? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.findingId = findingId
            self.scanName = scanName
        }
    }

}

extension CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case critical
        case high
        case info
        case low
        case medium
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let critical = self.critical {
            try encodeContainer.encode(critical, forKey: .critical)
        }
        if let high = self.high {
            try encodeContainer.encode(high, forKey: .high)
        }
        if let info = self.info {
            try encodeContainer.encode(info, forKey: .info)
        }
        if let low = self.low {
            try encodeContainer.encode(low, forKey: .low)
        }
        if let medium = self.medium {
            try encodeContainer.encode(medium, forKey: .medium)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infoDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .info)
        info = infoDecoded
        let lowDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .low)
        low = lowDecoded
        let mediumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .medium)
        medium = mediumDecoded
        let highDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .high)
        high = highDecoded
        let criticalDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .critical)
        critical = criticalDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// The severity of the issue in the code that generated a finding.
    public struct FindingMetricsValuePerSeverity: Swift.Equatable {
        /// The severity of the finding is critical and should be addressed immediately.
        public var critical: Swift.Double?
        /// The severity of the finding is high and should be addressed as a near-term priority.
        public var high: Swift.Double?
        /// The finding is related to quality or readability improvements and not considered actionable.
        public var info: Swift.Double?
        /// The severity of the finding is low and does require action on its own.
        public var low: Swift.Double?
        /// The severity of the finding is medium and should be addressed as a mid-term priority.
        public var medium: Swift.Double?

        public init(
            critical: Swift.Double? = nil,
            high: Swift.Double? = nil,
            info: Swift.Double? = nil,
            low: Swift.Double? = nil,
            medium: Swift.Double? = nil
        )
        {
            self.critical = critical
            self.high = high
            self.info = info
            self.low = low
            self.medium = medium
        }
    }

}

extension GetAccountConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/accountConfiguration/get"
    }
}

public struct GetAccountConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetAccountConfigurationInputBody: Swift.Equatable {
}

extension GetAccountConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct GetAccountConfigurationOutput: Swift.Equatable {
    /// An EncryptionConfig object that contains the KMS key ARN to use for encryption. By default, CodeGuru Security uses an AWS-managed key for encryption. To specify your own key, call UpdateAccountConfiguration.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct GetAccountConfigurationOutputBody: Swift.Equatable {
    let encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?
}

extension GetAccountConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

enum GetAccountConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scanName = scanName else {
            return nil
        }
        return "/findings/\(scanName.urlPercentEncoding())"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The name of the scan you want to retrieve findings from.
    /// This member is required.
    public var scanName: Swift.String?
    /// The status of the findings you want to get. Pass either Open, Closed, or All.
    public var status: CodeGuruSecurityClientTypes.Status?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanName: Swift.String? = nil,
        status: CodeGuruSecurityClientTypes.Status? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanName = scanName
        self.status = status
    }
}

struct GetFindingsInputBody: Swift.Equatable {
}

extension GetFindingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct GetFindingsOutput: Swift.Equatable {
    /// A list of findings generated by the specified scan.
    public var findings: [CodeGuruSecurityClientTypes.Finding]?
    /// A pagination token. You can use this in future calls to GetFindings to continue listing results after the current page.
    public var nextToken: Swift.String?

    public init(
        findings: [CodeGuruSecurityClientTypes.Finding]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct GetFindingsOutputBody: Swift.Equatable {
    let findings: [CodeGuruSecurityClientTypes.Finding]?
    let nextToken: Swift.String?
}

extension GetFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[CodeGuruSecurityClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [CodeGuruSecurityClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMetricsSummaryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let date = date else {
                let message = "Creating a URL Query Item failed. date is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let dateQueryItem = ClientRuntime.URLQueryItem(name: "date".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: date)).urlPercentEncoding())
            items.append(dateQueryItem)
            return items
        }
    }
}

extension GetMetricsSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metrics/summary"
    }
}

public struct GetMetricsSummaryInput: Swift.Equatable {
    /// The date you want to retrieve summary metrics from, rounded to the nearest day. The date must be within the past two years since metrics data is only stored for two years. If a date outside of this range is passed, the response will be empty.
    /// This member is required.
    public var date: ClientRuntime.Date?

    public init(
        date: ClientRuntime.Date? = nil
    )
    {
        self.date = date
    }
}

struct GetMetricsSummaryInputBody: Swift.Equatable {
}

extension GetMetricsSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMetricsSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMetricsSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.metricsSummary = output.metricsSummary
        } else {
            self.metricsSummary = nil
        }
    }
}

public struct GetMetricsSummaryOutput: Swift.Equatable {
    /// The summary metrics from the specified date.
    public var metricsSummary: CodeGuruSecurityClientTypes.MetricsSummary?

    public init(
        metricsSummary: CodeGuruSecurityClientTypes.MetricsSummary? = nil
    )
    {
        self.metricsSummary = metricsSummary
    }
}

struct GetMetricsSummaryOutputBody: Swift.Equatable {
    let metricsSummary: CodeGuruSecurityClientTypes.MetricsSummary?
}

extension GetMetricsSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metricsSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricsSummaryDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.MetricsSummary.self, forKey: .metricsSummary)
        metricsSummary = metricsSummaryDecoded
    }
}

enum GetMetricsSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetScanInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let runId = runId {
                let runIdQueryItem = ClientRuntime.URLQueryItem(name: "runId".urlPercentEncoding(), value: Swift.String(runId).urlPercentEncoding())
                items.append(runIdQueryItem)
            }
            return items
        }
    }
}

extension GetScanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let scanName = scanName else {
            return nil
        }
        return "/scans/\(scanName.urlPercentEncoding())"
    }
}

public struct GetScanInput: Swift.Equatable {
    /// UUID that identifies the individual scan run you want to view details about. You retrieve this when you call the CreateScan operation. Defaults to the latest scan run if missing.
    public var runId: Swift.String?
    /// The name of the scan you want to view details about.
    /// This member is required.
    public var scanName: Swift.String?

    public init(
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil
    )
    {
        self.runId = runId
        self.scanName = scanName
    }
}

struct GetScanInputBody: Swift.Equatable {
}

extension GetScanInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetScanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetScanOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisType = output.analysisType
            self.createdAt = output.createdAt
            self.numberOfRevisions = output.numberOfRevisions
            self.runId = output.runId
            self.scanName = output.scanName
            self.scanNameArn = output.scanNameArn
            self.scanState = output.scanState
            self.updatedAt = output.updatedAt
        } else {
            self.analysisType = nil
            self.createdAt = nil
            self.numberOfRevisions = nil
            self.runId = nil
            self.scanName = nil
            self.scanNameArn = nil
            self.scanState = nil
            self.updatedAt = nil
        }
    }
}

public struct GetScanOutput: Swift.Equatable {
    /// The type of analysis CodeGuru Security performed in the scan, either Security or All. The Security type only generates findings related to security. The All type generates both security findings and quality findings.
    /// This member is required.
    public var analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    /// The time the scan was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// The number of times a scan has been re-run on a revised resource.
    public var numberOfRevisions: Swift.Int?
    /// UUID that identifies the individual scan run.
    /// This member is required.
    public var runId: Swift.String?
    /// The name of the scan.
    /// This member is required.
    public var scanName: Swift.String?
    /// The ARN for the scan name.
    public var scanNameArn: Swift.String?
    /// The current state of the scan. Pass either InProgress, Successful, or Failed.
    /// This member is required.
    public var scanState: CodeGuruSecurityClientTypes.ScanState?
    /// The time when the scan was last updated. Only available for STANDARD scan types.
    public var updatedAt: ClientRuntime.Date?

    public init(
        analysisType: CodeGuruSecurityClientTypes.AnalysisType? = nil,
        createdAt: ClientRuntime.Date? = nil,
        numberOfRevisions: Swift.Int? = nil,
        runId: Swift.String? = nil,
        scanName: Swift.String? = nil,
        scanNameArn: Swift.String? = nil,
        scanState: CodeGuruSecurityClientTypes.ScanState? = nil,
        updatedAt: ClientRuntime.Date? = nil
    )
    {
        self.analysisType = analysisType
        self.createdAt = createdAt
        self.numberOfRevisions = numberOfRevisions
        self.runId = runId
        self.scanName = scanName
        self.scanNameArn = scanNameArn
        self.scanState = scanState
        self.updatedAt = updatedAt
    }
}

struct GetScanOutputBody: Swift.Equatable {
    let scanName: Swift.String?
    let runId: Swift.String?
    let scanState: CodeGuruSecurityClientTypes.ScanState?
    let createdAt: ClientRuntime.Date?
    let analysisType: CodeGuruSecurityClientTypes.AnalysisType?
    let updatedAt: ClientRuntime.Date?
    let numberOfRevisions: Swift.Int?
    let scanNameArn: Swift.String?
}

extension GetScanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisType
        case createdAt
        case numberOfRevisions
        case runId
        case scanName
        case scanNameArn
        case scanState
        case updatedAt
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let scanStateDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ScanState.self, forKey: .scanState)
        scanState = scanStateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analysisTypeDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.AnalysisType.self, forKey: .analysisType)
        analysisType = analysisTypeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let numberOfRevisionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRevisions)
        numberOfRevisions = numberOfRevisionsDecoded
        let scanNameArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanNameArn)
        scanNameArn = scanNameArnDecoded
    }
}

enum GetScanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.error = output.error
            self.properties.message = output.message
        } else {
            self.properties.error = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The internal error encountered by the server.
        public internal(set) var error: Swift.String? = nil
        /// Description of the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        error: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.error = error
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let error: Swift.String?
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFindingsMetricsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let endDate = endDate else {
                let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
            items.append(endDateQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let startDate = startDate else {
                let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
            items.append(startDateQueryItem)
            return items
        }
    }
}

extension ListFindingsMetricsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/metrics/findings"
    }
}

public struct ListFindingsMetricsInput: Swift.Equatable {
    /// The end date of the interval which you want to retrieve metrics from.
    /// This member is required.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The start date of the interval which you want to retrieve metrics from.
    /// This member is required.
    public var startDate: ClientRuntime.Date?

    public init(
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil
    )
    {
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startDate = startDate
    }
}

struct ListFindingsMetricsInputBody: Swift.Equatable {
}

extension ListFindingsMetricsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFindingsMetricsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsMetricsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingsMetrics = output.findingsMetrics
            self.nextToken = output.nextToken
        } else {
            self.findingsMetrics = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsMetricsOutput: Swift.Equatable {
    /// A list of AccountFindingsMetric objects retrieved from the specified time interval.
    public var findingsMetrics: [CodeGuruSecurityClientTypes.AccountFindingsMetric]?
    /// A pagination token. You can use this in future calls to ListFindingMetrics to continue listing results after the current page.
    public var nextToken: Swift.String?

    public init(
        findingsMetrics: [CodeGuruSecurityClientTypes.AccountFindingsMetric]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingsMetrics = findingsMetrics
        self.nextToken = nextToken
    }
}

struct ListFindingsMetricsOutputBody: Swift.Equatable {
    let findingsMetrics: [CodeGuruSecurityClientTypes.AccountFindingsMetric]?
    let nextToken: Swift.String?
}

extension ListFindingsMetricsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingsMetrics
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsMetricsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.AccountFindingsMetric?].self, forKey: .findingsMetrics)
        var findingsMetricsDecoded0:[CodeGuruSecurityClientTypes.AccountFindingsMetric]? = nil
        if let findingsMetricsContainer = findingsMetricsContainer {
            findingsMetricsDecoded0 = [CodeGuruSecurityClientTypes.AccountFindingsMetric]()
            for structure0 in findingsMetricsContainer {
                if let structure0 = structure0 {
                    findingsMetricsDecoded0?.append(structure0)
                }
            }
        }
        findingsMetrics = findingsMetricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsMetricsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListScansInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListScansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/scans"
    }
}

public struct ListScansInput: Swift.Equatable {
    /// The maximum number of results to return in the response. Use this parameter when paginating results. If additional results exist beyond the number you specify, the nextToken element is returned in the response. Use nextToken in a subsequent request to retrieve additional results.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request. For subsequent calls, use the nextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListScansInputBody: Swift.Equatable {
}

extension ListScansInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListScansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListScansOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.summaries = output.summaries
        } else {
            self.nextToken = nil
            self.summaries = nil
        }
    }
}

public struct ListScansOutput: Swift.Equatable {
    /// A pagination token. You can use this in future calls to ListScans to continue listing results after the current page.
    public var nextToken: Swift.String?
    /// A list of ScanSummary objects with information about all scans in an account.
    public var summaries: [CodeGuruSecurityClientTypes.ScanSummary]?

    public init(
        nextToken: Swift.String? = nil,
        summaries: [CodeGuruSecurityClientTypes.ScanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.summaries = summaries
    }
}

struct ListScansOutputBody: Swift.Equatable {
    let summaries: [CodeGuruSecurityClientTypes.ScanSummary]?
    let nextToken: Swift.String?
}

extension ListScansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case summaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summariesContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.ScanSummary?].self, forKey: .summaries)
        var summariesDecoded0:[CodeGuruSecurityClientTypes.ScanSummary]? = nil
        if let summariesContainer = summariesContainer {
            summariesDecoded0 = [CodeGuruSecurityClientTypes.ScanSummary]()
            for structure0 in summariesContainer {
                if let structure0 = structure0 {
                    summariesDecoded0?.append(structure0)
                }
            }
        }
        summaries = summariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListScansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CodeGuruSecurityClientTypes.MetricsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoriesWithMostFindings
        case date
        case openFindings
        case scansWithMostOpenCriticalFindings
        case scansWithMostOpenFindings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoriesWithMostFindings = categoriesWithMostFindings {
            var categoriesWithMostFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoriesWithMostFindings)
            for categorywithfindingnum0 in categoriesWithMostFindings {
                try categoriesWithMostFindingsContainer.encode(categorywithfindingnum0)
            }
        }
        if let date = self.date {
            try encodeContainer.encodeTimestamp(date, format: .epochSeconds, forKey: .date)
        }
        if let openFindings = self.openFindings {
            try encodeContainer.encode(openFindings, forKey: .openFindings)
        }
        if let scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindings {
            var scansWithMostOpenCriticalFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scansWithMostOpenCriticalFindings)
            for scannamewithfindingnum0 in scansWithMostOpenCriticalFindings {
                try scansWithMostOpenCriticalFindingsContainer.encode(scannamewithfindingnum0)
            }
        }
        if let scansWithMostOpenFindings = scansWithMostOpenFindings {
            var scansWithMostOpenFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scansWithMostOpenFindings)
            for scannamewithfindingnum0 in scansWithMostOpenFindings {
                try scansWithMostOpenFindingsContainer.encode(scannamewithfindingnum0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .date)
        date = dateDecoded
        let openFindingsDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity.self, forKey: .openFindings)
        openFindings = openFindingsDecoded
        let categoriesWithMostFindingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.CategoryWithFindingNum?].self, forKey: .categoriesWithMostFindings)
        var categoriesWithMostFindingsDecoded0:[CodeGuruSecurityClientTypes.CategoryWithFindingNum]? = nil
        if let categoriesWithMostFindingsContainer = categoriesWithMostFindingsContainer {
            categoriesWithMostFindingsDecoded0 = [CodeGuruSecurityClientTypes.CategoryWithFindingNum]()
            for structure0 in categoriesWithMostFindingsContainer {
                if let structure0 = structure0 {
                    categoriesWithMostFindingsDecoded0?.append(structure0)
                }
            }
        }
        categoriesWithMostFindings = categoriesWithMostFindingsDecoded0
        let scansWithMostOpenFindingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.ScanNameWithFindingNum?].self, forKey: .scansWithMostOpenFindings)
        var scansWithMostOpenFindingsDecoded0:[CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil
        if let scansWithMostOpenFindingsContainer = scansWithMostOpenFindingsContainer {
            scansWithMostOpenFindingsDecoded0 = [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]()
            for structure0 in scansWithMostOpenFindingsContainer {
                if let structure0 = structure0 {
                    scansWithMostOpenFindingsDecoded0?.append(structure0)
                }
            }
        }
        scansWithMostOpenFindings = scansWithMostOpenFindingsDecoded0
        let scansWithMostOpenCriticalFindingsContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.ScanNameWithFindingNum?].self, forKey: .scansWithMostOpenCriticalFindings)
        var scansWithMostOpenCriticalFindingsDecoded0:[CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil
        if let scansWithMostOpenCriticalFindingsContainer = scansWithMostOpenCriticalFindingsContainer {
            scansWithMostOpenCriticalFindingsDecoded0 = [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]()
            for structure0 in scansWithMostOpenCriticalFindingsContainer {
                if let structure0 = structure0 {
                    scansWithMostOpenCriticalFindingsDecoded0?.append(structure0)
                }
            }
        }
        scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindingsDecoded0
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about summary metrics in an account.
    public struct MetricsSummary: Swift.Equatable {
        /// A list of CategoryWithFindingNum objects for the top 5 finding categories with the most open findings in an account.
        public var categoriesWithMostFindings: [CodeGuruSecurityClientTypes.CategoryWithFindingNum]?
        /// The date from which the metrics summary information was retrieved.
        public var date: ClientRuntime.Date?
        /// The number of open findings of each severity in an account.
        public var openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open findings in an account.
        public var scansWithMostOpenCriticalFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]?
        /// A list of ScanNameWithFindingNum objects for the top 3 scans with the most number of open critical findings in an account.
        public var scansWithMostOpenFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]?

        public init(
            categoriesWithMostFindings: [CodeGuruSecurityClientTypes.CategoryWithFindingNum]? = nil,
            date: ClientRuntime.Date? = nil,
            openFindings: CodeGuruSecurityClientTypes.FindingMetricsValuePerSeverity? = nil,
            scansWithMostOpenCriticalFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil,
            scansWithMostOpenFindings: [CodeGuruSecurityClientTypes.ScanNameWithFindingNum]? = nil
        )
        {
            self.categoriesWithMostFindings = categoriesWithMostFindings
            self.date = date
            self.openFindings = openFindings
            self.scansWithMostOpenCriticalFindings = scansWithMostOpenCriticalFindings
            self.scansWithMostOpenFindings = scansWithMostOpenFindings
        }
    }

}

extension CodeGuruSecurityClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about the recommended course of action to remediate a finding.
    public struct Recommendation: Swift.Equatable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the recommendation for remediating the finding.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension CodeGuruSecurityClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
        case suggestedFixes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let suggestedFixes = suggestedFixes {
            var suggestedFixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .suggestedFixes)
            for suggestedfix0 in suggestedFixes {
                try suggestedFixesContainer.encode(suggestedfix0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let suggestedFixesContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.SuggestedFix?].self, forKey: .suggestedFixes)
        var suggestedFixesDecoded0:[CodeGuruSecurityClientTypes.SuggestedFix]? = nil
        if let suggestedFixesContainer = suggestedFixesContainer {
            suggestedFixesDecoded0 = [CodeGuruSecurityClientTypes.SuggestedFix]()
            for structure0 in suggestedFixesContainer {
                if let structure0 = structure0 {
                    suggestedFixesDecoded0?.append(structure0)
                }
            }
        }
        suggestedFixes = suggestedFixesDecoded0
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about how to remediate a finding.
    public struct Remediation: Swift.Equatable {
        /// An object that contains information about the recommended course of action to remediate a finding.
        public var recommendation: CodeGuruSecurityClientTypes.Recommendation?
        /// A list of SuggestedFix objects. Each object contains information about a suggested code fix to remediate the finding.
        public var suggestedFixes: [CodeGuruSecurityClientTypes.SuggestedFix]?

        public init(
            recommendation: CodeGuruSecurityClientTypes.Recommendation? = nil,
            suggestedFixes: [CodeGuruSecurityClientTypes.SuggestedFix]? = nil
        )
        {
            self.recommendation = recommendation
            self.suggestedFixes = suggestedFixes
        }
    }

}

extension CodeGuruSecurityClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case subResourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let subResourceId = self.subResourceId {
            try encodeContainer.encode(subResourceId, forKey: .subResourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let subResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subResourceId)
        subResourceId = subResourceIdDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a resource, such as an Amazon S3 bucket or AWS Lambda function, that contains a finding.
    public struct Resource: Swift.Equatable {
        /// The identifier for the resource.
        public var id: Swift.String?
        /// The identifier for a section of the resource, such as an AWS Lambda layer.
        public var subResourceId: Swift.String?

        public init(
            id: Swift.String? = nil,
            subResourceId: Swift.String? = nil
        )
        {
            self.id = id
            self.subResourceId = subResourceId
        }
    }

}

extension CodeGuruSecurityClientTypes.ResourceId: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeartifactid = "codeArtifactId"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .codeartifactid(codeartifactid):
                try container.encode(codeartifactid, forKey: .codeartifactid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let codeartifactidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .codeartifactid)
        if let codeartifactid = codeartifactidDecoded {
            self = .codeartifactid(codeartifactid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CodeGuruSecurityClientTypes {
    /// The identifier for a resource object that contains resources where a finding was detected.
    public enum ResourceId: Swift.Equatable {
        /// The identifier for the code file uploaded to the resource where a finding was detected.
        case codeartifactid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CodeGuruSecurityClientTypes.ScanNameWithFindingNum: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingNumber
        case scanName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingNumber = self.findingNumber {
            try encodeContainer.encode(findingNumber, forKey: .findingNumber)
        }
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let findingNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .findingNumber)
        findingNumber = findingNumberDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a scan with open findings.
    public struct ScanNameWithFindingNum: Swift.Equatable {
        /// The number of open findings generated by a scan.
        public var findingNumber: Swift.Int?
        /// The name of the scan.
        public var scanName: Swift.String?

        public init(
            findingNumber: Swift.Int? = nil,
            scanName: Swift.String? = nil
        )
        {
            self.findingNumber = findingNumber
            self.scanName = scanName
        }
    }

}

extension CodeGuruSecurityClientTypes {
    public enum ScanState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanState] {
            return [
                .failed,
                .inProgress,
                .successful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanState(rawValue: rawValue) ?? ScanState.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes.ScanSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case runId
        case scanName
        case scanNameArn
        case scanState
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let runId = self.runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let scanName = self.scanName {
            try encodeContainer.encode(scanName, forKey: .scanName)
        }
        if let scanNameArn = self.scanNameArn {
            try encodeContainer.encode(scanNameArn, forKey: .scanNameArn)
        }
        if let scanState = self.scanState {
            try encodeContainer.encode(scanState.rawValue, forKey: .scanState)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanStateDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ScanState.self, forKey: .scanState)
        scanState = scanStateDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let scanNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanName)
        scanName = scanNameDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let scanNameArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanNameArn)
        scanNameArn = scanNameArnDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a scan.
    public struct ScanSummary: Swift.Equatable {
        /// The time when the scan was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The identifier for the scan run.
        /// This member is required.
        public var runId: Swift.String?
        /// The name of the scan.
        /// This member is required.
        public var scanName: Swift.String?
        /// The ARN for the scan name.
        public var scanNameArn: Swift.String?
        /// The state of the scan. A scan can be In Progress, Complete, or Failed.
        /// This member is required.
        public var scanState: CodeGuruSecurityClientTypes.ScanState?
        /// The time the scan was last updated. A scan is updated when it is re-run.
        public var updatedAt: ClientRuntime.Date?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            runId: Swift.String? = nil,
            scanName: Swift.String? = nil,
            scanNameArn: Swift.String? = nil,
            scanState: CodeGuruSecurityClientTypes.ScanState? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.runId = runId
            self.scanName = scanName
            self.scanNameArn = scanNameArn
            self.scanState = scanState
            self.updatedAt = updatedAt
        }
    }

}

extension CodeGuruSecurityClientTypes {
    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case express
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .express,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .express: return "Express"
            case .standard: return "Standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanType(rawValue: rawValue) ?? ScanType.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case info
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .critical,
                .high,
                .info,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "Critical"
            case .high: return "High"
            case .info: return "Info"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case closed
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .all,
                .closed,
                .open,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .closed: return "Closed"
            case .open: return "Open"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes.SuggestedFix: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about the suggested code fix to remediate a finding.
    public struct SuggestedFix: Swift.Equatable {
        /// The suggested code to add to your file.
        public var code: Swift.String?
        /// A description of the suggested code fix and why it is being suggested.
        public var description: Swift.String?

        public init(
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of key-value pairs used to tag an existing scan. A tag is a custom attribute label with two parts:
    ///
    /// * A tag key. For example, CostCenter, Environment, or Secret. Tag keys are case sensitive.
    ///
    /// * An optional tag value field. For example, 111122223333, Production, or a team name. Omitting the tag value is the same as using an empty string. Tag values are case sensitive.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.errorCode = nil
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier for the originating quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier for the originating service.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the ScanName object. You can retrieve this ARN by calling ListScans or GetScan.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for each tag you want to remove from a scan.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccountConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfig = self.encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
    }
}

extension UpdateAccountConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateAccountConfiguration"
    }
}

public struct UpdateAccountConfigurationInput: Swift.Equatable {
    /// The KMS key ARN you want to use for encryption. Defaults to service-side encryption if missing.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct UpdateAccountConfigurationInputBody: Swift.Equatable {
    let encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?
}

extension UpdateAccountConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

extension UpdateAccountConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAccountConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.encryptionConfig = output.encryptionConfig
        } else {
            self.encryptionConfig = nil
        }
    }
}

public struct UpdateAccountConfigurationOutput: Swift.Equatable {
    /// An EncryptionConfig object that contains the KMS key ARN to use for encryption.
    /// This member is required.
    public var encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?

    public init(
        encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig? = nil
    )
    {
        self.encryptionConfig = encryptionConfig
    }
}

struct UpdateAccountConfigurationOutputBody: Swift.Equatable {
    let encryptionConfig: CodeGuruSecurityClientTypes.EncryptionConfig?
}

extension UpdateAccountConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfig
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
    }
}

enum UpdateAccountConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorCode = output.errorCode
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.errorCode = nil
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The identifier for the error.
        /// This member is required.
        public internal(set) var errorCode: Swift.String? = nil
        /// The field that caused the error, if applicable.
        public internal(set) var fieldList: [CodeGuruSecurityClientTypes.ValidationExceptionField]? = nil
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: CodeGuruSecurityClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorCode: Swift.String? = nil,
        fieldList: [CodeGuruSecurityClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: CodeGuruSecurityClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.errorCode = errorCode
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let errorCode: Swift.String?
    let message: Swift.String?
    let reason: CodeGuruSecurityClientTypes.ValidationExceptionReason?
    let fieldList: [CodeGuruSecurityClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([CodeGuruSecurityClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[CodeGuruSecurityClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [CodeGuruSecurityClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension CodeGuruSecurityClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Describes the exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension CodeGuruSecurityClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case lambdaCodeShaMismatch
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .lambdaCodeShaMismatch,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .lambdaCodeShaMismatch: return "lambdaCodeShaMisMatch"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CodeGuruSecurityClientTypes.Vulnerability: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePath
        case id
        case itemCount
        case referenceUrls
        case relatedVulnerabilities
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let itemCount = self.itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for string0 in referenceUrls {
                try referenceUrlsContainer.encode(string0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for string0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(CodeGuruSecurityClientTypes.FilePath.self, forKey: .filePath)
        filePath = filePathDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
    }
}

extension CodeGuruSecurityClientTypes {
    /// Information about a security vulnerability that Amazon CodeGuru Security detected.
    public struct Vulnerability: Swift.Equatable {
        /// An object that describes the location of the detected security vulnerability in your code.
        public var filePath: CodeGuruSecurityClientTypes.FilePath?
        /// The identifier for the vulnerability.
        public var id: Swift.String?
        /// The number of times the vulnerability appears in your code.
        public var itemCount: Swift.Int?
        /// One or more URL addresses that contain details about a vulnerability.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities that are related to the vulnerability being described.
        public var relatedVulnerabilities: [Swift.String]?

        public init(
            filePath: CodeGuruSecurityClientTypes.FilePath? = nil,
            id: Swift.String? = nil,
            itemCount: Swift.Int? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil
        )
        {
            self.filePath = filePath
            self.id = id
            self.itemCount = itemCount
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
        }
    }

}
