// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import Foundation
import Smithy
import SmithyHTTPAPI
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// CodeStar Notifications can't create the notification rule because you do not have sufficient permissions.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum CodestarnotificationsClientTypes {}

extension ConcurrentModificationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConcurrentModificationException {
        let reader = baseError.errorBodyReader
        var value = ConcurrentModificationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// CodeStar Notifications can't complete the request because the resource is being modified by another process. Wait a few minutes and try again.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ConfigurationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConfigurationException {
        let reader = baseError.errorBodyReader
        var value = ConfigurationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Some or all of the configuration is incomplete, missing, or not valid.
public struct ConfigurationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConfigurationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CreateNotificationRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateNotificationRuleInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), detailType: \(Swift.String(describing: detailType)), eventTypeIds: \(Swift.String(describing: eventTypeIds)), resource: \(Swift.String(describing: resource)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)), name: \"CONTENT_REDACTED\")"}
}

extension CreateNotificationRuleInput {

    static func urlPathProvider(_ value: CreateNotificationRuleInput) -> Swift.String? {
        return "/createNotificationRule"
    }
}

extension CreateNotificationRuleInput {

    static func write(value: CreateNotificationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["DetailType"].write(value.detailType)
        try writer["EventTypeIds"].writeList(value.eventTypeIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Resource"].write(value.resource)
        try writer["Status"].write(value.status)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: CodestarnotificationsClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateNotificationRuleInput {
    /// A unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request with the same parameters is received and a token is included, the request returns information about the initial request that used that token. The Amazon Web Services SDKs prepopulate client request tokens. If you are using an Amazon Web Services SDK, an idempotency token is created for you.
    public var clientRequestToken: Swift.String?
    /// The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by CodeStar Notifications and/or the service for the resource for which the notification is created.
    /// This member is required.
    public var detailType: CodestarnotificationsClientTypes.DetailType?
    /// A list of event types associated with this notification rule. For a list of allowed events, see [EventTypeSummary].
    /// This member is required.
    public var eventTypeIds: [Swift.String]?
    /// The name for the notification rule. Notification rule names must be unique in your Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource to associate with the notification rule. Supported resources include pipelines in CodePipeline, repositories in CodeCommit, and build projects in CodeBuild.
    /// This member is required.
    public var resource: Swift.String?
    /// The status of the notification rule. The default value is ENABLED. If the status is set to DISABLED, notifications aren't sent for the notification rule.
    public var status: CodestarnotificationsClientTypes.NotificationRuleStatus?
    /// A list of tags to apply to this notification rule. Key names cannot start with "aws".
    public var tags: [Swift.String:Swift.String]?
    /// A list of Amazon Resource Names (ARNs) of Amazon Simple Notification Service topics and Chatbot clients to associate with the notification rule.
    /// This member is required.
    public var targets: [CodestarnotificationsClientTypes.Target]?

    public init(
        clientRequestToken: Swift.String? = nil,
        detailType: CodestarnotificationsClientTypes.DetailType? = nil,
        eventTypeIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        resource: Swift.String? = nil,
        status: CodestarnotificationsClientTypes.NotificationRuleStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [CodestarnotificationsClientTypes.Target]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

extension CreateNotificationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> CreateNotificationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNotificationRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

public struct CreateNotificationRuleOutput {
    /// The Amazon Resource Name (ARN) of the notification rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

enum CreateNotificationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "ConfigurationException": return try ConfigurationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteNotificationRuleInput {

    static func urlPathProvider(_ value: DeleteNotificationRuleInput) -> Swift.String? {
        return "/deleteNotificationRule"
    }
}

extension DeleteNotificationRuleInput {

    static func write(value: DeleteNotificationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

public struct DeleteNotificationRuleInput {
    /// The Amazon Resource Name (ARN) of the notification rule you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeleteNotificationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DeleteNotificationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteNotificationRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

public struct DeleteNotificationRuleOutput {
    /// The Amazon Resource Name (ARN) of the deleted notification rule.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

enum DeleteNotificationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteTargetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTargetInput(forceUnsubscribeAll: \(Swift.String(describing: forceUnsubscribeAll)), targetAddress: \"CONTENT_REDACTED\")"}
}

extension DeleteTargetInput {

    static func urlPathProvider(_ value: DeleteTargetInput) -> Swift.String? {
        return "/deleteTarget"
    }
}

extension DeleteTargetInput {

    static func write(value: DeleteTargetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ForceUnsubscribeAll"].write(value.forceUnsubscribeAll)
        try writer["TargetAddress"].write(value.targetAddress)
    }
}

public struct DeleteTargetInput {
    /// A Boolean value that can be used to delete all associations with this Chatbot topic. The default value is FALSE. If set to TRUE, all associations between that target and every notification rule in your Amazon Web Services account are deleted.
    public var forceUnsubscribeAll: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the Chatbot topic or Chatbot client to delete.
    /// This member is required.
    public var targetAddress: Swift.String?

    public init(
        forceUnsubscribeAll: Swift.Bool? = nil,
        targetAddress: Swift.String? = nil
    )
    {
        self.forceUnsubscribeAll = forceUnsubscribeAll
        self.targetAddress = targetAddress
    }
}

extension DeleteTargetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DeleteTargetOutput {
        return DeleteTargetOutput()
    }
}

public struct DeleteTargetOutput {

    public init() { }
}

enum DeleteTargetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeNotificationRuleInput {

    static func urlPathProvider(_ value: DescribeNotificationRuleInput) -> Swift.String? {
        return "/describeNotificationRule"
    }
}

extension DescribeNotificationRuleInput {

    static func write(value: DescribeNotificationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

public struct DescribeNotificationRuleInput {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DescribeNotificationRuleOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNotificationRuleOutput(arn: \(Swift.String(describing: arn)), createdBy: \(Swift.String(describing: createdBy)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), detailType: \(Swift.String(describing: detailType)), eventTypes: \(Swift.String(describing: eventTypes)), lastModifiedTimestamp: \(Swift.String(describing: lastModifiedTimestamp)), resource: \(Swift.String(describing: resource)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)), targets: \(Swift.String(describing: targets)), name: \"CONTENT_REDACTED\")"}
}

extension DescribeNotificationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> DescribeNotificationRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNotificationRuleOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.createdTimestamp = try reader["CreatedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.detailType = try reader["DetailType"].readIfPresent()
        value.eventTypes = try reader["EventTypes"].readListIfPresent(memberReadingClosure: CodestarnotificationsClientTypes.EventTypeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.lastModifiedTimestamp = try reader["LastModifiedTimestamp"].readTimestampIfPresent(format: .epochSeconds)
        value.name = try reader["Name"].readIfPresent()
        value.resource = try reader["Resource"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: CodestarnotificationsClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct DescribeNotificationRuleOutput {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The name or email alias of the person who created the notification rule.
    public var createdBy: Swift.String?
    /// The date and time the notification rule was created, in timestamp format.
    public var createdTimestamp: Foundation.Date?
    /// The level of detail included in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by CodeStar Notifications and/or the service for the resource for which the notification is created.
    public var detailType: CodestarnotificationsClientTypes.DetailType?
    /// A list of the event types associated with the notification rule.
    public var eventTypes: [CodestarnotificationsClientTypes.EventTypeSummary]?
    /// The date and time the notification rule was most recently updated, in timestamp format.
    public var lastModifiedTimestamp: Foundation.Date?
    /// The name of the notification rule.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource associated with the notification rule.
    public var resource: Swift.String?
    /// The status of the notification rule. Valid statuses are on (sending notifications) or off (not sending notifications).
    public var status: CodestarnotificationsClientTypes.NotificationRuleStatus?
    /// The tags associated with the notification rule.
    public var tags: [Swift.String:Swift.String]?
    /// A list of the Chatbot topics and Chatbot clients associated with the notification rule.
    public var targets: [CodestarnotificationsClientTypes.TargetSummary]?

    public init(
        arn: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        createdTimestamp: Foundation.Date? = nil,
        detailType: CodestarnotificationsClientTypes.DetailType? = nil,
        eventTypes: [CodestarnotificationsClientTypes.EventTypeSummary]? = nil,
        lastModifiedTimestamp: Foundation.Date? = nil,
        name: Swift.String? = nil,
        resource: Swift.String? = nil,
        status: CodestarnotificationsClientTypes.NotificationRuleStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targets: [CodestarnotificationsClientTypes.TargetSummary]? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.createdTimestamp = createdTimestamp
        self.detailType = detailType
        self.eventTypes = eventTypes
        self.lastModifiedTimestamp = lastModifiedTimestamp
        self.name = name
        self.resource = resource
        self.status = status
        self.tags = tags
        self.targets = targets
    }
}

enum DescribeNotificationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodestarnotificationsClientTypes {

    public enum DetailType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case full
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailType] {
            return [
                .basic,
                .full
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .full: return "FULL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodestarnotificationsClientTypes.EventTypeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CodestarnotificationsClientTypes.EventTypeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodestarnotificationsClientTypes.EventTypeSummary()
        value.eventTypeId = try reader["EventTypeId"].readIfPresent()
        value.serviceName = try reader["ServiceName"].readIfPresent()
        value.eventTypeName = try reader["EventTypeName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        return value
    }
}

extension CodestarnotificationsClientTypes {
    /// Returns information about an event that has triggered a notification rule.
    public struct EventTypeSummary {
        /// The system-generated ID of the event. For a complete list of event types and IDs, see [Notification concepts](https://docs.aws.amazon.com/codestar-notifications/latest/userguide/concepts.html#concepts-api) in the Developer Tools Console User Guide.
        public var eventTypeId: Swift.String?
        /// The name of the event.
        public var eventTypeName: Swift.String?
        /// The resource type of the event.
        public var resourceType: Swift.String?
        /// The name of the service for which the event applies.
        public var serviceName: Swift.String?

        public init(
            eventTypeId: Swift.String? = nil,
            eventTypeName: Swift.String? = nil,
            resourceType: Swift.String? = nil,
            serviceName: Swift.String? = nil
        )
        {
            self.eventTypeId = eventTypeId
            self.eventTypeName = eventTypeName
            self.resourceType = resourceType
            self.serviceName = serviceName
        }
    }

}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// The value for the enumeration token used in the request to return the next batch of the results is not valid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// One of the CodeStar Notifications limits has been exceeded. Limits apply to accounts, notification rules, notifications, resources, and targets. For more information, see Limits.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CodestarnotificationsClientTypes.ListEventTypesFilter {

    static func write(value: CodestarnotificationsClientTypes.ListEventTypesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about a filter to apply to the list of returned event types. You can filter by resource type or service name.
    public struct ListEventTypesFilter {
        /// The system-generated name of the filter type you want to filter by.
        /// This member is required.
        public var name: CodestarnotificationsClientTypes.ListEventTypesFilterName?
        /// The name of the resource type (for example, pipeline) or service name (for example, CodePipeline) that you want to filter by.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: CodestarnotificationsClientTypes.ListEventTypesFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarnotificationsClientTypes {

    public enum ListEventTypesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case resourceType
        case serviceName
        case sdkUnknown(Swift.String)

        public static var allCases: [ListEventTypesFilterName] {
            return [
                .resourceType,
                .serviceName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resourceType: return "RESOURCE_TYPE"
            case .serviceName: return "SERVICE_NAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListEventTypesInput {

    static func urlPathProvider(_ value: ListEventTypesInput) -> Swift.String? {
        return "/listEventTypes"
    }
}

extension ListEventTypesInput {

    static func write(value: ListEventTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: CodestarnotificationsClientTypes.ListEventTypesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListEventTypesInput {
    /// The filters to use to return information by service or resource type.
    public var filters: [CodestarnotificationsClientTypes.ListEventTypesFilter]?
    /// A non-negative integer used to limit the number of returned results. The default number is 50. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        filters: [CodestarnotificationsClientTypes.ListEventTypesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListEventTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListEventTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEventTypesOutput()
        value.eventTypes = try reader["EventTypes"].readListIfPresent(memberReadingClosure: CodestarnotificationsClientTypes.EventTypeSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListEventTypesOutput {
    /// Information about each event, including service name, resource type, event ID, and event name.
    public var eventTypes: [CodestarnotificationsClientTypes.EventTypeSummary]?
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        eventTypes: [CodestarnotificationsClientTypes.EventTypeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

enum ListEventTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodestarnotificationsClientTypes.ListNotificationRulesFilter {

    static func write(value: CodestarnotificationsClientTypes.ListNotificationRulesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about a filter to apply to the list of returned notification rules. You can filter by event type, owner, resource, or target.
    public struct ListNotificationRulesFilter {
        /// The name of the attribute you want to use to filter the returned notification rules.
        /// This member is required.
        public var name: CodestarnotificationsClientTypes.ListNotificationRulesFilterName?
        /// The value of the attribute you want to use to filter the returned notification rules. For example, if you specify filtering by RESOURCE in Name, you might specify the ARN of a pipeline in CodePipeline for the value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: CodestarnotificationsClientTypes.ListNotificationRulesFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarnotificationsClientTypes {

    public enum ListNotificationRulesFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdBy
        case eventTypeId
        case resource
        case targetAddress
        case sdkUnknown(Swift.String)

        public static var allCases: [ListNotificationRulesFilterName] {
            return [
                .createdBy,
                .eventTypeId,
                .resource,
                .targetAddress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdBy: return "CREATED_BY"
            case .eventTypeId: return "EVENT_TYPE_ID"
            case .resource: return "RESOURCE"
            case .targetAddress: return "TARGET_ADDRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListNotificationRulesInput {

    static func urlPathProvider(_ value: ListNotificationRulesInput) -> Swift.String? {
        return "/listNotificationRules"
    }
}

extension ListNotificationRulesInput {

    static func write(value: ListNotificationRulesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: CodestarnotificationsClientTypes.ListNotificationRulesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListNotificationRulesInput {
    /// The filters to use to return information by service or resource type. For valid values, see [ListNotificationRulesFilter]. A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.
    public var filters: [CodestarnotificationsClientTypes.ListNotificationRulesFilter]?
    /// A non-negative integer used to limit the number of returned results. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        filters: [CodestarnotificationsClientTypes.ListNotificationRulesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListNotificationRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListNotificationRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNotificationRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notificationRules = try reader["NotificationRules"].readListIfPresent(memberReadingClosure: CodestarnotificationsClientTypes.NotificationRuleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListNotificationRulesOutput {
    /// An enumeration token that can be used in a request to return the next batch of the results.
    public var nextToken: Swift.String?
    /// The list of notification rules for the Amazon Web Services account, by Amazon Resource Name (ARN) and ID.
    public var notificationRules: [CodestarnotificationsClientTypes.NotificationRuleSummary]?

    public init(
        nextToken: Swift.String? = nil,
        notificationRules: [CodestarnotificationsClientTypes.NotificationRuleSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.notificationRules = notificationRules
    }
}

enum ListNotificationRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) for the notification rule.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags associated with the notification rule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodestarnotificationsClientTypes.ListTargetsFilter {

    static func write(value: CodestarnotificationsClientTypes.ListTargetsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Value"].write(value.value)
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about a filter to apply to the list of returned targets. You can filter by target type, address, or status. For example, to filter results to notification rules that have active Chatbot topics as targets, you could specify a ListTargetsFilter Name as TargetType and a Value of SNS, and a Name of TARGET_STATUS and a Value of ACTIVE.
    public struct ListTargetsFilter {
        /// The name of the attribute you want to use to filter the returned targets.
        /// This member is required.
        public var name: CodestarnotificationsClientTypes.ListTargetsFilterName?
        /// The value of the attribute you want to use to filter the returned targets. For example, if you specify SNS for the Target type, you could specify an Amazon Resource Name (ARN) for a topic as the value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            name: CodestarnotificationsClientTypes.ListTargetsFilterName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension CodestarnotificationsClientTypes {

    public enum ListTargetsFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case targetAddress
        case targetStatus
        case targetType
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTargetsFilterName] {
            return [
                .targetAddress,
                .targetStatus,
                .targetType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .targetAddress: return "TARGET_ADDRESS"
            case .targetStatus: return "TARGET_STATUS"
            case .targetType: return "TARGET_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ListTargetsInput {

    static func urlPathProvider(_ value: ListTargetsInput) -> Swift.String? {
        return "/listTargets"
    }
}

extension ListTargetsInput {

    static func write(value: ListTargetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filters"].writeList(value.filters, memberWritingClosure: CodestarnotificationsClientTypes.ListTargetsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

public struct ListTargetsInput {
    /// The filters to use to return information by service or resource type. Valid filters include target type, target address, and target status. A filter with the same name can appear more than once when used with OR statements. Filters with different names should be applied with AND statements.
    public var filters: [CodestarnotificationsClientTypes.ListTargetsFilter]?
    /// A non-negative integer used to limit the number of returned results. The maximum number of results that can be returned is 100.
    public var maxResults: Swift.Int?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var nextToken: Swift.String?

    public init(
        filters: [CodestarnotificationsClientTypes.ListTargetsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListTargetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> ListTargetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTargetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: CodestarnotificationsClientTypes.TargetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListTargetsOutput {
    /// An enumeration token that can be used in a request to return the next batch of results.
    public var nextToken: Swift.String?
    /// The list of notification rule targets.
    public var targets: [CodestarnotificationsClientTypes.TargetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        targets: [CodestarnotificationsClientTypes.TargetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

enum ListTargetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodestarnotificationsClientTypes {

    public enum NotificationRuleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationRuleStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodestarnotificationsClientTypes.NotificationRuleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CodestarnotificationsClientTypes.NotificationRuleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodestarnotificationsClientTypes.NotificationRuleSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about a specified notification rule.
    public struct NotificationRuleSummary {
        /// The Amazon Resource Name (ARN) of the notification rule.
        public var arn: Swift.String?
        /// The unique ID of the notification rule.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// A resource with the same name or ID already exists. Notification rule names must be unique in your Amazon Web Services account.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// CodeStar Notifications can't find a resource that matches the provided ARN.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SubscribeInput {

    static func urlPathProvider(_ value: SubscribeInput) -> Swift.String? {
        return "/subscribe"
    }
}

extension SubscribeInput {

    static func write(value: SubscribeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["ClientRequestToken"].write(value.clientRequestToken)
        try writer["Target"].write(value.target, with: CodestarnotificationsClientTypes.Target.write(value:to:))
    }
}

public struct SubscribeInput {
    /// The Amazon Resource Name (ARN) of the notification rule for which you want to create the association.
    /// This member is required.
    public var arn: Swift.String?
    /// An enumeration token that, when provided in a request, returns the next batch of the results.
    public var clientRequestToken: Swift.String?
    /// Information about the Chatbot topics or Chatbot clients associated with a notification rule.
    /// This member is required.
    public var target: CodestarnotificationsClientTypes.Target?

    public init(
        arn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        target: CodestarnotificationsClientTypes.Target? = nil
    )
    {
        self.arn = arn
        self.clientRequestToken = clientRequestToken
        self.target = target
    }
}

extension SubscribeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> SubscribeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SubscribeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

public struct SubscribeOutput {
    /// The Amazon Resource Name (ARN) of the notification rule for which you have created assocations.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

enum SubscribeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConfigurationException": return try ConfigurationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the notification rule to tag.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of tags to associate with the resource. Tag key names cannot start with "aws".
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> TagResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TagResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct TagResourceOutput {
    /// The list of tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CodestarnotificationsClientTypes.Target: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Target(targetType: \(Swift.String(describing: targetType)), targetAddress: \"CONTENT_REDACTED\")"}
}

extension CodestarnotificationsClientTypes.Target {

    static func write(value: CodestarnotificationsClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TargetAddress"].write(value.targetAddress)
        try writer["TargetType"].write(value.targetType)
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about the Chatbot topics or Chatbot clients associated with a notification rule.
    public struct Target {
        /// The Amazon Resource Name (ARN) of the Chatbot topic or Chatbot client.
        public var targetAddress: Swift.String?
        /// The target type. Can be an Chatbot topic or Chatbot client.
        ///
        /// * Chatbot topics are specified as SNS.
        ///
        /// * Chatbot clients are specified as AWSChatbotSlack.
        public var targetType: Swift.String?

        public init(
            targetAddress: Swift.String? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.targetAddress = targetAddress
            self.targetType = targetType
        }
    }

}

extension CodestarnotificationsClientTypes {

    public enum TargetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case deactivated
        case inactive
        case pending
        case unreachable
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetStatus] {
            return [
                .active,
                .deactivated,
                .inactive,
                .pending,
                .unreachable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deactivated: return "DEACTIVATED"
            case .inactive: return "INACTIVE"
            case .pending: return "PENDING"
            case .unreachable: return "UNREACHABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CodestarnotificationsClientTypes.TargetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetSummary(targetStatus: \(Swift.String(describing: targetStatus)), targetType: \(Swift.String(describing: targetType)), targetAddress: \"CONTENT_REDACTED\")"}
}

extension CodestarnotificationsClientTypes.TargetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CodestarnotificationsClientTypes.TargetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CodestarnotificationsClientTypes.TargetSummary()
        value.targetAddress = try reader["TargetAddress"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.targetStatus = try reader["TargetStatus"].readIfPresent()
        return value
    }
}

extension CodestarnotificationsClientTypes {
    /// Information about the targets specified for a notification rule.
    public struct TargetSummary {
        /// The Amazon Resource Name (ARN) of the Chatbot topic or Chatbot client.
        public var targetAddress: Swift.String?
        /// The status of the target.
        public var targetStatus: CodestarnotificationsClientTypes.TargetStatus?
        /// The type of the target (for example, SNS).
        ///
        /// * Chatbot topics are specified as SNS.
        ///
        /// * Chatbot clients are specified as AWSChatbotSlack.
        public var targetType: Swift.String?

        public init(
            targetAddress: Swift.String? = nil,
            targetStatus: CodestarnotificationsClientTypes.TargetStatus? = nil,
            targetType: Swift.String? = nil
        )
        {
            self.targetAddress = targetAddress
            self.targetStatus = targetStatus
            self.targetType = targetType
        }
    }

}

extension UnsubscribeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsubscribeInput(arn: \(Swift.String(describing: arn)), targetAddress: \"CONTENT_REDACTED\")"}
}

extension UnsubscribeInput {

    static func urlPathProvider(_ value: UnsubscribeInput) -> Swift.String? {
        return "/unsubscribe"
    }
}

extension UnsubscribeInput {

    static func write(value: UnsubscribeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["TargetAddress"].write(value.targetAddress)
    }
}

public struct UnsubscribeInput {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The ARN of the Chatbot topic to unsubscribe from the notification rule.
    /// This member is required.
    public var targetAddress: Swift.String?

    public init(
        arn: Swift.String? = nil,
        targetAddress: Swift.String? = nil
    )
    {
        self.arn = arn
        self.targetAddress = targetAddress
    }
}

extension UnsubscribeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UnsubscribeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnsubscribeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

public struct UnsubscribeOutput {
    /// The Amazon Resource Name (ARN) of the the notification rule from which you have removed a subscription.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

enum UnsubscribeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let arn = value.arn else {
            return nil
        }
        return "/untagResource/\(arn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the notification rule from which to remove the tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The key names of the tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConcurrentModificationException": return try ConcurrentModificationException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateNotificationRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateNotificationRuleInput(arn: \(Swift.String(describing: arn)), detailType: \(Swift.String(describing: detailType)), eventTypeIds: \(Swift.String(describing: eventTypeIds)), status: \(Swift.String(describing: status)), targets: \(Swift.String(describing: targets)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateNotificationRuleInput {

    static func urlPathProvider(_ value: UpdateNotificationRuleInput) -> Swift.String? {
        return "/updateNotificationRule"
    }
}

extension UpdateNotificationRuleInput {

    static func write(value: UpdateNotificationRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["DetailType"].write(value.detailType)
        try writer["EventTypeIds"].writeList(value.eventTypeIds, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["Status"].write(value.status)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: CodestarnotificationsClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct UpdateNotificationRuleInput {
    /// The Amazon Resource Name (ARN) of the notification rule.
    /// This member is required.
    public var arn: Swift.String?
    /// The level of detail to include in the notifications for this resource. BASIC will include only the contents of the event as it would appear in Amazon CloudWatch. FULL will include any supplemental information provided by CodeStar Notifications and/or the service for the resource for which the notification is created.
    public var detailType: CodestarnotificationsClientTypes.DetailType?
    /// A list of event types associated with this notification rule. For a complete list of event types and IDs, see [Notification concepts](https://docs.aws.amazon.com/codestar-notifications/latest/userguide/concepts.html#concepts-api) in the Developer Tools Console User Guide.
    public var eventTypeIds: [Swift.String]?
    /// The name of the notification rule.
    public var name: Swift.String?
    /// The status of the notification rule. Valid statuses include enabled (sending notifications) or disabled (not sending notifications).
    public var status: CodestarnotificationsClientTypes.NotificationRuleStatus?
    /// The address and type of the targets to receive notifications from this notification rule.
    public var targets: [CodestarnotificationsClientTypes.Target]?

    public init(
        arn: Swift.String? = nil,
        detailType: CodestarnotificationsClientTypes.DetailType? = nil,
        eventTypeIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        status: CodestarnotificationsClientTypes.NotificationRuleStatus? = nil,
        targets: [CodestarnotificationsClientTypes.Target]? = nil
    )
    {
        self.arn = arn
        self.detailType = detailType
        self.eventTypeIds = eventTypeIds
        self.name = name
        self.status = status
        self.targets = targets
    }
}

extension UpdateNotificationRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> UpdateNotificationRuleOutput {
        return UpdateNotificationRuleOutput()
    }
}

public struct UpdateNotificationRuleOutput {

    public init() { }
}

enum UpdateNotificationRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConfigurationException": return try ConfigurationException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// One or more parameter values are not valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
