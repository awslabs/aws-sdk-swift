// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateCustomDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = self.enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension AssociateCustomDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateCustomDomainInput: Swift.Equatable {
    /// A custom domain endpoint to associate. Specify a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
    /// This member is required.
    public var domainName: Swift.String?
    /// Set to true to associate the subdomain www.DomainName  with the App Runner service in addition to the base domain. Default: true
    public var enableWWWSubdomain: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to associate a custom domain name with.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        enableWWWSubdomain: Swift.Bool? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.enableWWWSubdomain = enableWWWSubdomain
        self.serviceArn = serviceArn
    }
}

struct AssociateCustomDomainInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let domainName: Swift.String?
    let enableWWWSubdomain: Swift.Bool?
}

extension AssociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
    }
}

extension AssociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AssociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dnsTarget = output.dnsTarget
            self.serviceArn = output.serviceArn
            self.vpcDNSTargets = output.vpcDNSTargets
        } else {
            self.customDomain = nil
            self.dnsTarget = nil
            self.serviceArn = nil
            self.vpcDNSTargets = nil
        }
    }
}

public struct AssociateCustomDomainOutputResponse: Swift.Equatable {
    /// A description of the domain name that's being associated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The custom domain name is mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service with which a custom domain name is associated.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dnsTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomain = customDomain
        self.dnsTarget = dnsTarget
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

struct AssociateCustomDomainOutputResponseBody: Swift.Equatable {
    let dnsTarget: Swift.String?
    let serviceArn: Swift.String?
    let customDomain: AppRunnerClientTypes.CustomDomain?
    let vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?
}

extension AssociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dnsTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
        case vpcDNSTargets = "VpcDNSTargets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsTarget)
        dnsTarget = dnsTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let vpcDNSTargetsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.VpcDNSTarget?].self, forKey: .vpcDNSTargets)
        var vpcDNSTargetsDecoded0:[AppRunnerClientTypes.VpcDNSTarget]? = nil
        if let vpcDNSTargetsContainer = vpcDNSTargetsContainer {
            vpcDNSTargetsDecoded0 = [AppRunnerClientTypes.VpcDNSTarget]()
            for structure0 in vpcDNSTargetsContainer {
                if let structure0 = structure0 {
                    vpcDNSTargetsDecoded0?.append(structure0)
                }
            }
        }
        vpcDNSTargets = vpcDNSTargetsDecoded0
    }
}

extension AppRunnerClientTypes.AuthenticationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessRoleArn = "AccessRoleArn"
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRoleArn = self.accessRoleArn {
            try encodeContainer.encode(accessRoleArn, forKey: .accessRoleArn)
        }
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let accessRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessRoleArn)
        accessRoleArn = accessRoleArnDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes resources needed to authenticate access to some source repositories. The specific resource depends on the repository provider.
    public struct AuthenticationConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the IAM role that grants the App Runner service access to a source repository. It's required for ECR image repositories (but not for ECR Public repositories).
        public var accessRoleArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the App Runner connection that enables the App Runner service to connect to a source repository. It's required for GitHub code repositories.
        public var connectionArn: Swift.String?

        public init (
            accessRoleArn: Swift.String? = nil,
            connectionArn: Swift.String? = nil
        )
        {
            self.accessRoleArn = accessRoleArn
            self.connectionArn = connectionArn
        }
    }

}

extension AppRunnerClientTypes.AutoScalingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = self.autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if maxConcurrency != 0 {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if maxSize != 0 {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if minSize != 0 {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoScalingConfigurationRevision) ?? 0
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .latest) ?? false
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency) ?? 0
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize) ?? 0
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize) ?? 0
        maxSize = maxSizeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes an App Runner automatic scaling configuration resource. A higher MinSize increases the spread of your App Runner service over more Availability Zones in the Amazon Web Services Region. The tradeoff is a higher minimal cost. A lower MaxSize controls your cost. The tradeoff is lower responsiveness during peak demand. Multiple revisions of a configuration might have the same AutoScalingConfigurationName and different AutoScalingConfigurationRevision values.
    public struct AutoScalingConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int
        /// The time when the auto scaling configuration was created. It's in Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The time when the auto scaling configuration was deleted. It's in Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same AutoScalingConfigurationName. It's set to false otherwise.
        public var latest: Swift.Bool
        /// The maximum number of concurrent requests that an instance processes. If the number of concurrent requests exceeds this limit, App Runner scales the service up.
        public var maxConcurrency: Swift.Int
        /// The maximum number of instances that a service scales up to. At most MaxSize instances actively serve traffic for your service.
        public var maxSize: Swift.Int
        /// The minimum number of instances that App Runner provisions for a service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code.
        public var minSize: Swift.Int
        /// The current state of the auto scaling configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.AutoScalingConfigurationStatus?

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            latest: Swift.Bool = false,
            maxConcurrency: Swift.Int = 0,
            maxSize: Swift.Int = 0,
            minSize: Swift.Int = 0,
            status: AppRunnerClientTypes.AutoScalingConfigurationStatus? = nil
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.maxConcurrency = maxConcurrency
            self.maxSize = maxSize
            self.minSize = minSize
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum AutoScalingConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoScalingConfigurationStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoScalingConfigurationStatus(rawValue: rawValue) ?? AutoScalingConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.AutoScalingConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case autoScalingConfigurationRevision = "AutoScalingConfigurationRevision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let autoScalingConfigurationName = self.autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if autoScalingConfigurationRevision != 0 {
            try encodeContainer.encode(autoScalingConfigurationRevision, forKey: .autoScalingConfigurationRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let autoScalingConfigurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .autoScalingConfigurationRevision) ?? 0
        autoScalingConfigurationRevision = autoScalingConfigurationRevisionDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information about an App Runner automatic scaling configuration resource. This type contains limited information about an auto scaling configuration. It includes only identification information, without configuration details. It's returned by the [ListAutoScalingConfigurations] action. Complete configuration information is returned by the [CreateAutoScalingConfiguration], [DescribeAutoScalingConfiguration], and [DeleteAutoScalingConfiguration] actions using the [AutoScalingConfiguration] type.
    public struct AutoScalingConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this auto scaling configuration.
        public var autoScalingConfigurationArn: Swift.String?
        /// The customer-provided auto scaling configuration name. It can be used in multiple revisions of a configuration.
        public var autoScalingConfigurationName: Swift.String?
        /// The revision of this auto scaling configuration. It's unique among all the active configurations ("Status": "ACTIVE") with the same AutoScalingConfigurationName.
        public var autoScalingConfigurationRevision: Swift.Int

        public init (
            autoScalingConfigurationArn: Swift.String? = nil,
            autoScalingConfigurationName: Swift.String? = nil,
            autoScalingConfigurationRevision: Swift.Int = 0
        )
        {
            self.autoScalingConfigurationArn = autoScalingConfigurationArn
            self.autoScalingConfigurationName = autoScalingConfigurationName
            self.autoScalingConfigurationRevision = autoScalingConfigurationRevision
        }
    }

}

extension AppRunnerClientTypes.CertificateValidationRecord: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case status = "Status"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CertificateValidationRecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a certificate CNAME record to add to your DNS. For more information, see [AssociateCustomDomain](https://docs.aws.amazon.com/apprunner/latest/api/API_AssociateCustomDomain.html).
    public struct CertificateValidationRecord: Swift.Equatable {
        /// The certificate CNAME record name.
        public var name: Swift.String?
        /// The current state of the certificate CNAME record validation. It should change to SUCCESS after App Runner completes validation with your DNS.
        public var status: AppRunnerClientTypes.CertificateValidationRecordStatus?
        /// The record type, always CNAME.
        public var type: Swift.String?
        /// The certificate CNAME record value.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            status: AppRunnerClientTypes.CertificateValidationRecordStatus? = nil,
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.status = status
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum CertificateValidationRecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pendingValidation
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [CertificateValidationRecordStatus] {
            return [
                .failed,
                .pendingValidation,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pendingValidation: return "PENDING_VALIDATION"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CertificateValidationRecordStatus(rawValue: rawValue) ?? CertificateValidationRecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.CodeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfigurationValues = "CodeConfigurationValues"
        case configurationSource = "ConfigurationSource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfigurationValues = self.codeConfigurationValues {
            try encodeContainer.encode(codeConfigurationValues, forKey: .codeConfigurationValues)
        }
        if let configurationSource = self.configurationSource {
            try encodeContainer.encode(configurationSource.rawValue, forKey: .configurationSource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSourceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConfigurationSource.self, forKey: .configurationSource)
        configurationSource = configurationSourceDecoded
        let codeConfigurationValuesDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfigurationValues.self, forKey: .codeConfigurationValues)
        codeConfigurationValues = codeConfigurationValuesDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the configuration that App Runner uses to build and run an App Runner service from a source code repository.
    public struct CodeConfiguration: Swift.Equatable {
        /// The basic configuration for building and running the App Runner service. Use it to quickly launch an App Runner service without providing a apprunner.yaml file in the source code repository (or ignoring the file if it exists).
        public var codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues?
        /// The source of the App Runner configuration. Values are interpreted as follows:
        ///
        /// * REPOSITORY – App Runner reads configuration values from the apprunner.yaml file in the source code repository and ignores CodeConfigurationValues.
        ///
        /// * API – App Runner uses configuration values provided in CodeConfigurationValues and ignores the apprunner.yaml file in the source code repository.
        /// This member is required.
        public var configurationSource: AppRunnerClientTypes.ConfigurationSource?

        public init (
            codeConfigurationValues: AppRunnerClientTypes.CodeConfigurationValues? = nil,
            configurationSource: AppRunnerClientTypes.ConfigurationSource? = nil
        )
        {
            self.codeConfigurationValues = codeConfigurationValues
            self.configurationSource = configurationSource
        }
    }

}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case buildCommand = "BuildCommand"
        case port = "Port"
        case runtime = "Runtime"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let buildCommand = self.buildCommand {
            try encodeContainer.encode(buildCommand, forKey: .buildCommand)
        }
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtime = self.runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeEnvironmentVariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeEnvironmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = self.startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let buildCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .buildCommand)
        buildCommand = buildCommandDecoded
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
    }
}

extension AppRunnerClientTypes.CodeConfigurationValues: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CodeConfigurationValues(port: \(Swift.String(describing: port)), runtime: \(Swift.String(describing: runtime)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), buildCommand: \"CONTENT_REDACTED\", startCommand: \"CONTENT_REDACTED\")"}
}

extension AppRunnerClientTypes {
    /// Describes the basic configuration needed for building and running an App Runner service. This type doesn't support the full set of possible configuration options. Fur full configuration capabilities, use a apprunner.yaml file in the source code repository.
    public struct CodeConfigurationValues: Swift.Equatable {
        /// The command App Runner runs to build your application.
        public var buildCommand: Swift.String?
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// A runtime environment type for building and running an App Runner service. It represents a programming language runtime.
        /// This member is required.
        public var runtime: AppRunnerClientTypes.Runtime?
        /// The environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public var runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// The command App Runner runs to start your application.
        public var startCommand: Swift.String?

        public init (
            buildCommand: Swift.String? = nil,
            port: Swift.String? = nil,
            runtime: AppRunnerClientTypes.Runtime? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.buildCommand = buildCommand
            self.port = port
            self.runtime = runtime
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.CodeRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case codeConfiguration = "CodeConfiguration"
        case repositoryUrl = "RepositoryUrl"
        case sourceCodeVersion = "SourceCodeVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeConfiguration = self.codeConfiguration {
            try encodeContainer.encode(codeConfiguration, forKey: .codeConfiguration)
        }
        if let repositoryUrl = self.repositoryUrl {
            try encodeContainer.encode(repositoryUrl, forKey: .repositoryUrl)
        }
        if let sourceCodeVersion = self.sourceCodeVersion {
            try encodeContainer.encode(sourceCodeVersion, forKey: .sourceCodeVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUrl)
        repositoryUrl = repositoryUrlDecoded
        let sourceCodeVersionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersion.self, forKey: .sourceCodeVersion)
        sourceCodeVersion = sourceCodeVersionDecoded
        let codeConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeConfiguration.self, forKey: .codeConfiguration)
        codeConfiguration = codeConfigurationDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a source code repository.
    public struct CodeRepository: Swift.Equatable {
        /// Configuration for building and running the service from a source code repository. CodeConfiguration is required only for CreateService request.
        public var codeConfiguration: AppRunnerClientTypes.CodeConfiguration?
        /// The location of the repository that contains the source code.
        /// This member is required.
        public var repositoryUrl: Swift.String?
        /// The version that should be used within the source code repository.
        /// This member is required.
        public var sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion?

        public init (
            codeConfiguration: AppRunnerClientTypes.CodeConfiguration? = nil,
            repositoryUrl: Swift.String? = nil,
            sourceCodeVersion: AppRunnerClientTypes.SourceCodeVersion? = nil
        )
        {
            self.codeConfiguration = codeConfiguration
            self.repositoryUrl = repositoryUrl
            self.sourceCodeVersion = sourceCodeVersion
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConfigurationSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case repository
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSource] {
            return [
                .api,
                .repository,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .repository: return "REPOSITORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSource(rawValue: rawValue) ?? ConfigurationSource.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Connection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let providerType = self.providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes an App Runner connection resource.
    public struct Connection: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: ClientRuntime.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case error
        case pendingHandshake
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .available,
                .deleted,
                .error,
                .pendingHandshake,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .pendingHandshake: return "PENDING_HANDSHAKE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ConnectionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionName = "ConnectionName"
        case createdAt = "CreatedAt"
        case providerType = "ProviderType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let providerType = self.providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information about an App Runner connection resource.
    public struct ConnectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this connection.
        public var connectionArn: Swift.String?
        /// The customer-provided connection name.
        public var connectionName: Swift.String?
        /// The App Runner connection creation time, expressed as a Unix time stamp.
        public var createdAt: ClientRuntime.Date?
        /// The source repository provider.
        public var providerType: AppRunnerClientTypes.ProviderType?
        /// The current state of the App Runner connection. When the state is AVAILABLE, you can use the connection to create an App Runner service.
        public var status: AppRunnerClientTypes.ConnectionStatus?

        public init (
            connectionArn: Swift.String? = nil,
            connectionName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            providerType: AppRunnerClientTypes.ProviderType? = nil,
            status: AppRunnerClientTypes.ConnectionStatus? = nil
        )
        {
            self.connectionArn = connectionArn
            self.connectionName = connectionName
            self.createdAt = createdAt
            self.providerType = providerType
            self.status = status
        }
    }

}

extension CreateAutoScalingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = self.autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if let maxConcurrency = self.maxConcurrency {
            try encodeContainer.encode(maxConcurrency, forKey: .maxConcurrency)
        }
        if let maxSize = self.maxSize {
            try encodeContainer.encode(maxSize, forKey: .maxSize)
        }
        if let minSize = self.minSize {
            try encodeContainer.encode(minSize, forKey: .minSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAutoScalingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAutoScalingConfigurationInput: Swift.Equatable {
    /// A name for the auto scaling configuration. When you use it for the first time in an Amazon Web Services Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. The name DefaultConfiguration is reserved (it's the configuration that App Runner uses if you don't provide a custome one). You can't use it to create a new auto scaling configuration, and you can't create a revision of it. When you want to use your own auto scaling configuration for your App Runner service, create a configuration with a different name, and then provide it when you create or update your service.
    /// This member is required.
    public var autoScalingConfigurationName: Swift.String?
    /// The maximum number of concurrent requests that you want an instance to process. If the number of concurrent requests exceeds this limit, App Runner scales up your service. Default: 100
    public var maxConcurrency: Swift.Int?
    /// The maximum number of instances that your service scales up to. At most MaxSize instances actively serve traffic for your service. Default: 25
    public var maxSize: Swift.Int?
    /// The minimum number of instances that App Runner provisions for your service. The service always has at least MinSize provisioned instances. Some of them actively serve traffic. The rest of them (provisioned and inactive instances) are a cost-effective compute capacity reserve and are ready to be quickly activated. You pay for memory usage of all the provisioned instances. You pay for CPU usage of only the active subset. App Runner temporarily doubles the number of provisioned instances during deployments, to maintain the same capacity for both old and new code. Default: 1
    public var minSize: Swift.Int?
    /// A list of metadata items that you can associate with your auto scaling configuration resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        maxConcurrency: Swift.Int? = nil,
        maxSize: Swift.Int? = nil,
        minSize: Swift.Int? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.maxConcurrency = maxConcurrency
        self.maxSize = maxSize
        self.minSize = minSize
        self.tags = tags
    }
}

struct CreateAutoScalingConfigurationInputBody: Swift.Equatable {
    let autoScalingConfigurationName: Swift.String?
    let maxConcurrency: Swift.Int?
    let minSize: Swift.Int?
    let maxSize: Swift.Int?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case maxConcurrency = "MaxConcurrency"
        case maxSize = "MaxSize"
        case minSize = "MinSize"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let maxConcurrencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrency)
        maxConcurrency = maxConcurrencyDecoded
        let minSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minSize)
        minSize = minSizeDecoded
        let maxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSize)
        maxSize = maxSizeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct CreateAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner auto scaling configuration that's created by this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct CreateAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension CreateAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

extension CreateConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let providerType = self.providerType {
            try encodeContainer.encode(providerType.rawValue, forKey: .providerType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConnectionInput: Swift.Equatable {
    /// A name for the new connection. It must be unique across all App Runner connections for the Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var connectionName: Swift.String?
    /// The source repository provider.
    /// This member is required.
    public var providerType: AppRunnerClientTypes.ProviderType?
    /// A list of metadata items that you can associate with your connection resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        connectionName: Swift.String? = nil,
        providerType: AppRunnerClientTypes.ProviderType? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.connectionName = connectionName
        self.providerType = providerType
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Swift.Equatable {
    let connectionName: Swift.String?
    let providerType: AppRunnerClientTypes.ProviderType?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case providerType = "ProviderType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let providerTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ProviderType.self, forKey: .providerType)
        providerType = providerTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner connection that's created by this request.
    /// This member is required.
    public var connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Swift.Equatable {
    let connection: AppRunnerClientTypes.Connection?
}

extension CreateConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension CreateObservabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationName = "ObservabilityConfigurationName"
        case tags = "Tags"
        case traceConfiguration = "TraceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observabilityConfigurationName = self.observabilityConfigurationName {
            try encodeContainer.encode(observabilityConfigurationName, forKey: .observabilityConfigurationName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let traceConfiguration = self.traceConfiguration {
            try encodeContainer.encode(traceConfiguration, forKey: .traceConfiguration)
        }
    }
}

extension CreateObservabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateObservabilityConfigurationInput: Swift.Equatable {
    /// A name for the observability configuration. When you use it for the first time in an Amazon Web Services Region, App Runner creates revision number 1 of this name. When you use the same name in subsequent calls, App Runner creates incremental revisions of the configuration. The name DefaultConfiguration is reserved. You can't use it to create a new observability configuration, and you can't create a revision of it. When you want to use your own observability configuration for your App Runner service, create a configuration with a different name, and then provide it when you create or update your service.
    /// This member is required.
    public var observabilityConfigurationName: Swift.String?
    /// A list of metadata items that you can associate with your observability configuration resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// The configuration of the tracing feature within this observability configuration. If you don't specify it, App Runner doesn't enable tracing.
    public var traceConfiguration: AppRunnerClientTypes.TraceConfiguration?

    public init (
        observabilityConfigurationName: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        traceConfiguration: AppRunnerClientTypes.TraceConfiguration? = nil
    )
    {
        self.observabilityConfigurationName = observabilityConfigurationName
        self.tags = tags
        self.traceConfiguration = traceConfiguration
    }
}

struct CreateObservabilityConfigurationInputBody: Swift.Equatable {
    let observabilityConfigurationName: Swift.String?
    let traceConfiguration: AppRunnerClientTypes.TraceConfiguration?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateObservabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationName = "ObservabilityConfigurationName"
        case tags = "Tags"
        case traceConfiguration = "TraceConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationName)
        observabilityConfigurationName = observabilityConfigurationNameDecoded
        let traceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.TraceConfiguration.self, forKey: .traceConfiguration)
        traceConfiguration = traceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateObservabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateObservabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateObservabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateObservabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateObservabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.observabilityConfiguration = output.observabilityConfiguration
        } else {
            self.observabilityConfiguration = nil
        }
    }
}

public struct CreateObservabilityConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner observability configuration that's created by this request.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init (
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

struct CreateObservabilityConfigurationOutputResponseBody: Swift.Equatable {
    let observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?
}

extension CreateObservabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfiguration = "ObservabilityConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension CreateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case networkConfiguration = "NetworkConfiguration"
        case observabilityConfiguration = "ObservabilityConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = self.healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let observabilityConfiguration = self.observabilityConfiguration {
            try encodeContainer.encode(observabilityConfiguration, forKey: .observabilityConfiguration)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with your service. If not provided, App Runner associates the latest revision of a default auto scaling configuration. Specify an ARN with a name and a revision number to associate that revision. For example: arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability/3 Specify just the name to associate the latest revision. For example: arn:aws:apprunner:us-east-1:123456789012:autoscalingconfiguration/high-availability
    public var autoScalingConfigurationArn: Swift.String?
    /// An optional custom encryption key that App Runner uses to encrypt the copy of your source repository that it maintains and your service logs. By default, App Runner uses an Amazon Web Services managed key.
    public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    /// The settings for the health check that App Runner performs to monitor the health of the App Runner service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration of instances (scaling units) of your service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// Configuration settings related to network traffic of the web application that the App Runner service runs.
    public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    /// The observability configuration of your service.
    public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
    /// A name for the App Runner service. It must be unique across all the running App Runner services in your Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var serviceName: Swift.String?
    /// The source to deploy to the App Runner service. It can be a code or an image repository.
    /// This member is required.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    /// An optional list of metadata items that you can associate with the App Runner service resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
        observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
        serviceName: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.encryptionConfiguration = encryptionConfiguration
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.networkConfiguration = networkConfiguration
        self.observabilityConfiguration = observabilityConfiguration
        self.serviceName = serviceName
        self.sourceConfiguration = sourceConfiguration
        self.tags = tags
    }
}

struct CreateServiceInputBody: Swift.Equatable {
    let serviceName: Swift.String?
    let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    let tags: [AppRunnerClientTypes.Tag]?
    let encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
    let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    let autoScalingConfigurationArn: Swift.String?
    let networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    let observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
}

extension CreateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case networkConfiguration = "NetworkConfiguration"
        case observabilityConfiguration = "ObservabilityConfiguration"
        case serviceName = "ServiceName"
        case sourceConfiguration = "SourceConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension CreateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct CreateServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations](https://docs.aws.amazon.com/apprunner/latest/api/API_ListOperations.html) call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that's created by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct CreateServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
    let operationId: Swift.String?
}

extension CreateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension CreateVpcConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
        case tags = "Tags"
        case vpcConnectorName = "VpcConnectorName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for string0 in securityGroups {
                try securityGroupsContainer.encode(string0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcConnectorName = self.vpcConnectorName {
            try encodeContainer.encode(vpcConnectorName, forKey: .vpcConnectorName)
        }
    }
}

extension CreateVpcConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVpcConnectorInput: Swift.Equatable {
    /// A list of IDs of security groups that App Runner should use for access to Amazon Web Services resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.
    public var securityGroups: [Swift.String]?
    /// A list of IDs of subnets that App Runner should use when it associates your service with a custom Amazon VPC. Specify IDs of subnets of a single Amazon VPC. App Runner determines the Amazon VPC from the subnets you specify. App Runner currently only provides support for IPv4.
    /// This member is required.
    public var subnets: [Swift.String]?
    /// A list of metadata items that you can associate with your VPC connector resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// A name for the VPC connector.
    /// This member is required.
    public var vpcConnectorName: Swift.String?

    public init (
        securityGroups: [Swift.String]? = nil,
        subnets: [Swift.String]? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        vpcConnectorName: Swift.String? = nil
    )
    {
        self.securityGroups = securityGroups
        self.subnets = subnets
        self.tags = tags
        self.vpcConnectorName = vpcConnectorName
    }
}

struct CreateVpcConnectorInputBody: Swift.Equatable {
    let vpcConnectorName: Swift.String?
    let subnets: [Swift.String]?
    let securityGroups: [Swift.String]?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateVpcConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
        case tags = "Tags"
        case vpcConnectorName = "VpcConnectorName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorName)
        vpcConnectorName = vpcConnectorNameDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVpcConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVpcConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcConnector = output.vpcConnector
        } else {
            self.vpcConnector = nil
        }
    }
}

public struct CreateVpcConnectorOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC connector that's created by this request.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init (
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

struct CreateVpcConnectorOutputResponseBody: Swift.Equatable {
    let vpcConnector: AppRunnerClientTypes.VpcConnector?
}

extension CreateVpcConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnector = "VpcConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcConnector.self, forKey: .vpcConnector)
        vpcConnector = vpcConnectorDecoded
    }
}

extension CreateVpcIngressConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingressVpcConfiguration = "IngressVpcConfiguration"
        case serviceArn = "ServiceArn"
        case tags = "Tags"
        case vpcIngressConnectionName = "VpcIngressConnectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingressVpcConfiguration = self.ingressVpcConfiguration {
            try encodeContainer.encode(ingressVpcConfiguration, forKey: .ingressVpcConfiguration)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcIngressConnectionName = self.vpcIngressConnectionName {
            try encodeContainer.encode(vpcIngressConnectionName, forKey: .vpcIngressConnectionName)
        }
    }
}

extension CreateVpcIngressConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateVpcIngressConnectionInput: Swift.Equatable {
    /// Specifications for the customer’s Amazon VPC and the related Amazon Web Services PrivateLink VPC endpoint that are used to create the VPC Ingress Connection resource.
    /// This member is required.
    public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
    /// The Amazon Resource Name (ARN) for this App Runner service that is used to create the VPC Ingress Connection resource.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// An optional list of metadata items that you can associate with the VPC Ingress Connection resource. A tag is a key-value pair.
    public var tags: [AppRunnerClientTypes.Tag]?
    /// A name for the VPC Ingress Connection resource. It must be unique across all the active VPC Ingress Connections in your Amazon Web Services account in the Amazon Web Services Region.
    /// This member is required.
    public var vpcIngressConnectionName: Swift.String?

    public init (
        ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil,
        vpcIngressConnectionName: Swift.String? = nil
    )
    {
        self.ingressVpcConfiguration = ingressVpcConfiguration
        self.serviceArn = serviceArn
        self.tags = tags
        self.vpcIngressConnectionName = vpcIngressConnectionName
    }
}

struct CreateVpcIngressConnectionInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let vpcIngressConnectionName: Swift.String?
    let ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension CreateVpcIngressConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingressVpcConfiguration = "IngressVpcConfiguration"
        case serviceArn = "ServiceArn"
        case tags = "Tags"
        case vpcIngressConnectionName = "VpcIngressConnectionName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let vpcIngressConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionName)
        vpcIngressConnectionName = vpcIngressConnectionNameDecoded
        let ingressVpcConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.IngressVpcConfiguration.self, forKey: .ingressVpcConfiguration)
        ingressVpcConfiguration = ingressVpcConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateVpcIngressConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVpcIngressConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceeded" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVpcIngressConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVpcIngressConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVpcIngressConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcIngressConnection = output.vpcIngressConnection
        } else {
            self.vpcIngressConnection = nil
        }
    }
}

public struct CreateVpcIngressConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC Ingress Connection resource that's created by this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init (
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

struct CreateVpcIngressConnectionOutputResponseBody: Swift.Equatable {
    let vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?
}

extension CreateVpcIngressConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnection = "VpcIngressConnection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcIngressConnection.self, forKey: .vpcIngressConnection)
        vpcIngressConnection = vpcIngressConnectionDecoded
    }
}

extension AppRunnerClientTypes.CustomDomain: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateValidationRecords = "CertificateValidationRecords"
        case domainName = "DomainName"
        case enableWWWSubdomain = "EnableWWWSubdomain"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateValidationRecords = certificateValidationRecords {
            var certificateValidationRecordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateValidationRecords)
            for certificatevalidationrecord0 in certificateValidationRecords {
                try certificateValidationRecordsContainer.encode(certificatevalidationrecord0)
            }
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let enableWWWSubdomain = self.enableWWWSubdomain {
            try encodeContainer.encode(enableWWWSubdomain, forKey: .enableWWWSubdomain)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let enableWWWSubdomainDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableWWWSubdomain)
        enableWWWSubdomain = enableWWWSubdomainDecoded
        let certificateValidationRecordsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CertificateValidationRecord?].self, forKey: .certificateValidationRecords)
        var certificateValidationRecordsDecoded0:[AppRunnerClientTypes.CertificateValidationRecord]? = nil
        if let certificateValidationRecordsContainer = certificateValidationRecordsContainer {
            certificateValidationRecordsDecoded0 = [AppRunnerClientTypes.CertificateValidationRecord]()
            for structure0 in certificateValidationRecordsContainer {
                if let structure0 = structure0 {
                    certificateValidationRecordsDecoded0?.append(structure0)
                }
            }
        }
        certificateValidationRecords = certificateValidationRecordsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomainAssociationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a custom domain that's associated with an App Runner service.
    public struct CustomDomain: Swift.Equatable {
        /// A list of certificate CNAME records that's used for this domain name.
        public var certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]?
        /// An associated custom domain endpoint. It can be a root domain (for example, example.com), a subdomain (for example, login.example.com or admin.login.example.com), or a wildcard (for example, *.example.com).
        /// This member is required.
        public var domainName: Swift.String?
        /// When true, the subdomain www.DomainName  is associated with the App Runner service in addition to the base domain.
        /// This member is required.
        public var enableWWWSubdomain: Swift.Bool?
        /// The current state of the domain name association.
        /// This member is required.
        public var status: AppRunnerClientTypes.CustomDomainAssociationStatus?

        public init (
            certificateValidationRecords: [AppRunnerClientTypes.CertificateValidationRecord]? = nil,
            domainName: Swift.String? = nil,
            enableWWWSubdomain: Swift.Bool? = nil,
            status: AppRunnerClientTypes.CustomDomainAssociationStatus? = nil
        )
        {
            self.certificateValidationRecords = certificateValidationRecords
            self.domainName = domainName
            self.enableWWWSubdomain = enableWWWSubdomain
            self.status = status
        }
    }

}

extension AppRunnerClientTypes {
    public enum CustomDomainAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case bindingCertificate
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case pendingCertificateDnsValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [CustomDomainAssociationStatus] {
            return [
                .active,
                .bindingCertificate,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .pendingCertificateDnsValidation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .bindingCertificate: return "BINDING_CERTIFICATE"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .pendingCertificateDnsValidation: return "PENDING_CERTIFICATE_DNS_VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CustomDomainAssociationStatus(rawValue: rawValue) ?? CustomDomainAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteAutoScalingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

extension DeleteAutoScalingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAutoScalingConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want to delete. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DeleteAutoScalingConfigurationInputBody: Swift.Equatable {
    let autoScalingConfigurationArn: Swift.String?
}

extension DeleteAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DeleteAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DeleteAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner auto scaling configuration that this request just deleted.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DeleteAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DeleteAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

extension DeleteConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = self.connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
    }
}

extension DeleteConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner connection that you want to delete.
    /// This member is required.
    public var connectionArn: Swift.String?

    public init (
        connectionArn: Swift.String? = nil
    )
    {
        self.connectionArn = connectionArn
    }
}

struct DeleteConnectionInputBody: Swift.Equatable {
    let connectionArn: Swift.String?
}

extension DeleteConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionArn = "ConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
    }
}

extension DeleteConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner connection that this request just deleted.
    public var connection: AppRunnerClientTypes.Connection?

    public init (
        connection: AppRunnerClientTypes.Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Swift.Equatable {
    let connection: AppRunnerClientTypes.Connection?
}

extension DeleteConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteObservabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observabilityConfigurationArn = self.observabilityConfigurationArn {
            try encodeContainer.encode(observabilityConfigurationArn, forKey: .observabilityConfigurationArn)
        }
    }
}

extension DeleteObservabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteObservabilityConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner observability configuration that you want to delete. The ARN can be a full observability configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is deleted.
    /// This member is required.
    public var observabilityConfigurationArn: Swift.String?

    public init (
        observabilityConfigurationArn: Swift.String? = nil
    )
    {
        self.observabilityConfigurationArn = observabilityConfigurationArn
    }
}

struct DeleteObservabilityConfigurationInputBody: Swift.Equatable {
    let observabilityConfigurationArn: Swift.String?
}

extension DeleteObservabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationArn)
        observabilityConfigurationArn = observabilityConfigurationArnDecoded
    }
}

extension DeleteObservabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteObservabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteObservabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteObservabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteObservabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.observabilityConfiguration = output.observabilityConfiguration
        } else {
            self.observabilityConfiguration = nil
        }
    }
}

public struct DeleteObservabilityConfigurationOutputResponse: Swift.Equatable {
    /// A description of the App Runner observability configuration that this request just deleted.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init (
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

struct DeleteObservabilityConfigurationOutputResponseBody: Swift.Equatable {
    let observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?
}

extension DeleteObservabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfiguration = "ObservabilityConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension DeleteServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension DeleteServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to delete.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DeleteServiceInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
}

extension DeleteServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DeleteServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct DeleteServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just deleted.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct DeleteServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
    let operationId: Swift.String?
}

extension DeleteServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension DeleteVpcConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectorArn = "VpcConnectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectorArn = self.vpcConnectorArn {
            try encodeContainer.encode(vpcConnectorArn, forKey: .vpcConnectorArn)
        }
    }
}

extension DeleteVpcConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVpcConnectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to delete. The ARN must be a full VPC connector ARN.
    /// This member is required.
    public var vpcConnectorArn: Swift.String?

    public init (
        vpcConnectorArn: Swift.String? = nil
    )
    {
        self.vpcConnectorArn = vpcConnectorArn
    }
}

struct DeleteVpcConnectorInputBody: Swift.Equatable {
    let vpcConnectorArn: Swift.String?
}

extension DeleteVpcConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectorArn = "VpcConnectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorArn)
        vpcConnectorArn = vpcConnectorArnDecoded
    }
}

extension DeleteVpcConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVpcConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVpcConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcConnector = output.vpcConnector
        } else {
            self.vpcConnector = nil
        }
    }
}

public struct DeleteVpcConnectorOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC connector that this request just deleted.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init (
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

struct DeleteVpcConnectorOutputResponseBody: Swift.Equatable {
    let vpcConnector: AppRunnerClientTypes.VpcConnector?
}

extension DeleteVpcConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnector = "VpcConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcConnector.self, forKey: .vpcConnector)
        vpcConnector = vpcConnectorDecoded
    }
}

extension DeleteVpcIngressConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
    }
}

extension DeleteVpcIngressConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteVpcIngressConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC Ingress Connection that you want to delete.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init (
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

struct DeleteVpcIngressConnectionInputBody: Swift.Equatable {
    let vpcIngressConnectionArn: Swift.String?
}

extension DeleteVpcIngressConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
    }
}

extension DeleteVpcIngressConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVpcIngressConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVpcIngressConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVpcIngressConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVpcIngressConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcIngressConnection = output.vpcIngressConnection
        } else {
            self.vpcIngressConnection = nil
        }
    }
}

public struct DeleteVpcIngressConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC Ingress Connection that this request just deleted.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init (
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

struct DeleteVpcIngressConnectionOutputResponseBody: Swift.Equatable {
    let vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?
}

extension DeleteVpcIngressConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnection = "VpcIngressConnection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcIngressConnection.self, forKey: .vpcIngressConnection)
        vpcIngressConnection = vpcIngressConnectionDecoded
    }
}

extension DescribeAutoScalingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
    }
}

extension DescribeAutoScalingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAutoScalingConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner auto scaling configuration that you want a description for. The ARN can be a full auto scaling configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
    /// This member is required.
    public var autoScalingConfigurationArn: Swift.String?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
    }
}

struct DescribeAutoScalingConfigurationInputBody: Swift.Equatable {
    let autoScalingConfigurationArn: Swift.String?
}

extension DescribeAutoScalingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
    }
}

extension DescribeAutoScalingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAutoScalingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAutoScalingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAutoScalingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAutoScalingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfiguration = output.autoScalingConfiguration
        } else {
            self.autoScalingConfiguration = nil
        }
    }
}

public struct DescribeAutoScalingConfigurationOutputResponse: Swift.Equatable {
    /// A full description of the App Runner auto scaling configuration that you specified in this request.
    /// This member is required.
    public var autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?

    public init (
        autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration? = nil
    )
    {
        self.autoScalingConfiguration = autoScalingConfiguration
    }
}

struct DescribeAutoScalingConfigurationOutputResponseBody: Swift.Equatable {
    let autoScalingConfiguration: AppRunnerClientTypes.AutoScalingConfiguration?
}

extension DescribeAutoScalingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfiguration = "AutoScalingConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfiguration.self, forKey: .autoScalingConfiguration)
        autoScalingConfiguration = autoScalingConfigurationDecoded
    }
}

extension DescribeCustomDomainsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension DescribeCustomDomainsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeCustomDomainsInput: Swift.Equatable {
    /// The maximum number of results that each response (result page) can include. It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want associated custom domain names to be described for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct DescribeCustomDomainsInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeCustomDomainsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeCustomDomainsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCustomDomainsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeCustomDomainsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCustomDomainsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeCustomDomainsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomains = output.customDomains
            self.dnsTarget = output.dnsTarget
            self.nextToken = output.nextToken
            self.serviceArn = output.serviceArn
            self.vpcDNSTargets = output.vpcDNSTargets
        } else {
            self.customDomains = nil
            self.dnsTarget = nil
            self.nextToken = nil
            self.serviceArn = nil
            self.vpcDNSTargets = nil
        }
    }
}

public struct DescribeCustomDomainsOutputResponse: Swift.Equatable {
    /// A list of descriptions of custom domain names that are associated with the service. In a paginated request, the request returns up to MaxResults records per call.
    /// This member is required.
    public var customDomains: [AppRunnerClientTypes.CustomDomain]?
    /// The App Runner subdomain of the App Runner service. The associated custom domain names are mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service whose associated custom domain names you want to describe.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init (
        customDomains: [AppRunnerClientTypes.CustomDomain]? = nil,
        dnsTarget: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomains = customDomains
        self.dnsTarget = dnsTarget
        self.nextToken = nextToken
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

struct DescribeCustomDomainsOutputResponseBody: Swift.Equatable {
    let dnsTarget: Swift.String?
    let serviceArn: Swift.String?
    let customDomains: [AppRunnerClientTypes.CustomDomain]?
    let vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?
    let nextToken: Swift.String?
}

extension DescribeCustomDomainsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomains = "CustomDomains"
        case dnsTarget = "DNSTarget"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
        case vpcDNSTargets = "VpcDNSTargets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsTarget)
        dnsTarget = dnsTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.CustomDomain?].self, forKey: .customDomains)
        var customDomainsDecoded0:[AppRunnerClientTypes.CustomDomain]? = nil
        if let customDomainsContainer = customDomainsContainer {
            customDomainsDecoded0 = [AppRunnerClientTypes.CustomDomain]()
            for structure0 in customDomainsContainer {
                if let structure0 = structure0 {
                    customDomainsDecoded0?.append(structure0)
                }
            }
        }
        customDomains = customDomainsDecoded0
        let vpcDNSTargetsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.VpcDNSTarget?].self, forKey: .vpcDNSTargets)
        var vpcDNSTargetsDecoded0:[AppRunnerClientTypes.VpcDNSTarget]? = nil
        if let vpcDNSTargetsContainer = vpcDNSTargetsContainer {
            vpcDNSTargetsDecoded0 = [AppRunnerClientTypes.VpcDNSTarget]()
            for structure0 in vpcDNSTargetsContainer {
                if let structure0 = structure0 {
                    vpcDNSTargetsDecoded0?.append(structure0)
                }
            }
        }
        vpcDNSTargets = vpcDNSTargetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeObservabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observabilityConfigurationArn = self.observabilityConfigurationArn {
            try encodeContainer.encode(observabilityConfigurationArn, forKey: .observabilityConfigurationArn)
        }
    }
}

extension DescribeObservabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeObservabilityConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner observability configuration that you want a description for. The ARN can be a full observability configuration ARN, or a partial ARN ending with either .../name  or .../name/revision . If a revision isn't specified, the latest active revision is described.
    /// This member is required.
    public var observabilityConfigurationArn: Swift.String?

    public init (
        observabilityConfigurationArn: Swift.String? = nil
    )
    {
        self.observabilityConfigurationArn = observabilityConfigurationArn
    }
}

struct DescribeObservabilityConfigurationInputBody: Swift.Equatable {
    let observabilityConfigurationArn: Swift.String?
}

extension DescribeObservabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationArn)
        observabilityConfigurationArn = observabilityConfigurationArnDecoded
    }
}

extension DescribeObservabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObservabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeObservabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObservabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeObservabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.observabilityConfiguration = output.observabilityConfiguration
        } else {
            self.observabilityConfiguration = nil
        }
    }
}

public struct DescribeObservabilityConfigurationOutputResponse: Swift.Equatable {
    /// A full description of the App Runner observability configuration that you specified in this request.
    /// This member is required.
    public var observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?

    public init (
        observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration? = nil
    )
    {
        self.observabilityConfiguration = observabilityConfiguration
    }
}

struct DescribeObservabilityConfigurationOutputResponseBody: Swift.Equatable {
    let observabilityConfiguration: AppRunnerClientTypes.ObservabilityConfiguration?
}

extension DescribeObservabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfiguration = "ObservabilityConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension DescribeServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension DescribeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a description for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct DescribeServiceInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
}

extension DescribeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension DescribeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.service = output.service
        } else {
            self.service = nil
        }
    }
}

public struct DescribeServiceOutputResponse: Swift.Equatable {
    /// A full description of the App Runner service that you specified in this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.service = service
    }
}

struct DescribeServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
}

extension DescribeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
    }
}

extension DescribeVpcConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectorArn = "VpcConnectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcConnectorArn = self.vpcConnectorArn {
            try encodeContainer.encode(vpcConnectorArn, forKey: .vpcConnectorArn)
        }
    }
}

extension DescribeVpcConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVpcConnectorInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want a description for. The ARN must be a full VPC connector ARN.
    /// This member is required.
    public var vpcConnectorArn: Swift.String?

    public init (
        vpcConnectorArn: Swift.String? = nil
    )
    {
        self.vpcConnectorArn = vpcConnectorArn
    }
}

struct DescribeVpcConnectorInputBody: Swift.Equatable {
    let vpcConnectorArn: Swift.String?
}

extension DescribeVpcConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnectorArn = "VpcConnectorArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorArn)
        vpcConnectorArn = vpcConnectorArnDecoded
    }
}

extension DescribeVpcConnectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVpcConnectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVpcConnectorOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVpcConnectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVpcConnectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcConnector = output.vpcConnector
        } else {
            self.vpcConnector = nil
        }
    }
}

public struct DescribeVpcConnectorOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC connector that you specified in this request.
    /// This member is required.
    public var vpcConnector: AppRunnerClientTypes.VpcConnector?

    public init (
        vpcConnector: AppRunnerClientTypes.VpcConnector? = nil
    )
    {
        self.vpcConnector = vpcConnector
    }
}

struct DescribeVpcConnectorOutputResponseBody: Swift.Equatable {
    let vpcConnector: AppRunnerClientTypes.VpcConnector?
}

extension DescribeVpcConnectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcConnector = "VpcConnector"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcConnector.self, forKey: .vpcConnector)
        vpcConnector = vpcConnectorDecoded
    }
}

extension DescribeVpcIngressConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
    }
}

extension DescribeVpcIngressConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeVpcIngressConnectionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner VPC Ingress Connection that you want a description for.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init (
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

struct DescribeVpcIngressConnectionInputBody: Swift.Equatable {
    let vpcIngressConnectionArn: Swift.String?
}

extension DescribeVpcIngressConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
    }
}

extension DescribeVpcIngressConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVpcIngressConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVpcIngressConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVpcIngressConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVpcIngressConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcIngressConnection = output.vpcIngressConnection
        } else {
            self.vpcIngressConnection = nil
        }
    }
}

public struct DescribeVpcIngressConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC Ingress Connection that you specified in this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init (
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

struct DescribeVpcIngressConnectionOutputResponseBody: Swift.Equatable {
    let vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?
}

extension DescribeVpcIngressConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnection = "VpcIngressConnection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcIngressConnection.self, forKey: .vpcIngressConnection)
        vpcIngressConnection = vpcIngressConnectionDecoded
    }
}

extension DisassociateCustomDomainInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension DisassociateCustomDomainInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateCustomDomainInput: Swift.Equatable {
    /// The domain name that you want to disassociate from the App Runner service.
    /// This member is required.
    public var domainName: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to disassociate a custom domain name from.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        domainName: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.domainName = domainName
        self.serviceArn = serviceArn
    }
}

struct DisassociateCustomDomainInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let domainName: Swift.String?
}

extension DisassociateCustomDomainInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension DisassociateCustomDomainOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomDomainOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateCustomDomainOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomDomainOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateCustomDomainOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.customDomain = output.customDomain
            self.dnsTarget = output.dnsTarget
            self.serviceArn = output.serviceArn
            self.vpcDNSTargets = output.vpcDNSTargets
        } else {
            self.customDomain = nil
            self.dnsTarget = nil
            self.serviceArn = nil
            self.vpcDNSTargets = nil
        }
    }
}

public struct DisassociateCustomDomainOutputResponse: Swift.Equatable {
    /// A description of the domain name that's being disassociated.
    /// This member is required.
    public var customDomain: AppRunnerClientTypes.CustomDomain?
    /// The App Runner subdomain of the App Runner service. The disassociated custom domain name was mapped to this target name.
    /// This member is required.
    public var dnsTarget: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that a custom domain name is disassociated from.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// DNS Target records for the custom domains of this Amazon VPC.
    /// This member is required.
    public var vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?

    public init (
        customDomain: AppRunnerClientTypes.CustomDomain? = nil,
        dnsTarget: Swift.String? = nil,
        serviceArn: Swift.String? = nil,
        vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]? = nil
    )
    {
        self.customDomain = customDomain
        self.dnsTarget = dnsTarget
        self.serviceArn = serviceArn
        self.vpcDNSTargets = vpcDNSTargets
    }
}

struct DisassociateCustomDomainOutputResponseBody: Swift.Equatable {
    let dnsTarget: Swift.String?
    let serviceArn: Swift.String?
    let customDomain: AppRunnerClientTypes.CustomDomain?
    let vpcDNSTargets: [AppRunnerClientTypes.VpcDNSTarget]?
}

extension DisassociateCustomDomainOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customDomain = "CustomDomain"
        case dnsTarget = "DNSTarget"
        case serviceArn = "ServiceArn"
        case vpcDNSTargets = "VpcDNSTargets"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dnsTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dnsTarget)
        dnsTarget = dnsTargetDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CustomDomain.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let vpcDNSTargetsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.VpcDNSTarget?].self, forKey: .vpcDNSTargets)
        var vpcDNSTargetsDecoded0:[AppRunnerClientTypes.VpcDNSTarget]? = nil
        if let vpcDNSTargetsContainer = vpcDNSTargetsContainer {
            vpcDNSTargetsDecoded0 = [AppRunnerClientTypes.VpcDNSTarget]()
            for structure0 in vpcDNSTargetsContainer {
                if let structure0 = structure0 {
                    vpcDNSTargetsDecoded0?.append(structure0)
                }
            }
        }
        vpcDNSTargets = vpcDNSTargetsDecoded0
    }
}

extension AppRunnerClientTypes.EgressConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressType = "EgressType"
        case vpcConnectorArn = "VpcConnectorArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressType = self.egressType {
            try encodeContainer.encode(egressType.rawValue, forKey: .egressType)
        }
        if let vpcConnectorArn = self.vpcConnectorArn {
            try encodeContainer.encode(vpcConnectorArn, forKey: .vpcConnectorArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EgressType.self, forKey: .egressType)
        egressType = egressTypeDecoded
        let vpcConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorArn)
        vpcConnectorArn = vpcConnectorArnDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes configuration settings related to outbound network traffic of an App Runner service.
    public struct EgressConfiguration: Swift.Equatable {
        /// The type of egress configuration. Set to DEFAULT for access to resources hosted on public networks. Set to VPC to associate your service to a custom VPC specified by VpcConnectorArn.
        public var egressType: AppRunnerClientTypes.EgressType?
        /// The Amazon Resource Name (ARN) of the App Runner VPC connector that you want to associate with your App Runner service. Only valid when EgressType = VPC.
        public var vpcConnectorArn: Swift.String?

        public init (
            egressType: AppRunnerClientTypes.EgressType? = nil,
            vpcConnectorArn: Swift.String? = nil
        )
        {
            self.egressType = egressType
            self.vpcConnectorArn = vpcConnectorArn
        }
    }

}

extension AppRunnerClientTypes {
    public enum EgressType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case vpc
        case sdkUnknown(Swift.String)

        public static var allCases: [EgressType] {
            return [
                .default,
                .vpc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .vpc: return "VPC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EgressType(rawValue: rawValue) ?? EgressType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a custom encryption key that App Runner uses to encrypt copies of the source repository and service logs.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The ARN of the KMS key that's used for encryption.
        /// This member is required.
        public var kmsKey: Swift.String?

        public init (
            kmsKey: Swift.String? = nil
        )
        {
            self.kmsKey = kmsKey
        }
    }

}

extension AppRunnerClientTypes.HealthCheckConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthyThreshold = "HealthyThreshold"
        case interval = "Interval"
        case path = "Path"
        case `protocol` = "Protocol"
        case timeout = "Timeout"
        case unhealthyThreshold = "UnhealthyThreshold"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthyThreshold = self.healthyThreshold {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let unhealthyThreshold = self.unhealthyThreshold {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let healthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the settings for the health check that App Runner performs to monitor the health of a service.
    public struct HealthCheckConfiguration: Swift.Equatable {
        /// The number of consecutive checks that must succeed before App Runner decides that the service is healthy. Default: 1
        public var healthyThreshold: Swift.Int?
        /// The time interval, in seconds, between health checks. Default: 5
        public var interval: Swift.Int?
        /// The URL that health check requests are sent to. Path is only applicable when you set Protocol to HTTP. Default: "/"
        public var path: Swift.String?
        /// The IP protocol that App Runner uses to perform health checks for your service. If you set Protocol to HTTP, App Runner sends health check requests to the HTTP path specified by Path. Default: TCP
        public var `protocol`: AppRunnerClientTypes.HealthCheckProtocol?
        /// The time, in seconds, to wait for a health check response before deciding it failed. Default: 2
        public var timeout: Swift.Int?
        /// The number of consecutive checks that must fail before App Runner decides that the service is unhealthy. Default: 5
        public var unhealthyThreshold: Swift.Int?

        public init (
            healthyThreshold: Swift.Int? = nil,
            interval: Swift.Int? = nil,
            path: Swift.String? = nil,
            `protocol`: AppRunnerClientTypes.HealthCheckProtocol? = nil,
            timeout: Swift.Int? = nil,
            unhealthyThreshold: Swift.Int? = nil
        )
        {
            self.healthyThreshold = healthyThreshold
            self.interval = interval
            self.path = path
            self.`protocol` = `protocol`
            self.timeout = timeout
            self.unhealthyThreshold = unhealthyThreshold
        }
    }

}

extension AppRunnerClientTypes {
    public enum HealthCheckProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case http
        case tcp
        case sdkUnknown(Swift.String)

        public static var allCases: [HealthCheckProtocol] {
            return [
                .http,
                .tcp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .http: return "HTTP"
            case .tcp: return "TCP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HealthCheckProtocol(rawValue: rawValue) ?? HealthCheckProtocol.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "Port"
        case runtimeEnvironmentVariables = "RuntimeEnvironmentVariables"
        case startCommand = "StartCommand"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let port = self.port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let runtimeEnvironmentVariables = runtimeEnvironmentVariables {
            var runtimeEnvironmentVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .runtimeEnvironmentVariables)
            for (dictKey0, runtimeEnvironmentVariables0) in runtimeEnvironmentVariables {
                try runtimeEnvironmentVariablesContainer.encode(runtimeEnvironmentVariables0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let startCommand = self.startCommand {
            try encodeContainer.encode(startCommand, forKey: .startCommand)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeEnvironmentVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .runtimeEnvironmentVariables)
        var runtimeEnvironmentVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let runtimeEnvironmentVariablesContainer = runtimeEnvironmentVariablesContainer {
            runtimeEnvironmentVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, runtimeenvironmentvariablesvalue0) in runtimeEnvironmentVariablesContainer {
                if let runtimeenvironmentvariablesvalue0 = runtimeenvironmentvariablesvalue0 {
                    runtimeEnvironmentVariablesDecoded0?[key0] = runtimeenvironmentvariablesvalue0
                }
            }
        }
        runtimeEnvironmentVariables = runtimeEnvironmentVariablesDecoded0
        let startCommandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startCommand)
        startCommand = startCommandDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .port)
        port = portDecoded
    }
}

extension AppRunnerClientTypes.ImageConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageConfiguration(port: \(Swift.String(describing: port)), runtimeEnvironmentVariables: \(Swift.String(describing: runtimeEnvironmentVariables)), startCommand: \"CONTENT_REDACTED\")"}
}

extension AppRunnerClientTypes {
    /// Describes the configuration that App Runner uses to run an App Runner service using an image pulled from a source image repository.
    public struct ImageConfiguration: Swift.Equatable {
        /// The port that your application listens to in the container. Default: 8080
        public var port: Swift.String?
        /// Environment variables that are available to your running App Runner service. An array of key-value pairs. Keys with a prefix of AWSAPPRUNNER are reserved for system use and aren't valid.
        public var runtimeEnvironmentVariables: [Swift.String:Swift.String]?
        /// An optional command that App Runner runs to start the application in the source image. If specified, this command overrides the Docker image’s default start command.
        public var startCommand: Swift.String?

        public init (
            port: Swift.String? = nil,
            runtimeEnvironmentVariables: [Swift.String:Swift.String]? = nil,
            startCommand: Swift.String? = nil
        )
        {
            self.port = port
            self.runtimeEnvironmentVariables = runtimeEnvironmentVariables
            self.startCommand = startCommand
        }
    }

}

extension AppRunnerClientTypes.ImageRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageConfiguration = "ImageConfiguration"
        case imageIdentifier = "ImageIdentifier"
        case imageRepositoryType = "ImageRepositoryType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageConfiguration = self.imageConfiguration {
            try encodeContainer.encode(imageConfiguration, forKey: .imageConfiguration)
        }
        if let imageIdentifier = self.imageIdentifier {
            try encodeContainer.encode(imageIdentifier, forKey: .imageIdentifier)
        }
        if let imageRepositoryType = self.imageRepositoryType {
            try encodeContainer.encode(imageRepositoryType.rawValue, forKey: .imageRepositoryType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageIdentifier)
        imageIdentifier = imageIdentifierDecoded
        let imageConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageConfiguration.self, forKey: .imageConfiguration)
        imageConfiguration = imageConfigurationDecoded
        let imageRepositoryTypeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepositoryType.self, forKey: .imageRepositoryType)
        imageRepositoryType = imageRepositoryTypeDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a source image repository.
    public struct ImageRepository: Swift.Equatable {
        /// Configuration for running the identified image.
        public var imageConfiguration: AppRunnerClientTypes.ImageConfiguration?
        /// The identifier of an image. For an image in Amazon Elastic Container Registry (Amazon ECR), this is an image name. For the image name format, see [Pulling an image](https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-pull-ecr-image.html) in the Amazon ECR User Guide.
        /// This member is required.
        public var imageIdentifier: Swift.String?
        /// The type of the image repository. This reflects the repository provider and whether the repository is private or public.
        /// This member is required.
        public var imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType?

        public init (
            imageConfiguration: AppRunnerClientTypes.ImageConfiguration? = nil,
            imageIdentifier: Swift.String? = nil,
            imageRepositoryType: AppRunnerClientTypes.ImageRepositoryType? = nil
        )
        {
            self.imageConfiguration = imageConfiguration
            self.imageIdentifier = imageIdentifier
            self.imageRepositoryType = imageRepositoryType
        }
    }

}

extension AppRunnerClientTypes {
    public enum ImageRepositoryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case ecrPublic
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageRepositoryType] {
            return [
                .ecr,
                .ecrPublic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case .ecrPublic: return "ECR_PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageRepositoryType(rawValue: rawValue) ?? ImageRepositoryType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.IngressConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPubliclyAccessible = "IsPubliclyAccessible"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isPubliclyAccessible != false {
            try encodeContainer.encode(isPubliclyAccessible, forKey: .isPubliclyAccessible)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isPubliclyAccessibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPubliclyAccessible) ?? false
        isPubliclyAccessible = isPubliclyAccessibleDecoded
    }
}

extension AppRunnerClientTypes {
    /// Network configuration settings for inbound network traffic.
    public struct IngressConfiguration: Swift.Equatable {
        /// Specifies whether your App Runner service is publicly accessible. To make the service publicly accessible set it to True. To make the service privately accessible, from only within an Amazon VPC set it to False.
        public var isPubliclyAccessible: Swift.Bool

        public init (
            isPubliclyAccessible: Swift.Bool = false
        )
        {
            self.isPubliclyAccessible = isPubliclyAccessible
        }
    }

}

extension AppRunnerClientTypes.IngressVpcConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

extension AppRunnerClientTypes {
    /// The configuration of your VPC and the associated VPC endpoint. The VPC endpoint is an Amazon Web Services PrivateLink resource that allows access to your App Runner services from within an Amazon VPC.
    public struct IngressVpcConfiguration: Swift.Equatable {
        /// The ID of the VPC endpoint that your App Runner service connects to.
        public var vpcEndpointId: Swift.String?
        /// The ID of the VPC that is used for the VPC endpoint.
        public var vpcId: Swift.String?

        public init (
            vpcEndpointId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.vpcEndpointId = vpcEndpointId
            self.vpcId = vpcId
        }
    }

}

extension AppRunnerClientTypes.InstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpu = "Cpu"
        case instanceRoleArn = "InstanceRoleArn"
        case memory = "Memory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpu = self.cpu {
            try encodeContainer.encode(cpu, forKey: .cpu)
        }
        if let instanceRoleArn = self.instanceRoleArn {
            try encodeContainer.encode(instanceRoleArn, forKey: .instanceRoleArn)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cpuDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpu)
        cpu = cpuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memory)
        memory = memoryDecoded
        let instanceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceRoleArn)
        instanceRoleArn = instanceRoleArnDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the runtime configuration of an App Runner service instance (scaling unit).
    public struct InstanceConfiguration: Swift.Equatable {
        /// The number of CPU units reserved for each instance of your App Runner service. Default: 1 vCPU
        public var cpu: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that provides permissions to your App Runner service. These are permissions that your code needs when it calls any Amazon Web Services APIs.
        public var instanceRoleArn: Swift.String?
        /// The amount of memory, in MB or GB, reserved for each instance of your App Runner service. Default: 2 GB
        public var memory: Swift.String?

        public init (
            cpu: Swift.String? = nil,
            instanceRoleArn: Swift.String? = nil,
            memory: Swift.String? = nil
        )
        {
            self.cpu = cpu
            self.instanceRoleArn = instanceRoleArn
            self.memory = memory
        }
    }

}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected service exception occurred.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more input parameters aren't valid. Refer to the API action's document page, correct the input parameters, and try the action again.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform this action when the resource is in its current state.
public struct InvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAutoScalingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationName = self.autoScalingConfigurationName {
            try encodeContainer.encode(autoScalingConfigurationName, forKey: .autoScalingConfigurationName)
        }
        if latestOnly != false {
            try encodeContainer.encode(latestOnly, forKey: .latestOnly)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAutoScalingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAutoScalingConfigurationsInput: Swift.Equatable {
    /// The name of the App Runner auto scaling configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all active configurations.
    public var autoScalingConfigurationName: Swift.String?
    /// Set to true to list only the latest revision for each requested configuration name. Set to false to list all revisions for each requested configuration name. Default: true
    public var latestOnly: Swift.Bool
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        autoScalingConfigurationName: Swift.String? = nil,
        latestOnly: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationName = autoScalingConfigurationName
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsInputBody: Swift.Equatable {
    let autoScalingConfigurationName: Swift.String?
    let latestOnly: Swift.Bool
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationName = "AutoScalingConfigurationName"
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationName)
        autoScalingConfigurationName = autoScalingConfigurationNameDecoded
        let latestOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .latestOnly) ?? false
        latestOnly = latestOnlyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAutoScalingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAutoScalingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAutoScalingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAutoScalingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAutoScalingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoScalingConfigurationSummaryList = output.autoScalingConfigurationSummaryList
            self.nextToken = output.nextToken
        } else {
            self.autoScalingConfigurationSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAutoScalingConfigurationsOutputResponse: Swift.Equatable {
    /// A list of summary information records for auto scaling configurations. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?

    public init (
        autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryList
        self.nextToken = nextToken
    }
}

struct ListAutoScalingConfigurationsOutputResponseBody: Swift.Equatable {
    let autoScalingConfigurationSummaryList: [AppRunnerClientTypes.AutoScalingConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListAutoScalingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummaryList = "AutoScalingConfigurationSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoScalingConfigurationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.AutoScalingConfigurationSummary?].self, forKey: .autoScalingConfigurationSummaryList)
        var autoScalingConfigurationSummaryListDecoded0:[AppRunnerClientTypes.AutoScalingConfigurationSummary]? = nil
        if let autoScalingConfigurationSummaryListContainer = autoScalingConfigurationSummaryListContainer {
            autoScalingConfigurationSummaryListDecoded0 = [AppRunnerClientTypes.AutoScalingConfigurationSummary]()
            for structure0 in autoScalingConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    autoScalingConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        autoScalingConfigurationSummaryList = autoScalingConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionName = self.connectionName {
            try encodeContainer.encode(connectionName, forKey: .connectionName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConnectionsInput: Swift.Equatable {
    /// If specified, only this connection is returned. If not specified, the result isn't filtered by name.
    public var connectionName: Swift.String?
    /// The maximum number of results to include in each response (result page). Used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        connectionName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionName = connectionName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Swift.Equatable {
    let connectionName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionName = "ConnectionName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionName)
        connectionName = connectionNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionSummaryList = output.connectionSummaryList
            self.nextToken = output.nextToken
        } else {
            self.connectionSummaryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Swift.Equatable {
    /// A list of summary information records for connections. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    /// The token that you can pass in a subsequent request to get the next result page. Returned in a paginated request.
    public var nextToken: Swift.String?

    public init (
        connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectionSummaryList = connectionSummaryList
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Swift.Equatable {
    let connectionSummaryList: [AppRunnerClientTypes.ConnectionSummary]?
    let nextToken: Swift.String?
}

extension ListConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionSummaryList = "ConnectionSummaryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ConnectionSummary?].self, forKey: .connectionSummaryList)
        var connectionSummaryListDecoded0:[AppRunnerClientTypes.ConnectionSummary]? = nil
        if let connectionSummaryListContainer = connectionSummaryListContainer {
            connectionSummaryListDecoded0 = [AppRunnerClientTypes.ConnectionSummary]()
            for structure0 in connectionSummaryListContainer {
                if let structure0 = structure0 {
                    connectionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        connectionSummaryList = connectionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListObservabilityConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case observabilityConfigurationName = "ObservabilityConfigurationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if latestOnly != false {
            try encodeContainer.encode(latestOnly, forKey: .latestOnly)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let observabilityConfigurationName = self.observabilityConfigurationName {
            try encodeContainer.encode(observabilityConfigurationName, forKey: .observabilityConfigurationName)
        }
    }
}

extension ListObservabilityConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListObservabilityConfigurationsInput: Swift.Equatable {
    /// Set to true to list only the latest revision for each requested configuration name. Set to false to list all revisions for each requested configuration name. Default: true
    public var latestOnly: Swift.Bool
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The name of the App Runner observability configuration that you want to list. If specified, App Runner lists revisions that share this name. If not specified, App Runner returns revisions of all active configurations.
    public var observabilityConfigurationName: Swift.String?

    public init (
        latestOnly: Swift.Bool = false,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        observabilityConfigurationName: Swift.String? = nil
    )
    {
        self.latestOnly = latestOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.observabilityConfigurationName = observabilityConfigurationName
    }
}

struct ListObservabilityConfigurationsInputBody: Swift.Equatable {
    let observabilityConfigurationName: Swift.String?
    let latestOnly: Swift.Bool
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListObservabilityConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestOnly = "LatestOnly"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case observabilityConfigurationName = "ObservabilityConfigurationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationName)
        observabilityConfigurationName = observabilityConfigurationNameDecoded
        let latestOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .latestOnly) ?? false
        latestOnly = latestOnlyDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListObservabilityConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListObservabilityConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListObservabilityConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListObservabilityConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListObservabilityConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.observabilityConfigurationSummaryList = output.observabilityConfigurationSummaryList
        } else {
            self.nextToken = nil
            self.observabilityConfigurationSummaryList = nil
        }
    }
}

public struct ListObservabilityConfigurationsOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of summary information records for observability configurations. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var observabilityConfigurationSummaryList: [AppRunnerClientTypes.ObservabilityConfigurationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        observabilityConfigurationSummaryList: [AppRunnerClientTypes.ObservabilityConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.observabilityConfigurationSummaryList = observabilityConfigurationSummaryList
    }
}

struct ListObservabilityConfigurationsOutputResponseBody: Swift.Equatable {
    let observabilityConfigurationSummaryList: [AppRunnerClientTypes.ObservabilityConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListObservabilityConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case observabilityConfigurationSummaryList = "ObservabilityConfigurationSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ObservabilityConfigurationSummary?].self, forKey: .observabilityConfigurationSummaryList)
        var observabilityConfigurationSummaryListDecoded0:[AppRunnerClientTypes.ObservabilityConfigurationSummary]? = nil
        if let observabilityConfigurationSummaryListContainer = observabilityConfigurationSummaryListContainer {
            observabilityConfigurationSummaryListDecoded0 = [AppRunnerClientTypes.ObservabilityConfigurationSummary]()
            for structure0 in observabilityConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    observabilityConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        observabilityConfigurationSummaryList = observabilityConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOperationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension ListOperationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListOperationsInput: Swift.Equatable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want a list of operations for.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serviceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceArn = serviceArn
    }
}

struct ListOperationsInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListOperationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOperationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOperationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOperationsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOperationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOperationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.operationSummaryList = output.operationSummaryList
        } else {
            self.nextToken = nil
            self.operationSummaryList = nil
        }
    }
}

public struct ListOperationsOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of operation summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    public var operationSummaryList: [AppRunnerClientTypes.OperationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        operationSummaryList: [AppRunnerClientTypes.OperationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.operationSummaryList = operationSummaryList
    }
}

struct ListOperationsOutputResponseBody: Swift.Equatable {
    let operationSummaryList: [AppRunnerClientTypes.OperationSummary]?
    let nextToken: Swift.String?
}

extension ListOperationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case operationSummaryList = "OperationSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.OperationSummary?].self, forKey: .operationSummaryList)
        var operationSummaryListDecoded0:[AppRunnerClientTypes.OperationSummary]? = nil
        if let operationSummaryListContainer = operationSummaryListContainer {
            operationSummaryListDecoded0 = [AppRunnerClientTypes.OperationSummary]()
            for structure0 in operationSummaryListContainer {
                if let structure0 = structure0 {
                    operationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        operationSummaryList = operationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListServicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListServicesInput: Swift.Equatable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. Used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListServicesOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListServicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serviceSummaryList = output.serviceSummaryList
        } else {
            self.nextToken = nil
            self.serviceSummaryList = nil
        }
    }
}

public struct ListServicesOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of service summary information records. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?

    public init (
        nextToken: Swift.String? = nil,
        serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceSummaryList = serviceSummaryList
    }
}

struct ListServicesOutputResponseBody: Swift.Equatable {
    let serviceSummaryList: [AppRunnerClientTypes.ServiceSummary]?
    let nextToken: Swift.String?
}

extension ListServicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serviceSummaryList = "ServiceSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.ServiceSummary?].self, forKey: .serviceSummaryList)
        var serviceSummaryListDecoded0:[AppRunnerClientTypes.ServiceSummary]? = nil
        if let serviceSummaryListContainer = serviceSummaryListContainer {
            serviceSummaryListDecoded0 = [AppRunnerClientTypes.ServiceSummary]()
            for structure0 in serviceSummaryListContainer {
                if let structure0 = structure0 {
                    serviceSummaryListDecoded0?.append(structure0)
                }
            }
        }
        serviceSummaryList = serviceSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that a tag list is requested for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of the tag key-value pairs that are associated with the resource.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [AppRunnerClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVpcConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListVpcConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVpcConnectorsInput: Swift.Equatable {
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVpcConnectorsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVpcConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVpcConnectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVpcConnectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVpcConnectorsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVpcConnectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVpcConnectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpcConnectors = output.vpcConnectors
        } else {
            self.nextToken = nil
            self.vpcConnectors = nil
        }
    }
}

public struct ListVpcConnectorsOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of information records for VPC connectors. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var vpcConnectors: [AppRunnerClientTypes.VpcConnector]?

    public init (
        nextToken: Swift.String? = nil,
        vpcConnectors: [AppRunnerClientTypes.VpcConnector]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcConnectors = vpcConnectors
    }
}

struct ListVpcConnectorsOutputResponseBody: Swift.Equatable {
    let vpcConnectors: [AppRunnerClientTypes.VpcConnector]?
    let nextToken: Swift.String?
}

extension ListVpcConnectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vpcConnectors = "VpcConnectors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.VpcConnector?].self, forKey: .vpcConnectors)
        var vpcConnectorsDecoded0:[AppRunnerClientTypes.VpcConnector]? = nil
        if let vpcConnectorsContainer = vpcConnectorsContainer {
            vpcConnectorsDecoded0 = [AppRunnerClientTypes.VpcConnector]()
            for structure0 in vpcConnectorsContainer {
                if let structure0 = structure0 {
                    vpcConnectorsDecoded0?.append(structure0)
                }
            }
        }
        vpcConnectors = vpcConnectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppRunnerClientTypes.ListVpcIngressConnectionsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
        case vpcEndpointId = "VpcEndpointId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let vpcEndpointId = self.vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
    }
}

extension AppRunnerClientTypes {
    /// Returns a list of VPC Ingress Connections based on the filter provided. It can return either ServiceArn or VpcEndpointId, or both.
    public struct ListVpcIngressConnectionsFilter: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a service to filter by.
        public var serviceArn: Swift.String?
        /// The ID of a VPC Endpoint to filter by.
        public var vpcEndpointId: Swift.String?

        public init (
            serviceArn: Swift.String? = nil,
            vpcEndpointId: Swift.String? = nil
        )
        {
            self.serviceArn = serviceArn
            self.vpcEndpointId = vpcEndpointId
        }
    }

}

extension ListVpcIngressConnectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListVpcIngressConnectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListVpcIngressConnectionsInput: Swift.Equatable {
    /// The VPC Ingress Connections to be listed based on either the Service Arn or Vpc Endpoint Id, or both.
    public var filter: AppRunnerClientTypes.ListVpcIngressConnectionsFilter?
    /// The maximum number of results to include in each response (result page). It's used for a paginated request. If you don't specify MaxResults, the request retrieves all available results in a single response.
    public var maxResults: Swift.Int?
    /// A token from a previous result page. It's used for a paginated request. The request retrieves the next result page. All other parameter values must be identical to the ones that are specified in the initial request. If you don't specify NextToken, the request retrieves the first result page.
    public var nextToken: Swift.String?

    public init (
        filter: AppRunnerClientTypes.ListVpcIngressConnectionsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVpcIngressConnectionsInputBody: Swift.Equatable {
    let filter: AppRunnerClientTypes.ListVpcIngressConnectionsFilter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListVpcIngressConnectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ListVpcIngressConnectionsFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVpcIngressConnectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVpcIngressConnectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVpcIngressConnectionsOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVpcIngressConnectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVpcIngressConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.vpcIngressConnectionSummaryList = output.vpcIngressConnectionSummaryList
        } else {
            self.nextToken = nil
            self.vpcIngressConnectionSummaryList = nil
        }
    }
}

public struct ListVpcIngressConnectionsOutputResponse: Swift.Equatable {
    /// The token that you can pass in a subsequent request to get the next result page. It's returned in a paginated request.
    public var nextToken: Swift.String?
    /// A list of summary information records for VPC Ingress Connections. In a paginated request, the request returns up to MaxResults records for each call.
    /// This member is required.
    public var vpcIngressConnectionSummaryList: [AppRunnerClientTypes.VpcIngressConnectionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        vpcIngressConnectionSummaryList: [AppRunnerClientTypes.VpcIngressConnectionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpcIngressConnectionSummaryList = vpcIngressConnectionSummaryList
    }
}

struct ListVpcIngressConnectionsOutputResponseBody: Swift.Equatable {
    let vpcIngressConnectionSummaryList: [AppRunnerClientTypes.VpcIngressConnectionSummary]?
    let nextToken: Swift.String?
}

extension ListVpcIngressConnectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case vpcIngressConnectionSummaryList = "VpcIngressConnectionSummaryList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionSummaryListContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.VpcIngressConnectionSummary?].self, forKey: .vpcIngressConnectionSummaryList)
        var vpcIngressConnectionSummaryListDecoded0:[AppRunnerClientTypes.VpcIngressConnectionSummary]? = nil
        if let vpcIngressConnectionSummaryListContainer = vpcIngressConnectionSummaryListContainer {
            vpcIngressConnectionSummaryListDecoded0 = [AppRunnerClientTypes.VpcIngressConnectionSummary]()
            for structure0 in vpcIngressConnectionSummaryListContainer {
                if let structure0 = structure0 {
                    vpcIngressConnectionSummaryListDecoded0?.append(structure0)
                }
            }
        }
        vpcIngressConnectionSummaryList = vpcIngressConnectionSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppRunnerClientTypes.NetworkConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case egressConfiguration = "EgressConfiguration"
        case ingressConfiguration = "IngressConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressConfiguration = self.egressConfiguration {
            try encodeContainer.encode(egressConfiguration, forKey: .egressConfiguration)
        }
        if let ingressConfiguration = self.ingressConfiguration {
            try encodeContainer.encode(ingressConfiguration, forKey: .ingressConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EgressConfiguration.self, forKey: .egressConfiguration)
        egressConfiguration = egressConfigurationDecoded
        let ingressConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.IngressConfiguration.self, forKey: .ingressConfiguration)
        ingressConfiguration = ingressConfigurationDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes configuration settings related to network traffic of an App Runner service. Consists of embedded objects for each configurable network feature.
    public struct NetworkConfiguration: Swift.Equatable {
        /// Network configuration settings for outbound message traffic.
        public var egressConfiguration: AppRunnerClientTypes.EgressConfiguration?
        /// Network configuration settings for inbound message traffic.
        public var ingressConfiguration: AppRunnerClientTypes.IngressConfiguration?

        public init (
            egressConfiguration: AppRunnerClientTypes.EgressConfiguration? = nil,
            ingressConfiguration: AppRunnerClientTypes.IngressConfiguration? = nil
        )
        {
            self.egressConfiguration = egressConfiguration
            self.ingressConfiguration = ingressConfiguration
        }
    }

}

extension AppRunnerClientTypes.ObservabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case latest = "Latest"
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
        case observabilityConfigurationName = "ObservabilityConfigurationName"
        case observabilityConfigurationRevision = "ObservabilityConfigurationRevision"
        case status = "Status"
        case traceConfiguration = "TraceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if latest != false {
            try encodeContainer.encode(latest, forKey: .latest)
        }
        if let observabilityConfigurationArn = self.observabilityConfigurationArn {
            try encodeContainer.encode(observabilityConfigurationArn, forKey: .observabilityConfigurationArn)
        }
        if let observabilityConfigurationName = self.observabilityConfigurationName {
            try encodeContainer.encode(observabilityConfigurationName, forKey: .observabilityConfigurationName)
        }
        if observabilityConfigurationRevision != 0 {
            try encodeContainer.encode(observabilityConfigurationRevision, forKey: .observabilityConfigurationRevision)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let traceConfiguration = self.traceConfiguration {
            try encodeContainer.encode(traceConfiguration, forKey: .traceConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationArn)
        observabilityConfigurationArn = observabilityConfigurationArnDecoded
        let observabilityConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationName)
        observabilityConfigurationName = observabilityConfigurationNameDecoded
        let traceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.TraceConfiguration.self, forKey: .traceConfiguration)
        traceConfiguration = traceConfigurationDecoded
        let observabilityConfigurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .observabilityConfigurationRevision) ?? 0
        observabilityConfigurationRevision = observabilityConfigurationRevisionDecoded
        let latestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .latest) ?? false
        latest = latestDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ObservabilityConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes an App Runner observability configuration resource. Multiple revisions of a configuration have the same ObservabilityConfigurationName and different ObservabilityConfigurationRevision values. The resource is designed to configure multiple features (currently one feature, tracing). This type contains optional members that describe the configuration of these features (currently one member, TraceConfiguration). If a feature member isn't specified, the feature isn't enabled.
    public struct ObservabilityConfiguration: Swift.Equatable {
        /// The time when the observability configuration was created. It's in Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The time when the observability configuration was deleted. It's in Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// It's set to true for the configuration with the highest Revision among all configurations that share the same ObservabilityConfigurationName. It's set to false otherwise.
        public var latest: Swift.Bool
        /// The Amazon Resource Name (ARN) of this observability configuration.
        public var observabilityConfigurationArn: Swift.String?
        /// The customer-provided observability configuration name. It can be used in multiple revisions of a configuration.
        public var observabilityConfigurationName: Swift.String?
        /// The revision of this observability configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same ObservabilityConfigurationName.
        public var observabilityConfigurationRevision: Swift.Int
        /// The current state of the observability configuration. If the status of a configuration revision is INACTIVE, it was deleted and can't be used. Inactive configuration revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.ObservabilityConfigurationStatus?
        /// The configuration of the tracing feature within this observability configuration. If not specified, tracing isn't enabled.
        public var traceConfiguration: AppRunnerClientTypes.TraceConfiguration?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            latest: Swift.Bool = false,
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityConfigurationName: Swift.String? = nil,
            observabilityConfigurationRevision: Swift.Int = 0,
            status: AppRunnerClientTypes.ObservabilityConfigurationStatus? = nil,
            traceConfiguration: AppRunnerClientTypes.TraceConfiguration? = nil
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.latest = latest
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityConfigurationName = observabilityConfigurationName
            self.observabilityConfigurationRevision = observabilityConfigurationRevision
            self.status = status
            self.traceConfiguration = traceConfiguration
        }
    }

}

extension AppRunnerClientTypes {
    public enum ObservabilityConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ObservabilityConfigurationStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ObservabilityConfigurationStatus(rawValue: rawValue) ?? ObservabilityConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ObservabilityConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
        case observabilityConfigurationName = "ObservabilityConfigurationName"
        case observabilityConfigurationRevision = "ObservabilityConfigurationRevision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observabilityConfigurationArn = self.observabilityConfigurationArn {
            try encodeContainer.encode(observabilityConfigurationArn, forKey: .observabilityConfigurationArn)
        }
        if let observabilityConfigurationName = self.observabilityConfigurationName {
            try encodeContainer.encode(observabilityConfigurationName, forKey: .observabilityConfigurationName)
        }
        if observabilityConfigurationRevision != 0 {
            try encodeContainer.encode(observabilityConfigurationRevision, forKey: .observabilityConfigurationRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationArn)
        observabilityConfigurationArn = observabilityConfigurationArnDecoded
        let observabilityConfigurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationName)
        observabilityConfigurationName = observabilityConfigurationNameDecoded
        let observabilityConfigurationRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .observabilityConfigurationRevision) ?? 0
        observabilityConfigurationRevision = observabilityConfigurationRevisionDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information about an App Runner observability configuration resource. This type contains limited information about an observability configuration. It includes only identification information, without configuration details. It's returned by the [ListObservabilityConfigurations] action. Complete configuration information is returned by the [CreateObservabilityConfiguration], [DescribeObservabilityConfiguration], and [DeleteObservabilityConfiguration] actions using the [ObservabilityConfiguration] type.
    public struct ObservabilityConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of this observability configuration.
        public var observabilityConfigurationArn: Swift.String?
        /// The customer-provided observability configuration name. It can be used in multiple revisions of a configuration.
        public var observabilityConfigurationName: Swift.String?
        /// The revision of this observability configuration. It's unique among all the active configurations ("Status": "ACTIVE") that share the same ObservabilityConfigurationName.
        public var observabilityConfigurationRevision: Swift.Int

        public init (
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityConfigurationName: Swift.String? = nil,
            observabilityConfigurationRevision: Swift.Int = 0
        )
        {
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityConfigurationName = observabilityConfigurationName
            self.observabilityConfigurationRevision = observabilityConfigurationRevision
        }
    }

}

extension AppRunnerClientTypes {
    public enum OperationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case pending
        case rollbackFailed
        case rollbackInProgress
        case rollbackSucceeded
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationStatus] {
            return [
                .failed,
                .inProgress,
                .pending,
                .rollbackFailed,
                .rollbackInProgress,
                .rollbackSucceeded,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .rollbackFailed: return "ROLLBACK_FAILED"
            case .rollbackInProgress: return "ROLLBACK_IN_PROGRESS"
            case .rollbackSucceeded: return "ROLLBACK_SUCCEEDED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationStatus(rawValue: rawValue) ?? OperationStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.OperationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endedAt = "EndedAt"
        case id = "Id"
        case startedAt = "StartedAt"
        case status = "Status"
        case targetArn = "TargetArn"
        case type = "Type"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endedAt = self.endedAt {
            try encodeContainer.encodeTimestamp(endedAt, format: .epochSeconds, forKey: .endedAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetArn = self.targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.OperationStatus.self, forKey: .status)
        status = statusDecoded
        let targetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endedAt)
        endedAt = endedAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information for an operation that occurred on an App Runner service.
    public struct OperationSummary: Swift.Equatable {
        /// The time when the operation ended. It's in the Unix time stamp format.
        public var endedAt: ClientRuntime.Date?
        /// A unique ID of this operation. It's unique in the scope of the App Runner service.
        public var id: Swift.String?
        /// The time when the operation started. It's in the Unix time stamp format.
        public var startedAt: ClientRuntime.Date?
        /// The current state of the operation.
        public var status: AppRunnerClientTypes.OperationStatus?
        /// The Amazon Resource Name (ARN) of the resource that the operation acted on (for example, an App Runner service).
        public var targetArn: Swift.String?
        /// The type of operation. It indicates a specific action that occured.
        public var type: AppRunnerClientTypes.OperationType?
        /// The time when the operation was last updated. It's in the Unix time stamp format.
        public var updatedAt: ClientRuntime.Date?

        public init (
            endedAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            status: AppRunnerClientTypes.OperationStatus? = nil,
            targetArn: Swift.String? = nil,
            type: AppRunnerClientTypes.OperationType? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.endedAt = endedAt
            self.id = id
            self.startedAt = startedAt
            self.status = status
            self.targetArn = targetArn
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes {
    public enum OperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createService
        case deleteService
        case pauseService
        case resumeService
        case startDeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [OperationType] {
            return [
                .createService,
                .deleteService,
                .pauseService,
                .resumeService,
                .startDeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createService: return "CREATE_SERVICE"
            case .deleteService: return "DELETE_SERVICE"
            case .pauseService: return "PAUSE_SERVICE"
            case .resumeService: return "RESUME_SERVICE"
            case .startDeployment: return "START_DEPLOYMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OperationType(rawValue: rawValue) ?? OperationType.sdkUnknown(rawValue)
        }
    }
}

extension PauseServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension PauseServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PauseServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to pause.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct PauseServiceInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
}

extension PauseServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension PauseServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PauseServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PauseServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PauseServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PauseServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct PauseServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just paused.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct PauseServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
    let operationId: Swift.String?
}

extension PauseServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case github
        case sdkUnknown(Swift.String)

        public static var allCases: [ProviderType] {
            return [
                .github,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .github: return "GITHUB"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProviderType(rawValue: rawValue) ?? ProviderType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource doesn't exist for the specified Amazon Resource Name (ARN) in your Amazon Web Services account.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResumeServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension ResumeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResumeServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to resume.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct ResumeServiceInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
}

extension ResumeServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension ResumeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResumeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResumeServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResumeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResumeServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct ResumeServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    public var operationId: Swift.String?
    /// A description of the App Runner service that this request just resumed.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct ResumeServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
    let operationId: Swift.String?
}

extension ResumeServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes {
    public enum Runtime: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case corretto11
        case corretto8
        case dotnet6
        case go1
        case nodejs12
        case nodejs14
        case nodejs16
        case php81
        case python3
        case ruby31
        case sdkUnknown(Swift.String)

        public static var allCases: [Runtime] {
            return [
                .corretto11,
                .corretto8,
                .dotnet6,
                .go1,
                .nodejs12,
                .nodejs14,
                .nodejs16,
                .php81,
                .python3,
                .ruby31,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .corretto11: return "CORRETTO_11"
            case .corretto8: return "CORRETTO_8"
            case .dotnet6: return "DOTNET_6"
            case .go1: return "GO_1"
            case .nodejs12: return "NODEJS_12"
            case .nodejs14: return "NODEJS_14"
            case .nodejs16: return "NODEJS_16"
            case .php81: return "PHP_81"
            case .python3: return "PYTHON_3"
            case .ruby31: return "RUBY_31"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationSummary = "AutoScalingConfigurationSummary"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case encryptionConfiguration = "EncryptionConfiguration"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case networkConfiguration = "NetworkConfiguration"
        case observabilityConfiguration = "ObservabilityConfiguration"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case sourceConfiguration = "SourceConfiguration"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationSummary = self.autoScalingConfigurationSummary {
            try encodeContainer.encode(autoScalingConfigurationSummary, forKey: .autoScalingConfigurationSummary)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let healthCheckConfiguration = self.healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let observabilityConfiguration = self.observabilityConfiguration {
            try encodeContainer.encode(observabilityConfiguration, forKey: .observabilityConfiguration)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = self.serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let autoScalingConfigurationSummaryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AutoScalingConfigurationSummary.self, forKey: .autoScalingConfigurationSummary)
        autoScalingConfigurationSummary = autoScalingConfigurationSummaryDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes an App Runner service. It can describe a service in any state, including deleted services. This type contains the full information about a service, including configuration details. It's returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions. A subset of this information is returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action using the [ServiceSummary](https://docs.aws.amazon.com/apprunner/latest/api/API_ServiceSummary.html) type.
    public struct Service: Swift.Equatable {
        /// Summary information for the App Runner automatic scaling configuration resource that's associated with this service.
        /// This member is required.
        public var autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary?
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// The encryption key that App Runner uses to encrypt the service logs and the copy of the source repository that App Runner maintains for the service. It can be either a customer-provided encryption key or an Amazon Web Services managed key.
        public var encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration?
        /// The settings for the health check that App Runner performs to monitor the health of this service.
        public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
        /// The runtime configuration of instances (scaling units) of this service.
        /// This member is required.
        public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
        /// Configuration settings related to network traffic of the web application that this service runs.
        /// This member is required.
        public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
        /// The observability configuration of this service.
        public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
        /// The Amazon Resource Name (ARN) of this service.
        /// This member is required.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the Amazon Web Services Region.
        /// This member is required.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        /// This member is required.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public var serviceUrl: Swift.String?
        /// The source deployed to the App Runner service. It can be a code or an image repository.
        /// This member is required.
        public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED – The service failed to create. To troubleshoot this failure, read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.
        ///
        /// * DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        /// This member is required.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated at. It's in the Unix time stamp format.
        /// This member is required.
        public var updatedAt: ClientRuntime.Date?

        public init (
            autoScalingConfigurationSummary: AppRunnerClientTypes.AutoScalingConfigurationSummary? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            encryptionConfiguration: AppRunnerClientTypes.EncryptionConfiguration? = nil,
            healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
            instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
            networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
            observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.autoScalingConfigurationSummary = autoScalingConfigurationSummary
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.encryptionConfiguration = encryptionConfiguration
            self.healthCheckConfiguration = healthCheckConfiguration
            self.instanceConfiguration = instanceConfiguration
            self.networkConfiguration = networkConfiguration
            self.observabilityConfiguration = observabilityConfiguration
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.sourceConfiguration = sourceConfiguration
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes.ServiceObservabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case observabilityConfigurationArn = "ObservabilityConfigurationArn"
        case observabilityEnabled = "ObservabilityEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observabilityConfigurationArn = self.observabilityConfigurationArn {
            try encodeContainer.encode(observabilityConfigurationArn, forKey: .observabilityConfigurationArn)
        }
        if observabilityEnabled != false {
            try encodeContainer.encode(observabilityEnabled, forKey: .observabilityEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observabilityEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .observabilityEnabled) ?? false
        observabilityEnabled = observabilityEnabledDecoded
        let observabilityConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .observabilityConfigurationArn)
        observabilityConfigurationArn = observabilityConfigurationArnDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the observability configuration of an App Runner service. These are additional observability features, like tracing, that you choose to enable. They're configured in a separate resource that you associate with your service.
    public struct ServiceObservabilityConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the observability configuration that is associated with the service. Specified only when ObservabilityEnabled is true. Specify an ARN with a name and a revision number to associate that revision. For example: arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing/3 Specify just the name to associate the latest revision. For example: arn:aws:apprunner:us-east-1:123456789012:observabilityconfiguration/xray-tracing
        public var observabilityConfigurationArn: Swift.String?
        /// When true, an observability configuration resource is associated with the service, and an ObservabilityConfigurationArn is specified.
        /// This member is required.
        public var observabilityEnabled: Swift.Bool

        public init (
            observabilityConfigurationArn: Swift.String? = nil,
            observabilityEnabled: Swift.Bool = false
        )
        {
            self.observabilityConfigurationArn = observabilityConfigurationArn
            self.observabilityEnabled = observabilityEnabled
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// App Runner can't create this resource. You've reached your account quota for this resource type. For App Runner per-resource quotas, see [App Runner endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/apprunner.html) in the Amazon Web Services General Reference.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppRunnerClientTypes {
    public enum ServiceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case deleted
        case deleteFailed
        case operationInProgress
        case paused
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceStatus] {
            return [
                .createFailed,
                .deleted,
                .deleteFailed,
                .operationInProgress,
                .paused,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .deleted: return "DELETED"
            case .deleteFailed: return "DELETE_FAILED"
            case .operationInProgress: return "OPERATION_IN_PROGRESS"
            case .paused: return "PAUSED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceStatus(rawValue: rawValue) ?? ServiceStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.ServiceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case serviceArn = "ServiceArn"
        case serviceId = "ServiceId"
        case serviceName = "ServiceName"
        case serviceUrl = "ServiceUrl"
        case status = "Status"
        case updatedAt = "UpdatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let serviceId = self.serviceId {
            try encodeContainer.encode(serviceId, forKey: .serviceId)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let serviceUrl = self.serviceUrl {
            try encodeContainer.encode(serviceUrl, forKey: .serviceUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let serviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceId)
        serviceId = serviceIdDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let serviceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceUrl)
        serviceUrl = serviceUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information for an App Runner service. This type contains limited information about a service. It doesn't include configuration details. It's returned by the [ListServices](https://docs.aws.amazon.com/apprunner/latest/api/API_ListServices.html) action. Complete service information is returned by the [CreateService](https://docs.aws.amazon.com/apprunner/latest/api/API_CreateService.html), [DescribeService](https://docs.aws.amazon.com/apprunner/latest/api/API_DescribeService.html), and [DeleteService](https://docs.aws.amazon.com/apprunner/latest/api/API_DeleteService.html) actions using the [Service](https://docs.aws.amazon.com/apprunner/latest/api/API_Service.html) type.
    public struct ServiceSummary: Swift.Equatable {
        /// The time when the App Runner service was created. It's in the Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of this service.
        public var serviceArn: Swift.String?
        /// An ID that App Runner generated for this service. It's unique within the Amazon Web Services Region.
        public var serviceId: Swift.String?
        /// The customer-provided service name.
        public var serviceName: Swift.String?
        /// A subdomain URL that App Runner generated for this service. You can use this URL to access your service web application.
        public var serviceUrl: Swift.String?
        /// The current state of the App Runner service. These particular values mean the following.
        ///
        /// * CREATE_FAILED – The service failed to create. Read the failure events and logs, change any parameters that need to be fixed, and retry the call to create the service. The failed service isn't usable, and still counts towards your service quota. When you're done analyzing the failure, delete the service.
        ///
        /// * DELETE_FAILED – The service failed to delete and can't be successfully recovered. Retry the service deletion call to ensure that all related resources are removed.
        public var status: AppRunnerClientTypes.ServiceStatus?
        /// The time when the App Runner service was last updated. It's in theUnix time stamp format.
        public var updatedAt: ClientRuntime.Date?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            serviceArn: Swift.String? = nil,
            serviceId: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            serviceUrl: Swift.String? = nil,
            status: AppRunnerClientTypes.ServiceStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.createdAt = createdAt
            self.serviceArn = serviceArn
            self.serviceId = serviceId
            self.serviceName = serviceName
            self.serviceUrl = serviceUrl
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension AppRunnerClientTypes.SourceCodeVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceCodeVersionType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes {
    /// Identifies a version of code that App Runner refers to within a source code repository.
    public struct SourceCodeVersion: Swift.Equatable {
        /// The type of version identifier. For a git-based repository, branches represent versions.
        /// This member is required.
        public var type: AppRunnerClientTypes.SourceCodeVersionType?
        /// A source code version. For a git-based repository, a branch name maps to a specific version. App Runner uses the most recent commit to the branch.
        /// This member is required.
        public var value: Swift.String?

        public init (
            type: AppRunnerClientTypes.SourceCodeVersionType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension AppRunnerClientTypes {
    public enum SourceCodeVersionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case branch
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeVersionType] {
            return [
                .branch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .branch: return "BRANCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceCodeVersionType(rawValue: rawValue) ?? SourceCodeVersionType.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.SourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationConfiguration = "AuthenticationConfiguration"
        case autoDeploymentsEnabled = "AutoDeploymentsEnabled"
        case codeRepository = "CodeRepository"
        case imageRepository = "ImageRepository"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationConfiguration = self.authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let autoDeploymentsEnabled = self.autoDeploymentsEnabled {
            try encodeContainer.encode(autoDeploymentsEnabled, forKey: .autoDeploymentsEnabled)
        }
        if let codeRepository = self.codeRepository {
            try encodeContainer.encode(codeRepository, forKey: .codeRepository)
        }
        if let imageRepository = self.imageRepository {
            try encodeContainer.encode(imageRepository, forKey: .imageRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.CodeRepository.self, forKey: .codeRepository)
        codeRepository = codeRepositoryDecoded
        let imageRepositoryDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ImageRepository.self, forKey: .imageRepository)
        imageRepository = imageRepositoryDecoded
        let autoDeploymentsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoDeploymentsEnabled)
        autoDeploymentsEnabled = autoDeploymentsEnabledDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.AuthenticationConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the source deployed to an App Runner service. It can be a code or an image repository.
    public struct SourceConfiguration: Swift.Equatable {
        /// Describes the resources that are needed to authenticate access to some source repositories.
        public var authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration?
        /// If true, continuous integration from the source repository is enabled for the App Runner service. Each repository change (including any source code commit or new image version) starts a deployment. Default: App Runner sets to false for a source image that uses an ECR Public repository or an ECR repository that's in an Amazon Web Services account other than the one that the service is in. App Runner sets to true in all other cases (which currently include a source code repository or a source image using a same-account ECR repository).
        public var autoDeploymentsEnabled: Swift.Bool?
        /// The description of a source code repository. You must provide either this member or ImageRepository (but not both).
        public var codeRepository: AppRunnerClientTypes.CodeRepository?
        /// The description of a source image repository. You must provide either this member or CodeRepository (but not both).
        public var imageRepository: AppRunnerClientTypes.ImageRepository?

        public init (
            authenticationConfiguration: AppRunnerClientTypes.AuthenticationConfiguration? = nil,
            autoDeploymentsEnabled: Swift.Bool? = nil,
            codeRepository: AppRunnerClientTypes.CodeRepository? = nil,
            imageRepository: AppRunnerClientTypes.ImageRepository? = nil
        )
        {
            self.authenticationConfiguration = authenticationConfiguration
            self.autoDeploymentsEnabled = autoDeploymentsEnabled
            self.codeRepository = codeRepository
            self.imageRepository = imageRepository
        }
    }

}

extension StartDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
    }
}

extension StartDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDeploymentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to manually deploy to.
    /// This member is required.
    public var serviceArn: Swift.String?

    public init (
        serviceArn: Swift.String? = nil
    )
    {
        self.serviceArn = serviceArn
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension StartDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
        } else {
            self.operationId = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?

    public init (
        operationId: Swift.String? = nil
    )
    {
        self.operationId = operationId
    }
}

struct StartDeploymentOutputResponseBody: Swift.Equatable {
    let operationId: Swift.String?
}

extension StartDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension AppRunnerClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes a tag that is applied to an App Runner resource. A tag is a metadata item consisting of a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        public var key: Swift.String?
        /// The value of the tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to update tags for. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag key-value pairs to add or update. If a key is new to the resource, the tag is added with the provided value. If a key is already associated with the resource, the value of the tag is updated.
    /// This member is required.
    public var tags: [AppRunnerClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [AppRunnerClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [AppRunnerClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AppRunnerClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AppRunnerClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AppRunnerClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension AppRunnerClientTypes.TraceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vendor = "Vendor"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vendor = self.vendor {
            try encodeContainer.encode(vendor.rawValue, forKey: .vendor)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vendorDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.TracingVendor.self, forKey: .vendor)
        vendor = vendorDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes the configuration of the tracing feature within an App Runner observability configuration.
    public struct TraceConfiguration: Swift.Equatable {
        /// The implementation provider chosen for tracing App Runner services.
        /// This member is required.
        public var vendor: AppRunnerClientTypes.TracingVendor?

        public init (
            vendor: AppRunnerClientTypes.TracingVendor? = nil
        )
        {
            self.vendor = vendor
        }
    }

}

extension AppRunnerClientTypes {
    public enum TracingVendor: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsxray
        case sdkUnknown(Swift.String)

        public static var allCases: [TracingVendor] {
            return [
                .awsxray,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsxray: return "AWSXRAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TracingVendor(rawValue: rawValue) ?? TracingVendor.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from. It must be the ARN of an App Runner resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case networkConfiguration = "NetworkConfiguration"
        case observabilityConfiguration = "ObservabilityConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoScalingConfigurationArn = self.autoScalingConfigurationArn {
            try encodeContainer.encode(autoScalingConfigurationArn, forKey: .autoScalingConfigurationArn)
        }
        if let healthCheckConfiguration = self.healthCheckConfiguration {
            try encodeContainer.encode(healthCheckConfiguration, forKey: .healthCheckConfiguration)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let networkConfiguration = self.networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let observabilityConfiguration = self.observabilityConfiguration {
            try encodeContainer.encode(observabilityConfiguration, forKey: .observabilityConfiguration)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let sourceConfiguration = self.sourceConfiguration {
            try encodeContainer.encode(sourceConfiguration, forKey: .sourceConfiguration)
        }
    }
}

extension UpdateServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateServiceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of an App Runner automatic scaling configuration resource that you want to associate with the App Runner service.
    public var autoScalingConfigurationArn: Swift.String?
    /// The settings for the health check that App Runner performs to monitor the health of the App Runner service.
    public var healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    /// The runtime configuration to apply to instances (scaling units) of your service.
    public var instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    /// Configuration settings related to network traffic of the web application that the App Runner service runs.
    public var networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    /// The observability configuration of your service.
    public var observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
    /// The Amazon Resource Name (ARN) of the App Runner service that you want to update.
    /// This member is required.
    public var serviceArn: Swift.String?
    /// The source configuration to apply to the App Runner service. You can change the configuration of the code or image repository that the service uses. However, you can't switch from code to image or the other way around. This means that you must provide the same structure member of SourceConfiguration that you originally included when you created the service. Specifically, you can include either CodeRepository or ImageRepository. To update the source configuration, set the values to members of the structure that you include.
    public var sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?

    public init (
        autoScalingConfigurationArn: Swift.String? = nil,
        healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration? = nil,
        instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration? = nil,
        networkConfiguration: AppRunnerClientTypes.NetworkConfiguration? = nil,
        observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration? = nil,
        serviceArn: Swift.String? = nil,
        sourceConfiguration: AppRunnerClientTypes.SourceConfiguration? = nil
    )
    {
        self.autoScalingConfigurationArn = autoScalingConfigurationArn
        self.healthCheckConfiguration = healthCheckConfiguration
        self.instanceConfiguration = instanceConfiguration
        self.networkConfiguration = networkConfiguration
        self.observabilityConfiguration = observabilityConfiguration
        self.serviceArn = serviceArn
        self.sourceConfiguration = sourceConfiguration
    }
}

struct UpdateServiceInputBody: Swift.Equatable {
    let serviceArn: Swift.String?
    let sourceConfiguration: AppRunnerClientTypes.SourceConfiguration?
    let instanceConfiguration: AppRunnerClientTypes.InstanceConfiguration?
    let autoScalingConfigurationArn: Swift.String?
    let healthCheckConfiguration: AppRunnerClientTypes.HealthCheckConfiguration?
    let networkConfiguration: AppRunnerClientTypes.NetworkConfiguration?
    let observabilityConfiguration: AppRunnerClientTypes.ServiceObservabilityConfiguration?
}

extension UpdateServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoScalingConfigurationArn = "AutoScalingConfigurationArn"
        case healthCheckConfiguration = "HealthCheckConfiguration"
        case instanceConfiguration = "InstanceConfiguration"
        case networkConfiguration = "NetworkConfiguration"
        case observabilityConfiguration = "ObservabilityConfiguration"
        case serviceArn = "ServiceArn"
        case sourceConfiguration = "SourceConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let sourceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.SourceConfiguration.self, forKey: .sourceConfiguration)
        sourceConfiguration = sourceConfigurationDecoded
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let autoScalingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .autoScalingConfigurationArn)
        autoScalingConfigurationArn = autoScalingConfigurationArnDecoded
        let healthCheckConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.HealthCheckConfiguration.self, forKey: .healthCheckConfiguration)
        healthCheckConfiguration = healthCheckConfigurationDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let observabilityConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.ServiceObservabilityConfiguration.self, forKey: .observabilityConfiguration)
        observabilityConfiguration = observabilityConfigurationDecoded
    }
}

extension UpdateServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateServiceOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.operationId = output.operationId
            self.service = output.service
        } else {
            self.operationId = nil
            self.service = nil
        }
    }
}

public struct UpdateServiceOutputResponse: Swift.Equatable {
    /// The unique ID of the asynchronous operation that this request started. You can use it combined with the [ListOperations] call to track the operation's progress.
    /// This member is required.
    public var operationId: Swift.String?
    /// A description of the App Runner service updated by this request. All configuration values in the returned Service structure reflect configuration changes that are being applied by this request.
    /// This member is required.
    public var service: AppRunnerClientTypes.Service?

    public init (
        operationId: Swift.String? = nil,
        service: AppRunnerClientTypes.Service? = nil
    )
    {
        self.operationId = operationId
        self.service = service
    }
}

struct UpdateServiceOutputResponseBody: Swift.Equatable {
    let service: AppRunnerClientTypes.Service?
    let operationId: Swift.String?
}

extension UpdateServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operationId = "OperationId"
        case service = "Service"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let operationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operationId)
        operationId = operationIdDecoded
    }
}

extension UpdateVpcIngressConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingressVpcConfiguration = "IngressVpcConfiguration"
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ingressVpcConfiguration = self.ingressVpcConfiguration {
            try encodeContainer.encode(ingressVpcConfiguration, forKey: .ingressVpcConfiguration)
        }
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
    }
}

extension UpdateVpcIngressConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateVpcIngressConnectionInput: Swift.Equatable {
    /// Specifications for the customer’s Amazon VPC and the related Amazon Web Services PrivateLink VPC endpoint that are used to update the VPC Ingress Connection resource.
    /// This member is required.
    public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
    /// The Amazon Resource Name (Arn) for the App Runner VPC Ingress Connection resource that you want to update.
    /// This member is required.
    public var vpcIngressConnectionArn: Swift.String?

    public init (
        ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
        vpcIngressConnectionArn: Swift.String? = nil
    )
    {
        self.ingressVpcConfiguration = ingressVpcConfiguration
        self.vpcIngressConnectionArn = vpcIngressConnectionArn
    }
}

struct UpdateVpcIngressConnectionInputBody: Swift.Equatable {
    let vpcIngressConnectionArn: Swift.String?
    let ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
}

extension UpdateVpcIngressConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ingressVpcConfiguration = "IngressVpcConfiguration"
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
        let ingressVpcConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.IngressVpcConfiguration.self, forKey: .ingressVpcConfiguration)
        ingressVpcConfiguration = ingressVpcConfigurationDecoded
    }
}

extension UpdateVpcIngressConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVpcIngressConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequest" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidState" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotfound" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVpcIngressConnectionOutputError: Swift.Error, Swift.Equatable {
    case internalServiceErrorException(InternalServiceErrorException)
    case invalidRequestException(InvalidRequestException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVpcIngressConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVpcIngressConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.vpcIngressConnection = output.vpcIngressConnection
        } else {
            self.vpcIngressConnection = nil
        }
    }
}

public struct UpdateVpcIngressConnectionOutputResponse: Swift.Equatable {
    /// A description of the App Runner VPC Ingress Connection resource that's updated by this request.
    /// This member is required.
    public var vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?

    public init (
        vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection? = nil
    )
    {
        self.vpcIngressConnection = vpcIngressConnection
    }
}

struct UpdateVpcIngressConnectionOutputResponseBody: Swift.Equatable {
    let vpcIngressConnection: AppRunnerClientTypes.VpcIngressConnection?
}

extension UpdateVpcIngressConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcIngressConnection = "VpcIngressConnection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcIngressConnection.self, forKey: .vpcIngressConnection)
        vpcIngressConnection = vpcIngressConnectionDecoded
    }
}

extension AppRunnerClientTypes.VpcConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case securityGroups = "SecurityGroups"
        case status = "Status"
        case subnets = "Subnets"
        case vpcConnectorArn = "VpcConnectorArn"
        case vpcConnectorName = "VpcConnectorName"
        case vpcConnectorRevision = "VpcConnectorRevision"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for string0 in securityGroups {
                try securityGroupsContainer.encode(string0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for string0 in subnets {
                try subnetsContainer.encode(string0)
            }
        }
        if let vpcConnectorArn = self.vpcConnectorArn {
            try encodeContainer.encode(vpcConnectorArn, forKey: .vpcConnectorArn)
        }
        if let vpcConnectorName = self.vpcConnectorName {
            try encodeContainer.encode(vpcConnectorName, forKey: .vpcConnectorName)
        }
        if vpcConnectorRevision != 0 {
            try encodeContainer.encode(vpcConnectorRevision, forKey: .vpcConnectorRevision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConnectorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorName)
        vpcConnectorName = vpcConnectorNameDecoded
        let vpcConnectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcConnectorArn)
        vpcConnectorArn = vpcConnectorArnDecoded
        let vpcConnectorRevisionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .vpcConnectorRevision) ?? 0
        vpcConnectorRevision = vpcConnectorRevisionDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnets)
        var subnetsDecoded0:[Swift.String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Swift.String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[Swift.String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [Swift.String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcConnectorStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// Describes an App Runner VPC connector resource. A VPC connector describes the Amazon Virtual Private Cloud (Amazon VPC) that an App Runner service is associated with, and the subnets and security group that are used. Multiple revisions of a connector might have the same Name and different Revision values. At this time, App Runner supports only one revision per name.
    public struct VpcConnector: Swift.Equatable {
        /// The time when the VPC connector was created. It's in Unix time stamp format.
        public var createdAt: ClientRuntime.Date?
        /// The time when the VPC connector was deleted. It's in Unix time stamp format.
        public var deletedAt: ClientRuntime.Date?
        /// A list of IDs of security groups that App Runner uses for access to Amazon Web Services resources under the specified subnets. If not specified, App Runner uses the default security group of the Amazon VPC. The default security group allows all outbound traffic.
        public var securityGroups: [Swift.String]?
        /// The current state of the VPC connector. If the status of a connector revision is INACTIVE, it was deleted and can't be used. Inactive connector revisions are permanently removed some time after they are deleted.
        public var status: AppRunnerClientTypes.VpcConnectorStatus?
        /// A list of IDs of subnets that App Runner uses for your service. All IDs are of subnets of a single Amazon VPC.
        public var subnets: [Swift.String]?
        /// The Amazon Resource Name (ARN) of this VPC connector.
        public var vpcConnectorArn: Swift.String?
        /// The customer-provided VPC connector name.
        public var vpcConnectorName: Swift.String?
        /// The revision of this VPC connector. It's unique among all the active connectors ("Status": "ACTIVE") that share the same Name. At this time, App Runner supports only one revision per name.
        public var vpcConnectorRevision: Swift.Int

        public init (
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            securityGroups: [Swift.String]? = nil,
            status: AppRunnerClientTypes.VpcConnectorStatus? = nil,
            subnets: [Swift.String]? = nil,
            vpcConnectorArn: Swift.String? = nil,
            vpcConnectorName: Swift.String? = nil,
            vpcConnectorRevision: Swift.Int = 0
        )
        {
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.securityGroups = securityGroups
            self.status = status
            self.subnets = subnets
            self.vpcConnectorArn = vpcConnectorArn
            self.vpcConnectorName = vpcConnectorName
            self.vpcConnectorRevision = vpcConnectorRevision
        }
    }

}

extension AppRunnerClientTypes {
    public enum VpcConnectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcConnectorStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcConnectorStatus(rawValue: rawValue) ?? VpcConnectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.VpcDNSTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case vpcId = "VpcId"
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
    }
}

extension AppRunnerClientTypes {
    /// DNS Target record for a custom domain of this Amazon VPC.
    public struct VpcDNSTarget: Swift.Equatable {
        /// The domain name of your target DNS that is associated with the Amazon VPC.
        public var domainName: Swift.String?
        /// The ID of the Amazon VPC that is associated with the custom domain name of the target DNS.
        public var vpcId: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection that is associated with your service.
        public var vpcIngressConnectionArn: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            vpcId: Swift.String? = nil,
            vpcIngressConnectionArn: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.vpcId = vpcId
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
        }
    }

}

extension AppRunnerClientTypes.VpcIngressConnection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdAt = "CreatedAt"
        case deletedAt = "DeletedAt"
        case domainName = "DomainName"
        case ingressVpcConfiguration = "IngressVpcConfiguration"
        case serviceArn = "ServiceArn"
        case status = "Status"
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
        case vpcIngressConnectionName = "VpcIngressConnectionName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let deletedAt = self.deletedAt {
            try encodeContainer.encodeTimestamp(deletedAt, format: .epochSeconds, forKey: .deletedAt)
        }
        if let domainName = self.domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let ingressVpcConfiguration = self.ingressVpcConfiguration {
            try encodeContainer.encode(ingressVpcConfiguration, forKey: .ingressVpcConfiguration)
        }
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
        if let vpcIngressConnectionName = self.vpcIngressConnectionName {
            try encodeContainer.encode(vpcIngressConnectionName, forKey: .vpcIngressConnectionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
        let vpcIngressConnectionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionName)
        vpcIngressConnectionName = vpcIngressConnectionNameDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.VpcIngressConnectionStatus.self, forKey: .status)
        status = statusDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let ingressVpcConfigurationDecoded = try containerValues.decodeIfPresent(AppRunnerClientTypes.IngressVpcConfiguration.self, forKey: .ingressVpcConfiguration)
        ingressVpcConfiguration = ingressVpcConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deletedAt)
        deletedAt = deletedAtDecoded
    }
}

extension AppRunnerClientTypes {
    /// The App Runner resource that specifies an App Runner endpoint for incoming traffic. It establishes a connection between a VPC interface endpoint and a App Runner service, to make your App Runner service accessible from only within an Amazon VPC.
    public struct VpcIngressConnection: Swift.Equatable {
        /// The Account Id you use to create the VPC Ingress Connection resource.
        public var accountId: Swift.String?
        /// The time when the VPC Ingress Connection was created. It's in the Unix time stamp format.
        ///
        /// * Type: Timestamp
        ///
        /// * Required: Yes
        public var createdAt: ClientRuntime.Date?
        /// The time when the App Runner service was deleted. It's in the Unix time stamp format.
        ///
        /// * Type: Timestamp
        ///
        /// * Required: No
        public var deletedAt: ClientRuntime.Date?
        /// The domain name associated with the VPC Ingress Connection resource.
        public var domainName: Swift.String?
        /// Specifications for the customer’s VPC and related PrivateLink VPC endpoint that are used to associate with the VPC Ingress Connection resource.
        public var ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration?
        /// The Amazon Resource Name (ARN) of the service associated with the VPC Ingress Connection.
        public var serviceArn: Swift.String?
        /// The current status of the VPC Ingress Connection. The VPC Ingress Connection displays one of the following statuses: AVAILABLE, PENDING_CREATION, PENDING_UPDATE, PENDING_DELETION,FAILED_CREATION, FAILED_UPDATE, FAILED_DELETION, and DELETED..
        public var status: AppRunnerClientTypes.VpcIngressConnectionStatus?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection.
        public var vpcIngressConnectionArn: Swift.String?
        /// The customer-provided VPC Ingress Connection name.
        public var vpcIngressConnectionName: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            deletedAt: ClientRuntime.Date? = nil,
            domainName: Swift.String? = nil,
            ingressVpcConfiguration: AppRunnerClientTypes.IngressVpcConfiguration? = nil,
            serviceArn: Swift.String? = nil,
            status: AppRunnerClientTypes.VpcIngressConnectionStatus? = nil,
            vpcIngressConnectionArn: Swift.String? = nil,
            vpcIngressConnectionName: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.createdAt = createdAt
            self.deletedAt = deletedAt
            self.domainName = domainName
            self.ingressVpcConfiguration = ingressVpcConfiguration
            self.serviceArn = serviceArn
            self.status = status
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
            self.vpcIngressConnectionName = vpcIngressConnectionName
        }
    }

}

extension AppRunnerClientTypes {
    public enum VpcIngressConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case failedCreation
        case failedDeletion
        case failedUpdate
        case pendingCreation
        case pendingDeletion
        case pendingUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [VpcIngressConnectionStatus] {
            return [
                .available,
                .deleted,
                .failedCreation,
                .failedDeletion,
                .failedUpdate,
                .pendingCreation,
                .pendingDeletion,
                .pendingUpdate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .failedCreation: return "FAILED_CREATION"
            case .failedDeletion: return "FAILED_DELETION"
            case .failedUpdate: return "FAILED_UPDATE"
            case .pendingCreation: return "PENDING_CREATION"
            case .pendingDeletion: return "PENDING_DELETION"
            case .pendingUpdate: return "PENDING_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VpcIngressConnectionStatus(rawValue: rawValue) ?? VpcIngressConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AppRunnerClientTypes.VpcIngressConnectionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceArn = "ServiceArn"
        case vpcIngressConnectionArn = "VpcIngressConnectionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceArn = self.serviceArn {
            try encodeContainer.encode(serviceArn, forKey: .serviceArn)
        }
        if let vpcIngressConnectionArn = self.vpcIngressConnectionArn {
            try encodeContainer.encode(vpcIngressConnectionArn, forKey: .vpcIngressConnectionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIngressConnectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcIngressConnectionArn)
        vpcIngressConnectionArn = vpcIngressConnectionArnDecoded
        let serviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceArn)
        serviceArn = serviceArnDecoded
    }
}

extension AppRunnerClientTypes {
    /// Provides summary information about an VPC Ingress Connection, which includes its VPC Ingress Connection ARN and its associated Service ARN.
    public struct VpcIngressConnectionSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the service associated with the VPC Ingress Connection.
        public var serviceArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the VPC Ingress Connection.
        public var vpcIngressConnectionArn: Swift.String?

        public init (
            serviceArn: Swift.String? = nil,
            vpcIngressConnectionArn: Swift.String? = nil
        )
        {
            self.serviceArn = serviceArn
            self.vpcIngressConnectionArn = vpcIngressConnectionArn
        }
    }

}
