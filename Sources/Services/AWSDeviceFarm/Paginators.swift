// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DeviceFarmClient {
    /// Paginate over `[GetOfferingStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetOfferingStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetOfferingStatusOutput`
    public func getOfferingStatusPaginated(input: GetOfferingStatusInput) -> ClientRuntime.PaginatorSequence<GetOfferingStatusInput, GetOfferingStatusOutput> {
        return ClientRuntime.PaginatorSequence<GetOfferingStatusInput, GetOfferingStatusOutput>(input: input, inputKey: \GetOfferingStatusInput.nextToken, outputKey: \GetOfferingStatusOutput.nextToken, paginationFunction: self.getOfferingStatus(input:))
    }
}

extension GetOfferingStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetOfferingStatusInput {
        return GetOfferingStatusInput(
            nextToken: token
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListArtifactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListArtifactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListArtifactsOutput`
    public func listArtifactsPaginated(input: ListArtifactsInput) -> ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput> {
        return ClientRuntime.PaginatorSequence<ListArtifactsInput, ListArtifactsOutput>(input: input, inputKey: \ListArtifactsInput.nextToken, outputKey: \ListArtifactsOutput.nextToken, paginationFunction: self.listArtifacts(input:))
    }
}

extension ListArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListArtifactsInput {
        return ListArtifactsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListArtifactsInput, Output == ListArtifactsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listArtifactsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Artifact]`
    /// - Returns: `[DeviceFarmClientTypes.Artifact]`
    public func artifacts() async throws -> [DeviceFarmClientTypes.Artifact] {
        return try await self.asyncCompactMap { item in item.artifacts }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListDevicePoolsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicePoolsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicePoolsOutput`
    public func listDevicePoolsPaginated(input: ListDevicePoolsInput) -> ClientRuntime.PaginatorSequence<ListDevicePoolsInput, ListDevicePoolsOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicePoolsInput, ListDevicePoolsOutput>(input: input, inputKey: \ListDevicePoolsInput.nextToken, outputKey: \ListDevicePoolsOutput.nextToken, paginationFunction: self.listDevicePools(input:))
    }
}

extension ListDevicePoolsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicePoolsInput {
        return ListDevicePoolsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListDevicePoolsInput, Output == ListDevicePoolsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicePoolsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.DevicePool]`
    /// - Returns: `[DeviceFarmClientTypes.DevicePool]`
    public func devicePools() async throws -> [DeviceFarmClientTypes.DevicePool] {
        return try await self.asyncCompactMap { item in item.devicePools }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListDevicesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDevicesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDevicesOutput`
    public func listDevicesPaginated(input: ListDevicesInput) -> ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput> {
        return ClientRuntime.PaginatorSequence<ListDevicesInput, ListDevicesOutput>(input: input, inputKey: \ListDevicesInput.nextToken, outputKey: \ListDevicesOutput.nextToken, paginationFunction: self.listDevices(input:))
    }
}

extension ListDevicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDevicesInput {
        return ListDevicesInput(
            arn: self.arn,
            filters: self.filters,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDevicesInput, Output == ListDevicesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listDevicesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Device]`
    /// - Returns: `[DeviceFarmClientTypes.Device]`
    public func devices() async throws -> [DeviceFarmClientTypes.Device] {
        return try await self.asyncCompactMap { item in item.devices }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutput`
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutput>(input: input, inputKey: \ListJobsInput.nextToken, outputKey: \ListJobsOutput.nextToken, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListJobsInput, Output == ListJobsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Job]`
    /// - Returns: `[DeviceFarmClientTypes.Job]`
    public func jobs() async throws -> [DeviceFarmClientTypes.Job] {
        return try await self.asyncCompactMap { item in item.jobs }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListOfferingsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingsOutput`
    public func listOfferingsPaginated(input: ListOfferingsInput) -> ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingsInput, ListOfferingsOutput>(input: input, inputKey: \ListOfferingsInput.nextToken, outputKey: \ListOfferingsOutput.nextToken, paginationFunction: self.listOfferings(input:))
    }
}

extension ListOfferingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingsInput {
        return ListOfferingsInput(
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListOfferingsInput, Output == ListOfferingsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Offering]`
    /// - Returns: `[DeviceFarmClientTypes.Offering]`
    public func offerings() async throws -> [DeviceFarmClientTypes.Offering] {
        return try await self.asyncCompactMap { item in item.offerings }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListOfferingTransactionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListOfferingTransactionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListOfferingTransactionsOutput`
    public func listOfferingTransactionsPaginated(input: ListOfferingTransactionsInput) -> ClientRuntime.PaginatorSequence<ListOfferingTransactionsInput, ListOfferingTransactionsOutput> {
        return ClientRuntime.PaginatorSequence<ListOfferingTransactionsInput, ListOfferingTransactionsOutput>(input: input, inputKey: \ListOfferingTransactionsInput.nextToken, outputKey: \ListOfferingTransactionsOutput.nextToken, paginationFunction: self.listOfferingTransactions(input:))
    }
}

extension ListOfferingTransactionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListOfferingTransactionsInput {
        return ListOfferingTransactionsInput(
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListOfferingTransactionsInput, Output == ListOfferingTransactionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listOfferingTransactionsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.OfferingTransaction]`
    /// - Returns: `[DeviceFarmClientTypes.OfferingTransaction]`
    public func offeringTransactions() async throws -> [DeviceFarmClientTypes.OfferingTransaction] {
        return try await self.asyncCompactMap { item in item.offeringTransactions }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListProjectsOutput`
    public func listProjectsPaginated(input: ListProjectsInput) -> ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListProjectsInput, ListProjectsOutput>(input: input, inputKey: \ListProjectsInput.nextToken, outputKey: \ListProjectsOutput.nextToken, paginationFunction: self.listProjects(input:))
    }
}

extension ListProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListProjectsInput {
        return ListProjectsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListProjectsInput, Output == ListProjectsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listProjectsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Project]`
    /// - Returns: `[DeviceFarmClientTypes.Project]`
    public func projects() async throws -> [DeviceFarmClientTypes.Project] {
        return try await self.asyncCompactMap { item in item.projects }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListRunsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRunsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRunsOutput`
    public func listRunsPaginated(input: ListRunsInput) -> ClientRuntime.PaginatorSequence<ListRunsInput, ListRunsOutput> {
        return ClientRuntime.PaginatorSequence<ListRunsInput, ListRunsOutput>(input: input, inputKey: \ListRunsInput.nextToken, outputKey: \ListRunsOutput.nextToken, paginationFunction: self.listRuns(input:))
    }
}

extension ListRunsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRunsInput {
        return ListRunsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListRunsInput, Output == ListRunsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRunsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Run]`
    /// - Returns: `[DeviceFarmClientTypes.Run]`
    public func runs() async throws -> [DeviceFarmClientTypes.Run] {
        return try await self.asyncCompactMap { item in item.runs }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListSamplesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSamplesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSamplesOutput`
    public func listSamplesPaginated(input: ListSamplesInput) -> ClientRuntime.PaginatorSequence<ListSamplesInput, ListSamplesOutput> {
        return ClientRuntime.PaginatorSequence<ListSamplesInput, ListSamplesOutput>(input: input, inputKey: \ListSamplesInput.nextToken, outputKey: \ListSamplesOutput.nextToken, paginationFunction: self.listSamples(input:))
    }
}

extension ListSamplesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSamplesInput {
        return ListSamplesInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSamplesInput, Output == ListSamplesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSamplesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Sample]`
    /// - Returns: `[DeviceFarmClientTypes.Sample]`
    public func samples() async throws -> [DeviceFarmClientTypes.Sample] {
        return try await self.asyncCompactMap { item in item.samples }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListSuitesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSuitesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSuitesOutput`
    public func listSuitesPaginated(input: ListSuitesInput) -> ClientRuntime.PaginatorSequence<ListSuitesInput, ListSuitesOutput> {
        return ClientRuntime.PaginatorSequence<ListSuitesInput, ListSuitesOutput>(input: input, inputKey: \ListSuitesInput.nextToken, outputKey: \ListSuitesOutput.nextToken, paginationFunction: self.listSuites(input:))
    }
}

extension ListSuitesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSuitesInput {
        return ListSuitesInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListSuitesInput, Output == ListSuitesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listSuitesPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Suite]`
    /// - Returns: `[DeviceFarmClientTypes.Suite]`
    public func suites() async throws -> [DeviceFarmClientTypes.Suite] {
        return try await self.asyncCompactMap { item in item.suites }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridProjectsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridProjectsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridProjectsOutput`
    public func listTestGridProjectsPaginated(input: ListTestGridProjectsInput) -> ClientRuntime.PaginatorSequence<ListTestGridProjectsInput, ListTestGridProjectsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridProjectsInput, ListTestGridProjectsOutput>(input: input, inputKey: \ListTestGridProjectsInput.nextToken, outputKey: \ListTestGridProjectsOutput.nextToken, paginationFunction: self.listTestGridProjects(input:))
    }
}

extension ListTestGridProjectsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridProjectsInput {
        return ListTestGridProjectsInput(
            maxResult: self.maxResult,
            nextToken: token
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionActionsOutput`
    public func listTestGridSessionActionsPaginated(input: ListTestGridSessionActionsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionActionsInput, ListTestGridSessionActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionActionsInput, ListTestGridSessionActionsOutput>(input: input, inputKey: \ListTestGridSessionActionsInput.nextToken, outputKey: \ListTestGridSessionActionsOutput.nextToken, paginationFunction: self.listTestGridSessionActions(input:))
    }
}

extension ListTestGridSessionActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionActionsInput {
        return ListTestGridSessionActionsInput(
            maxResult: self.maxResult,
            nextToken: token,
            sessionArn: self.sessionArn
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionArtifactsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionArtifactsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionArtifactsOutput`
    public func listTestGridSessionArtifactsPaginated(input: ListTestGridSessionArtifactsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionArtifactsInput, ListTestGridSessionArtifactsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionArtifactsInput, ListTestGridSessionArtifactsOutput>(input: input, inputKey: \ListTestGridSessionArtifactsInput.nextToken, outputKey: \ListTestGridSessionArtifactsOutput.nextToken, paginationFunction: self.listTestGridSessionArtifacts(input:))
    }
}

extension ListTestGridSessionArtifactsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionArtifactsInput {
        return ListTestGridSessionArtifactsInput(
            maxResult: self.maxResult,
            nextToken: token,
            sessionArn: self.sessionArn,
            type: self.type
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestGridSessionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestGridSessionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestGridSessionsOutput`
    public func listTestGridSessionsPaginated(input: ListTestGridSessionsInput) -> ClientRuntime.PaginatorSequence<ListTestGridSessionsInput, ListTestGridSessionsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestGridSessionsInput, ListTestGridSessionsOutput>(input: input, inputKey: \ListTestGridSessionsInput.nextToken, outputKey: \ListTestGridSessionsOutput.nextToken, paginationFunction: self.listTestGridSessions(input:))
    }
}

extension ListTestGridSessionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestGridSessionsInput {
        return ListTestGridSessionsInput(
            creationTimeAfter: self.creationTimeAfter,
            creationTimeBefore: self.creationTimeBefore,
            endTimeAfter: self.endTimeAfter,
            endTimeBefore: self.endTimeBefore,
            maxResult: self.maxResult,
            nextToken: token,
            projectArn: self.projectArn,
            status: self.status
        )}
}
extension DeviceFarmClient {
    /// Paginate over `[ListTestsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTestsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTestsOutput`
    public func listTestsPaginated(input: ListTestsInput) -> ClientRuntime.PaginatorSequence<ListTestsInput, ListTestsOutput> {
        return ClientRuntime.PaginatorSequence<ListTestsInput, ListTestsOutput>(input: input, inputKey: \ListTestsInput.nextToken, outputKey: \ListTestsOutput.nextToken, paginationFunction: self.listTests(input:))
    }
}

extension ListTestsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTestsInput {
        return ListTestsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListTestsInput, Output == ListTestsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTestsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Test]`
    /// - Returns: `[DeviceFarmClientTypes.Test]`
    public func tests() async throws -> [DeviceFarmClientTypes.Test] {
        return try await self.asyncCompactMap { item in item.tests }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListUniqueProblemsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUniqueProblemsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUniqueProblemsOutput`
    public func listUniqueProblemsPaginated(input: ListUniqueProblemsInput) -> ClientRuntime.PaginatorSequence<ListUniqueProblemsInput, ListUniqueProblemsOutput> {
        return ClientRuntime.PaginatorSequence<ListUniqueProblemsInput, ListUniqueProblemsOutput>(input: input, inputKey: \ListUniqueProblemsInput.nextToken, outputKey: \ListUniqueProblemsOutput.nextToken, paginationFunction: self.listUniqueProblems(input:))
    }
}

extension ListUniqueProblemsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUniqueProblemsInput {
        return ListUniqueProblemsInput(
            arn: self.arn,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListUniqueProblemsInput, Output == ListUniqueProblemsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUniqueProblemsPaginated`
    /// to access the nested member `[(String, [DeviceFarmClientTypes.UniqueProblem])]`
    /// - Returns: `[(String, [DeviceFarmClientTypes.UniqueProblem])]`
    public func uniqueProblems() async throws -> [(String, [DeviceFarmClientTypes.UniqueProblem])] {
        return try await self.asyncCompactMap { item in item.uniqueProblems?.map { ($0, $1) } }
    }
}
extension DeviceFarmClient {
    /// Paginate over `[ListUploadsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListUploadsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListUploadsOutput`
    public func listUploadsPaginated(input: ListUploadsInput) -> ClientRuntime.PaginatorSequence<ListUploadsInput, ListUploadsOutput> {
        return ClientRuntime.PaginatorSequence<ListUploadsInput, ListUploadsOutput>(input: input, inputKey: \ListUploadsInput.nextToken, outputKey: \ListUploadsOutput.nextToken, paginationFunction: self.listUploads(input:))
    }
}

extension ListUploadsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListUploadsInput {
        return ListUploadsInput(
            arn: self.arn,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListUploadsInput, Output == ListUploadsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listUploadsPaginated`
    /// to access the nested member `[DeviceFarmClientTypes.Upload]`
    /// - Returns: `[DeviceFarmClientTypes.Upload]`
    public func uploads() async throws -> [DeviceFarmClientTypes.Upload] {
        return try await self.asyncCompactMap { item in item.uploads }
    }
}
