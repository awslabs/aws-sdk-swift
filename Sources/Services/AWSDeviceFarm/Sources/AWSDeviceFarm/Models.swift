//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension DeviceFarmClientTypes {

    /// Represents information about free trial device minutes for an AWS account.
    public struct TrialMinutes: Swift.Sendable {
        /// The number of free trial minutes remaining in the account.
        public var remaining: Swift.Double?
        /// The total number of free trial minutes that the account started with.
        public var total: Swift.Double?

        public init(
            remaining: Swift.Double? = nil,
            total: Swift.Double? = nil
        )
        {
            self.remaining = remaining
            self.total = total
        }
    }
}

extension DeviceFarmClientTypes {

    public enum DevicePlatform: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case android
        case ios
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePlatform] {
            return [
                .android,
                .ios
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .android: return "ANDROID"
            case .ios: return "IOS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// A container for account-level settings in AWS Device Farm.
    public struct AccountSettings: Swift.Sendable {
        /// The AWS account number specified in the AccountSettings container.
        public var awsAccountNumber: Swift.String?
        /// The default number of minutes (at the account level) a test run executes before it times out. The default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The maximum number of minutes a test run executes before it times out.
        public var maxJobTimeoutMinutes: Swift.Int?
        /// The maximum number of device slots that the AWS account can purchase. Each maximum is expressed as an offering-id:number pair, where the offering-id represents one of the IDs returned by the ListOfferings command.
        public var maxSlots: [Swift.String: Swift.Int]?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Information about an AWS account's usage of free trial device minutes.
        public var trialMinutes: DeviceFarmClientTypes.TrialMinutes?
        /// Returns the unmetered devices you have purchased or want to purchase.
        public var unmeteredDevices: [Swift.String: Swift.Int]?
        /// Returns the unmetered remote access devices you have purchased or want to purchase.
        public var unmeteredRemoteAccessDevices: [Swift.String: Swift.Int]?

        public init(
            awsAccountNumber: Swift.String? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            maxJobTimeoutMinutes: Swift.Int? = nil,
            maxSlots: [Swift.String: Swift.Int]? = nil,
            skipAppResign: Swift.Bool? = nil,
            trialMinutes: DeviceFarmClientTypes.TrialMinutes? = nil,
            unmeteredDevices: [Swift.String: Swift.Int]? = nil,
            unmeteredRemoteAccessDevices: [Swift.String: Swift.Int]? = nil
        )
        {
            self.awsAccountNumber = awsAccountNumber
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.maxJobTimeoutMinutes = maxJobTimeoutMinutes
            self.maxSlots = maxSlots
            self.skipAppResign = skipAppResign
            self.trialMinutes = trialMinutes
            self.unmeteredDevices = unmeteredDevices
            self.unmeteredRemoteAccessDevices = unmeteredRemoteAccessDevices
        }
    }
}

/// An invalid argument was specified.
public struct ArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeviceFarmClientTypes {

    public enum ArtifactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appiumJavaOutput
        case appiumJavaXmlOutput
        case appiumPythonOutput
        case appiumPythonXmlOutput
        case appiumServerOutput
        case applicationCrashReport
        case automationOutput
        case calabashJavaXmlOutput
        case calabashJsonOutput
        case calabashPrettyOutput
        case calabashStandardOutput
        case customerArtifact
        case customerArtifactLog
        case deviceLog
        case exerciserMonkeyOutput
        case explorerEventLog
        case explorerSummaryLog
        case instrumentationOutput
        case messageLog
        case resultLog
        case screenshot
        case serviceLog
        case testspecOutput
        case unknown
        case video
        case videoLog
        case webkitLog
        case xctestLog
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactType] {
            return [
                .appiumJavaOutput,
                .appiumJavaXmlOutput,
                .appiumPythonOutput,
                .appiumPythonXmlOutput,
                .appiumServerOutput,
                .applicationCrashReport,
                .automationOutput,
                .calabashJavaXmlOutput,
                .calabashJsonOutput,
                .calabashPrettyOutput,
                .calabashStandardOutput,
                .customerArtifact,
                .customerArtifactLog,
                .deviceLog,
                .exerciserMonkeyOutput,
                .explorerEventLog,
                .explorerSummaryLog,
                .instrumentationOutput,
                .messageLog,
                .resultLog,
                .screenshot,
                .serviceLog,
                .testspecOutput,
                .unknown,
                .video,
                .videoLog,
                .webkitLog,
                .xctestLog
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaOutput: return "APPIUM_JAVA_OUTPUT"
            case .appiumJavaXmlOutput: return "APPIUM_JAVA_XML_OUTPUT"
            case .appiumPythonOutput: return "APPIUM_PYTHON_OUTPUT"
            case .appiumPythonXmlOutput: return "APPIUM_PYTHON_XML_OUTPUT"
            case .appiumServerOutput: return "APPIUM_SERVER_OUTPUT"
            case .applicationCrashReport: return "APPLICATION_CRASH_REPORT"
            case .automationOutput: return "AUTOMATION_OUTPUT"
            case .calabashJavaXmlOutput: return "CALABASH_JAVA_XML_OUTPUT"
            case .calabashJsonOutput: return "CALABASH_JSON_OUTPUT"
            case .calabashPrettyOutput: return "CALABASH_PRETTY_OUTPUT"
            case .calabashStandardOutput: return "CALABASH_STANDARD_OUTPUT"
            case .customerArtifact: return "CUSTOMER_ARTIFACT"
            case .customerArtifactLog: return "CUSTOMER_ARTIFACT_LOG"
            case .deviceLog: return "DEVICE_LOG"
            case .exerciserMonkeyOutput: return "EXERCISER_MONKEY_OUTPUT"
            case .explorerEventLog: return "EXPLORER_EVENT_LOG"
            case .explorerSummaryLog: return "EXPLORER_SUMMARY_LOG"
            case .instrumentationOutput: return "INSTRUMENTATION_OUTPUT"
            case .messageLog: return "MESSAGE_LOG"
            case .resultLog: return "RESULT_LOG"
            case .screenshot: return "SCREENSHOT"
            case .serviceLog: return "SERVICE_LOG"
            case .testspecOutput: return "TESTSPEC_OUTPUT"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case .videoLog: return "VIDEO_LOG"
            case .webkitLog: return "WEBKIT_LOG"
            case .xctestLog: return "XCTEST_LOG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the output of a test. Examples of artifacts include logs and screenshots.
    public struct Artifact: Swift.Sendable {
        /// The artifact's ARN.
        public var arn: Swift.String?
        /// The artifact's file extension.
        public var `extension`: Swift.String?
        /// The artifact's name.
        public var name: Swift.String?
        /// The artifact's type. Allowed values include the following:
        ///
        /// * UNKNOWN
        ///
        /// * SCREENSHOT
        ///
        /// * DEVICE_LOG
        ///
        /// * MESSAGE_LOG
        ///
        /// * VIDEO_LOG
        ///
        /// * RESULT_LOG
        ///
        /// * SERVICE_LOG
        ///
        /// * WEBKIT_LOG
        ///
        /// * INSTRUMENTATION_OUTPUT
        ///
        /// * EXERCISER_MONKEY_OUTPUT: the artifact (log) generated by an Android fuzz test.
        ///
        /// * APPIUM_SERVER_OUTPUT
        ///
        /// * APPIUM_JAVA_OUTPUT
        ///
        /// * APPIUM_JAVA_XML_OUTPUT
        ///
        /// * APPIUM_PYTHON_OUTPUT
        ///
        /// * APPIUM_PYTHON_XML_OUTPUT
        ///
        /// * APPLICATION_CRASH_REPORT
        ///
        /// * XCTEST_LOG
        ///
        /// * VIDEO
        ///
        /// * CUSTOMER_ARTIFACT
        ///
        /// * CUSTOMER_ARTIFACT_LOG
        ///
        /// * TESTSPEC_OUTPUT
        public var type: DeviceFarmClientTypes.ArtifactType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the artifact's file.
        public var url: Swift.String?

        public init(
            arn: Swift.String? = nil,
            `extension`: Swift.String? = nil,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.ArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.`extension` = `extension`
            self.name = name
            self.type = type
            self.url = url
        }
    }
}

extension DeviceFarmClientTypes {

    public enum ArtifactCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case file
        case log
        case screenshot
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactCategory] {
            return [
                .file,
                .log,
                .screenshot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .file: return "FILE"
            case .log: return "LOG"
            case .screenshot: return "SCREENSHOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum BillingMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case metered
        case unmetered
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingMethod] {
            return [
                .metered,
                .unmetered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .metered: return "METERED"
            case .unmetered: return "UNMETERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested object could not be deleted.
public struct CannotDeleteException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CannotDeleteException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeviceFarmClientTypes {

    /// Represents entity counters.
    public struct Counters: Swift.Sendable {
        /// The number of errored entities.
        public var errored: Swift.Int?
        /// The number of failed entities.
        public var failed: Swift.Int?
        /// The number of passed entities.
        public var passed: Swift.Int?
        /// The number of skipped entities.
        public var skipped: Swift.Int?
        /// The number of stopped entities.
        public var stopped: Swift.Int?
        /// The total number of entities.
        public var total: Swift.Int?
        /// The number of warned entities.
        public var warned: Swift.Int?

        public init(
            errored: Swift.Int? = nil,
            failed: Swift.Int? = nil,
            passed: Swift.Int? = nil,
            skipped: Swift.Int? = nil,
            stopped: Swift.Int? = nil,
            total: Swift.Int? = nil,
            warned: Swift.Int? = nil
        )
        {
            self.errored = errored
            self.failed = failed
            self.passed = passed
            self.skipped = skipped
            self.stopped = stopped
            self.total = total
            self.warned = warned
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the amount of CPU that an app is using on a physical device. Does not represent system-wide CPU usage.
    public struct CPU: Swift.Sendable {
        /// The CPU's architecture (for example, x86 or ARM).
        public var architecture: Swift.String?
        /// The clock speed of the device's CPU, expressed in hertz (Hz). For example, a 1.2 GHz CPU is expressed as 1200000000.
        public var clock: Swift.Double?
        /// The CPU's frequency.
        public var frequency: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            clock: Swift.Double? = nil,
            frequency: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.clock = clock
            self.frequency = frequency
        }
    }
}

/// A limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified entity was not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// There was a problem with the service account.
public struct ServiceAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceAccountException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeviceFarmClientTypes {

    public enum DeviceAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appiumVersion
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAttribute] {
            return [
                .appiumVersion,
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appiumVersion: return "APPIUM_VERSION"
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum RuleOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case greaterThan
        case greaterThanOrEquals
        case `in`
        case lessThan
        case lessThanOrEquals
        case notIn
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleOperator] {
            return [
                .contains,
                .equals,
                .greaterThan,
                .greaterThanOrEquals,
                .in,
                .lessThan,
                .lessThanOrEquals,
                .notIn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .greaterThan: return "GREATER_THAN"
            case .greaterThanOrEquals: return "GREATER_THAN_OR_EQUALS"
            case .in: return "IN"
            case .lessThan: return "LESS_THAN"
            case .lessThanOrEquals: return "LESS_THAN_OR_EQUALS"
            case .notIn: return "NOT_IN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a condition for a device pool.
    public struct Rule: Swift.Sendable {
        /// The rule's stringified attribute. For example, specify the value as "\"abc\"". The supported operators for each attribute are provided in the following list. APPIUM_VERSION The Appium version for the test. Supported operators: CONTAINS ARN The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example. Supported operators: EQUALS, IN, NOT_IN AVAILABILITY The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS FLEET_TYPE The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS FORM_FACTOR The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS, IN, NOT_IN INSTANCE_ARN The Amazon Resource Name (ARN) of the device instance. Supported operators: IN, NOT_IN INSTANCE_LABELS The label of the device instance. Supported operators: CONTAINS MANUFACTURER The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN MODEL The device model, such as Apple iPad Air 2 or Google Pixel. Supported operators: CONTAINS, EQUALS, IN, NOT_IN OS_VERSION The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN PLATFORM The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS, IN, NOT_IN REMOTE_ACCESS_ENABLED Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS REMOTE_DEBUG_ENABLED Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored.
        public var attribute: DeviceFarmClientTypes.DeviceAttribute?
        /// Specifies how Device Farm compares the rule's attribute to the value. For the operators that are supported by each attribute, see the attribute descriptions.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// The rule's value.
        public var value: Swift.String?

        public init(
            attribute: DeviceFarmClientTypes.DeviceAttribute? = nil,
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            value: Swift.String? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.value = value
        }
    }
}

/// Represents a request to the create device pool operation.
public struct CreateDevicePoolInput: Swift.Sendable {
    /// The device pool's description.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
    public var maxDevices: Swift.Int?
    /// The device pool's name.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the device pool.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The device pool's rules.
    /// This member is required.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init(
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.projectArn = projectArn
        self.rules = rules
    }
}

extension DeviceFarmClientTypes {

    public enum DevicePoolType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [DevicePoolType] {
            return [
                .curated,
                .private
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a collection of device types.
    public struct DevicePool: Swift.Sendable {
        /// The device pool's ARN.
        public var arn: Swift.String?
        /// The device pool's description.
        public var description: Swift.String?
        /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests.
        public var maxDevices: Swift.Int?
        /// The device pool's name.
        public var name: Swift.String?
        /// Information about the device pool's rules.
        public var rules: [DeviceFarmClientTypes.Rule]?
        /// The device pool's type. Allowed values include:
        ///
        /// * CURATED: A device pool that is created and managed by AWS Device Farm.
        ///
        /// * PRIVATE: A device pool that is created and managed by the device pool developer.
        public var type: DeviceFarmClientTypes.DevicePoolType?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            maxDevices: Swift.Int? = nil,
            name: Swift.String? = nil,
            rules: [DeviceFarmClientTypes.Rule]? = nil,
            type: DeviceFarmClientTypes.DevicePoolType? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.maxDevices = maxDevices
            self.name = name
            self.rules = rules
            self.type = type
        }
    }
}

/// Represents the result of a create device pool request.
public struct CreateDevicePoolOutput: Swift.Sendable {
    /// The newly created device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init(
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

public struct CreateInstanceProfileInput: Swift.Sendable {
    /// The description of your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run. The list of packages is considered only if you set packageCleanup to true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The name of your instance profile.
    /// This member is required.
    public var name: Swift.String?
    /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
    public var packageCleanup: Swift.Bool?
    /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
    public var rebootAfterUse: Swift.Bool?

    public init(
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

extension DeviceFarmClientTypes {

    /// Represents the instance profile.
    public struct InstanceProfile: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the instance profile.
        public var arn: Swift.String?
        /// The description of the instance profile.
        public var description: Swift.String?
        /// An array of strings containing the list of app packages that should not be cleaned up from the device after a test run completes. The list of packages is considered only if you set packageCleanup to true.
        public var excludeAppPackagesFromCleanup: [Swift.String]?
        /// The name of the instance profile.
        public var name: Swift.String?
        /// When set to true, Device Farm removes app packages after a test run. The default value is false for private devices.
        public var packageCleanup: Swift.Bool?
        /// When set to true, Device Farm reboots the instance after a test run. The default value is true.
        public var rebootAfterUse: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            excludeAppPackagesFromCleanup: [Swift.String]? = nil,
            name: Swift.String? = nil,
            packageCleanup: Swift.Bool? = nil,
            rebootAfterUse: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
            self.name = name
            self.packageCleanup = packageCleanup
            self.rebootAfterUse = rebootAfterUse
        }
    }
}

public struct CreateInstanceProfileOutput: Swift.Sendable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init(
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

extension DeviceFarmClientTypes {

    public enum NetworkProfileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkProfileType] {
            return [
                .curated,
                .private
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateNetworkProfileInput: Swift.Sendable {
    /// The description of the network profile.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int?
    /// The name for the new network profile.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a network profile.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The type of network profile to create. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
    public var uplinkLossPercent: Swift.Int?

    public init(
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int? = 0,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int? = 0
    )
    {
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.projectArn = projectArn
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

extension DeviceFarmClientTypes {

    /// An array of settings that describes characteristics of a network profile.
    public struct NetworkProfile: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the network profile.
        public var arn: Swift.String?
        /// The description of the network profile.
        public var description: Swift.String?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var downlinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var downlinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var downlinkJitterMs: Swift.Int?
        /// Proportion of received packets that fail to arrive from 0 to 100 percent.
        public var downlinkLossPercent: Swift.Int
        /// The name of the network profile.
        public var name: Swift.String?
        /// The type of network profile. Valid values are listed here.
        public var type: DeviceFarmClientTypes.NetworkProfileType?
        /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
        public var uplinkBandwidthBits: Swift.Int?
        /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
        public var uplinkDelayMs: Swift.Int?
        /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
        public var uplinkJitterMs: Swift.Int?
        /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
        public var uplinkLossPercent: Swift.Int

        public init(
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            downlinkBandwidthBits: Swift.Int? = nil,
            downlinkDelayMs: Swift.Int? = nil,
            downlinkJitterMs: Swift.Int? = nil,
            downlinkLossPercent: Swift.Int = 0,
            name: Swift.String? = nil,
            type: DeviceFarmClientTypes.NetworkProfileType? = nil,
            uplinkBandwidthBits: Swift.Int? = nil,
            uplinkDelayMs: Swift.Int? = nil,
            uplinkJitterMs: Swift.Int? = nil,
            uplinkLossPercent: Swift.Int = 0
        )
        {
            self.arn = arn
            self.description = description
            self.downlinkBandwidthBits = downlinkBandwidthBits
            self.downlinkDelayMs = downlinkDelayMs
            self.downlinkJitterMs = downlinkJitterMs
            self.downlinkLossPercent = downlinkLossPercent
            self.name = name
            self.type = type
            self.uplinkBandwidthBits = uplinkBandwidthBits
            self.uplinkDelayMs = uplinkDelayMs
            self.uplinkJitterMs = uplinkJitterMs
            self.uplinkLossPercent = uplinkLossPercent
        }
    }
}

public struct CreateNetworkProfileOutput: Swift.Sendable {
    /// The network profile that is returned by the create network profile request.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init(
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

/// The operation was not successful. Try again.
public struct TagOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

extension DeviceFarmClientTypes {

    /// Contains the VPC configuration data necessary to interface with AWS Device Farm's services.
    public struct VpcConfig: Swift.Sendable {
        /// An array of one or more security groups IDs in your Amazon VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// An array of one or more subnet IDs in your Amazon VPC.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the Amazon VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

/// Represents a request to the create project operation.
public struct CreateProjectInput: Swift.Sendable {
    /// Sets the execution timeout value (in minutes) for a project. All test runs in this project use the specified execution timeout value unless overridden when scheduling a run.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// The project's name.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

    public init(
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
    )
    {
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

extension DeviceFarmClientTypes {

    /// Represents an operating-system neutral workspace for running and managing tests.
    public struct Project: Swift.Sendable {
        /// The project's ARN.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: Foundation.Date?
        /// The default number of minutes (at the project level) a test run executes before it times out. The default value is 150 minutes.
        public var defaultJobTimeoutMinutes: Swift.Int?
        /// The project's name.
        public var name: Swift.String?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

        public init(
            arn: Swift.String? = nil,
            created: Foundation.Date? = nil,
            defaultJobTimeoutMinutes: Swift.Int? = nil,
            name: Swift.String? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
            self.name = name
            self.vpcConfig = vpcConfig
        }
    }
}

/// Represents the result of a create project request.
public struct CreateProjectOutput: Swift.Sendable {
    /// The newly created project.
    public var project: DeviceFarmClientTypes.Project?

    public init(
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

extension DeviceFarmClientTypes {

    /// Configuration settings for a remote access session, including billing method.
    public struct CreateRemoteAccessSessionConfiguration: Swift.Sendable {
        /// The billing method for the remote access session.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// An array of ARNs included in the VPC endpoint configuration.
        public var vpceConfigurationArns: [Swift.String]?

        public init(
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.billingMethod = billingMethod
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }
}

extension DeviceFarmClientTypes {

    public enum InteractionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case interactive
        case noVideo
        case videoOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [InteractionMode] {
            return [
                .interactive,
                .noVideo,
                .videoOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .interactive: return "INTERACTIVE"
            case .noVideo: return "NO_VIDEO"
            case .videoOnly: return "VIDEO_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Creates and submits a request to start a remote access session.
public struct CreateRemoteAccessSessionInput: Swift.Sendable {
    /// Unique identifier for the client. If you want access to multiple devices on the same client, you should pass the same clientId value in each call to CreateRemoteAccessSession. This identifier is required only if remoteDebugEnabled is set to true. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var clientId: Swift.String?
    /// The configuration information for the remote access session request.
    public var configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?
    /// The ARN of the device for which you want to create a remote access session.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the device instance for which you want to create a remote access session.
    public var instanceArn: Swift.String?
    /// The interaction mode of the remote access session. Valid values are:
    ///
    /// * INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.
    ///
    /// * NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.
    ///
    /// * VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
    public var interactionMode: DeviceFarmClientTypes.InteractionMode?
    /// The name of the remote access session to create.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the project for which you want to create a remote access session.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Set to true if you want to access devices remotely for debugging in your remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var remoteDebugEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) for the app to be recorded in the remote access session.
    public var remoteRecordAppArn: Swift.String?
    /// Set to true to enable remote recording for the remote access session.
    public var remoteRecordEnabled: Swift.Bool?
    /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information on how Device Farm modifies your uploads during tests, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/)
    public var skipAppResign: Swift.Bool?
    /// Ignored. The public key of the ssh key pair you want to use for connecting to remote devices in your remote debugging session. This key is required only if remoteDebugEnabled is set to true. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
    public var sshPublicKey: Swift.String?

    public init(
        clientId: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration? = nil,
        deviceArn: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        remoteDebugEnabled: Swift.Bool? = nil,
        remoteRecordAppArn: Swift.String? = nil,
        remoteRecordEnabled: Swift.Bool? = nil,
        skipAppResign: Swift.Bool? = nil,
        sshPublicKey: Swift.String? = nil
    )
    {
        self.clientId = clientId
        self.configuration = configuration
        self.deviceArn = deviceArn
        self.instanceArn = instanceArn
        self.interactionMode = interactionMode
        self.name = name
        self.projectArn = projectArn
        self.remoteDebugEnabled = remoteDebugEnabled
        self.remoteRecordAppArn = remoteRecordAppArn
        self.remoteRecordEnabled = remoteRecordEnabled
        self.skipAppResign = skipAppResign
        self.sshPublicKey = sshPublicKey
    }
}

extension DeviceFarmClientTypes {

    public enum DeviceAvailability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case busy
        case highlyAvailable
        case temporaryNotAvailable
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceAvailability] {
            return [
                .available,
                .busy,
                .highlyAvailable,
                .temporaryNotAvailable
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .busy: return "BUSY"
            case .highlyAvailable: return "HIGHLY_AVAILABLE"
            case .temporaryNotAvailable: return "TEMPORARY_NOT_AVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum DeviceFormFactor: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case phone
        case tablet
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFormFactor] {
            return [
                .phone,
                .tablet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .phone: return "PHONE"
            case .tablet: return "TABLET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum InstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case inUse
        case notAvailable
        case preparing
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .available,
                .inUse,
                .notAvailable,
                .preparing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .inUse: return "IN_USE"
            case .notAvailable: return "NOT_AVAILABLE"
            case .preparing: return "PREPARING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the device instance.
    public struct DeviceInstance: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the device instance.
        public var arn: Swift.String?
        /// The ARN of the device.
        public var deviceArn: Swift.String?
        /// A object that contains information about the instance profile.
        public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?
        /// An array of strings that describe the device instance.
        public var labels: [Swift.String]?
        /// The status of the device instance. Valid values are listed here.
        public var status: DeviceFarmClientTypes.InstanceStatus?
        /// Unique device identifier for the device instance.
        public var udid: Swift.String?

        public init(
            arn: Swift.String? = nil,
            deviceArn: Swift.String? = nil,
            instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil,
            labels: [Swift.String]? = nil,
            status: DeviceFarmClientTypes.InstanceStatus? = nil,
            udid: Swift.String? = nil
        )
        {
            self.arn = arn
            self.deviceArn = deviceArn
            self.instanceProfile = instanceProfile
            self.labels = labels
            self.status = status
            self.udid = udid
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the screen resolution of a device in height and width, expressed in pixels.
    public struct Resolution: Swift.Sendable {
        /// The screen resolution's height, expressed in pixels.
        public var height: Swift.Int?
        /// The screen resolution's width, expressed in pixels.
        public var width: Swift.Int?

        public init(
            height: Swift.Int? = nil,
            width: Swift.Int? = nil
        )
        {
            self.height = height
            self.width = width
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a device type that an app is tested against.
    public struct Device: Swift.Sendable {
        /// The device's ARN.
        public var arn: Swift.String?
        /// Indicates how likely a device is available for a test run. Currently available in the [ListDevices] and GetDevice API methods.
        public var availability: DeviceFarmClientTypes.DeviceAvailability?
        /// The device's carrier.
        public var carrier: Swift.String?
        /// Information about the device's CPU.
        public var cpu: DeviceFarmClientTypes.CPU?
        /// The name of the fleet to which this device belongs.
        public var fleetName: Swift.String?
        /// The type of fleet to which this device belongs. Possible values are PRIVATE and PUBLIC.
        public var fleetType: Swift.String?
        /// The device's form factor. Allowed values include:
        ///
        /// * PHONE
        ///
        /// * TABLET
        public var formFactor: DeviceFarmClientTypes.DeviceFormFactor?
        /// The device's heap size, expressed in bytes.
        public var heapSize: Swift.Int?
        /// The device's image name.
        public var image: Swift.String?
        /// The instances that belong to this device.
        public var instances: [DeviceFarmClientTypes.DeviceInstance]?
        /// The device's manufacturer name.
        public var manufacturer: Swift.String?
        /// The device's total memory size, expressed in bytes.
        public var memory: Swift.Int?
        /// The device's model name.
        public var model: Swift.String?
        /// The device's model ID.
        public var modelId: Swift.String?
        /// The device's display name.
        public var name: Swift.String?
        /// The device's operating system type.
        public var os: Swift.String?
        /// The device's platform. Allowed values include:
        ///
        /// * ANDROID
        ///
        /// * IOS
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// The device's radio.
        public var radio: Swift.String?
        /// Specifies whether remote access has been enabled for the specified device.
        public var remoteAccessEnabled: Swift.Bool?
        /// This flag is set to true if remote debugging is enabled for the device. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var remoteDebugEnabled: Swift.Bool?
        /// The resolution of the device.
        public var resolution: DeviceFarmClientTypes.Resolution?

        public init(
            arn: Swift.String? = nil,
            availability: DeviceFarmClientTypes.DeviceAvailability? = nil,
            carrier: Swift.String? = nil,
            cpu: DeviceFarmClientTypes.CPU? = nil,
            fleetName: Swift.String? = nil,
            fleetType: Swift.String? = nil,
            formFactor: DeviceFarmClientTypes.DeviceFormFactor? = nil,
            heapSize: Swift.Int? = nil,
            image: Swift.String? = nil,
            instances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
            manufacturer: Swift.String? = nil,
            memory: Swift.Int? = nil,
            model: Swift.String? = nil,
            modelId: Swift.String? = nil,
            name: Swift.String? = nil,
            os: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radio: Swift.String? = nil,
            remoteAccessEnabled: Swift.Bool? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            resolution: DeviceFarmClientTypes.Resolution? = nil
        )
        {
            self.arn = arn
            self.availability = availability
            self.carrier = carrier
            self.cpu = cpu
            self.fleetName = fleetName
            self.fleetType = fleetType
            self.formFactor = formFactor
            self.heapSize = heapSize
            self.image = image
            self.instances = instances
            self.manufacturer = manufacturer
            self.memory = memory
            self.model = model
            self.modelId = modelId
            self.name = name
            self.os = os
            self.platform = platform
            self.radio = radio
            self.remoteAccessEnabled = remoteAccessEnabled
            self.remoteDebugEnabled = remoteDebugEnabled
            self.resolution = resolution
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the total (metered or unmetered) minutes used by the resource to run tests. Contains the sum of minutes consumed by all children.
    public struct DeviceMinutes: Swift.Sendable {
        /// When specified, represents only the sum of metered minutes used by the resource to run tests.
        public var metered: Swift.Double?
        /// When specified, represents the total minutes used by the resource to run tests.
        public var total: Swift.Double?
        /// When specified, represents only the sum of unmetered minutes used by the resource to run tests.
        public var unmetered: Swift.Double?

        public init(
            metered: Swift.Double? = nil,
            total: Swift.Double? = nil,
            unmetered: Swift.Double? = nil
        )
        {
            self.metered = metered
            self.total = total
            self.unmetered = unmetered
        }
    }
}

extension DeviceFarmClientTypes {

    public enum ExecutionResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case errored
        case failed
        case passed
        case pending
        case skipped
        case stopped
        case warned
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResult] {
            return [
                .errored,
                .failed,
                .passed,
                .pending,
                .skipped,
                .stopped,
                .warned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .errored: return "ERRORED"
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .pending: return "PENDING"
            case .skipped: return "SKIPPED"
            case .stopped: return "STOPPED"
            case .warned: return "WARNED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum ExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case pending
        case pendingConcurrnecy
        case pendingDevice
        case preparing
        case processing
        case running
        case scheduling
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .completed,
                .pending,
                .pendingConcurrnecy,
                .pendingDevice,
                .preparing,
                .processing,
                .running,
                .scheduling,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .pendingConcurrnecy: return "PENDING_CONCURRENCY"
            case .pendingDevice: return "PENDING_DEVICE"
            case .preparing: return "PREPARING"
            case .processing: return "PROCESSING"
            case .running: return "RUNNING"
            case .scheduling: return "SCHEDULING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents information about the remote access session.
    public struct RemoteAccessSession: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the remote access session.
        public var arn: Swift.String?
        /// The billing method of the remote access session. Possible values include METERED or UNMETERED. For more information about metered devices, see [AWS Device Farm terminology](https://docs.aws.amazon.com/devicefarm/latest/developerguide/welcome.html#welcome-terminology).
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Unique identifier of your client for the remote access session. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var clientId: Swift.String?
        /// The date and time the remote access session was created.
        public var created: Foundation.Date?
        /// The device (phone or tablet) used in the remote access session.
        public var device: DeviceFarmClientTypes.Device?
        /// The number of minutes a device is used in a remote access session (including setup and teardown minutes).
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// Unique device identifier for the remote device. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var deviceUdid: Swift.String?
        /// The endpoint for the remote access sesssion.
        public var endpoint: Swift.String?
        /// IP address of the EC2 host where you need to connect to remotely debug devices. Only returned if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var hostAddress: Swift.String?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// The interaction mode of the remote access session. Valid values are:
        ///
        /// * INTERACTIVE: You can interact with the iOS device by viewing, touching, and rotating the screen. You cannot run XCUITest framework-based tests in this mode.
        ///
        /// * NO_VIDEO: You are connected to the device, but cannot interact with it or view the screen. This mode has the fastest test execution speed. You can run XCUITest framework-based tests in this mode.
        ///
        /// * VIDEO_ONLY: You can view the screen, but cannot touch or rotate it. You can run XCUITest framework-based tests and watch the screen in this mode.
        public var interactionMode: DeviceFarmClientTypes.InteractionMode?
        /// A message about the remote access session.
        public var message: Swift.String?
        /// The name of the remote access session.
        public var name: Swift.String?
        /// This flag is set to true if remote debugging is enabled for the remote access session. Remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html).
        public var remoteDebugEnabled: Swift.Bool?
        /// The ARN for the app to be recorded in the remote access session.
        public var remoteRecordAppArn: Swift.String?
        /// This flag is set to true if remote recording is enabled for the remote access session.
        public var remoteRecordEnabled: Swift.Bool?
        /// The result of the remote access session. Can be any of the following:
        ///
        /// * PENDING.
        ///
        /// * PASSED.
        ///
        /// * WARNED.
        ///
        /// * FAILED.
        ///
        /// * SKIPPED.
        ///
        /// * ERRORED.
        ///
        /// * STOPPED.
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The date and time the remote access session was started.
        public var started: Foundation.Date?
        /// The status of the remote access session. Can be any of the following:
        ///
        /// * PENDING.
        ///
        /// * PENDING_CONCURRENCY.
        ///
        /// * PENDING_DEVICE.
        ///
        /// * PROCESSING.
        ///
        /// * SCHEDULING.
        ///
        /// * PREPARING.
        ///
        /// * RUNNING.
        ///
        /// * COMPLETED.
        ///
        /// * STOPPING.
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The date and time the remote access session was stopped.
        public var stopped: Foundation.Date?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

        public init(
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            clientId: Swift.String? = nil,
            created: Foundation.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            deviceUdid: Swift.String? = nil,
            endpoint: Swift.String? = nil,
            hostAddress: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            interactionMode: DeviceFarmClientTypes.InteractionMode? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            remoteDebugEnabled: Swift.Bool? = nil,
            remoteRecordAppArn: Swift.String? = nil,
            remoteRecordEnabled: Swift.Bool? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: Foundation.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: Foundation.Date? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.billingMethod = billingMethod
            self.clientId = clientId
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.deviceUdid = deviceUdid
            self.endpoint = endpoint
            self.hostAddress = hostAddress
            self.instanceArn = instanceArn
            self.interactionMode = interactionMode
            self.message = message
            self.name = name
            self.remoteDebugEnabled = remoteDebugEnabled
            self.remoteRecordAppArn = remoteRecordAppArn
            self.remoteRecordEnabled = remoteRecordEnabled
            self.result = result
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.vpcConfig = vpcConfig
        }
    }
}

/// Represents the server response from a request to create a remote access session.
public struct CreateRemoteAccessSessionOutput: Swift.Sendable {
    /// A container that describes the remote access session when the request to create a remote access session is sent.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init(
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

/// An internal exception was raised in the service. Contact [aws-devicefarm-support@amazon.com](mailto:aws-devicefarm-support@amazon.com) if you see this error.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeviceFarmClientTypes {

    /// The VPC security groups and subnets that are attached to a project.
    public struct TestGridVpcConfig: Swift.Sendable {
        /// A list of VPC security group IDs in your Amazon VPC.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// A list of VPC subnet IDs in your Amazon VPC.
        /// This member is required.
        public var subnetIds: [Swift.String]?
        /// The ID of the Amazon VPC.
        /// This member is required.
        public var vpcId: Swift.String?

        public init(
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }
}

public struct CreateTestGridProjectInput: Swift.Sendable {
    /// Human-readable description of the project.
    public var description: Swift.String?
    /// Human-readable name of the Selenium testing project.
    /// This member is required.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

extension DeviceFarmClientTypes {

    /// A Selenium testing project. Projects are used to collect and collate sessions.
    public struct TestGridProject: Swift.Sendable {
        /// The ARN for the project.
        public var arn: Swift.String?
        /// When the project was created.
        public var created: Foundation.Date?
        /// A human-readable description for the project.
        public var description: Swift.String?
        /// A human-readable name for the project.
        public var name: Swift.String?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

        public init(
            arn: Swift.String? = nil,
            created: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
        )
        {
            self.arn = arn
            self.created = created
            self.description = description
            self.name = name
            self.vpcConfig = vpcConfig
        }
    }
}

public struct CreateTestGridProjectOutput: Swift.Sendable {
    /// ARN of the Selenium testing project that was created.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init(
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

public struct CreateTestGridUrlInput: Swift.Sendable {
    /// Lifetime, in seconds, of the URL.
    /// This member is required.
    public var expiresInSeconds: Swift.Int?
    /// ARN (from [CreateTestGridProject] or [ListTestGridProjects]) to associate with the short-term URL.
    /// This member is required.
    public var projectArn: Swift.String?

    public init(
        expiresInSeconds: Swift.Int? = nil,
        projectArn: Swift.String? = nil
    )
    {
        self.expiresInSeconds = expiresInSeconds
        self.projectArn = projectArn
    }
}

public struct CreateTestGridUrlOutput: Swift.Sendable {
    /// The number of seconds the URL from [CreateTestGridUrlResult$url] stays active.
    public var expires: Foundation.Date?
    /// A signed URL, expiring in [CreateTestGridUrlRequest$expiresInSeconds] seconds, to be passed to a RemoteWebDriver.
    public var url: Swift.String?

    public init(
        expires: Foundation.Date? = nil,
        url: Swift.String? = nil
    )
    {
        self.expires = expires
        self.url = url
    }
}

extension CreateTestGridUrlOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTestGridUrlOutput(expires: \(Swift.String(describing: expires)), url: \"CONTENT_REDACTED\")"}
}

extension DeviceFarmClientTypes {

    public enum UploadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case androidApp
        case appiumJavaJunitTestPackage
        case appiumJavaJunitTestSpec
        case appiumJavaTestngTestPackage
        case appiumJavaTestngTestSpec
        case appiumNodeTestPackage
        case appiumNodeTestSpec
        case appiumPythonTestPackage
        case appiumPythonTestSpec
        case appiumRubyTestPackage
        case appiumRubyTestSpec
        case appiumWebJavaJunitTestPackage
        case appiumWebJavaJunitTestSpec
        case appiumWebJavaTestngTestPackage
        case appiumWebJavaTestngTestSpec
        case appiumWebNodeTestPackage
        case appiumWebNodeTestSpec
        case appiumWebPythonTestPackage
        case appiumWebPythonTestSpec
        case appiumWebRubyTestPackage
        case appiumWebRubyTestSpec
        case calabashTestPackage
        case externalData
        case instrumentationTestPackage
        case instrumentationTestSpec
        case iosApp
        case uiautomationTestPackage
        case uiautomatorTestPackage
        case webApp
        case xctestTestPackage
        case xctestUiTestPackage
        case xctestUiTestSpec
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadType] {
            return [
                .androidApp,
                .appiumJavaJunitTestPackage,
                .appiumJavaJunitTestSpec,
                .appiumJavaTestngTestPackage,
                .appiumJavaTestngTestSpec,
                .appiumNodeTestPackage,
                .appiumNodeTestSpec,
                .appiumPythonTestPackage,
                .appiumPythonTestSpec,
                .appiumRubyTestPackage,
                .appiumRubyTestSpec,
                .appiumWebJavaJunitTestPackage,
                .appiumWebJavaJunitTestSpec,
                .appiumWebJavaTestngTestPackage,
                .appiumWebJavaTestngTestSpec,
                .appiumWebNodeTestPackage,
                .appiumWebNodeTestSpec,
                .appiumWebPythonTestPackage,
                .appiumWebPythonTestSpec,
                .appiumWebRubyTestPackage,
                .appiumWebRubyTestSpec,
                .calabashTestPackage,
                .externalData,
                .instrumentationTestPackage,
                .instrumentationTestSpec,
                .iosApp,
                .uiautomationTestPackage,
                .uiautomatorTestPackage,
                .webApp,
                .xctestTestPackage,
                .xctestUiTestPackage,
                .xctestUiTestSpec
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .androidApp: return "ANDROID_APP"
            case .appiumJavaJunitTestPackage: return "APPIUM_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumJavaJunitTestSpec: return "APPIUM_JAVA_JUNIT_TEST_SPEC"
            case .appiumJavaTestngTestPackage: return "APPIUM_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumJavaTestngTestSpec: return "APPIUM_JAVA_TESTNG_TEST_SPEC"
            case .appiumNodeTestPackage: return "APPIUM_NODE_TEST_PACKAGE"
            case .appiumNodeTestSpec: return "APPIUM_NODE_TEST_SPEC"
            case .appiumPythonTestPackage: return "APPIUM_PYTHON_TEST_PACKAGE"
            case .appiumPythonTestSpec: return "APPIUM_PYTHON_TEST_SPEC"
            case .appiumRubyTestPackage: return "APPIUM_RUBY_TEST_PACKAGE"
            case .appiumRubyTestSpec: return "APPIUM_RUBY_TEST_SPEC"
            case .appiumWebJavaJunitTestPackage: return "APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE"
            case .appiumWebJavaJunitTestSpec: return "APPIUM_WEB_JAVA_JUNIT_TEST_SPEC"
            case .appiumWebJavaTestngTestPackage: return "APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE"
            case .appiumWebJavaTestngTestSpec: return "APPIUM_WEB_JAVA_TESTNG_TEST_SPEC"
            case .appiumWebNodeTestPackage: return "APPIUM_WEB_NODE_TEST_PACKAGE"
            case .appiumWebNodeTestSpec: return "APPIUM_WEB_NODE_TEST_SPEC"
            case .appiumWebPythonTestPackage: return "APPIUM_WEB_PYTHON_TEST_PACKAGE"
            case .appiumWebPythonTestSpec: return "APPIUM_WEB_PYTHON_TEST_SPEC"
            case .appiumWebRubyTestPackage: return "APPIUM_WEB_RUBY_TEST_PACKAGE"
            case .appiumWebRubyTestSpec: return "APPIUM_WEB_RUBY_TEST_SPEC"
            case .calabashTestPackage: return "CALABASH_TEST_PACKAGE"
            case .externalData: return "EXTERNAL_DATA"
            case .instrumentationTestPackage: return "INSTRUMENTATION_TEST_PACKAGE"
            case .instrumentationTestSpec: return "INSTRUMENTATION_TEST_SPEC"
            case .iosApp: return "IOS_APP"
            case .uiautomationTestPackage: return "UIAUTOMATION_TEST_PACKAGE"
            case .uiautomatorTestPackage: return "UIAUTOMATOR_TEST_PACKAGE"
            case .webApp: return "WEB_APP"
            case .xctestTestPackage: return "XCTEST_TEST_PACKAGE"
            case .xctestUiTestPackage: return "XCTEST_UI_TEST_PACKAGE"
            case .xctestUiTestSpec: return "XCTEST_UI_TEST_SPEC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Represents a request to the create upload operation.
public struct CreateUploadInput: Swift.Sendable {
    /// The upload's content type (for example, application/octet-stream).
    public var contentType: Swift.String?
    /// The upload's file name. The name should not contain any forward slashes (/). If you are uploading an iOS app, the file name must end with the .ipa extension. If you are uploading an Android app, the file name must end with the .apk extension. For all others, the file name must end with the .zip file extension.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of the project for the upload.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The upload's upload type. Must be one of the following values:
    ///
    /// * ANDROID_APP
    ///
    /// * IOS_APP
    ///
    /// * WEB_APP
    ///
    /// * EXTERNAL_DATA
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_RUBY_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    /// * INSTRUMENTATION_TEST_PACKAGE
    ///
    /// * XCTEST_TEST_PACKAGE
    ///
    /// * XCTEST_UI_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_NODE_TEST_SPEC
    ///
    /// * APPIUM_RUBY_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_WEB_NODE_TEST_SPEC
    ///
    /// * APPIUM_WEB_RUBY_TEST_SPEC
    ///
    /// * INSTRUMENTATION_TEST_SPEC
    ///
    /// * XCTEST_UI_TEST_SPEC
    ///
    ///
    /// If you call CreateUpload with WEB_APP specified, AWS Device Farm throws an ArgumentException error.
    /// This member is required.
    public var type: DeviceFarmClientTypes.UploadType?

    public init(
        contentType: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.contentType = contentType
        self.name = name
        self.projectArn = projectArn
        self.type = type
    }
}

extension DeviceFarmClientTypes {

    public enum UploadCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case curated
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadCategory] {
            return [
                .curated,
                .private
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .curated: return "CURATED"
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    public enum UploadStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case initialized
        case processing
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [UploadStatus] {
            return [
                .failed,
                .initialized,
                .processing,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .initialized: return "INITIALIZED"
            case .processing: return "PROCESSING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// An app or a set of one or more tests to upload or that have been uploaded.
    public struct Upload: Swift.Sendable {
        /// The upload's ARN.
        public var arn: Swift.String?
        /// The upload's category. Allowed values include:
        ///
        /// * CURATED: An upload managed by AWS Device Farm.
        ///
        /// * PRIVATE: An upload managed by the AWS Device Farm customer.
        public var category: DeviceFarmClientTypes.UploadCategory?
        /// The upload's content type (for example, application/octet-stream).
        public var contentType: Swift.String?
        /// When the upload was created.
        public var created: Foundation.Date?
        /// A message about the upload's result.
        public var message: Swift.String?
        /// The upload's metadata. For example, for Android, this contains information that is parsed from the manifest and is displayed in the AWS Device Farm console after the associated app is uploaded.
        public var metadata: Swift.String?
        /// The upload's file name.
        public var name: Swift.String?
        /// The upload's status. Must be one of the following values:
        ///
        /// * FAILED
        ///
        /// * INITIALIZED
        ///
        /// * PROCESSING
        ///
        /// * SUCCEEDED
        public var status: DeviceFarmClientTypes.UploadStatus?
        /// The upload's type. Must be one of the following values:
        ///
        /// * ANDROID_APP
        ///
        /// * IOS_APP
        ///
        /// * WEB_APP
        ///
        /// * EXTERNAL_DATA
        ///
        /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
        ///
        /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
        ///
        /// * APPIUM_PYTHON_TEST_PACKAGE
        ///
        /// * APPIUM_NODE_TEST_PACKAGE
        ///
        /// * APPIUM_RUBY_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_NODE_TEST_PACKAGE
        ///
        /// * APPIUM_WEB_RUBY_TEST_PACKAGE
        ///
        /// * INSTRUMENTATION_TEST_PACKAGE
        ///
        /// * XCTEST_TEST_PACKAGE
        ///
        /// * XCTEST_UI_TEST_PACKAGE
        ///
        /// * APPIUM_JAVA_JUNIT_TEST_SPEC
        ///
        /// * APPIUM_JAVA_TESTNG_TEST_SPEC
        ///
        /// * APPIUM_PYTHON_TEST_SPEC
        ///
        /// * APPIUM_NODE_TEST_SPEC
        ///
        /// * APPIUM_RUBY_TEST_SPEC
        ///
        /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
        ///
        /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
        ///
        /// * APPIUM_WEB_PYTHON_TEST_SPEC
        ///
        /// * APPIUM_WEB_NODE_TEST_SPEC
        ///
        /// * APPIUM_WEB_RUBY_TEST_SPEC
        ///
        /// * INSTRUMENTATION_TEST_SPEC
        ///
        /// * XCTEST_UI_TEST_SPEC
        public var type: DeviceFarmClientTypes.UploadType?
        /// The presigned Amazon S3 URL that was used to store a file using a PUT request.
        public var url: Swift.String?

        public init(
            arn: Swift.String? = nil,
            category: DeviceFarmClientTypes.UploadCategory? = nil,
            contentType: Swift.String? = nil,
            created: Foundation.Date? = nil,
            message: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil,
            status: DeviceFarmClientTypes.UploadStatus? = nil,
            type: DeviceFarmClientTypes.UploadType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.category = category
            self.contentType = contentType
            self.created = created
            self.message = message
            self.metadata = metadata
            self.name = name
            self.status = status
            self.type = type
            self.url = url
        }
    }
}

extension DeviceFarmClientTypes.Upload: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Upload(arn: \(Swift.String(describing: arn)), category: \(Swift.String(describing: category)), contentType: \(Swift.String(describing: contentType)), created: \(Swift.String(describing: created)), message: \(Swift.String(describing: message)), metadata: \(Swift.String(describing: metadata)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), url: \"CONTENT_REDACTED\")"}
}

/// Represents the result of a create upload request.
public struct CreateUploadOutput: Swift.Sendable {
    /// The newly created upload.
    public var upload: DeviceFarmClientTypes.Upload?

    public init(
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

public struct CreateVPCEConfigurationInput: Swift.Sendable {
    /// The DNS name of the service running in your VPC that you want Device Farm to test.
    /// This member is required.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration, to manage your configurations more easily.
    /// This member is required.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    /// This member is required.
    public var vpceServiceName: Swift.String?

    public init(
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

extension DeviceFarmClientTypes {

    /// Represents an Amazon Virtual Private Cloud (VPC) endpoint configuration.
    public struct VPCEConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the VPC endpoint configuration.
        public var arn: Swift.String?
        /// The DNS name that maps to the private IP address of the service you want to access.
        public var serviceDnsName: Swift.String?
        /// An optional description that provides details about your VPC endpoint configuration.
        public var vpceConfigurationDescription: Swift.String?
        /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
        public var vpceConfigurationName: Swift.String?
        /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
        public var vpceServiceName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            serviceDnsName: Swift.String? = nil,
            vpceConfigurationDescription: Swift.String? = nil,
            vpceConfigurationName: Swift.String? = nil,
            vpceServiceName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.serviceDnsName = serviceDnsName
            self.vpceConfigurationDescription = vpceConfigurationDescription
            self.vpceConfigurationName = vpceConfigurationName
            self.vpceServiceName = vpceServiceName
        }
    }
}

public struct CreateVPCEConfigurationOutput: Swift.Sendable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init(
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

extension DeviceFarmClientTypes {

    public enum CurrencyCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .usd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// A JSON object that specifies the paths where the artifacts generated by the customer's tests, on the device or in the test environment, are pulled from. Specify deviceHostPaths and optionally specify either iosPaths or androidPaths. For web app tests, you can specify both iosPaths and androidPaths.
    public struct CustomerArtifactPaths: Swift.Sendable {
        /// Comma-separated list of paths on the Android device where the artifacts generated by the customer's tests are pulled from.
        public var androidPaths: [Swift.String]?
        /// Comma-separated list of paths in the test execution environment where the artifacts generated by the customer's tests are pulled from.
        public var deviceHostPaths: [Swift.String]?
        /// Comma-separated list of paths on the iOS device where the artifacts generated by the customer's tests are pulled from.
        public var iosPaths: [Swift.String]?

        public init(
            androidPaths: [Swift.String]? = nil,
            deviceHostPaths: [Swift.String]? = nil,
            iosPaths: [Swift.String]? = nil
        )
        {
            self.androidPaths = androidPaths
            self.deviceHostPaths = deviceHostPaths
            self.iosPaths = iosPaths
        }
    }
}

/// Represents a request to the delete device pool operation.
public struct DeleteDevicePoolInput: Swift.Sendable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm device pool to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a delete device pool request.
public struct DeleteDevicePoolOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInstanceProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the instance profile you are requesting to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteInstanceProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteNetworkProfileInput: Swift.Sendable {
    /// The ARN of the network profile to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteNetworkProfileOutput: Swift.Sendable {

    public init() { }
}

/// Represents a request to the delete project operation.
public struct DeleteProjectInput: Swift.Sendable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm project to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a delete project request.
public struct DeleteProjectOutput: Swift.Sendable {

    public init() { }
}

/// Represents the request to delete the specified remote access session.
public struct DeleteRemoteAccessSessionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the session for which you want to delete remote access.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// The response from the server when a request is made to delete the remote access session.
public struct DeleteRemoteAccessSessionOutput: Swift.Sendable {

    public init() { }
}

/// Represents a request to the delete run operation.
public struct DeleteRunInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for the run to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a delete run request.
public struct DeleteRunOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTestGridProjectInput: Swift.Sendable {
    /// The ARN of the project to delete, from [CreateTestGridProject] or [ListTestGridProjects].
    /// This member is required.
    public var projectArn: Swift.String?

    public init(
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

public struct DeleteTestGridProjectOutput: Swift.Sendable {

    public init() { }
}

/// Represents a request to the delete upload operation.
public struct DeleteUploadInput: Swift.Sendable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm upload to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a delete upload request.
public struct DeleteUploadOutput: Swift.Sendable {

    public init() { }
}

/// There was an error with the update request, or you do not have sufficient permissions to update this VPC endpoint configuration.
public struct InvalidOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteVPCEConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to delete.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeleteVPCEConfigurationOutput: Swift.Sendable {

    public init() { }
}

/// Represents the request sent to retrieve the account settings.
public struct GetAccountSettingsInput: Swift.Sendable {

    public init() { }
}

/// Represents the account settings return values from the GetAccountSettings request.
public struct GetAccountSettingsOutput: Swift.Sendable {
    /// The account settings.
    public var accountSettings: DeviceFarmClientTypes.AccountSettings?

    public init(
        accountSettings: DeviceFarmClientTypes.AccountSettings? = nil
    )
    {
        self.accountSettings = accountSettings
    }
}

/// Represents a request to the get device request.
public struct GetDeviceInput: Swift.Sendable {
    /// The device type's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a get device request.
public struct GetDeviceOutput: Swift.Sendable {
    /// An object that contains information about the requested device.
    public var device: DeviceFarmClientTypes.Device?

    public init(
        device: DeviceFarmClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

public struct GetDeviceInstanceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the instance you're requesting information about.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetDeviceInstanceOutput: Swift.Sendable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init(
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

/// Represents a request to the get device pool operation.
public struct GetDevicePoolInput: Swift.Sendable {
    /// The device pool's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a get device pool request.
public struct GetDevicePoolOutput: Swift.Sendable {
    /// An object that contains information about the requested device pool.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init(
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

extension DeviceFarmClientTypes {

    /// Represents a latitude and longitude pair, expressed in geographic coordinate system degrees (for example, 47.6204, -122.3491). Elevation is currently not supported.
    public struct Location: Swift.Sendable {
        /// The latitude.
        /// This member is required.
        public var latitude: Swift.Double?
        /// The longitude.
        /// This member is required.
        public var longitude: Swift.Double?

        public init(
            latitude: Swift.Double? = nil,
            longitude: Swift.Double? = nil
        )
        {
            self.latitude = latitude
            self.longitude = longitude
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the set of radios and their states on a device. Examples of radios include Wi-Fi, GPS, Bluetooth, and NFC.
    public struct Radios: Swift.Sendable {
        /// True if Bluetooth is enabled at the beginning of the test. Otherwise, false.
        public var bluetooth: Swift.Bool?
        /// True if GPS is enabled at the beginning of the test. Otherwise, false.
        public var gps: Swift.Bool?
        /// True if NFC is enabled at the beginning of the test. Otherwise, false.
        public var nfc: Swift.Bool?
        /// True if Wi-Fi is enabled at the beginning of the test. Otherwise, false.
        public var wifi: Swift.Bool?

        public init(
            bluetooth: Swift.Bool? = nil,
            gps: Swift.Bool? = nil,
            nfc: Swift.Bool? = nil,
            wifi: Swift.Bool? = nil
        )
        {
            self.bluetooth = bluetooth
            self.gps = gps
            self.nfc = nfc
            self.wifi = wifi
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the settings for a run. Includes things like location, radio states, auxiliary apps, and network profiles.
    public struct ScheduleRunConfiguration: Swift.Sendable {
        /// A list of upload ARNs for app packages to be installed with your app.
        public var auxiliaryApps: [Swift.String]?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered. If you have purchased unmetered device slots, you must set this parameter to unmetered to make use of them. Otherwise, your run counts against your metered time.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// Input CustomerArtifactPaths object for the scheduled run configuration.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// The ARN of the extra data for the run. The extra data is a .zip file that AWS Device Farm extracts to external data for Android or the app's sandbox for iOS.
        public var extraDataPackageArn: Swift.String?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// Reserved for internal use.
        public var networkProfileArn: Swift.String?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// An array of ARNs for your VPC endpoint configurations.
        public var vpceConfigurationArns: [Swift.String]?

        public init(
            auxiliaryApps: [Swift.String]? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            extraDataPackageArn: Swift.String? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            networkProfileArn: Swift.String? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            vpceConfigurationArns: [Swift.String]? = nil
        )
        {
            self.auxiliaryApps = auxiliaryApps
            self.billingMethod = billingMethod
            self.customerArtifactPaths = customerArtifactPaths
            self.extraDataPackageArn = extraDataPackageArn
            self.locale = locale
            self.location = location
            self.networkProfileArn = networkProfileArn
            self.radios = radios
            self.vpceConfigurationArns = vpceConfigurationArns
        }
    }
}

extension DeviceFarmClientTypes {

    public enum TestType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appiumJavaJunit
        case appiumJavaTestng
        case appiumNode
        case appiumPython
        case appiumRuby
        case appiumWebJavaJunit
        case appiumWebJavaTestng
        case appiumWebNode
        case appiumWebPython
        case appiumWebRuby
        case builtinFuzz
        case instrumentation
        case xctest
        case xctestUi
        case sdkUnknown(Swift.String)

        public static var allCases: [TestType] {
            return [
                .appiumJavaJunit,
                .appiumJavaTestng,
                .appiumNode,
                .appiumPython,
                .appiumRuby,
                .appiumWebJavaJunit,
                .appiumWebJavaTestng,
                .appiumWebNode,
                .appiumWebPython,
                .appiumWebRuby,
                .builtinFuzz,
                .instrumentation,
                .xctest,
                .xctestUi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appiumJavaJunit: return "APPIUM_JAVA_JUNIT"
            case .appiumJavaTestng: return "APPIUM_JAVA_TESTNG"
            case .appiumNode: return "APPIUM_NODE"
            case .appiumPython: return "APPIUM_PYTHON"
            case .appiumRuby: return "APPIUM_RUBY"
            case .appiumWebJavaJunit: return "APPIUM_WEB_JAVA_JUNIT"
            case .appiumWebJavaTestng: return "APPIUM_WEB_JAVA_TESTNG"
            case .appiumWebNode: return "APPIUM_WEB_NODE"
            case .appiumWebPython: return "APPIUM_WEB_PYTHON"
            case .appiumWebRuby: return "APPIUM_WEB_RUBY"
            case .builtinFuzz: return "BUILTIN_FUZZ"
            case .instrumentation: return "INSTRUMENTATION"
            case .xctest: return "XCTEST"
            case .xctestUi: return "XCTEST_UI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents test settings. This data structure is passed in as the test parameter to ScheduleRun. For an example of the JSON request syntax, see [ScheduleRun].
    public struct ScheduleRunTest: Swift.Sendable {
        /// The test's filter.
        public var filter: Swift.String?
        /// The test's parameters, such as test framework parameters and fixture settings. Parameters are represented by name-value pairs of strings. For all tests:
        ///
        /// * app_performance_monitoring: Performance monitoring is enabled by default. Set this parameter to false to disable it.
        ///
        ///
        /// For Appium tests (all types):
        ///
        /// * appium_version: The Appium version. Currently supported values are 1.6.5 (and later), latest, and default.
        ///
        /// * latest runs the latest Appium version supported by Device Farm (1.9.1).
        ///
        /// * For default, Device Farm selects a compatible version of Appium for the device. The current behavior is to run 1.7.2 on Android devices and iOS 9 and earlier and 1.7.2 for iOS 10 and later.
        ///
        /// * This behavior is subject to change.
        ///
        ///
        ///
        ///
        ///
        /// For fuzz tests (Android only):
        ///
        /// * event_count: The number of events, between 1 and 10000, that the UI fuzz test should perform.
        ///
        /// * throttle: The time, in ms, between 0 and 1000, that the UI fuzz test should wait between events.
        ///
        /// * seed: A seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        ///
        ///
        /// For Instrumentation:
        ///
        /// * filter: A test filter string. Examples:
        ///
        /// * Running a single test case: com.android.abc.Test1
        ///
        /// * Running a single test: com.android.abc.Test1#smoke
        ///
        /// * Running multiple tests: com.android.abc.Test1,com.android.abc.Test2
        ///
        ///
        ///
        ///
        ///
        /// For XCTest and XCTestUI:
        ///
        /// * filter: A test filter string. Examples:
        ///
        /// * Running a single test class: LoginTests
        ///
        /// * Running a multiple test classes: LoginTests,SmokeTests
        ///
        /// * Running a single test: LoginTests/testValid
        ///
        /// * Running multiple tests: LoginTests/testValid,LoginTests/testInvalid
        public var parameters: [Swift.String: Swift.String]?
        /// The ARN of the uploaded test to be run.
        public var testPackageArn: Swift.String?
        /// The ARN of the YAML-formatted test specification.
        public var testSpecArn: Swift.String?
        /// The test's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * INSTRUMENTATION
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        /// This member is required.
        public var type: DeviceFarmClientTypes.TestType?

        public init(
            filter: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            testPackageArn: Swift.String? = nil,
            testSpecArn: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.filter = filter
            self.parameters = parameters
            self.testPackageArn = testPackageArn
            self.testSpecArn = testSpecArn
            self.type = type
        }
    }
}

/// Represents a request to the get device pool compatibility operation.
public struct GetDevicePoolCompatibilityInput: Swift.Sendable {
    /// The ARN of the app that is associated with the specified device pool.
    public var appArn: Swift.String?
    /// An object that contains information about the settings for a run.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The device pool's ARN.
    /// This member is required.
    public var devicePoolArn: Swift.String?
    /// Information about the uploaded test to be run against the device pool.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?
    /// The test type for the specified device pool. Allowed values include the following:
    ///
    /// * BUILTIN_FUZZ.
    ///
    /// * APPIUM_JAVA_JUNIT.
    ///
    /// * APPIUM_JAVA_TESTNG.
    ///
    /// * APPIUM_PYTHON.
    ///
    /// * APPIUM_NODE.
    ///
    /// * APPIUM_RUBY.
    ///
    /// * APPIUM_WEB_JAVA_JUNIT.
    ///
    /// * APPIUM_WEB_JAVA_TESTNG.
    ///
    /// * APPIUM_WEB_PYTHON.
    ///
    /// * APPIUM_WEB_NODE.
    ///
    /// * APPIUM_WEB_RUBY.
    ///
    /// * INSTRUMENTATION.
    ///
    /// * XCTEST.
    ///
    /// * XCTEST_UI.
    public var testType: DeviceFarmClientTypes.TestType?

    public init(
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil,
        testType: DeviceFarmClientTypes.TestType? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.test = test
        self.testType = testType
    }
}

extension DeviceFarmClientTypes {

    /// Represents information about incompatibility.
    public struct IncompatibilityMessage: Swift.Sendable {
        /// A message about the incompatibility.
        public var message: Swift.String?
        /// The type of incompatibility. Allowed values include:
        ///
        /// * ARN
        ///
        /// * FORM_FACTOR (for example, phone or tablet)
        ///
        /// * MANUFACTURER
        ///
        /// * PLATFORM (for example, Android or iOS)
        ///
        /// * REMOTE_ACCESS_ENABLED
        ///
        /// * APPIUM_VERSION
        public var type: DeviceFarmClientTypes.DeviceAttribute?

        public init(
            message: Swift.String? = nil,
            type: DeviceFarmClientTypes.DeviceAttribute? = nil
        )
        {
            self.message = message
            self.type = type
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a device pool compatibility result.
    public struct DevicePoolCompatibilityResult: Swift.Sendable {
        /// Whether the result was compatible with the device pool.
        public var compatible: Swift.Bool?
        /// The device (phone or tablet) to return information about.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the compatibility.
        public var incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]?

        public init(
            compatible: Swift.Bool? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            incompatibilityMessages: [DeviceFarmClientTypes.IncompatibilityMessage]? = nil
        )
        {
            self.compatible = compatible
            self.device = device
            self.incompatibilityMessages = incompatibilityMessages
        }
    }
}

/// Represents the result of describe device pool compatibility request.
public struct GetDevicePoolCompatibilityOutput: Swift.Sendable {
    /// Information about compatible devices.
    public var compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?
    /// Information about incompatible devices.
    public var incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]?

    public init(
        compatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil,
        incompatibleDevices: [DeviceFarmClientTypes.DevicePoolCompatibilityResult]? = nil
    )
    {
        self.compatibleDevices = compatibleDevices
        self.incompatibleDevices = incompatibleDevices
    }
}

public struct GetInstanceProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of an instance profile.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetInstanceProfileOutput: Swift.Sendable {
    /// An object that contains information about an instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init(
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

/// Represents a request to the get job operation.
public struct GetJobInput: Swift.Sendable {
    /// The job's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeviceFarmClientTypes {

    /// Represents a device.
    public struct Job: Swift.Sendable {
        /// The job's ARN.
        public var arn: Swift.String?
        /// The job's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the job was created.
        public var created: Foundation.Date?
        /// The device (phone or tablet).
        public var device: DeviceFarmClientTypes.Device?
        /// Represents the total (metered or unmetered) minutes used by the job.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the instance.
        public var instanceArn: Swift.String?
        /// A message about the job's result.
        public var message: Swift.String?
        /// The job's name.
        public var name: Swift.String?
        /// The job's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The job's start time.
        public var started: Foundation.Date?
        /// The job's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The job's stop time.
        public var stopped: Foundation.Date?
        /// The job's type. Allowed values include the following:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * INSTRUMENTATION
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?
        /// This value is set to true if video capture is enabled. Otherwise, it is set to false.
        public var videoCapture: Swift.Bool?
        /// The endpoint for streaming device video.
        public var videoEndpoint: Swift.String?

        public init(
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: Foundation.Date? = nil,
            device: DeviceFarmClientTypes.Device? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            instanceArn: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: Foundation.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: Foundation.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            videoCapture: Swift.Bool? = nil,
            videoEndpoint: Swift.String? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.device = device
            self.deviceMinutes = deviceMinutes
            self.instanceArn = instanceArn
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
            self.videoCapture = videoCapture
            self.videoEndpoint = videoEndpoint
        }
    }
}

/// Represents the result of a get job request.
public struct GetJobOutput: Swift.Sendable {
    /// An object that contains information about the requested job.
    public var job: DeviceFarmClientTypes.Job?

    public init(
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

public struct GetNetworkProfileInput: Swift.Sendable {
    /// The ARN of the network profile to return information about.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetNetworkProfileOutput: Swift.Sendable {
    /// The network profile.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init(
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

/// Exception gets thrown when a user is not eligible to perform the specified transaction.
public struct NotEligibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The HTTP response code of a Not Eligible exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotEligibleException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Represents the request to retrieve the offering status for the specified customer or account.
public struct GetOfferingStatusInput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    /// A number that represents the monetary amount for an offering or transaction.
    public struct MonetaryAmount: Swift.Sendable {
        /// The numerical amount of an offering or transaction.
        public var amount: Swift.Double?
        /// The currency code of a monetary amount. For example, USD means U.S. dollars.
        public var currencyCode: DeviceFarmClientTypes.CurrencyCode?

        public init(
            amount: Swift.Double? = nil,
            currencyCode: DeviceFarmClientTypes.CurrencyCode? = nil
        )
        {
            self.amount = amount
            self.currencyCode = currencyCode
        }
    }
}

extension DeviceFarmClientTypes {

    public enum RecurringChargeFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [RecurringChargeFrequency] {
            return [
                .monthly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Specifies whether charges for devices are recurring.
    public struct RecurringCharge: Swift.Sendable {
        /// The cost of the recurring charge.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The frequency in which charges recur.
        public var frequency: DeviceFarmClientTypes.RecurringChargeFrequency?

        public init(
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            frequency: DeviceFarmClientTypes.RecurringChargeFrequency? = nil
        )
        {
            self.cost = cost
            self.frequency = frequency
        }
    }
}

extension DeviceFarmClientTypes {

    public enum OfferingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case recurring
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingType] {
            return [
                .recurring
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .recurring: return "RECURRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents the metadata of a device offering.
    public struct Offering: Swift.Sendable {
        /// A string that describes the offering.
        public var description: Swift.String?
        /// The ID that corresponds to a device offering.
        public var id: Swift.String?
        /// The platform of the device (for example, ANDROID or IOS).
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Specifies whether there are recurring charges for the offering.
        public var recurringCharges: [DeviceFarmClientTypes.RecurringCharge]?
        /// The type of offering (for example, RECURRING) for a device.
        public var type: DeviceFarmClientTypes.OfferingType?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            recurringCharges: [DeviceFarmClientTypes.RecurringCharge]? = nil,
            type: DeviceFarmClientTypes.OfferingType? = nil
        )
        {
            self.description = description
            self.id = id
            self.platform = platform
            self.recurringCharges = recurringCharges
            self.type = type
        }
    }
}

extension DeviceFarmClientTypes {

    public enum OfferingTransactionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case purchase
        case renew
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [OfferingTransactionType] {
            return [
                .purchase,
                .renew,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .purchase: return "PURCHASE"
            case .renew: return "RENEW"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// The status of the offering.
    public struct OfferingStatus: Swift.Sendable {
        /// The date on which the offering is effective.
        public var effectiveOn: Foundation.Date?
        /// Represents the metadata of an offering status.
        public var offering: DeviceFarmClientTypes.Offering?
        /// The number of available devices in the offering.
        public var quantity: Swift.Int?
        /// The type specified for the offering status.
        public var type: DeviceFarmClientTypes.OfferingTransactionType?

        public init(
            effectiveOn: Foundation.Date? = nil,
            offering: DeviceFarmClientTypes.Offering? = nil,
            quantity: Swift.Int? = nil,
            type: DeviceFarmClientTypes.OfferingTransactionType? = nil
        )
        {
            self.effectiveOn = effectiveOn
            self.offering = offering
            self.quantity = quantity
            self.type = type
        }
    }
}

/// Returns the status result for a device offering.
public struct GetOfferingStatusOutput: Swift.Sendable {
    /// When specified, gets the offering status for the current period.
    public var current: [Swift.String: DeviceFarmClientTypes.OfferingStatus]?
    /// When specified, gets the offering status for the next period.
    public var nextPeriod: [Swift.String: DeviceFarmClientTypes.OfferingStatus]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        current: [Swift.String: DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextPeriod: [Swift.String: DeviceFarmClientTypes.OfferingStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.current = current
        self.nextPeriod = nextPeriod
        self.nextToken = nextToken
    }
}

/// Represents a request to the get project operation.
public struct GetProjectInput: Swift.Sendable {
    /// The project's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a get project request.
public struct GetProjectOutput: Swift.Sendable {
    /// The project to get information about.
    public var project: DeviceFarmClientTypes.Project?

    public init(
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

/// Represents the request to get information about the specified remote access session.
public struct GetRemoteAccessSessionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the remote access session about which you want to get session information.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the response from the server that lists detailed information about the remote access session.
public struct GetRemoteAccessSessionOutput: Swift.Sendable {
    /// A container that lists detailed information about the remote access session.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init(
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

/// Represents a request to the get run operation.
public struct GetRunInput: Swift.Sendable {
    /// The run's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeviceFarmClientTypes {

    public enum DeviceFilterAttribute: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case arn
        case availability
        case fleetType
        case formFactor
        case instanceArn
        case instanceLabels
        case manufacturer
        case model
        case osVersion
        case platform
        case remoteAccessEnabled
        case remoteDebugEnabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceFilterAttribute] {
            return [
                .arn,
                .availability,
                .fleetType,
                .formFactor,
                .instanceArn,
                .instanceLabels,
                .manufacturer,
                .model,
                .osVersion,
                .platform,
                .remoteAccessEnabled,
                .remoteDebugEnabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .arn: return "ARN"
            case .availability: return "AVAILABILITY"
            case .fleetType: return "FLEET_TYPE"
            case .formFactor: return "FORM_FACTOR"
            case .instanceArn: return "INSTANCE_ARN"
            case .instanceLabels: return "INSTANCE_LABELS"
            case .manufacturer: return "MANUFACTURER"
            case .model: return "MODEL"
            case .osVersion: return "OS_VERSION"
            case .platform: return "PLATFORM"
            case .remoteAccessEnabled: return "REMOTE_ACCESS_ENABLED"
            case .remoteDebugEnabled: return "REMOTE_DEBUG_ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a device filter used to select a set of devices to be included in a test run. This data structure is passed in as the deviceSelectionConfiguration parameter to ScheduleRun. For an example of the JSON request syntax, see [ScheduleRun]. It is also passed in as the filters parameter to ListDevices. For an example of the JSON request syntax, see [ListDevices].
    public struct DeviceFilter: Swift.Sendable {
        /// The aspect of a device such as platform or model used as the selection criteria in a device filter. The supported operators for each attribute are provided in the following list. ARN The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example). Supported operators: EQUALS, IN, NOT_IN PLATFORM The device platform. Valid values are ANDROID or IOS. Supported operators: EQUALS OS_VERSION The operating system version (for example, 10.3.2). Supported operators: EQUALS, GREATER_THAN, GREATER_THAN_OR_EQUALS, IN, LESS_THAN, LESS_THAN_OR_EQUALS, NOT_IN MODEL The device model (for example, iPad 5th Gen). Supported operators: CONTAINS, EQUALS, IN, NOT_IN AVAILABILITY The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE. Supported operators: EQUALS FORM_FACTOR The device form factor. Valid values are PHONE or TABLET. Supported operators: EQUALS MANUFACTURER The device manufacturer (for example, Apple). Supported operators: EQUALS, IN, NOT_IN REMOTE_ACCESS_ENABLED Whether the device is enabled for remote access. Valid values are TRUE or FALSE. Supported operators: EQUALS REMOTE_DEBUG_ENABLED Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Supported operators: EQUALS Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored. INSTANCE_ARN The Amazon Resource Name (ARN) of the device instance. Supported operators: EQUALS, IN, NOT_IN INSTANCE_LABELS The label of the device instance. Supported operators: CONTAINS FLEET_TYPE The fleet type. Valid values are PUBLIC or PRIVATE. Supported operators: EQUALS
        /// This member is required.
        public var attribute: DeviceFarmClientTypes.DeviceFilterAttribute?
        /// Specifies how Device Farm compares the filter's attribute to the value. See the attribute descriptions.
        /// This member is required.
        public var `operator`: DeviceFarmClientTypes.RuleOperator?
        /// An array of one or more filter values used in a device filter. Operator Values
        ///
        /// * The IN and NOT_IN operators can take a values array that has more than one element.
        ///
        /// * The other operators require an array with a single element.
        ///
        ///
        /// Attribute Values
        ///
        /// * The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        /// * The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        /// * The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            attribute: DeviceFarmClientTypes.DeviceFilterAttribute? = nil,
            `operator`: DeviceFarmClientTypes.RuleOperator? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.attribute = attribute
            self.`operator` = `operator`
            self.values = values
        }
    }
}

extension DeviceFarmClientTypes {

    /// Contains the run results requested by the device selection configuration and how many devices were returned. For an example of the JSON response syntax, see [ScheduleRun].
    public struct DeviceSelectionResult: Swift.Sendable {
        /// The filters in a device selection result.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The number of devices that matched the device filter selection criteria.
        public var matchedDevicesCount: Swift.Int?
        /// The maximum number of devices to be selected by a device filter and included in a test run.
        public var maxDevices: Swift.Int?

        public init(
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            matchedDevicesCount: Swift.Int? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.matchedDevicesCount = matchedDevicesCount
            self.maxDevices = maxDevices
        }
    }
}

extension DeviceFarmClientTypes {

    public enum ExecutionResultCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case parsingFailed
        case vpcEndpointSetupFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionResultCode] {
            return [
                .parsingFailed,
                .vpcEndpointSetupFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .parsingFailed: return "PARSING_FAILED"
            case .vpcEndpointSetupFailed: return "VPC_ENDPOINT_SETUP_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a test run on a set of devices with a given app package, test parameters, and so on.
    public struct Run: Swift.Sendable {
        /// An app to upload or that has been uploaded.
        public var appUpload: Swift.String?
        /// The run's ARN.
        public var arn: Swift.String?
        /// Specifies the billing method for a test run: metered or unmetered. If the parameter is not specified, the default value is metered. If you have unmetered device slots, you must set this to unmetered to use them. Otherwise, the run is counted toward metered device minutes.
        public var billingMethod: DeviceFarmClientTypes.BillingMethod?
        /// The total number of completed jobs.
        public var completedJobs: Swift.Int?
        /// The run's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the run was created.
        public var created: Foundation.Date?
        /// Output CustomerArtifactPaths object for the test run.
        public var customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths?
        /// Represents the total (metered or unmetered) minutes used by the test run.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// The ARN of the device pool for the run.
        public var devicePoolArn: Swift.String?
        /// The results of a device filter used to select the devices for a test run.
        public var deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult?
        /// For fuzz tests, this is the number of events, between 1 and 10000, that the UI fuzz test should perform.
        public var eventCount: Swift.Int?
        /// The number of minutes the job executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// Information about the locale that is used for the run.
        public var locale: Swift.String?
        /// Information about the location that is used for the run.
        public var location: DeviceFarmClientTypes.Location?
        /// A message about the run's result.
        public var message: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The network profile being used for a test run.
        public var networkProfile: DeviceFarmClientTypes.NetworkProfile?
        /// Read-only URL for an object in an S3 bucket where you can get the parsing results of the test package. If the test package doesn't parse, the reason why it doesn't parse appears in the file that this URL points to.
        public var parsingResultUrl: Swift.String?
        /// The run's platform. Allowed values include:
        ///
        /// * ANDROID
        ///
        /// * IOS
        public var platform: DeviceFarmClientTypes.DevicePlatform?
        /// Information about the radio states for the run.
        public var radios: DeviceFarmClientTypes.Radios?
        /// The run's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Supporting field for the result field. Set only if result is SKIPPED. PARSING_FAILED if the result is skipped because of test package parsing failure.
        public var resultCode: DeviceFarmClientTypes.ExecutionResultCode?
        /// For fuzz tests, this is a seed to use for randomizing the UI fuzz test. Using the same seed value between tests ensures identical event sequences.
        public var seed: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// The run's start time.
        public var started: Foundation.Date?
        /// The run's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The run's stop time.
        public var stopped: Foundation.Date?
        /// The ARN of the YAML-formatted test specification for the run.
        public var testSpecArn: Swift.String?
        /// The total number of jobs for the run.
        public var totalJobs: Swift.Int?
        /// The run's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * INSTRUMENTATION
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?
        /// The VPC security groups and subnets that are attached to a project.
        public var vpcConfig: DeviceFarmClientTypes.VpcConfig?
        /// The Device Farm console URL for the recording of the run.
        public var webUrl: Swift.String?

        public init(
            appUpload: Swift.String? = nil,
            arn: Swift.String? = nil,
            billingMethod: DeviceFarmClientTypes.BillingMethod? = nil,
            completedJobs: Swift.Int? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: Foundation.Date? = nil,
            customerArtifactPaths: DeviceFarmClientTypes.CustomerArtifactPaths? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            devicePoolArn: Swift.String? = nil,
            deviceSelectionResult: DeviceFarmClientTypes.DeviceSelectionResult? = nil,
            eventCount: Swift.Int? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            locale: Swift.String? = nil,
            location: DeviceFarmClientTypes.Location? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil,
            parsingResultUrl: Swift.String? = nil,
            platform: DeviceFarmClientTypes.DevicePlatform? = nil,
            radios: DeviceFarmClientTypes.Radios? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            resultCode: DeviceFarmClientTypes.ExecutionResultCode? = nil,
            seed: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            started: Foundation.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: Foundation.Date? = nil,
            testSpecArn: Swift.String? = nil,
            totalJobs: Swift.Int? = nil,
            type: DeviceFarmClientTypes.TestType? = nil,
            vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil,
            webUrl: Swift.String? = nil
        )
        {
            self.appUpload = appUpload
            self.arn = arn
            self.billingMethod = billingMethod
            self.completedJobs = completedJobs
            self.counters = counters
            self.created = created
            self.customerArtifactPaths = customerArtifactPaths
            self.deviceMinutes = deviceMinutes
            self.devicePoolArn = devicePoolArn
            self.deviceSelectionResult = deviceSelectionResult
            self.eventCount = eventCount
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.locale = locale
            self.location = location
            self.message = message
            self.name = name
            self.networkProfile = networkProfile
            self.parsingResultUrl = parsingResultUrl
            self.platform = platform
            self.radios = radios
            self.result = result
            self.resultCode = resultCode
            self.seed = seed
            self.skipAppResign = skipAppResign
            self.started = started
            self.status = status
            self.stopped = stopped
            self.testSpecArn = testSpecArn
            self.totalJobs = totalJobs
            self.type = type
            self.vpcConfig = vpcConfig
            self.webUrl = webUrl
        }
    }
}

/// Represents the result of a get run request.
public struct GetRunOutput: Swift.Sendable {
    /// The run to get results from.
    public var run: DeviceFarmClientTypes.Run?

    public init(
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

/// Represents a request to the get suite operation.
public struct GetSuiteInput: Swift.Sendable {
    /// The suite's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeviceFarmClientTypes {

    /// Represents a collection of one or more tests.
    public struct Suite: Swift.Sendable {
        /// The suite's ARN.
        public var arn: Swift.String?
        /// The suite's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the suite was created.
        public var created: Foundation.Date?
        /// Represents the total (metered or unmetered) minutes used by the test suite.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the suite's result.
        public var message: Swift.String?
        /// The suite's name.
        public var name: Swift.String?
        /// The suite's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The suite's start time.
        public var started: Foundation.Date?
        /// The suite's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The suite's stop time.
        public var stopped: Foundation.Date?
        /// The suite's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * INSTRUMENTATION
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?

        public init(
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: Foundation.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: Foundation.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: Foundation.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }
}

/// Represents the result of a get suite request.
public struct GetSuiteOutput: Swift.Sendable {
    /// A collection of one or more tests.
    public var suite: DeviceFarmClientTypes.Suite?

    public init(
        suite: DeviceFarmClientTypes.Suite? = nil
    )
    {
        self.suite = suite
    }
}

/// Represents a request to the get test operation.
public struct GetTestInput: Swift.Sendable {
    /// The test's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

extension DeviceFarmClientTypes {

    /// Represents a condition that is evaluated.
    public struct Test: Swift.Sendable {
        /// The test's ARN.
        public var arn: Swift.String?
        /// The test's result counters.
        public var counters: DeviceFarmClientTypes.Counters?
        /// When the test was created.
        public var created: Foundation.Date?
        /// Represents the total (metered or unmetered) minutes used by the test.
        public var deviceMinutes: DeviceFarmClientTypes.DeviceMinutes?
        /// A message about the test's result.
        public var message: Swift.String?
        /// The test's name.
        public var name: Swift.String?
        /// The test's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// The test's start time.
        public var started: Foundation.Date?
        /// The test's status. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PENDING_CONCURRENCY
        ///
        /// * PENDING_DEVICE
        ///
        /// * PROCESSING
        ///
        /// * SCHEDULING
        ///
        /// * PREPARING
        ///
        /// * RUNNING
        ///
        /// * COMPLETED
        ///
        /// * STOPPING
        public var status: DeviceFarmClientTypes.ExecutionStatus?
        /// The test's stop time.
        public var stopped: Foundation.Date?
        /// The test's type. Must be one of the following values:
        ///
        /// * BUILTIN_FUZZ
        ///
        /// * APPIUM_JAVA_JUNIT
        ///
        /// * APPIUM_JAVA_TESTNG
        ///
        /// * APPIUM_PYTHON
        ///
        /// * APPIUM_NODE
        ///
        /// * APPIUM_RUBY
        ///
        /// * APPIUM_WEB_JAVA_JUNIT
        ///
        /// * APPIUM_WEB_JAVA_TESTNG
        ///
        /// * APPIUM_WEB_PYTHON
        ///
        /// * APPIUM_WEB_NODE
        ///
        /// * APPIUM_WEB_RUBY
        ///
        /// * INSTRUMENTATION
        ///
        /// * XCTEST
        ///
        /// * XCTEST_UI
        public var type: DeviceFarmClientTypes.TestType?

        public init(
            arn: Swift.String? = nil,
            counters: DeviceFarmClientTypes.Counters? = nil,
            created: Foundation.Date? = nil,
            deviceMinutes: DeviceFarmClientTypes.DeviceMinutes? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            started: Foundation.Date? = nil,
            status: DeviceFarmClientTypes.ExecutionStatus? = nil,
            stopped: Foundation.Date? = nil,
            type: DeviceFarmClientTypes.TestType? = nil
        )
        {
            self.arn = arn
            self.counters = counters
            self.created = created
            self.deviceMinutes = deviceMinutes
            self.message = message
            self.name = name
            self.result = result
            self.started = started
            self.status = status
            self.stopped = stopped
            self.type = type
        }
    }
}

/// Represents the result of a get test request.
public struct GetTestOutput: Swift.Sendable {
    /// A test condition that is evaluated.
    public var test: DeviceFarmClientTypes.Test?

    public init(
        test: DeviceFarmClientTypes.Test? = nil
    )
    {
        self.test = test
    }
}

public struct GetTestGridProjectInput: Swift.Sendable {
    /// The ARN of the Selenium testing project, from either [CreateTestGridProject] or [ListTestGridProjects].
    /// This member is required.
    public var projectArn: Swift.String?

    public init(
        projectArn: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

public struct GetTestGridProjectOutput: Swift.Sendable {
    /// A [TestGridProject].
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init(
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

public struct GetTestGridSessionInput: Swift.Sendable {
    /// The ARN for the project that this session belongs to. See [CreateTestGridProject] and [ListTestGridProjects].
    public var projectArn: Swift.String?
    /// An ARN that uniquely identifies a [TestGridSession].
    public var sessionArn: Swift.String?
    /// An ID associated with this session.
    public var sessionId: Swift.String?

    public init(
        projectArn: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.sessionArn = sessionArn
        self.sessionId = sessionId
    }
}

extension DeviceFarmClientTypes {

    public enum TestGridSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case closed
        case errored
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionStatus] {
            return [
                .active,
                .closed,
                .errored
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .closed: return "CLOSED"
            case .errored: return "ERRORED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// A [TestGridSession] is a single instance of a browser launched from the URL provided by a call to [CreateTestGridUrl].
    public struct TestGridSession: Swift.Sendable {
        /// The ARN of the session.
        public var arn: Swift.String?
        /// The number of billed minutes that were used for this session.
        public var billingMinutes: Swift.Double?
        /// The time that the session was started.
        public var created: Foundation.Date?
        /// The time the session ended.
        public var ended: Foundation.Date?
        /// A JSON object of options and parameters passed to the Selenium WebDriver.
        public var seleniumProperties: Swift.String?
        /// The state of the session.
        public var status: DeviceFarmClientTypes.TestGridSessionStatus?

        public init(
            arn: Swift.String? = nil,
            billingMinutes: Swift.Double? = nil,
            created: Foundation.Date? = nil,
            ended: Foundation.Date? = nil,
            seleniumProperties: Swift.String? = nil,
            status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
        )
        {
            self.arn = arn
            self.billingMinutes = billingMinutes
            self.created = created
            self.ended = ended
            self.seleniumProperties = seleniumProperties
            self.status = status
        }
    }
}

public struct GetTestGridSessionOutput: Swift.Sendable {
    /// The [TestGridSession] that was requested.
    public var testGridSession: DeviceFarmClientTypes.TestGridSession?

    public init(
        testGridSession: DeviceFarmClientTypes.TestGridSession? = nil
    )
    {
        self.testGridSession = testGridSession
    }
}

/// Represents a request to the get upload operation.
public struct GetUploadInput: Swift.Sendable {
    /// The upload's ARN.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the result of a get upload request.
public struct GetUploadOutput: Swift.Sendable {
    /// An app or a set of one or more tests to upload or that have been uploaded.
    public var upload: DeviceFarmClientTypes.Upload?

    public init(
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

public struct GetVPCEConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to describe.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct GetVPCEConfigurationOutput: Swift.Sendable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init(
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

/// Represents the request to install an Android application (in .apk format) or an iOS application (in .ipa format) as part of a remote access session.
public struct InstallToRemoteAccessSessionInput: Swift.Sendable {
    /// The ARN of the app about which you are requesting information.
    /// This member is required.
    public var appArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the remote access session about which you are requesting information.
    /// This member is required.
    public var remoteAccessSessionArn: Swift.String?

    public init(
        appArn: Swift.String? = nil,
        remoteAccessSessionArn: Swift.String? = nil
    )
    {
        self.appArn = appArn
        self.remoteAccessSessionArn = remoteAccessSessionArn
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to install to a remote access session.
public struct InstallToRemoteAccessSessionOutput: Swift.Sendable {
    /// An app to upload or that has been uploaded.
    public var appUpload: DeviceFarmClientTypes.Upload?

    public init(
        appUpload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.appUpload = appUpload
    }
}

/// Represents a request to the list artifacts operation.
public struct ListArtifactsInput: Swift.Sendable {
    /// The run, job, suite, or test ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The artifacts' type. Allowed values include:
    ///
    /// * FILE
    ///
    /// * LOG
    ///
    /// * SCREENSHOT
    /// This member is required.
    public var type: DeviceFarmClientTypes.ArtifactCategory?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.ArtifactCategory? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

/// Represents the result of a list artifacts operation.
public struct ListArtifactsOutput: Swift.Sendable {
    /// Information about the artifacts.
    public var artifacts: [DeviceFarmClientTypes.Artifact]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        artifacts: [DeviceFarmClientTypes.Artifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

public struct ListDeviceInstancesInput: Swift.Sendable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDeviceInstancesOutput: Swift.Sendable {
    /// An object that contains information about your device instances.
    public var deviceInstances: [DeviceFarmClientTypes.DeviceInstance]?
    /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        deviceInstances: [DeviceFarmClientTypes.DeviceInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceInstances = deviceInstances
        self.nextToken = nextToken
    }
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsInput: Swift.Sendable {
    /// The project ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The device pools' type. Allowed values include:
    ///
    /// * CURATED: A device pool that is created and managed by AWS Device Farm.
    ///
    /// * PRIVATE: A device pool that is created and managed by the device pool developer.
    public var type: DeviceFarmClientTypes.DevicePoolType?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.DevicePoolType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

/// Represents the result of a list device pools request.
public struct ListDevicePoolsOutput: Swift.Sendable {
    /// Information about the device pools.
    public var devicePools: [DeviceFarmClientTypes.DevicePool]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        devicePools: [DeviceFarmClientTypes.DevicePool]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devicePools = devicePools
        self.nextToken = nextToken
    }
}

/// Represents the result of a list devices request.
public struct ListDevicesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project.
    public var arn: Swift.String?
    /// Used to select a set of devices. A filter is made up of an attribute, an operator, and one or more values.
    ///
    /// * Attribute: The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:
    ///
    /// * ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).
    ///
    /// * PLATFORM: The device platform. Valid values are ANDROID or IOS.
    ///
    /// * OS_VERSION: The operating system version (for example, 10.3.2).
    ///
    /// * MODEL: The device model (for example, iPad 5th Gen).
    ///
    /// * AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    ///
    /// * FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.
    ///
    /// * MANUFACTURER: The device manufacturer (for example, Apple).
    ///
    /// * REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.
    ///
    /// * REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this attribute is ignored.
    ///
    /// * INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.
    ///
    /// * INSTANCE_LABELS: The label of the device instance.
    ///
    /// * FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
    ///
    ///
    ///
    ///
    /// * Operator: The filter operator.
    ///
    /// * The EQUALS operator is available for every attribute except INSTANCE_LABELS.
    ///
    /// * The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.
    ///
    /// * The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
    ///
    /// * The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.
    ///
    ///
    ///
    ///
    /// * Values: An array of one or more filter values.
    ///
    /// * The IN and NOT_IN operators take a values array that has one or more elements.
    ///
    /// * The other operators require an array with a single element.
    ///
    /// * In a request, the AVAILABILITY attribute takes the following values: AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
    public var filters: [DeviceFarmClientTypes.DeviceFilter]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.filters = filters
        self.nextToken = nextToken
    }
}

/// Represents the result of a list devices operation.
public struct ListDevicesOutput: Swift.Sendable {
    /// Information about the devices.
    public var devices: [DeviceFarmClientTypes.Device]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        devices: [DeviceFarmClientTypes.Device]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListInstanceProfilesInput: Swift.Sendable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInstanceProfilesOutput: Swift.Sendable {
    /// An object that contains information about your instance profiles.
    public var instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]?
    /// An identifier that can be used in the next call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        instanceProfiles: [DeviceFarmClientTypes.InstanceProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceProfiles = instanceProfiles
        self.nextToken = nextToken
    }
}

/// Represents a request to the list jobs operation.
public struct ListJobsInput: Swift.Sendable {
    /// The run's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the result of a list jobs request.
public struct ListJobsOutput: Swift.Sendable {
    /// Information about the jobs.
    public var jobs: [DeviceFarmClientTypes.Job]?
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        jobs: [DeviceFarmClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

public struct ListNetworkProfilesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list network profiles.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

public struct ListNetworkProfilesOutput: Swift.Sendable {
    /// A list of the available network profiles.
    public var networkProfiles: [DeviceFarmClientTypes.NetworkProfile]?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        networkProfiles: [DeviceFarmClientTypes.NetworkProfile]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
    }
}

public struct ListOfferingPromotionsInput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    /// Represents information about an offering promotion.
    public struct OfferingPromotion: Swift.Sendable {
        /// A string that describes the offering promotion.
        public var description: Swift.String?
        /// The ID of the offering promotion.
        public var id: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
        }
    }
}

public struct ListOfferingPromotionsOutput: Swift.Sendable {
    /// An identifier to be used in the next call to this operation, to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the offering promotions.
    public var offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]?

    public init(
        nextToken: Swift.String? = nil,
        offeringPromotions: [DeviceFarmClientTypes.OfferingPromotion]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringPromotions = offeringPromotions
    }
}

/// Represents the request to list all offerings.
public struct ListOfferingsInput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

/// Represents the return values of the list of offerings.
public struct ListOfferingsOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A value that represents the list offering results.
    public var offerings: [DeviceFarmClientTypes.Offering]?

    public init(
        nextToken: Swift.String? = nil,
        offerings: [DeviceFarmClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

/// Represents the request to list the offering transaction history.
public struct ListOfferingTransactionsInput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    /// Represents the metadata of an offering transaction.
    public struct OfferingTransaction: Swift.Sendable {
        /// The cost of an offering transaction.
        public var cost: DeviceFarmClientTypes.MonetaryAmount?
        /// The date on which an offering transaction was created.
        public var createdOn: Foundation.Date?
        /// The ID that corresponds to a device offering promotion.
        public var offeringPromotionId: Swift.String?
        /// The status of an offering transaction.
        public var offeringStatus: DeviceFarmClientTypes.OfferingStatus?
        /// The transaction ID of the offering transaction.
        public var transactionId: Swift.String?

        public init(
            cost: DeviceFarmClientTypes.MonetaryAmount? = nil,
            createdOn: Foundation.Date? = nil,
            offeringPromotionId: Swift.String? = nil,
            offeringStatus: DeviceFarmClientTypes.OfferingStatus? = nil,
            transactionId: Swift.String? = nil
        )
        {
            self.cost = cost
            self.createdOn = createdOn
            self.offeringPromotionId = offeringPromotionId
            self.offeringStatus = offeringStatus
            self.transactionId = transactionId
        }
    }
}

/// Returns the transaction log of the specified offerings.
public struct ListOfferingTransactionsOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The audit log of subscriptions you have purchased and modified through AWS Device Farm.
    public var offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]?

    public init(
        nextToken: Swift.String? = nil,
        offeringTransactions: [DeviceFarmClientTypes.OfferingTransaction]? = nil
    )
    {
        self.nextToken = nextToken
        self.offeringTransactions = offeringTransactions
    }
}

/// Represents a request to the list projects operation.
public struct ListProjectsInput: Swift.Sendable {
    /// Optional. If no Amazon Resource Name (ARN) is specified, then AWS Device Farm returns a list of all projects for the AWS account. You can also specify a project ARN.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the result of a list projects request.
public struct ListProjectsOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the projects.
    public var projects: [DeviceFarmClientTypes.Project]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [DeviceFarmClientTypes.Project]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

/// Represents the request to return information about the remote access session.
public struct ListRemoteAccessSessionsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project about which you are requesting information.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the response from the server after AWS Device Farm makes a request to return information about the remote access session.
public struct ListRemoteAccessSessionsOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// A container that represents the metadata from the service about each remote access session you are requesting.
    public var remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]?

    public init(
        nextToken: Swift.String? = nil,
        remoteAccessSessions: [DeviceFarmClientTypes.RemoteAccessSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.remoteAccessSessions = remoteAccessSessions
    }
}

/// Represents a request to the list runs operation.
public struct ListRunsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list runs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the result of a list runs request.
public struct ListRunsOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the runs.
    public var runs: [DeviceFarmClientTypes.Run]?

    public init(
        nextToken: Swift.String? = nil,
        runs: [DeviceFarmClientTypes.Run]? = nil
    )
    {
        self.nextToken = nextToken
        self.runs = runs
    }
}

/// Represents a request to the list samples operation.
public struct ListSamplesInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the job used to list samples.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    public enum SampleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cpu
        case memory
        case nativeAvgDrawtime
        case nativeFps
        case nativeFrames
        case nativeMaxDrawtime
        case nativeMinDrawtime
        case openglAvgDrawtime
        case openglFps
        case openglFrames
        case openglMaxDrawtime
        case openglMinDrawtime
        case rx
        case rxRate
        case threads
        case tx
        case txRate
        case sdkUnknown(Swift.String)

        public static var allCases: [SampleType] {
            return [
                .cpu,
                .memory,
                .nativeAvgDrawtime,
                .nativeFps,
                .nativeFrames,
                .nativeMaxDrawtime,
                .nativeMinDrawtime,
                .openglAvgDrawtime,
                .openglFps,
                .openglFrames,
                .openglMaxDrawtime,
                .openglMinDrawtime,
                .rx,
                .rxRate,
                .threads,
                .tx,
                .txRate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cpu: return "CPU"
            case .memory: return "MEMORY"
            case .nativeAvgDrawtime: return "NATIVE_AVG_DRAWTIME"
            case .nativeFps: return "NATIVE_FPS"
            case .nativeFrames: return "NATIVE_FRAMES"
            case .nativeMaxDrawtime: return "NATIVE_MAX_DRAWTIME"
            case .nativeMinDrawtime: return "NATIVE_MIN_DRAWTIME"
            case .openglAvgDrawtime: return "OPENGL_AVG_DRAWTIME"
            case .openglFps: return "OPENGL_FPS"
            case .openglFrames: return "OPENGL_FRAMES"
            case .openglMaxDrawtime: return "OPENGL_MAX_DRAWTIME"
            case .openglMinDrawtime: return "OPENGL_MIN_DRAWTIME"
            case .rx: return "RX"
            case .rxRate: return "RX_RATE"
            case .threads: return "THREADS"
            case .tx: return "TX"
            case .txRate: return "TX_RATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a sample of performance data.
    public struct Sample: Swift.Sendable {
        /// The sample's ARN.
        public var arn: Swift.String?
        /// The sample's type. Must be one of the following values:
        ///
        /// * CPU: A CPU sample type. This is expressed as the app processing CPU time (including child processes) as reported by process, as a percentage.
        ///
        /// * MEMORY: A memory usage sample type. This is expressed as the total proportional set size of an app process, in kilobytes.
        ///
        /// * NATIVE_AVG_DRAWTIME
        ///
        /// * NATIVE_FPS
        ///
        /// * NATIVE_FRAMES
        ///
        /// * NATIVE_MAX_DRAWTIME
        ///
        /// * NATIVE_MIN_DRAWTIME
        ///
        /// * OPENGL_AVG_DRAWTIME
        ///
        /// * OPENGL_FPS
        ///
        /// * OPENGL_FRAMES
        ///
        /// * OPENGL_MAX_DRAWTIME
        ///
        /// * OPENGL_MIN_DRAWTIME
        ///
        /// * RX
        ///
        /// * RX_RATE: The total number of bytes per second (TCP and UDP) that are sent, by app process.
        ///
        /// * THREADS: A threads sample type. This is expressed as the total number of threads per app process.
        ///
        /// * TX
        ///
        /// * TX_RATE: The total number of bytes per second (TCP and UDP) that are received, by app process.
        public var type: DeviceFarmClientTypes.SampleType?
        /// The presigned Amazon S3 URL that can be used with a GET request to download the sample's file.
        public var url: Swift.String?

        public init(
            arn: Swift.String? = nil,
            type: DeviceFarmClientTypes.SampleType? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
            self.url = url
        }
    }
}

/// Represents the result of a list samples request.
public struct ListSamplesOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the samples.
    public var samples: [DeviceFarmClientTypes.Sample]?

    public init(
        nextToken: Swift.String? = nil,
        samples: [DeviceFarmClientTypes.Sample]? = nil
    )
    {
        self.nextToken = nextToken
        self.samples = samples
    }
}

/// Represents a request to the list suites operation.
public struct ListSuitesInput: Swift.Sendable {
    /// The job's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the result of a list suites request.
public struct ListSuitesOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the suites.
    public var suites: [DeviceFarmClientTypes.Suite]?

    public init(
        nextToken: Swift.String? = nil,
        suites: [DeviceFarmClientTypes.Suite]? = nil
    )
    {
        self.nextToken = nextToken
        self.suites = suites
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource or resources for which to list tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

extension DeviceFarmClientTypes {

    /// The metadata that you apply to a resource to help you categorize and organize it. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Sendable {
        /// One part of a key-value pair that makes up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// The optional part of a key-value pair that makes up a tag. A value acts as a descriptor in a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init(
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct ListTestGridProjectsInput: Swift.Sendable {
    /// Return no more than this number of results.
    public var maxResult: Swift.Int?
    /// From a response, used to continue a paginated listing.
    public var nextToken: Swift.String?

    public init(
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
    }
}

public struct ListTestGridProjectsOutput: Swift.Sendable {
    /// Used for pagination. Pass into [ListTestGridProjects] to get more results in a paginated request.
    public var nextToken: Swift.String?
    /// The list of TestGridProjects, based on a [ListTestGridProjectsRequest].
    public var testGridProjects: [DeviceFarmClientTypes.TestGridProject]?

    public init(
        nextToken: Swift.String? = nil,
        testGridProjects: [DeviceFarmClientTypes.TestGridProject]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridProjects = testGridProjects
    }
}

public struct ListTestGridSessionActionsInput: Swift.Sendable {
    /// The maximum number of sessions to return per response.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of the session to retrieve.
    /// This member is required.
    public var sessionArn: Swift.String?

    public init(
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
    }
}

extension DeviceFarmClientTypes {

    /// An action taken by a [TestGridSession] browser instance.
    public struct TestGridSessionAction: Swift.Sendable {
        /// The action taken by the session.
        public var action: Swift.String?
        /// The time, in milliseconds, that the action took to complete in the browser.
        public var duration: Swift.Int?
        /// HTTP method that the browser used to make the request.
        public var requestMethod: Swift.String?
        /// The time that the session invoked the action.
        public var started: Foundation.Date?
        /// HTTP status code returned to the browser when the action was taken.
        public var statusCode: Swift.String?

        public init(
            action: Swift.String? = nil,
            duration: Swift.Int? = nil,
            requestMethod: Swift.String? = nil,
            started: Foundation.Date? = nil,
            statusCode: Swift.String? = nil
        )
        {
            self.action = action
            self.duration = duration
            self.requestMethod = requestMethod
            self.started = started
            self.statusCode = statusCode
        }
    }
}

public struct ListTestGridSessionActionsOutput: Swift.Sendable {
    /// The action taken by the session.
    public var actions: [DeviceFarmClientTypes.TestGridSessionAction]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        actions: [DeviceFarmClientTypes.TestGridSessionAction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    public enum TestGridSessionArtifactCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case log
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactCategory] {
            return [
                .log,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .log: return "LOG"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListTestGridSessionArtifactsInput: Swift.Sendable {
    /// The maximum number of results to be returned by a request.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The ARN of a [TestGridSession].
    /// This member is required.
    public var sessionArn: Swift.String?
    /// Limit results to a specified type of artifact.
    public var type: DeviceFarmClientTypes.TestGridSessionArtifactCategory?

    public init(
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sessionArn: Swift.String? = nil,
        type: DeviceFarmClientTypes.TestGridSessionArtifactCategory? = nil
    )
    {
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.sessionArn = sessionArn
        self.type = type
    }
}

extension DeviceFarmClientTypes {

    public enum TestGridSessionArtifactType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case seleniumLog
        case unknown
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [TestGridSessionArtifactType] {
            return [
                .seleniumLog,
                .unknown,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .seleniumLog: return "SELENIUM_LOG"
            case .unknown: return "UNKNOWN"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension DeviceFarmClientTypes {

    /// Artifacts are video and other files that are produced in the process of running a browser in an automated context. Video elements might be broken up into multiple artifacts as they grow in size during creation.
    public struct TestGridSessionArtifact: Swift.Sendable {
        /// The file name of the artifact.
        public var filename: Swift.String?
        /// The kind of artifact.
        public var type: DeviceFarmClientTypes.TestGridSessionArtifactType?
        /// A semi-stable URL to the content of the object.
        public var url: Swift.String?

        public init(
            filename: Swift.String? = nil,
            type: DeviceFarmClientTypes.TestGridSessionArtifactType? = nil,
            url: Swift.String? = nil
        )
        {
            self.filename = filename
            self.type = type
            self.url = url
        }
    }
}

extension DeviceFarmClientTypes.TestGridSessionArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TestGridSessionArtifact(filename: \(Swift.String(describing: filename)), type: \(Swift.String(describing: type)), url: \"CONTENT_REDACTED\")"}
}

public struct ListTestGridSessionArtifactsOutput: Swift.Sendable {
    /// A list of test grid session artifacts for a [TestGridSession].
    public var artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]?
    /// Pagination token.
    public var nextToken: Swift.String?

    public init(
        artifacts: [DeviceFarmClientTypes.TestGridSessionArtifact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.artifacts = artifacts
        self.nextToken = nextToken
    }
}

public struct ListTestGridSessionsInput: Swift.Sendable {
    /// Return only sessions created after this time.
    public var creationTimeAfter: Foundation.Date?
    /// Return only sessions created before this time.
    public var creationTimeBefore: Foundation.Date?
    /// Return only sessions that ended after this time.
    public var endTimeAfter: Foundation.Date?
    /// Return only sessions that ended before this time.
    public var endTimeBefore: Foundation.Date?
    /// Return only this many results at a time.
    public var maxResult: Swift.Int?
    /// Pagination token.
    public var nextToken: Swift.String?
    /// ARN of a [TestGridProject].
    /// This member is required.
    public var projectArn: Swift.String?
    /// Return only sessions in this state.
    public var status: DeviceFarmClientTypes.TestGridSessionStatus?

    public init(
        creationTimeAfter: Foundation.Date? = nil,
        creationTimeBefore: Foundation.Date? = nil,
        endTimeAfter: Foundation.Date? = nil,
        endTimeBefore: Foundation.Date? = nil,
        maxResult: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        status: DeviceFarmClientTypes.TestGridSessionStatus? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.endTimeAfter = endTimeAfter
        self.endTimeBefore = endTimeBefore
        self.maxResult = maxResult
        self.nextToken = nextToken
        self.projectArn = projectArn
        self.status = status
    }
}

public struct ListTestGridSessionsOutput: Swift.Sendable {
    /// Pagination token.
    public var nextToken: Swift.String?
    /// The sessions that match the criteria in a [ListTestGridSessionsRequest].
    public var testGridSessions: [DeviceFarmClientTypes.TestGridSession]?

    public init(
        nextToken: Swift.String? = nil,
        testGridSessions: [DeviceFarmClientTypes.TestGridSession]? = nil
    )
    {
        self.nextToken = nextToken
        self.testGridSessions = testGridSessions
    }
}

/// Represents a request to the list tests operation.
public struct ListTestsInput: Swift.Sendable {
    /// The test suite's Amazon Resource Name (ARN).
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

/// Represents the result of a list tests request.
public struct ListTestsOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the tests.
    public var tests: [DeviceFarmClientTypes.Test]?

    public init(
        nextToken: Swift.String? = nil,
        tests: [DeviceFarmClientTypes.Test]? = nil
    )
    {
        self.nextToken = nextToken
        self.tests = tests
    }
}

/// Represents a request to the list unique problems operation.
public struct ListUniqueProblemsInput: Swift.Sendable {
    /// The unique problems' ARNs.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
    }
}

extension DeviceFarmClientTypes {

    /// Information about a problem detail.
    public struct ProblemDetail: Swift.Sendable {
        /// The problem detail's ARN.
        public var arn: Swift.String?
        /// The problem detail's name.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents a specific warning or failure.
    public struct Problem: Swift.Sendable {
        /// Information about the associated device.
        public var device: DeviceFarmClientTypes.Device?
        /// Information about the associated job.
        public var job: DeviceFarmClientTypes.ProblemDetail?
        /// A message about the problem's result.
        public var message: Swift.String?
        /// The problem's result. Allowed values include:
        ///
        /// * PENDING
        ///
        /// * PASSED
        ///
        /// * WARNED
        ///
        /// * FAILED
        ///
        /// * SKIPPED
        ///
        /// * ERRORED
        ///
        /// * STOPPED
        public var result: DeviceFarmClientTypes.ExecutionResult?
        /// Information about the associated run.
        public var run: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated suite.
        public var suite: DeviceFarmClientTypes.ProblemDetail?
        /// Information about the associated test.
        public var test: DeviceFarmClientTypes.ProblemDetail?

        public init(
            device: DeviceFarmClientTypes.Device? = nil,
            job: DeviceFarmClientTypes.ProblemDetail? = nil,
            message: Swift.String? = nil,
            result: DeviceFarmClientTypes.ExecutionResult? = nil,
            run: DeviceFarmClientTypes.ProblemDetail? = nil,
            suite: DeviceFarmClientTypes.ProblemDetail? = nil,
            test: DeviceFarmClientTypes.ProblemDetail? = nil
        )
        {
            self.device = device
            self.job = job
            self.message = message
            self.result = result
            self.run = run
            self.suite = suite
            self.test = test
        }
    }
}

extension DeviceFarmClientTypes {

    /// A collection of one or more problems, grouped by their result.
    public struct UniqueProblem: Swift.Sendable {
        /// A message about the unique problems' result.
        public var message: Swift.String?
        /// Information about the problems.
        public var problems: [DeviceFarmClientTypes.Problem]?

        public init(
            message: Swift.String? = nil,
            problems: [DeviceFarmClientTypes.Problem]? = nil
        )
        {
            self.message = message
            self.problems = problems
        }
    }
}

/// Represents the result of a list unique problems request.
public struct ListUniqueProblemsOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the unique problems. Allowed values include:
    ///
    /// * PENDING
    ///
    /// * PASSED
    ///
    /// * WARNED
    ///
    /// * FAILED
    ///
    /// * SKIPPED
    ///
    /// * ERRORED
    ///
    /// * STOPPED
    public var uniqueProblems: [Swift.String: [DeviceFarmClientTypes.UniqueProblem]]?

    public init(
        nextToken: Swift.String? = nil,
        uniqueProblems: [Swift.String: [DeviceFarmClientTypes.UniqueProblem]]? = nil
    )
    {
        self.nextToken = nextToken
        self.uniqueProblems = uniqueProblems
    }
}

/// Represents a request to the list uploads operation.
public struct ListUploadsInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project for which you want to list uploads.
    /// This member is required.
    public var arn: Swift.String?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// The type of upload. Must be one of the following values:
    ///
    /// * ANDROID_APP
    ///
    /// * IOS_APP
    ///
    /// * WEB_APP
    ///
    /// * EXTERNAL_DATA
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_RUBY_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_PYTHON_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_NODE_TEST_PACKAGE
    ///
    /// * APPIUM_WEB_RUBY_TEST_PACKAGE
    ///
    /// * INSTRUMENTATION_TEST_PACKAGE
    ///
    /// * XCTEST_TEST_PACKAGE
    ///
    /// * XCTEST_UI_TEST_PACKAGE
    ///
    /// * APPIUM_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_NODE_TEST_SPEC
    ///
    /// * APPIUM_RUBY_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_JUNIT_TEST_SPEC
    ///
    /// * APPIUM_WEB_JAVA_TESTNG_TEST_SPEC
    ///
    /// * APPIUM_WEB_PYTHON_TEST_SPEC
    ///
    /// * APPIUM_WEB_NODE_TEST_SPEC
    ///
    /// * APPIUM_WEB_RUBY_TEST_SPEC
    ///
    /// * INSTRUMENTATION_TEST_SPEC
    ///
    /// * XCTEST_UI_TEST_SPEC
    public var type: DeviceFarmClientTypes.UploadType?

    public init(
        arn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        type: DeviceFarmClientTypes.UploadType? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.type = type
    }
}

/// Represents the result of a list uploads request.
public struct ListUploadsOutput: Swift.Sendable {
    /// If the number of items that are returned is significantly large, this is an identifier that is also returned. It can be used in a subsequent call to this operation to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// Information about the uploads.
    public var uploads: [DeviceFarmClientTypes.Upload]?

    public init(
        nextToken: Swift.String? = nil,
        uploads: [DeviceFarmClientTypes.Upload]? = nil
    )
    {
        self.nextToken = nextToken
        self.uploads = uploads
    }
}

public struct ListVPCEConfigurationsInput: Swift.Sendable {
    /// An integer that specifies the maximum number of items you want to return in the API response.
    public var maxResults: Swift.Int?
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListVPCEConfigurationsOutput: Swift.Sendable {
    /// An identifier that was returned from the previous call to this operation, which can be used to return the next set of items in the list.
    public var nextToken: Swift.String?
    /// An array of VPCEConfiguration objects that contain information about your VPC endpoint configuration.
    public var vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        vpceConfigurations: [DeviceFarmClientTypes.VPCEConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.vpceConfigurations = vpceConfigurations
    }
}

/// Represents a request for a purchase offering.
public struct PurchaseOfferingInput: Swift.Sendable {
    /// The ID of the offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The ID of the offering promotion to be applied to the purchase.
    public var offeringPromotionId: Swift.String?
    /// The number of device slots to purchase in an offering request.
    /// This member is required.
    public var quantity: Swift.Int?

    public init(
        offeringId: Swift.String? = nil,
        offeringPromotionId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.offeringPromotionId = offeringPromotionId
        self.quantity = quantity
    }
}

/// The result of the purchase offering (for example, success or failure).
public struct PurchaseOfferingOutput: Swift.Sendable {
    /// Represents the offering transaction for the purchase result.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init(
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

/// A request that represents an offering renewal.
public struct RenewOfferingInput: Swift.Sendable {
    /// The ID of a request to renew an offering.
    /// This member is required.
    public var offeringId: Swift.String?
    /// The quantity requested in an offering renewal.
    /// This member is required.
    public var quantity: Swift.Int?

    public init(
        offeringId: Swift.String? = nil,
        quantity: Swift.Int? = nil
    )
    {
        self.offeringId = offeringId
        self.quantity = quantity
    }
}

/// The result of a renewal offering.
public struct RenewOfferingOutput: Swift.Sendable {
    /// Represents the status of the offering transaction for the renewal.
    public var offeringTransaction: DeviceFarmClientTypes.OfferingTransaction?

    public init(
        offeringTransaction: DeviceFarmClientTypes.OfferingTransaction? = nil
    )
    {
        self.offeringTransaction = offeringTransaction
    }
}

/// An entity with the same name already exists.
public struct IdempotencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Any additional information about the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IdempotencyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension DeviceFarmClientTypes {

    /// Represents the device filters used in a test run and the maximum number of devices to be included in the run. It is passed in as the deviceSelectionConfiguration request parameter in [ScheduleRun].
    public struct DeviceSelectionConfiguration: Swift.Sendable {
        /// Used to dynamically select a set of devices for a test run. A filter is made up of an attribute, an operator, and one or more values.
        ///
        /// * Attribute The aspect of a device such as platform or model used as the selection criteria in a device filter. Allowed values include:
        ///
        /// * ARN: The Amazon Resource Name (ARN) of the device (for example, arn:aws:devicefarm:us-west-2::device:12345Example).
        ///
        /// * PLATFORM: The device platform. Valid values are ANDROID or IOS.
        ///
        /// * OS_VERSION: The operating system version (for example, 10.3.2).
        ///
        /// * MODEL: The device model (for example, iPad 5th Gen).
        ///
        /// * AVAILABILITY: The current availability of the device. Valid values are AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * FORM_FACTOR: The device form factor. Valid values are PHONE or TABLET.
        ///
        /// * MANUFACTURER: The device manufacturer (for example, Apple).
        ///
        /// * REMOTE_ACCESS_ENABLED: Whether the device is enabled for remote access. Valid values are TRUE or FALSE.
        ///
        /// * REMOTE_DEBUG_ENABLED: Whether the device is enabled for remote debugging. Valid values are TRUE or FALSE. Because remote debugging is [no longer supported](https://docs.aws.amazon.com/devicefarm/latest/developerguide/history.html), this filter is ignored.
        ///
        /// * INSTANCE_ARN: The Amazon Resource Name (ARN) of the device instance.
        ///
        /// * INSTANCE_LABELS: The label of the device instance.
        ///
        /// * FLEET_TYPE: The fleet type. Valid values are PUBLIC or PRIVATE.
        ///
        ///
        ///
        ///
        /// * Operator The filter operator.
        ///
        /// * The EQUALS operator is available for every attribute except INSTANCE_LABELS.
        ///
        /// * The CONTAINS operator is available for the INSTANCE_LABELS and MODEL attributes.
        ///
        /// * The IN and NOT_IN operators are available for the ARN, OS_VERSION, MODEL, MANUFACTURER, and INSTANCE_ARN attributes.
        ///
        /// * The LESS_THAN, GREATER_THAN, LESS_THAN_OR_EQUALS, and GREATER_THAN_OR_EQUALS operators are also available for the OS_VERSION attribute.
        ///
        ///
        ///
        ///
        /// * Values An array of one or more filter values. Operator Values
        ///
        /// * The IN and NOT_IN operators can take a values array that has more than one element.
        ///
        /// * The other operators require an array with a single element.
        ///
        ///
        /// Attribute Values
        ///
        /// * The PLATFORM attribute can be set to ANDROID or IOS.
        ///
        /// * The AVAILABILITY attribute can be set to AVAILABLE, HIGHLY_AVAILABLE, BUSY, or TEMPORARY_NOT_AVAILABLE.
        ///
        /// * The FORM_FACTOR attribute can be set to PHONE or TABLET.
        ///
        /// * The FLEET_TYPE attribute can be set to PUBLIC or PRIVATE.
        /// This member is required.
        public var filters: [DeviceFarmClientTypes.DeviceFilter]?
        /// The maximum number of devices to be included in a test run.
        /// This member is required.
        public var maxDevices: Swift.Int?

        public init(
            filters: [DeviceFarmClientTypes.DeviceFilter]? = nil,
            maxDevices: Swift.Int? = nil
        )
        {
            self.filters = filters
            self.maxDevices = maxDevices
        }
    }
}

extension DeviceFarmClientTypes {

    /// Represents configuration information about a test run, such as the execution timeout (in minutes).
    public struct ExecutionConfiguration: Swift.Sendable {
        /// True if account cleanup is enabled at the beginning of the test. Otherwise, false.
        public var accountsCleanup: Swift.Bool?
        /// True if app package cleanup is enabled at the beginning of the test. Otherwise, false.
        public var appPackagesCleanup: Swift.Bool?
        /// The number of minutes a test run executes before it times out.
        public var jobTimeoutMinutes: Swift.Int?
        /// When set to true, for private devices, Device Farm does not sign your app again. For public devices, Device Farm always signs your apps again. For more information about how Device Farm re-signs your apps, see [Do you modify my app?](http://aws.amazon.com/device-farm/faqs/) in the AWS Device Farm FAQs.
        public var skipAppResign: Swift.Bool?
        /// Set to true to enable video capture. Otherwise, set to false. The default is true.
        public var videoCapture: Swift.Bool?

        public init(
            accountsCleanup: Swift.Bool? = nil,
            appPackagesCleanup: Swift.Bool? = nil,
            jobTimeoutMinutes: Swift.Int? = nil,
            skipAppResign: Swift.Bool? = nil,
            videoCapture: Swift.Bool? = nil
        )
        {
            self.accountsCleanup = accountsCleanup
            self.appPackagesCleanup = appPackagesCleanup
            self.jobTimeoutMinutes = jobTimeoutMinutes
            self.skipAppResign = skipAppResign
            self.videoCapture = videoCapture
        }
    }
}

/// Represents a request to the schedule run operation.
public struct ScheduleRunInput: Swift.Sendable {
    /// The ARN of an application package to run tests against, created with [CreateUpload]. See [ListUploads].
    public var appArn: Swift.String?
    /// Information about the settings for the run to be scheduled.
    public var configuration: DeviceFarmClientTypes.ScheduleRunConfiguration?
    /// The ARN of the device pool for the run to be scheduled.
    public var devicePoolArn: Swift.String?
    /// The filter criteria used to dynamically select a set of devices for a test run and the maximum number of devices to be included in the run. Either devicePoolArn or deviceSelectionConfiguration is required in a request.
    public var deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration?
    /// Specifies configuration information about a test run, such as the execution timeout (in minutes).
    public var executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration?
    /// The name for the run to be scheduled.
    public var name: Swift.String?
    /// The ARN of the project for the run to be scheduled.
    /// This member is required.
    public var projectArn: Swift.String?
    /// Information about the test for the run to be scheduled.
    /// This member is required.
    public var test: DeviceFarmClientTypes.ScheduleRunTest?

    public init(
        appArn: Swift.String? = nil,
        configuration: DeviceFarmClientTypes.ScheduleRunConfiguration? = nil,
        devicePoolArn: Swift.String? = nil,
        deviceSelectionConfiguration: DeviceFarmClientTypes.DeviceSelectionConfiguration? = nil,
        executionConfiguration: DeviceFarmClientTypes.ExecutionConfiguration? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        test: DeviceFarmClientTypes.ScheduleRunTest? = nil
    )
    {
        self.appArn = appArn
        self.configuration = configuration
        self.devicePoolArn = devicePoolArn
        self.deviceSelectionConfiguration = deviceSelectionConfiguration
        self.executionConfiguration = executionConfiguration
        self.name = name
        self.projectArn = projectArn
        self.test = test
    }
}

/// Represents the result of a schedule run request.
public struct ScheduleRunOutput: Swift.Sendable {
    /// Information about the scheduled run.
    public var run: DeviceFarmClientTypes.Run?

    public init(
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

public struct StopJobInput: Swift.Sendable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm job to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct StopJobOutput: Swift.Sendable {
    /// The job that was stopped.
    public var job: DeviceFarmClientTypes.Job?

    public init(
        job: DeviceFarmClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

/// Represents the request to stop the remote access session.
public struct StopRemoteAccessSessionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the remote access session to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the response from the server that describes the remote access session when AWS Device Farm stops the session.
public struct StopRemoteAccessSessionOutput: Swift.Sendable {
    /// A container that represents the metadata from the service about the remote access session you are stopping.
    public var remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession?

    public init(
        remoteAccessSession: DeviceFarmClientTypes.RemoteAccessSession? = nil
    )
    {
        self.remoteAccessSession = remoteAccessSession
    }
}

/// Represents the request to stop a specific run.
public struct StopRunInput: Swift.Sendable {
    /// Represents the Amazon Resource Name (ARN) of the Device Farm run to stop.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

/// Represents the results of your stop run attempt.
public struct StopRunOutput: Swift.Sendable {
    /// The run that was stopped.
    public var run: DeviceFarmClientTypes.Run?

    public init(
        run: DeviceFarmClientTypes.Run? = nil
    )
    {
        self.run = run
    }
}

/// The request doesn't comply with the AWS Identity and Access Management (IAM) tag policy. Correct your request and then retry it.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource or resources to which to add tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters. Tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [DeviceFarmClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [DeviceFarmClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource or resources from which to delete tags. You can associate tags with the following Device Farm resources: PROJECT, RUN, NETWORK_PROFILE, INSTANCE_PROFILE, DEVICE_INSTANCE, SESSION, DEVICE_POOL, DEVICE, and VPCE_CONFIGURATION.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDeviceInstanceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the device instance.
    /// This member is required.
    public var arn: Swift.String?
    /// An array of strings that you want to associate with the device instance.
    public var labels: [Swift.String]?
    /// The ARN of the profile that you want to associate with the device instance.
    public var profileArn: Swift.String?

    public init(
        arn: Swift.String? = nil,
        labels: [Swift.String]? = nil,
        profileArn: Swift.String? = nil
    )
    {
        self.arn = arn
        self.labels = labels
        self.profileArn = profileArn
    }
}

public struct UpdateDeviceInstanceOutput: Swift.Sendable {
    /// An object that contains information about your device instance.
    public var deviceInstance: DeviceFarmClientTypes.DeviceInstance?

    public init(
        deviceInstance: DeviceFarmClientTypes.DeviceInstance? = nil
    )
    {
        self.deviceInstance = deviceInstance
    }
}

/// Represents a request to the update device pool operation.
public struct UpdateDevicePoolInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Device Farm device pool to update.
    /// This member is required.
    public var arn: Swift.String?
    /// Sets whether the maxDevices parameter applies to your device pool. If you set this parameter to true, the maxDevices parameter does not apply, and Device Farm does not limit the number of devices that it adds to your device pool. In this case, Device Farm adds all available devices that meet the criteria specified in the rules parameter. If you use this parameter in your request, you cannot use the maxDevices parameter in the same request.
    public var clearMaxDevices: Swift.Bool?
    /// A description of the device pool to update.
    public var description: Swift.String?
    /// The number of devices that Device Farm can add to your device pool. Device Farm adds devices that are available and that meet the criteria that you assign for the rules parameter. Depending on how many devices meet these constraints, your device pool might contain fewer devices than the value for this parameter. By specifying the maximum number of devices, you can control the costs that you incur by running tests. If you use this parameter in your request, you cannot use the clearMaxDevices parameter in the same request.
    public var maxDevices: Swift.Int?
    /// A string that represents the name of the device pool to update.
    public var name: Swift.String?
    /// Represents the rules to modify for the device pool. Updating rules is optional. If you update rules for your request, the update replaces the existing rules.
    public var rules: [DeviceFarmClientTypes.Rule]?

    public init(
        arn: Swift.String? = nil,
        clearMaxDevices: Swift.Bool? = nil,
        description: Swift.String? = nil,
        maxDevices: Swift.Int? = nil,
        name: Swift.String? = nil,
        rules: [DeviceFarmClientTypes.Rule]? = nil
    )
    {
        self.arn = arn
        self.clearMaxDevices = clearMaxDevices
        self.description = description
        self.maxDevices = maxDevices
        self.name = name
        self.rules = rules
    }
}

/// Represents the result of an update device pool request.
public struct UpdateDevicePoolOutput: Swift.Sendable {
    /// The device pool you just updated.
    public var devicePool: DeviceFarmClientTypes.DevicePool?

    public init(
        devicePool: DeviceFarmClientTypes.DevicePool? = nil
    )
    {
        self.devicePool = devicePool
    }
}

public struct UpdateInstanceProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the instance profile.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated description for your instance profile.
    public var description: Swift.String?
    /// An array of strings that specifies the list of app packages that should not be cleaned up from the device after a test run is over. The list of packages is only considered if you set packageCleanup to true.
    public var excludeAppPackagesFromCleanup: [Swift.String]?
    /// The updated name for your instance profile.
    public var name: Swift.String?
    /// The updated choice for whether you want to specify package cleanup. The default value is false for private devices.
    public var packageCleanup: Swift.Bool?
    /// The updated choice for whether you want to reboot the device after use. The default value is true.
    public var rebootAfterUse: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        excludeAppPackagesFromCleanup: [Swift.String]? = nil,
        name: Swift.String? = nil,
        packageCleanup: Swift.Bool? = nil,
        rebootAfterUse: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.excludeAppPackagesFromCleanup = excludeAppPackagesFromCleanup
        self.name = name
        self.packageCleanup = packageCleanup
        self.rebootAfterUse = rebootAfterUse
    }
}

public struct UpdateInstanceProfileOutput: Swift.Sendable {
    /// An object that contains information about your instance profile.
    public var instanceProfile: DeviceFarmClientTypes.InstanceProfile?

    public init(
        instanceProfile: DeviceFarmClientTypes.InstanceProfile? = nil
    )
    {
        self.instanceProfile = instanceProfile
    }
}

public struct UpdateNetworkProfileInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project for which you want to update network profile settings.
    /// This member is required.
    public var arn: Swift.String?
    /// The description of the network profile about which you are returning information.
    public var description: Swift.String?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var downlinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var downlinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var downlinkJitterMs: Swift.Int?
    /// Proportion of received packets that fail to arrive from 0 to 100 percent.
    public var downlinkLossPercent: Swift.Int?
    /// The name of the network profile about which you are returning information.
    public var name: Swift.String?
    /// The type of network profile to return information about. Valid values are listed here.
    public var type: DeviceFarmClientTypes.NetworkProfileType?
    /// The data throughput rate in bits per second, as an integer from 0 to 104857600.
    public var uplinkBandwidthBits: Swift.Int?
    /// Delay time for all packets to destination in milliseconds as an integer from 0 to 2000.
    public var uplinkDelayMs: Swift.Int?
    /// Time variation in the delay of received packets in milliseconds as an integer from 0 to 2000.
    public var uplinkJitterMs: Swift.Int?
    /// Proportion of transmitted packets that fail to arrive from 0 to 100 percent.
    public var uplinkLossPercent: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        downlinkBandwidthBits: Swift.Int? = nil,
        downlinkDelayMs: Swift.Int? = nil,
        downlinkJitterMs: Swift.Int? = nil,
        downlinkLossPercent: Swift.Int? = 0,
        name: Swift.String? = nil,
        type: DeviceFarmClientTypes.NetworkProfileType? = nil,
        uplinkBandwidthBits: Swift.Int? = nil,
        uplinkDelayMs: Swift.Int? = nil,
        uplinkJitterMs: Swift.Int? = nil,
        uplinkLossPercent: Swift.Int? = 0
    )
    {
        self.arn = arn
        self.description = description
        self.downlinkBandwidthBits = downlinkBandwidthBits
        self.downlinkDelayMs = downlinkDelayMs
        self.downlinkJitterMs = downlinkJitterMs
        self.downlinkLossPercent = downlinkLossPercent
        self.name = name
        self.type = type
        self.uplinkBandwidthBits = uplinkBandwidthBits
        self.uplinkDelayMs = uplinkDelayMs
        self.uplinkJitterMs = uplinkJitterMs
        self.uplinkLossPercent = uplinkLossPercent
    }
}

public struct UpdateNetworkProfileOutput: Swift.Sendable {
    /// A list of the available network profiles.
    public var networkProfile: DeviceFarmClientTypes.NetworkProfile?

    public init(
        networkProfile: DeviceFarmClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

/// Represents a request to the update project operation.
public struct UpdateProjectInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the project whose name to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The number of minutes a test run in the project executes before it times out.
    public var defaultJobTimeoutMinutes: Swift.Int?
    /// A string that represents the new name of the project that you are updating.
    public var name: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.VpcConfig?

    public init(
        arn: Swift.String? = nil,
        defaultJobTimeoutMinutes: Swift.Int? = nil,
        name: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.VpcConfig? = nil
    )
    {
        self.arn = arn
        self.defaultJobTimeoutMinutes = defaultJobTimeoutMinutes
        self.name = name
        self.vpcConfig = vpcConfig
    }
}

/// Represents the result of an update project request.
public struct UpdateProjectOutput: Swift.Sendable {
    /// The project to update.
    public var project: DeviceFarmClientTypes.Project?

    public init(
        project: DeviceFarmClientTypes.Project? = nil
    )
    {
        self.project = project
    }
}

public struct UpdateTestGridProjectInput: Swift.Sendable {
    /// Human-readable description for the project.
    public var description: Swift.String?
    /// Human-readable name for the project.
    public var name: Swift.String?
    /// ARN of the project to update.
    /// This member is required.
    public var projectArn: Swift.String?
    /// The VPC security groups and subnets that are attached to a project.
    public var vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        vpcConfig: DeviceFarmClientTypes.TestGridVpcConfig? = nil
    )
    {
        self.description = description
        self.name = name
        self.projectArn = projectArn
        self.vpcConfig = vpcConfig
    }
}

public struct UpdateTestGridProjectOutput: Swift.Sendable {
    /// The project, including updated information.
    public var testGridProject: DeviceFarmClientTypes.TestGridProject?

    public init(
        testGridProject: DeviceFarmClientTypes.TestGridProject? = nil
    )
    {
        self.testGridProject = testGridProject
    }
}

public struct UpdateUploadInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the uploaded test spec.
    /// This member is required.
    public var arn: Swift.String?
    /// The upload's content type (for example, application/x-yaml).
    public var contentType: Swift.String?
    /// Set to true if the YAML file has changed and must be updated. Otherwise, set to false.
    public var editContent: Swift.Bool?
    /// The upload's test spec file name. The name must not contain any forward slashes (/). The test spec file name must end with the .yaml or .yml file extension.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        contentType: Swift.String? = nil,
        editContent: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.contentType = contentType
        self.editContent = editContent
        self.name = name
    }
}

public struct UpdateUploadOutput: Swift.Sendable {
    /// A test spec uploaded to Device Farm.
    public var upload: DeviceFarmClientTypes.Upload?

    public init(
        upload: DeviceFarmClientTypes.Upload? = nil
    )
    {
        self.upload = upload
    }
}

public struct UpdateVPCEConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the VPC endpoint configuration you want to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The DNS (domain) name used to connect to your private service in your VPC. The DNS name must not already be in use on the internet.
    public var serviceDnsName: Swift.String?
    /// An optional description that provides details about your VPC endpoint configuration.
    public var vpceConfigurationDescription: Swift.String?
    /// The friendly name you give to your VPC endpoint configuration to manage your configurations more easily.
    public var vpceConfigurationName: Swift.String?
    /// The name of the VPC endpoint service running in your AWS account that you want Device Farm to test.
    public var vpceServiceName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        serviceDnsName: Swift.String? = nil,
        vpceConfigurationDescription: Swift.String? = nil,
        vpceConfigurationName: Swift.String? = nil,
        vpceServiceName: Swift.String? = nil
    )
    {
        self.arn = arn
        self.serviceDnsName = serviceDnsName
        self.vpceConfigurationDescription = vpceConfigurationDescription
        self.vpceConfigurationName = vpceConfigurationName
        self.vpceServiceName = vpceServiceName
    }
}

public struct UpdateVPCEConfigurationOutput: Swift.Sendable {
    /// An object that contains information about your VPC endpoint configuration.
    public var vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration?

    public init(
        vpceConfiguration: DeviceFarmClientTypes.VPCEConfiguration? = nil
    )
    {
        self.vpceConfiguration = vpceConfiguration
    }
}

extension CreateDevicePoolInput {

    static func urlPathProvider(_ value: CreateDevicePoolInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceProfileInput {

    static func urlPathProvider(_ value: CreateInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNetworkProfileInput {

    static func urlPathProvider(_ value: CreateNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRemoteAccessSessionInput {

    static func urlPathProvider(_ value: CreateRemoteAccessSessionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTestGridProjectInput {

    static func urlPathProvider(_ value: CreateTestGridProjectInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTestGridUrlInput {

    static func urlPathProvider(_ value: CreateTestGridUrlInput) -> Swift.String? {
        return "/"
    }
}

extension CreateUploadInput {

    static func urlPathProvider(_ value: CreateUploadInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVPCEConfigurationInput {

    static func urlPathProvider(_ value: CreateVPCEConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDevicePoolInput {

    static func urlPathProvider(_ value: DeleteDevicePoolInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceProfileInput {

    static func urlPathProvider(_ value: DeleteInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNetworkProfileInput {

    static func urlPathProvider(_ value: DeleteNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRemoteAccessSessionInput {

    static func urlPathProvider(_ value: DeleteRemoteAccessSessionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRunInput {

    static func urlPathProvider(_ value: DeleteRunInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTestGridProjectInput {

    static func urlPathProvider(_ value: DeleteTestGridProjectInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteUploadInput {

    static func urlPathProvider(_ value: DeleteUploadInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVPCEConfigurationInput {

    static func urlPathProvider(_ value: DeleteVPCEConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAccountSettingsInput {

    static func urlPathProvider(_ value: GetAccountSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        return "/"
    }
}

extension GetDeviceInstanceInput {

    static func urlPathProvider(_ value: GetDeviceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension GetDevicePoolInput {

    static func urlPathProvider(_ value: GetDevicePoolInput) -> Swift.String? {
        return "/"
    }
}

extension GetDevicePoolCompatibilityInput {

    static func urlPathProvider(_ value: GetDevicePoolCompatibilityInput) -> Swift.String? {
        return "/"
    }
}

extension GetInstanceProfileInput {

    static func urlPathProvider(_ value: GetInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetJobInput {

    static func urlPathProvider(_ value: GetJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetNetworkProfileInput {

    static func urlPathProvider(_ value: GetNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetOfferingStatusInput {

    static func urlPathProvider(_ value: GetOfferingStatusInput) -> Swift.String? {
        return "/"
    }
}

extension GetProjectInput {

    static func urlPathProvider(_ value: GetProjectInput) -> Swift.String? {
        return "/"
    }
}

extension GetRemoteAccessSessionInput {

    static func urlPathProvider(_ value: GetRemoteAccessSessionInput) -> Swift.String? {
        return "/"
    }
}

extension GetRunInput {

    static func urlPathProvider(_ value: GetRunInput) -> Swift.String? {
        return "/"
    }
}

extension GetSuiteInput {

    static func urlPathProvider(_ value: GetSuiteInput) -> Swift.String? {
        return "/"
    }
}

extension GetTestInput {

    static func urlPathProvider(_ value: GetTestInput) -> Swift.String? {
        return "/"
    }
}

extension GetTestGridProjectInput {

    static func urlPathProvider(_ value: GetTestGridProjectInput) -> Swift.String? {
        return "/"
    }
}

extension GetTestGridSessionInput {

    static func urlPathProvider(_ value: GetTestGridSessionInput) -> Swift.String? {
        return "/"
    }
}

extension GetUploadInput {

    static func urlPathProvider(_ value: GetUploadInput) -> Swift.String? {
        return "/"
    }
}

extension GetVPCEConfigurationInput {

    static func urlPathProvider(_ value: GetVPCEConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension InstallToRemoteAccessSessionInput {

    static func urlPathProvider(_ value: InstallToRemoteAccessSessionInput) -> Swift.String? {
        return "/"
    }
}

extension ListArtifactsInput {

    static func urlPathProvider(_ value: ListArtifactsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDeviceInstancesInput {

    static func urlPathProvider(_ value: ListDeviceInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListDevicePoolsInput {

    static func urlPathProvider(_ value: ListDevicePoolsInput) -> Swift.String? {
        return "/"
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceProfilesInput {

    static func urlPathProvider(_ value: ListInstanceProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListJobsInput {

    static func urlPathProvider(_ value: ListJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListNetworkProfilesInput {

    static func urlPathProvider(_ value: ListNetworkProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOfferingPromotionsInput {

    static func urlPathProvider(_ value: ListOfferingPromotionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOfferingsInput {

    static func urlPathProvider(_ value: ListOfferingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOfferingTransactionsInput {

    static func urlPathProvider(_ value: ListOfferingTransactionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRemoteAccessSessionsInput {

    static func urlPathProvider(_ value: ListRemoteAccessSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRunsInput {

    static func urlPathProvider(_ value: ListRunsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSamplesInput {

    static func urlPathProvider(_ value: ListSamplesInput) -> Swift.String? {
        return "/"
    }
}

extension ListSuitesInput {

    static func urlPathProvider(_ value: ListSuitesInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTestGridProjectsInput {

    static func urlPathProvider(_ value: ListTestGridProjectsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTestGridSessionActionsInput {

    static func urlPathProvider(_ value: ListTestGridSessionActionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTestGridSessionArtifactsInput {

    static func urlPathProvider(_ value: ListTestGridSessionArtifactsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTestGridSessionsInput {

    static func urlPathProvider(_ value: ListTestGridSessionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTestsInput {

    static func urlPathProvider(_ value: ListTestsInput) -> Swift.String? {
        return "/"
    }
}

extension ListUniqueProblemsInput {

    static func urlPathProvider(_ value: ListUniqueProblemsInput) -> Swift.String? {
        return "/"
    }
}

extension ListUploadsInput {

    static func urlPathProvider(_ value: ListUploadsInput) -> Swift.String? {
        return "/"
    }
}

extension ListVPCEConfigurationsInput {

    static func urlPathProvider(_ value: ListVPCEConfigurationsInput) -> Swift.String? {
        return "/"
    }
}

extension PurchaseOfferingInput {

    static func urlPathProvider(_ value: PurchaseOfferingInput) -> Swift.String? {
        return "/"
    }
}

extension RenewOfferingInput {

    static func urlPathProvider(_ value: RenewOfferingInput) -> Swift.String? {
        return "/"
    }
}

extension ScheduleRunInput {

    static func urlPathProvider(_ value: ScheduleRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopJobInput {

    static func urlPathProvider(_ value: StopJobInput) -> Swift.String? {
        return "/"
    }
}

extension StopRemoteAccessSessionInput {

    static func urlPathProvider(_ value: StopRemoteAccessSessionInput) -> Swift.String? {
        return "/"
    }
}

extension StopRunInput {

    static func urlPathProvider(_ value: StopRunInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDeviceInstanceInput {

    static func urlPathProvider(_ value: UpdateDeviceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDevicePoolInput {

    static func urlPathProvider(_ value: UpdateDevicePoolInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInstanceProfileInput {

    static func urlPathProvider(_ value: UpdateInstanceProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNetworkProfileInput {

    static func urlPathProvider(_ value: UpdateNetworkProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTestGridProjectInput {

    static func urlPathProvider(_ value: UpdateTestGridProjectInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateUploadInput {

    static func urlPathProvider(_ value: UpdateUploadInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateVPCEConfigurationInput {

    static func urlPathProvider(_ value: UpdateVPCEConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDevicePoolInput {

    static func write(value: CreateDevicePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["maxDevices"].write(value.maxDevices)
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["rules"].writeList(value.rules, memberWritingClosure: DeviceFarmClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInstanceProfileInput {

    static func write(value: CreateInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["excludeAppPackagesFromCleanup"].writeList(value.excludeAppPackagesFromCleanup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["packageCleanup"].write(value.packageCleanup)
        try writer["rebootAfterUse"].write(value.rebootAfterUse)
    }
}

extension CreateNetworkProfileInput {

    static func write(value: CreateNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["downlinkBandwidthBits"].write(value.downlinkBandwidthBits)
        try writer["downlinkDelayMs"].write(value.downlinkDelayMs)
        try writer["downlinkJitterMs"].write(value.downlinkJitterMs)
        try writer["downlinkLossPercent"].write(value.downlinkLossPercent)
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["type"].write(value.type)
        try writer["uplinkBandwidthBits"].write(value.uplinkBandwidthBits)
        try writer["uplinkDelayMs"].write(value.uplinkDelayMs)
        try writer["uplinkJitterMs"].write(value.uplinkJitterMs)
        try writer["uplinkLossPercent"].write(value.uplinkLossPercent)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultJobTimeoutMinutes"].write(value.defaultJobTimeoutMinutes)
        try writer["name"].write(value.name)
        try writer["vpcConfig"].write(value.vpcConfig, with: DeviceFarmClientTypes.VpcConfig.write(value:to:))
    }
}

extension CreateRemoteAccessSessionInput {

    static func write(value: CreateRemoteAccessSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["configuration"].write(value.configuration, with: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration.write(value:to:))
        try writer["deviceArn"].write(value.deviceArn)
        try writer["instanceArn"].write(value.instanceArn)
        try writer["interactionMode"].write(value.interactionMode)
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["remoteDebugEnabled"].write(value.remoteDebugEnabled)
        try writer["remoteRecordAppArn"].write(value.remoteRecordAppArn)
        try writer["remoteRecordEnabled"].write(value.remoteRecordEnabled)
        try writer["skipAppResign"].write(value.skipAppResign)
        try writer["sshPublicKey"].write(value.sshPublicKey)
    }
}

extension CreateTestGridProjectInput {

    static func write(value: CreateTestGridProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["vpcConfig"].write(value.vpcConfig, with: DeviceFarmClientTypes.TestGridVpcConfig.write(value:to:))
    }
}

extension CreateTestGridUrlInput {

    static func write(value: CreateTestGridUrlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresInSeconds"].write(value.expiresInSeconds)
        try writer["projectArn"].write(value.projectArn)
    }
}

extension CreateUploadInput {

    static func write(value: CreateUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contentType"].write(value.contentType)
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["type"].write(value.type)
    }
}

extension CreateVPCEConfigurationInput {

    static func write(value: CreateVPCEConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serviceDnsName"].write(value.serviceDnsName)
        try writer["vpceConfigurationDescription"].write(value.vpceConfigurationDescription)
        try writer["vpceConfigurationName"].write(value.vpceConfigurationName)
        try writer["vpceServiceName"].write(value.vpceServiceName)
    }
}

extension DeleteDevicePoolInput {

    static func write(value: DeleteDevicePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteInstanceProfileInput {

    static func write(value: DeleteInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteNetworkProfileInput {

    static func write(value: DeleteNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteProjectInput {

    static func write(value: DeleteProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteRemoteAccessSessionInput {

    static func write(value: DeleteRemoteAccessSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteRunInput {

    static func write(value: DeleteRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteTestGridProjectInput {

    static func write(value: DeleteTestGridProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
    }
}

extension DeleteUploadInput {

    static func write(value: DeleteUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension DeleteVPCEConfigurationInput {

    static func write(value: DeleteVPCEConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetAccountSettingsInput {

    static func write(value: GetAccountSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetDeviceInput {

    static func write(value: GetDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetDeviceInstanceInput {

    static func write(value: GetDeviceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetDevicePoolInput {

    static func write(value: GetDevicePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetDevicePoolCompatibilityInput {

    static func write(value: GetDevicePoolCompatibilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appArn"].write(value.appArn)
        try writer["configuration"].write(value.configuration, with: DeviceFarmClientTypes.ScheduleRunConfiguration.write(value:to:))
        try writer["devicePoolArn"].write(value.devicePoolArn)
        try writer["test"].write(value.test, with: DeviceFarmClientTypes.ScheduleRunTest.write(value:to:))
        try writer["testType"].write(value.testType)
    }
}

extension GetInstanceProfileInput {

    static func write(value: GetInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetJobInput {

    static func write(value: GetJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetNetworkProfileInput {

    static func write(value: GetNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetOfferingStatusInput {

    static func write(value: GetOfferingStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetProjectInput {

    static func write(value: GetProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetRemoteAccessSessionInput {

    static func write(value: GetRemoteAccessSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetRunInput {

    static func write(value: GetRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetSuiteInput {

    static func write(value: GetSuiteInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetTestInput {

    static func write(value: GetTestInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetTestGridProjectInput {

    static func write(value: GetTestGridProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
    }
}

extension GetTestGridSessionInput {

    static func write(value: GetTestGridSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
        try writer["sessionArn"].write(value.sessionArn)
        try writer["sessionId"].write(value.sessionId)
    }
}

extension GetUploadInput {

    static func write(value: GetUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetVPCEConfigurationInput {

    static func write(value: GetVPCEConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension InstallToRemoteAccessSessionInput {

    static func write(value: InstallToRemoteAccessSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appArn"].write(value.appArn)
        try writer["remoteAccessSessionArn"].write(value.remoteAccessSessionArn)
    }
}

extension ListArtifactsInput {

    static func write(value: ListArtifactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
        try writer["type"].write(value.type)
    }
}

extension ListDeviceInstancesInput {

    static func write(value: ListDeviceInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListDevicePoolsInput {

    static func write(value: ListDevicePoolsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
        try writer["type"].write(value.type)
    }
}

extension ListDevicesInput {

    static func write(value: ListDevicesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["filters"].writeList(value.filters, memberWritingClosure: DeviceFarmClientTypes.DeviceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListInstanceProfilesInput {

    static func write(value: ListInstanceProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListJobsInput {

    static func write(value: ListJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListNetworkProfilesInput {

    static func write(value: ListNetworkProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
        try writer["type"].write(value.type)
    }
}

extension ListOfferingPromotionsInput {

    static func write(value: ListOfferingPromotionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListOfferingsInput {

    static func write(value: ListOfferingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListOfferingTransactionsInput {

    static func write(value: ListOfferingTransactionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListProjectsInput {

    static func write(value: ListProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRemoteAccessSessionsInput {

    static func write(value: ListRemoteAccessSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRunsInput {

    static func write(value: ListRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSamplesInput {

    static func write(value: ListSamplesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSuitesInput {

    static func write(value: ListSuitesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListTestGridProjectsInput {

    static func write(value: ListTestGridProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResult"].write(value.maxResult)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTestGridSessionActionsInput {

    static func write(value: ListTestGridSessionActionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResult"].write(value.maxResult)
        try writer["nextToken"].write(value.nextToken)
        try writer["sessionArn"].write(value.sessionArn)
    }
}

extension ListTestGridSessionArtifactsInput {

    static func write(value: ListTestGridSessionArtifactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResult"].write(value.maxResult)
        try writer["nextToken"].write(value.nextToken)
        try writer["sessionArn"].write(value.sessionArn)
        try writer["type"].write(value.type)
    }
}

extension ListTestGridSessionsInput {

    static func write(value: ListTestGridSessionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["creationTimeAfter"].writeTimestamp(value.creationTimeAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["creationTimeBefore"].writeTimestamp(value.creationTimeBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["endTimeAfter"].writeTimestamp(value.endTimeAfter, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["endTimeBefore"].writeTimestamp(value.endTimeBefore, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["maxResult"].write(value.maxResult)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectArn"].write(value.projectArn)
        try writer["status"].write(value.status)
    }
}

extension ListTestsInput {

    static func write(value: ListTestsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListUniqueProblemsInput {

    static func write(value: ListUniqueProblemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListUploadsInput {

    static func write(value: ListUploadsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["nextToken"].write(value.nextToken)
        try writer["type"].write(value.type)
    }
}

extension ListVPCEConfigurationsInput {

    static func write(value: ListVPCEConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension PurchaseOfferingInput {

    static func write(value: PurchaseOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offeringId"].write(value.offeringId)
        try writer["offeringPromotionId"].write(value.offeringPromotionId)
        try writer["quantity"].write(value.quantity)
    }
}

extension RenewOfferingInput {

    static func write(value: RenewOfferingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offeringId"].write(value.offeringId)
        try writer["quantity"].write(value.quantity)
    }
}

extension ScheduleRunInput {

    static func write(value: ScheduleRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appArn"].write(value.appArn)
        try writer["configuration"].write(value.configuration, with: DeviceFarmClientTypes.ScheduleRunConfiguration.write(value:to:))
        try writer["devicePoolArn"].write(value.devicePoolArn)
        try writer["deviceSelectionConfiguration"].write(value.deviceSelectionConfiguration, with: DeviceFarmClientTypes.DeviceSelectionConfiguration.write(value:to:))
        try writer["executionConfiguration"].write(value.executionConfiguration, with: DeviceFarmClientTypes.ExecutionConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["test"].write(value.test, with: DeviceFarmClientTypes.ScheduleRunTest.write(value:to:))
    }
}

extension StopJobInput {

    static func write(value: StopJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension StopRemoteAccessSessionInput {

    static func write(value: StopRemoteAccessSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension StopRunInput {

    static func write(value: StopRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: DeviceFarmClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDeviceInstanceInput {

    static func write(value: UpdateDeviceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["labels"].writeList(value.labels, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["profileArn"].write(value.profileArn)
    }
}

extension UpdateDevicePoolInput {

    static func write(value: UpdateDevicePoolInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["clearMaxDevices"].write(value.clearMaxDevices)
        try writer["description"].write(value.description)
        try writer["maxDevices"].write(value.maxDevices)
        try writer["name"].write(value.name)
        try writer["rules"].writeList(value.rules, memberWritingClosure: DeviceFarmClientTypes.Rule.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateInstanceProfileInput {

    static func write(value: UpdateInstanceProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["description"].write(value.description)
        try writer["excludeAppPackagesFromCleanup"].writeList(value.excludeAppPackagesFromCleanup, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["packageCleanup"].write(value.packageCleanup)
        try writer["rebootAfterUse"].write(value.rebootAfterUse)
    }
}

extension UpdateNetworkProfileInput {

    static func write(value: UpdateNetworkProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["description"].write(value.description)
        try writer["downlinkBandwidthBits"].write(value.downlinkBandwidthBits)
        try writer["downlinkDelayMs"].write(value.downlinkDelayMs)
        try writer["downlinkJitterMs"].write(value.downlinkJitterMs)
        try writer["downlinkLossPercent"].write(value.downlinkLossPercent)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
        try writer["uplinkBandwidthBits"].write(value.uplinkBandwidthBits)
        try writer["uplinkDelayMs"].write(value.uplinkDelayMs)
        try writer["uplinkJitterMs"].write(value.uplinkJitterMs)
        try writer["uplinkLossPercent"].write(value.uplinkLossPercent)
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["defaultJobTimeoutMinutes"].write(value.defaultJobTimeoutMinutes)
        try writer["name"].write(value.name)
        try writer["vpcConfig"].write(value.vpcConfig, with: DeviceFarmClientTypes.VpcConfig.write(value:to:))
    }
}

extension UpdateTestGridProjectInput {

    static func write(value: UpdateTestGridProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["projectArn"].write(value.projectArn)
        try writer["vpcConfig"].write(value.vpcConfig, with: DeviceFarmClientTypes.TestGridVpcConfig.write(value:to:))
    }
}

extension UpdateUploadInput {

    static func write(value: UpdateUploadInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["contentType"].write(value.contentType)
        try writer["editContent"].write(value.editContent)
        try writer["name"].write(value.name)
    }
}

extension UpdateVPCEConfigurationInput {

    static func write(value: UpdateVPCEConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["serviceDnsName"].write(value.serviceDnsName)
        try writer["vpceConfigurationDescription"].write(value.vpceConfigurationDescription)
        try writer["vpceConfigurationName"].write(value.vpceConfigurationName)
        try writer["vpceServiceName"].write(value.vpceServiceName)
    }
}

extension CreateDevicePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDevicePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDevicePoolOutput()
        value.devicePool = try reader["devicePool"].readIfPresent(with: DeviceFarmClientTypes.DevicePool.read(from:))
        return value
    }
}

extension CreateInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceProfileOutput()
        value.instanceProfile = try reader["instanceProfile"].readIfPresent(with: DeviceFarmClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension CreateNetworkProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNetworkProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNetworkProfileOutput()
        value.networkProfile = try reader["networkProfile"].readIfPresent(with: DeviceFarmClientTypes.NetworkProfile.read(from:))
        return value
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.project = try reader["project"].readIfPresent(with: DeviceFarmClientTypes.Project.read(from:))
        return value
    }
}

extension CreateRemoteAccessSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRemoteAccessSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRemoteAccessSessionOutput()
        value.remoteAccessSession = try reader["remoteAccessSession"].readIfPresent(with: DeviceFarmClientTypes.RemoteAccessSession.read(from:))
        return value
    }
}

extension CreateTestGridProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTestGridProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTestGridProjectOutput()
        value.testGridProject = try reader["testGridProject"].readIfPresent(with: DeviceFarmClientTypes.TestGridProject.read(from:))
        return value
    }
}

extension CreateTestGridUrlOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTestGridUrlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTestGridUrlOutput()
        value.expires = try reader["expires"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension CreateUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateUploadOutput()
        value.upload = try reader["upload"].readIfPresent(with: DeviceFarmClientTypes.Upload.read(from:))
        return value
    }
}

extension CreateVPCEConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVPCEConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVPCEConfigurationOutput()
        value.vpceConfiguration = try reader["vpceConfiguration"].readIfPresent(with: DeviceFarmClientTypes.VPCEConfiguration.read(from:))
        return value
    }
}

extension DeleteDevicePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDevicePoolOutput {
        return DeleteDevicePoolOutput()
    }
}

extension DeleteInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceProfileOutput {
        return DeleteInstanceProfileOutput()
    }
}

extension DeleteNetworkProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNetworkProfileOutput {
        return DeleteNetworkProfileOutput()
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

extension DeleteRemoteAccessSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRemoteAccessSessionOutput {
        return DeleteRemoteAccessSessionOutput()
    }
}

extension DeleteRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRunOutput {
        return DeleteRunOutput()
    }
}

extension DeleteTestGridProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTestGridProjectOutput {
        return DeleteTestGridProjectOutput()
    }
}

extension DeleteUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteUploadOutput {
        return DeleteUploadOutput()
    }
}

extension DeleteVPCEConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVPCEConfigurationOutput {
        return DeleteVPCEConfigurationOutput()
    }
}

extension GetAccountSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccountSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccountSettingsOutput()
        value.accountSettings = try reader["accountSettings"].readIfPresent(with: DeviceFarmClientTypes.AccountSettings.read(from:))
        return value
    }
}

extension GetDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceOutput()
        value.device = try reader["device"].readIfPresent(with: DeviceFarmClientTypes.Device.read(from:))
        return value
    }
}

extension GetDeviceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceInstanceOutput()
        value.deviceInstance = try reader["deviceInstance"].readIfPresent(with: DeviceFarmClientTypes.DeviceInstance.read(from:))
        return value
    }
}

extension GetDevicePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevicePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicePoolOutput()
        value.devicePool = try reader["devicePool"].readIfPresent(with: DeviceFarmClientTypes.DevicePool.read(from:))
        return value
    }
}

extension GetDevicePoolCompatibilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDevicePoolCompatibilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDevicePoolCompatibilityOutput()
        value.compatibleDevices = try reader["compatibleDevices"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DevicePoolCompatibilityResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.incompatibleDevices = try reader["incompatibleDevices"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DevicePoolCompatibilityResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInstanceProfileOutput()
        value.instanceProfile = try reader["instanceProfile"].readIfPresent(with: DeviceFarmClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension GetJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetJobOutput()
        value.job = try reader["job"].readIfPresent(with: DeviceFarmClientTypes.Job.read(from:))
        return value
    }
}

extension GetNetworkProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNetworkProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNetworkProfileOutput()
        value.networkProfile = try reader["networkProfile"].readIfPresent(with: DeviceFarmClientTypes.NetworkProfile.read(from:))
        return value
    }
}

extension GetOfferingStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOfferingStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOfferingStatusOutput()
        value.current = try reader["current"].readMapIfPresent(valueReadingClosure: DeviceFarmClientTypes.OfferingStatus.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextPeriod = try reader["nextPeriod"].readMapIfPresent(valueReadingClosure: DeviceFarmClientTypes.OfferingStatus.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProjectOutput()
        value.project = try reader["project"].readIfPresent(with: DeviceFarmClientTypes.Project.read(from:))
        return value
    }
}

extension GetRemoteAccessSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRemoteAccessSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRemoteAccessSessionOutput()
        value.remoteAccessSession = try reader["remoteAccessSession"].readIfPresent(with: DeviceFarmClientTypes.RemoteAccessSession.read(from:))
        return value
    }
}

extension GetRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRunOutput()
        value.run = try reader["run"].readIfPresent(with: DeviceFarmClientTypes.Run.read(from:))
        return value
    }
}

extension GetSuiteOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSuiteOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSuiteOutput()
        value.suite = try reader["suite"].readIfPresent(with: DeviceFarmClientTypes.Suite.read(from:))
        return value
    }
}

extension GetTestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestOutput()
        value.test = try reader["test"].readIfPresent(with: DeviceFarmClientTypes.Test.read(from:))
        return value
    }
}

extension GetTestGridProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestGridProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestGridProjectOutput()
        value.testGridProject = try reader["testGridProject"].readIfPresent(with: DeviceFarmClientTypes.TestGridProject.read(from:))
        return value
    }
}

extension GetTestGridSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTestGridSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTestGridSessionOutput()
        value.testGridSession = try reader["testGridSession"].readIfPresent(with: DeviceFarmClientTypes.TestGridSession.read(from:))
        return value
    }
}

extension GetUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetUploadOutput()
        value.upload = try reader["upload"].readIfPresent(with: DeviceFarmClientTypes.Upload.read(from:))
        return value
    }
}

extension GetVPCEConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVPCEConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVPCEConfigurationOutput()
        value.vpceConfiguration = try reader["vpceConfiguration"].readIfPresent(with: DeviceFarmClientTypes.VPCEConfiguration.read(from:))
        return value
    }
}

extension InstallToRemoteAccessSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InstallToRemoteAccessSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InstallToRemoteAccessSessionOutput()
        value.appUpload = try reader["appUpload"].readIfPresent(with: DeviceFarmClientTypes.Upload.read(from:))
        return value
    }
}

extension ListArtifactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListArtifactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListArtifactsOutput()
        value.artifacts = try reader["artifacts"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Artifact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDeviceInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceInstancesOutput()
        value.deviceInstances = try reader["deviceInstances"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DeviceInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDevicePoolsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicePoolsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicePoolsOutput()
        value.devicePools = try reader["devicePools"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DevicePool.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Device.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInstanceProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceProfilesOutput()
        value.instanceProfiles = try reader["instanceProfiles"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.InstanceProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJobsOutput()
        value.jobs = try reader["jobs"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Job.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListNetworkProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNetworkProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNetworkProfilesOutput()
        value.networkProfiles = try reader["networkProfiles"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.NetworkProfile.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListOfferingPromotionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOfferingPromotionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOfferingPromotionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.offeringPromotions = try reader["offeringPromotions"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.OfferingPromotion.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOfferingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOfferingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOfferingsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.offerings = try reader["offerings"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Offering.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListOfferingTransactionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOfferingTransactionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOfferingTransactionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.offeringTransactions = try reader["offeringTransactions"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.OfferingTransaction.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Project.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRemoteAccessSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRemoteAccessSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRemoteAccessSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.remoteAccessSessions = try reader["remoteAccessSessions"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.RemoteAccessSession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRunsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.runs = try reader["runs"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Run.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSamplesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSamplesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSamplesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.samples = try reader["samples"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Sample.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSuitesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSuitesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSuitesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.suites = try reader["suites"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Suite.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTestGridProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestGridProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestGridProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testGridProjects = try reader["testGridProjects"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.TestGridProject.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTestGridSessionActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestGridSessionActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestGridSessionActionsOutput()
        value.actions = try reader["actions"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.TestGridSessionAction.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTestGridSessionArtifactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestGridSessionArtifactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestGridSessionArtifactsOutput()
        value.artifacts = try reader["artifacts"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.TestGridSessionArtifact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTestGridSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestGridSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestGridSessionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.testGridSessions = try reader["testGridSessions"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.TestGridSession.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTestsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTestsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTestsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tests = try reader["tests"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Test.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListUniqueProblemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUniqueProblemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUniqueProblemsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.uniqueProblems = try reader["uniqueProblems"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: DeviceFarmClientTypes.UniqueProblem.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListUploadsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListUploadsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListUploadsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.uploads = try reader["uploads"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Upload.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListVPCEConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListVPCEConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListVPCEConfigurationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.vpceConfigurations = try reader["vpceConfigurations"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.VPCEConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PurchaseOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PurchaseOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PurchaseOfferingOutput()
        value.offeringTransaction = try reader["offeringTransaction"].readIfPresent(with: DeviceFarmClientTypes.OfferingTransaction.read(from:))
        return value
    }
}

extension RenewOfferingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RenewOfferingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RenewOfferingOutput()
        value.offeringTransaction = try reader["offeringTransaction"].readIfPresent(with: DeviceFarmClientTypes.OfferingTransaction.read(from:))
        return value
    }
}

extension ScheduleRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ScheduleRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ScheduleRunOutput()
        value.run = try reader["run"].readIfPresent(with: DeviceFarmClientTypes.Run.read(from:))
        return value
    }
}

extension StopJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopJobOutput()
        value.job = try reader["job"].readIfPresent(with: DeviceFarmClientTypes.Job.read(from:))
        return value
    }
}

extension StopRemoteAccessSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRemoteAccessSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopRemoteAccessSessionOutput()
        value.remoteAccessSession = try reader["remoteAccessSession"].readIfPresent(with: DeviceFarmClientTypes.RemoteAccessSession.read(from:))
        return value
    }
}

extension StopRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StopRunOutput()
        value.run = try reader["run"].readIfPresent(with: DeviceFarmClientTypes.Run.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDeviceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeviceInstanceOutput()
        value.deviceInstance = try reader["deviceInstance"].readIfPresent(with: DeviceFarmClientTypes.DeviceInstance.read(from:))
        return value
    }
}

extension UpdateDevicePoolOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDevicePoolOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDevicePoolOutput()
        value.devicePool = try reader["devicePool"].readIfPresent(with: DeviceFarmClientTypes.DevicePool.read(from:))
        return value
    }
}

extension UpdateInstanceProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInstanceProfileOutput()
        value.instanceProfile = try reader["instanceProfile"].readIfPresent(with: DeviceFarmClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension UpdateNetworkProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNetworkProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateNetworkProfileOutput()
        value.networkProfile = try reader["networkProfile"].readIfPresent(with: DeviceFarmClientTypes.NetworkProfile.read(from:))
        return value
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProjectOutput()
        value.project = try reader["project"].readIfPresent(with: DeviceFarmClientTypes.Project.read(from:))
        return value
    }
}

extension UpdateTestGridProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTestGridProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTestGridProjectOutput()
        value.testGridProject = try reader["testGridProject"].readIfPresent(with: DeviceFarmClientTypes.TestGridProject.read(from:))
        return value
    }
}

extension UpdateUploadOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateUploadOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateUploadOutput()
        value.upload = try reader["upload"].readIfPresent(with: DeviceFarmClientTypes.Upload.read(from:))
        return value
    }
}

extension UpdateVPCEConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateVPCEConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateVPCEConfigurationOutput()
        value.vpceConfiguration = try reader["vpceConfiguration"].readIfPresent(with: DeviceFarmClientTypes.VPCEConfiguration.read(from:))
        return value
    }
}

enum CreateDevicePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNetworkProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            case "TagOperationException": return try TagOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRemoteAccessSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTestGridProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTestGridUrlOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVPCEConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDevicePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNetworkProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRemoteAccessSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTestGridProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "CannotDeleteException": return try CannotDeleteException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVPCEConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccountSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevicePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDevicePoolCompatibilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNetworkProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOfferingStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRemoteAccessSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSuiteOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestGridProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTestGridSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVPCEConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InstallToRemoteAccessSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListArtifactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicePoolsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNetworkProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOfferingPromotionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOfferingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOfferingTransactionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRemoteAccessSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSamplesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSuitesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TagOperationException": return try TagOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestGridProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestGridSessionActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestGridSessionArtifactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestGridSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTestsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUniqueProblemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListUploadsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListVPCEConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PurchaseOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RenewOfferingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotEligibleException": return try NotEligibleException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ScheduleRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "IdempotencyException": return try IdempotencyException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRemoteAccessSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TagOperationException": return try TagOperationException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TagOperationException": return try TagOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDevicePoolOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNetworkProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTestGridProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InternalServiceException": return try InternalServiceException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateUploadOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateVPCEConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ArgumentException": return try ArgumentException.makeError(baseError: baseError)
            case "InvalidOperationException": return try InvalidOperationException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceAccountException": return try ServiceAccountException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ArgumentException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ArgumentException {
        let reader = baseError.errorBodyReader
        var value = ArgumentException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceAccountException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceAccountException {
        let reader = baseError.errorBodyReader
        var value = ServiceAccountException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagOperationException {
        let reader = baseError.errorBodyReader
        var value = TagOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServiceException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServiceException {
        let reader = baseError.errorBodyReader
        var value = InternalServiceException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CannotDeleteException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CannotDeleteException {
        let reader = baseError.errorBodyReader
        var value = CannotDeleteException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidOperationException {
        let reader = baseError.errorBodyReader
        var value = InvalidOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotEligibleException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotEligibleException {
        let reader = baseError.errorBodyReader
        var value = NotEligibleException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IdempotencyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> IdempotencyException {
        let reader = baseError.errorBodyReader
        var value = IdempotencyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceFarmClientTypes.DevicePool {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DevicePool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DevicePool()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.rules = try reader["rules"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.maxDevices = try reader["maxDevices"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Rule {

    static func write(value: DeviceFarmClientTypes.Rule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["operator"].write(value.`operator`)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Rule()
        value.attribute = try reader["attribute"].readIfPresent()
        value.`operator` = try reader["operator"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.InstanceProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.InstanceProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.InstanceProfile()
        value.arn = try reader["arn"].readIfPresent()
        value.packageCleanup = try reader["packageCleanup"].readIfPresent()
        value.excludeAppPackagesFromCleanup = try reader["excludeAppPackagesFromCleanup"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rebootAfterUse = try reader["rebootAfterUse"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.NetworkProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.NetworkProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.NetworkProfile()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.uplinkBandwidthBits = try reader["uplinkBandwidthBits"].readIfPresent()
        value.downlinkBandwidthBits = try reader["downlinkBandwidthBits"].readIfPresent()
        value.uplinkDelayMs = try reader["uplinkDelayMs"].readIfPresent()
        value.downlinkDelayMs = try reader["downlinkDelayMs"].readIfPresent()
        value.uplinkJitterMs = try reader["uplinkJitterMs"].readIfPresent()
        value.downlinkJitterMs = try reader["downlinkJitterMs"].readIfPresent()
        value.uplinkLossPercent = try reader["uplinkLossPercent"].readIfPresent() ?? 0
        value.downlinkLossPercent = try reader["downlinkLossPercent"].readIfPresent() ?? 0
        return value
    }
}

extension DeviceFarmClientTypes.Project {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Project {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Project()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.defaultJobTimeoutMinutes = try reader["defaultJobTimeoutMinutes"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: DeviceFarmClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.VpcConfig {

    static func write(value: DeviceFarmClientTypes.VpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.VpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.VpcConfig()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension DeviceFarmClientTypes.RemoteAccessSession {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.RemoteAccessSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.RemoteAccessSession()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopped = try reader["stopped"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.device = try reader["device"].readIfPresent(with: DeviceFarmClientTypes.Device.read(from:))
        value.instanceArn = try reader["instanceArn"].readIfPresent()
        value.remoteDebugEnabled = try reader["remoteDebugEnabled"].readIfPresent()
        value.remoteRecordEnabled = try reader["remoteRecordEnabled"].readIfPresent()
        value.remoteRecordAppArn = try reader["remoteRecordAppArn"].readIfPresent()
        value.hostAddress = try reader["hostAddress"].readIfPresent()
        value.clientId = try reader["clientId"].readIfPresent()
        value.billingMethod = try reader["billingMethod"].readIfPresent()
        value.deviceMinutes = try reader["deviceMinutes"].readIfPresent(with: DeviceFarmClientTypes.DeviceMinutes.read(from:))
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.deviceUdid = try reader["deviceUdid"].readIfPresent()
        value.interactionMode = try reader["interactionMode"].readIfPresent()
        value.skipAppResign = try reader["skipAppResign"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: DeviceFarmClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.DeviceMinutes {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DeviceMinutes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DeviceMinutes()
        value.total = try reader["total"].readIfPresent()
        value.metered = try reader["metered"].readIfPresent()
        value.unmetered = try reader["unmetered"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Device()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.manufacturer = try reader["manufacturer"].readIfPresent()
        value.model = try reader["model"].readIfPresent()
        value.modelId = try reader["modelId"].readIfPresent()
        value.formFactor = try reader["formFactor"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.os = try reader["os"].readIfPresent()
        value.cpu = try reader["cpu"].readIfPresent(with: DeviceFarmClientTypes.CPU.read(from:))
        value.resolution = try reader["resolution"].readIfPresent(with: DeviceFarmClientTypes.Resolution.read(from:))
        value.heapSize = try reader["heapSize"].readIfPresent()
        value.memory = try reader["memory"].readIfPresent()
        value.image = try reader["image"].readIfPresent()
        value.carrier = try reader["carrier"].readIfPresent()
        value.radio = try reader["radio"].readIfPresent()
        value.remoteAccessEnabled = try reader["remoteAccessEnabled"].readIfPresent()
        value.remoteDebugEnabled = try reader["remoteDebugEnabled"].readIfPresent()
        value.fleetType = try reader["fleetType"].readIfPresent()
        value.fleetName = try reader["fleetName"].readIfPresent()
        value.instances = try reader["instances"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DeviceInstance.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.availability = try reader["availability"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.DeviceInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DeviceInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DeviceInstance()
        value.arn = try reader["arn"].readIfPresent()
        value.deviceArn = try reader["deviceArn"].readIfPresent()
        value.labels = try reader["labels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent()
        value.udid = try reader["udid"].readIfPresent()
        value.instanceProfile = try reader["instanceProfile"].readIfPresent(with: DeviceFarmClientTypes.InstanceProfile.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.Resolution {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Resolution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Resolution()
        value.width = try reader["width"].readIfPresent()
        value.height = try reader["height"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.CPU {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.CPU {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.CPU()
        value.frequency = try reader["frequency"].readIfPresent()
        value.architecture = try reader["architecture"].readIfPresent()
        value.clock = try reader["clock"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.TestGridProject {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TestGridProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TestGridProject()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: DeviceFarmClientTypes.TestGridVpcConfig.read(from:))
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DeviceFarmClientTypes.TestGridVpcConfig {

    static func write(value: DeviceFarmClientTypes.TestGridVpcConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["subnetIds"].writeList(value.subnetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["vpcId"].write(value.vpcId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TestGridVpcConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TestGridVpcConfig()
        value.securityGroupIds = try reader["securityGroupIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.subnetIds = try reader["subnetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vpcId = try reader["vpcId"].readIfPresent() ?? ""
        return value
    }
}

extension DeviceFarmClientTypes.Upload {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Upload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Upload()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["type"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        value.metadata = try reader["metadata"].readIfPresent()
        value.contentType = try reader["contentType"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.category = try reader["category"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.VPCEConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.VPCEConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.VPCEConfiguration()
        value.arn = try reader["arn"].readIfPresent()
        value.vpceConfigurationName = try reader["vpceConfigurationName"].readIfPresent()
        value.vpceServiceName = try reader["vpceServiceName"].readIfPresent()
        value.serviceDnsName = try reader["serviceDnsName"].readIfPresent()
        value.vpceConfigurationDescription = try reader["vpceConfigurationDescription"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.AccountSettings {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.AccountSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.AccountSettings()
        value.awsAccountNumber = try reader["awsAccountNumber"].readIfPresent()
        value.unmeteredDevices = try reader["unmeteredDevices"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.unmeteredRemoteAccessDevices = try reader["unmeteredRemoteAccessDevices"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.maxJobTimeoutMinutes = try reader["maxJobTimeoutMinutes"].readIfPresent()
        value.trialMinutes = try reader["trialMinutes"].readIfPresent(with: DeviceFarmClientTypes.TrialMinutes.read(from:))
        value.maxSlots = try reader["maxSlots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readInt(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.defaultJobTimeoutMinutes = try reader["defaultJobTimeoutMinutes"].readIfPresent()
        value.skipAppResign = try reader["skipAppResign"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.TrialMinutes {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TrialMinutes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TrialMinutes()
        value.total = try reader["total"].readIfPresent()
        value.remaining = try reader["remaining"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.DevicePoolCompatibilityResult {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DevicePoolCompatibilityResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DevicePoolCompatibilityResult()
        value.device = try reader["device"].readIfPresent(with: DeviceFarmClientTypes.Device.read(from:))
        value.compatible = try reader["compatible"].readIfPresent()
        value.incompatibilityMessages = try reader["incompatibilityMessages"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.IncompatibilityMessage.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeviceFarmClientTypes.IncompatibilityMessage {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.IncompatibilityMessage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.IncompatibilityMessage()
        value.message = try reader["message"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Job {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Job {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Job()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopped = try reader["stopped"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.counters = try reader["counters"].readIfPresent(with: DeviceFarmClientTypes.Counters.read(from:))
        value.message = try reader["message"].readIfPresent()
        value.device = try reader["device"].readIfPresent(with: DeviceFarmClientTypes.Device.read(from:))
        value.instanceArn = try reader["instanceArn"].readIfPresent()
        value.deviceMinutes = try reader["deviceMinutes"].readIfPresent(with: DeviceFarmClientTypes.DeviceMinutes.read(from:))
        value.videoEndpoint = try reader["videoEndpoint"].readIfPresent()
        value.videoCapture = try reader["videoCapture"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Counters {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Counters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Counters()
        value.total = try reader["total"].readIfPresent()
        value.passed = try reader["passed"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        value.warned = try reader["warned"].readIfPresent()
        value.errored = try reader["errored"].readIfPresent()
        value.stopped = try reader["stopped"].readIfPresent()
        value.skipped = try reader["skipped"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.OfferingStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.OfferingStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.OfferingStatus()
        value.type = try reader["type"].readIfPresent()
        value.offering = try reader["offering"].readIfPresent(with: DeviceFarmClientTypes.Offering.read(from:))
        value.quantity = try reader["quantity"].readIfPresent()
        value.effectiveOn = try reader["effectiveOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension DeviceFarmClientTypes.Offering {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Offering {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Offering()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.recurringCharges = try reader["recurringCharges"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.RecurringCharge.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeviceFarmClientTypes.RecurringCharge {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.RecurringCharge {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.RecurringCharge()
        value.cost = try reader["cost"].readIfPresent(with: DeviceFarmClientTypes.MonetaryAmount.read(from:))
        value.frequency = try reader["frequency"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.MonetaryAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.MonetaryAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.MonetaryAmount()
        value.amount = try reader["amount"].readIfPresent()
        value.currencyCode = try reader["currencyCode"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Run {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Run {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Run()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.platform = try reader["platform"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopped = try reader["stopped"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.counters = try reader["counters"].readIfPresent(with: DeviceFarmClientTypes.Counters.read(from:))
        value.message = try reader["message"].readIfPresent()
        value.totalJobs = try reader["totalJobs"].readIfPresent()
        value.completedJobs = try reader["completedJobs"].readIfPresent()
        value.billingMethod = try reader["billingMethod"].readIfPresent()
        value.deviceMinutes = try reader["deviceMinutes"].readIfPresent(with: DeviceFarmClientTypes.DeviceMinutes.read(from:))
        value.networkProfile = try reader["networkProfile"].readIfPresent(with: DeviceFarmClientTypes.NetworkProfile.read(from:))
        value.parsingResultUrl = try reader["parsingResultUrl"].readIfPresent()
        value.resultCode = try reader["resultCode"].readIfPresent()
        value.seed = try reader["seed"].readIfPresent()
        value.appUpload = try reader["appUpload"].readIfPresent()
        value.eventCount = try reader["eventCount"].readIfPresent()
        value.jobTimeoutMinutes = try reader["jobTimeoutMinutes"].readIfPresent()
        value.devicePoolArn = try reader["devicePoolArn"].readIfPresent()
        value.locale = try reader["locale"].readIfPresent()
        value.radios = try reader["radios"].readIfPresent(with: DeviceFarmClientTypes.Radios.read(from:))
        value.location = try reader["location"].readIfPresent(with: DeviceFarmClientTypes.Location.read(from:))
        value.customerArtifactPaths = try reader["customerArtifactPaths"].readIfPresent(with: DeviceFarmClientTypes.CustomerArtifactPaths.read(from:))
        value.webUrl = try reader["webUrl"].readIfPresent()
        value.skipAppResign = try reader["skipAppResign"].readIfPresent()
        value.testSpecArn = try reader["testSpecArn"].readIfPresent()
        value.deviceSelectionResult = try reader["deviceSelectionResult"].readIfPresent(with: DeviceFarmClientTypes.DeviceSelectionResult.read(from:))
        value.vpcConfig = try reader["vpcConfig"].readIfPresent(with: DeviceFarmClientTypes.VpcConfig.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.DeviceSelectionResult {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DeviceSelectionResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DeviceSelectionResult()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.DeviceFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchedDevicesCount = try reader["matchedDevicesCount"].readIfPresent()
        value.maxDevices = try reader["maxDevices"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.DeviceFilter {

    static func write(value: DeviceFarmClientTypes.DeviceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute)
        try writer["operator"].write(value.`operator`)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.DeviceFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.DeviceFilter()
        value.attribute = try reader["attribute"].readIfPresent() ?? .sdkUnknown("")
        value.`operator` = try reader["operator"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension DeviceFarmClientTypes.CustomerArtifactPaths {

    static func write(value: DeviceFarmClientTypes.CustomerArtifactPaths?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["androidPaths"].writeList(value.androidPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["deviceHostPaths"].writeList(value.deviceHostPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["iosPaths"].writeList(value.iosPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.CustomerArtifactPaths {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.CustomerArtifactPaths()
        value.iosPaths = try reader["iosPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.androidPaths = try reader["androidPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.deviceHostPaths = try reader["deviceHostPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeviceFarmClientTypes.Location {

    static func write(value: DeviceFarmClientTypes.Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["latitude"].write(value.latitude)
        try writer["longitude"].write(value.longitude)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Location()
        value.latitude = try reader["latitude"].readIfPresent() ?? 0.0
        value.longitude = try reader["longitude"].readIfPresent() ?? 0.0
        return value
    }
}

extension DeviceFarmClientTypes.Radios {

    static func write(value: DeviceFarmClientTypes.Radios?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bluetooth"].write(value.bluetooth)
        try writer["gps"].write(value.gps)
        try writer["nfc"].write(value.nfc)
        try writer["wifi"].write(value.wifi)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Radios {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Radios()
        value.wifi = try reader["wifi"].readIfPresent()
        value.bluetooth = try reader["bluetooth"].readIfPresent()
        value.nfc = try reader["nfc"].readIfPresent()
        value.gps = try reader["gps"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Suite {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Suite {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Suite()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopped = try reader["stopped"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.counters = try reader["counters"].readIfPresent(with: DeviceFarmClientTypes.Counters.read(from:))
        value.message = try reader["message"].readIfPresent()
        value.deviceMinutes = try reader["deviceMinutes"].readIfPresent(with: DeviceFarmClientTypes.DeviceMinutes.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.Test {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Test {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Test()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopped = try reader["stopped"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.counters = try reader["counters"].readIfPresent(with: DeviceFarmClientTypes.Counters.read(from:))
        value.message = try reader["message"].readIfPresent()
        value.deviceMinutes = try reader["deviceMinutes"].readIfPresent(with: DeviceFarmClientTypes.DeviceMinutes.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.TestGridSession {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TestGridSession {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TestGridSession()
        value.arn = try reader["arn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.created = try reader["created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.ended = try reader["ended"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.billingMinutes = try reader["billingMinutes"].readIfPresent()
        value.seleniumProperties = try reader["seleniumProperties"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Artifact {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Artifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Artifact()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.`extension` = try reader["extension"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.OfferingPromotion {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.OfferingPromotion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.OfferingPromotion()
        value.id = try reader["id"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.OfferingTransaction {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.OfferingTransaction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.OfferingTransaction()
        value.offeringStatus = try reader["offeringStatus"].readIfPresent(with: DeviceFarmClientTypes.OfferingStatus.read(from:))
        value.transactionId = try reader["transactionId"].readIfPresent()
        value.offeringPromotionId = try reader["offeringPromotionId"].readIfPresent()
        value.createdOn = try reader["createdOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.cost = try reader["cost"].readIfPresent(with: DeviceFarmClientTypes.MonetaryAmount.read(from:))
        return value
    }
}

extension DeviceFarmClientTypes.Sample {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Sample {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Sample()
        value.arn = try reader["arn"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.Tag {

    static func write(value: DeviceFarmClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension DeviceFarmClientTypes.TestGridSessionAction {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TestGridSessionAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TestGridSessionAction()
        value.action = try reader["action"].readIfPresent()
        value.started = try reader["started"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.duration = try reader["duration"].readIfPresent()
        value.statusCode = try reader["statusCode"].readIfPresent()
        value.requestMethod = try reader["requestMethod"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.TestGridSessionArtifact {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.TestGridSessionArtifact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.TestGridSessionArtifact()
        value.filename = try reader["filename"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.url = try reader["url"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.UniqueProblem {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.UniqueProblem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.UniqueProblem()
        value.message = try reader["message"].readIfPresent()
        value.problems = try reader["problems"].readListIfPresent(memberReadingClosure: DeviceFarmClientTypes.Problem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DeviceFarmClientTypes.Problem {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.Problem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.Problem()
        value.run = try reader["run"].readIfPresent(with: DeviceFarmClientTypes.ProblemDetail.read(from:))
        value.job = try reader["job"].readIfPresent(with: DeviceFarmClientTypes.ProblemDetail.read(from:))
        value.suite = try reader["suite"].readIfPresent(with: DeviceFarmClientTypes.ProblemDetail.read(from:))
        value.test = try reader["test"].readIfPresent(with: DeviceFarmClientTypes.ProblemDetail.read(from:))
        value.device = try reader["device"].readIfPresent(with: DeviceFarmClientTypes.Device.read(from:))
        value.result = try reader["result"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.ProblemDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> DeviceFarmClientTypes.ProblemDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = DeviceFarmClientTypes.ProblemDetail()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration {

    static func write(value: DeviceFarmClientTypes.CreateRemoteAccessSessionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billingMethod"].write(value.billingMethod)
        try writer["vpceConfigurationArns"].writeList(value.vpceConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeviceFarmClientTypes.ScheduleRunTest {

    static func write(value: DeviceFarmClientTypes.ScheduleRunTest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["testPackageArn"].write(value.testPackageArn)
        try writer["testSpecArn"].write(value.testSpecArn)
        try writer["type"].write(value.type)
    }
}

extension DeviceFarmClientTypes.ScheduleRunConfiguration {

    static func write(value: DeviceFarmClientTypes.ScheduleRunConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["auxiliaryApps"].writeList(value.auxiliaryApps, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["billingMethod"].write(value.billingMethod)
        try writer["customerArtifactPaths"].write(value.customerArtifactPaths, with: DeviceFarmClientTypes.CustomerArtifactPaths.write(value:to:))
        try writer["extraDataPackageArn"].write(value.extraDataPackageArn)
        try writer["locale"].write(value.locale)
        try writer["location"].write(value.location, with: DeviceFarmClientTypes.Location.write(value:to:))
        try writer["networkProfileArn"].write(value.networkProfileArn)
        try writer["radios"].write(value.radios, with: DeviceFarmClientTypes.Radios.write(value:to:))
        try writer["vpceConfigurationArns"].writeList(value.vpceConfigurationArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeviceFarmClientTypes.DeviceSelectionConfiguration {

    static func write(value: DeviceFarmClientTypes.DeviceSelectionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: DeviceFarmClientTypes.DeviceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxDevices"].write(value.maxDevices)
    }
}

extension DeviceFarmClientTypes.ExecutionConfiguration {

    static func write(value: DeviceFarmClientTypes.ExecutionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountsCleanup"].write(value.accountsCleanup)
        try writer["appPackagesCleanup"].write(value.appPackagesCleanup)
        try writer["jobTimeoutMinutes"].write(value.jobTimeoutMinutes)
        try writer["skipAppResign"].write(value.skipAppResign)
        try writer["videoCapture"].write(value.videoCapture)
    }
}

public enum DeviceFarmClientTypes {}
