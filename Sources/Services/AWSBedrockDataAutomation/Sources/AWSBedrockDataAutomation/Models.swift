//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// This exception is thrown when a request is denied per access permissions
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown if there was an unexpected error during processing of request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when a resource referenced by the operation does not exist
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the number of requests exceeds the limit
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception
    public struct ValidationExceptionField: Swift.Sendable {
        /// Non Blank String
        /// This member is required.
        public var message: Swift.String?
        /// Non Blank String
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

/// This exception is thrown when the request's input validation fails
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// list of ValidationExceptionField
        public internal(set) var fieldList: [BedrockDataAutomationClientTypes.ValidationExceptionField]? = nil
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockDataAutomationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

/// Structure for request of GetBlueprintOptimizationStatus API.
public struct GetBlueprintOptimizationStatusInput: Swift.Sendable {
    /// Invocation arn.
    /// This member is required.
    public var invocationArn: Swift.String?

    public init(
        invocationArn: Swift.String? = nil
    ) {
        self.invocationArn = invocationArn
    }
}

extension BedrockDataAutomationClientTypes {

    /// S3 object
    public struct S3Object: Swift.Sendable {
        /// S3 uri.
        /// This member is required.
        public var s3Uri: Swift.String?
        /// S3 object version.
        public var version: Swift.String?

        public init(
            s3Uri: Swift.String? = nil,
            version: Swift.String? = nil
        ) {
            self.s3Uri = s3Uri
            self.version = version
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Optimization Output configuration.
    public struct BlueprintOptimizationOutputConfiguration: Swift.Sendable {
        /// S3 object.
        /// This member is required.
        public var s3Object: BedrockDataAutomationClientTypes.S3Object?

        public init(
            s3Object: BedrockDataAutomationClientTypes.S3Object? = nil
        ) {
            self.s3Object = s3Object
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// List of status supported by optimization jobs
    public enum BlueprintOptimizationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case clientError
        case created
        case inProgress
        case serviceError
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintOptimizationJobStatus] {
            return [
                .clientError,
                .created,
                .inProgress,
                .serviceError,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .clientError: return "ClientError"
            case .created: return "Created"
            case .inProgress: return "InProgress"
            case .serviceError: return "ServiceError"
            case .success: return "Success"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Response of GetBlueprintOptimizationStatus API.
public struct GetBlueprintOptimizationStatusOutput: Swift.Sendable {
    /// Error Message.
    public var errorMessage: Swift.String?
    /// Error Type.
    public var errorType: Swift.String?
    /// Output configuration.
    public var outputConfiguration: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration?
    /// Job Status.
    public var status: BedrockDataAutomationClientTypes.BlueprintOptimizationJobStatus?

    public init(
        errorMessage: Swift.String? = nil,
        errorType: Swift.String? = nil,
        outputConfiguration: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration? = nil,
        status: BedrockDataAutomationClientTypes.BlueprintOptimizationJobStatus? = nil
    ) {
        self.errorMessage = errorMessage
        self.errorType = errorType
        self.outputConfiguration = outputConfiguration
        self.status = status
    }
}

/// This exception is thrown when a request is made beyond the service quota
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stage of the Blueprint
    public enum BlueprintStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Structure for single blueprint entity.
    public struct BlueprintOptimizationObject: Swift.Sendable {
        /// Arn of blueprint.
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of blueprint.
        public var stage: BedrockDataAutomationClientTypes.BlueprintStage?

        public init(
            blueprintArn: Swift.String? = nil,
            stage: BedrockDataAutomationClientTypes.BlueprintStage? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.stage = stage
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// KMS Encryption Configuration
    public struct EncryptionConfiguration: Swift.Sendable {
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init(
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil
        ) {
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Recommendation Sample
    public struct BlueprintOptimizationSample: Swift.Sendable {
        /// S3 Object of the asset
        /// This member is required.
        public var assetS3Object: BedrockDataAutomationClientTypes.S3Object?
        /// Ground truth for the Blueprint and Asset combination
        /// This member is required.
        public var groundTruthS3Object: BedrockDataAutomationClientTypes.S3Object?

        public init(
            assetS3Object: BedrockDataAutomationClientTypes.S3Object? = nil,
            groundTruthS3Object: BedrockDataAutomationClientTypes.S3Object? = nil
        ) {
            self.assetS3Object = assetS3Object
            self.groundTruthS3Object = groundTruthS3Object
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Key value pair of a tag
    public struct Tag: Swift.Sendable {
        /// Defines the context of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Defines the value within the context. e.g. <key=reason, value=training>.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

/// Invoke Blueprint Optimization Async Request
public struct InvokeBlueprintOptimizationAsyncInput: Swift.Sendable {
    /// Blueprint to be optimized
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.BlueprintOptimizationObject?
    /// Data automation profile ARN
    /// This member is required.
    public var dataAutomationProfileArn: Swift.String?
    /// Encryption configuration.
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Output configuration where the results should be placed
    /// This member is required.
    public var outputConfiguration: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration?
    /// List of Blueprint Optimization Samples
    /// This member is required.
    public var samples: [BedrockDataAutomationClientTypes.BlueprintOptimizationSample]?
    /// List of tags.
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        blueprint: BedrockDataAutomationClientTypes.BlueprintOptimizationObject? = nil,
        dataAutomationProfileArn: Swift.String? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        outputConfiguration: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration? = nil,
        samples: [BedrockDataAutomationClientTypes.BlueprintOptimizationSample]? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.blueprint = blueprint
        self.dataAutomationProfileArn = dataAutomationProfileArn
        self.encryptionConfiguration = encryptionConfiguration
        self.outputConfiguration = outputConfiguration
        self.samples = samples
        self.tags = tags
    }
}

/// Invoke Blueprint Optimization Async Response
public struct InvokeBlueprintOptimizationAsyncOutput: Swift.Sendable {
    /// ARN of the blueprint optimization job
    /// This member is required.
    public var invocationArn: Swift.String?

    public init(
        invocationArn: Swift.String? = nil
    ) {
        self.invocationArn = invocationArn
    }
}

/// This exception is thrown when there is a conflict performing an operation
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockDataAutomationClientTypes {

    /// Type
    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audio
        case document
        case image
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .audio,
                .document,
                .image,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Create Blueprint Request
public struct CreateBlueprintInput: Swift.Sendable {
    /// Name of the Blueprint
    /// This member is required.
    public var blueprintName: Swift.String?
    /// Stage of the Blueprint
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Schema of the blueprint
    /// This member is required.
    public var schema: Swift.String?
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?
    /// Type
    /// This member is required.
    public var type: BedrockDataAutomationClientTypes.ModelType?

    public init(
        blueprintName: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        clientToken: Swift.String? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        schema: Swift.String? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil,
        type: BedrockDataAutomationClientTypes.ModelType? = nil
    ) {
        self.blueprintName = blueprintName
        self.blueprintStage = blueprintStage
        self.clientToken = clientToken
        self.encryptionConfiguration = encryptionConfiguration
        self.schema = schema
        self.tags = tags
        self.type = type
    }
}

extension CreateBlueprintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBlueprintInput(blueprintStage: \(Swift.String(describing: blueprintStage)), clientToken: \(Swift.String(describing: clientToken)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), blueprintName: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\")"}
}

extension BedrockDataAutomationClientTypes {

    /// Contains the information of a Blueprint.
    public struct Blueprint: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Name of the Blueprint
        /// This member is required.
        public var blueprintName: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        public var kmsKeyId: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// List of Blueprint Optimization Samples
        public var optimizationSamples: [BedrockDataAutomationClientTypes.BlueprintOptimizationSample]?
        /// Time Stamp
        public var optimizationTime: Foundation.Date?
        /// Schema of the blueprint
        /// This member is required.
        public var schema: Swift.String?
        /// Type
        /// This member is required.
        public var type: BedrockDataAutomationClientTypes.ModelType?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintName: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            optimizationSamples: [BedrockDataAutomationClientTypes.BlueprintOptimizationSample]? = nil,
            optimizationTime: Foundation.Date? = nil,
            schema: Swift.String? = nil,
            type: BedrockDataAutomationClientTypes.ModelType? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.optimizationSamples = optimizationSamples
            self.optimizationTime = optimizationTime
            self.schema = schema
            self.type = type
        }
    }
}

extension BedrockDataAutomationClientTypes.Blueprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Blueprint(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), blueprintVersion: \(Swift.String(describing: blueprintVersion)), creationTime: \(Swift.String(describing: creationTime)), kmsEncryptionContext: \(Swift.String(describing: kmsEncryptionContext)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), optimizationSamples: \(Swift.String(describing: optimizationSamples)), optimizationTime: \(Swift.String(describing: optimizationTime)), type: \(Swift.String(describing: type)), blueprintName: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\")"}
}

/// Create Blueprint Response
public struct CreateBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

/// Delete Blueprint Request
public struct DeleteBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Optional field to delete a specific Blueprint version
    public var blueprintVersion: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintVersion: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintVersion = blueprintVersion
    }
}

/// Delete Blueprint Response
public struct DeleteBlueprintOutput: Swift.Sendable {

    public init() { }
}

/// Get Blueprint Request
public struct GetBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Optional field to get a specific Blueprint stage
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// Optional field to get a specific Blueprint version
    public var blueprintVersion: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        blueprintVersion: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStage = blueprintStage
        self.blueprintVersion = blueprintVersion
    }
}

/// Get Blueprint Response
public struct GetBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Stage filter
    public enum BlueprintStageFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStageFilter] {
            return [
                .all,
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stage of the Project
    public enum DataAutomationProjectStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Data Automation Project Filter
    public struct DataAutomationProjectFilter: Swift.Sendable {
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?

        public init(
            projectArn: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil
        ) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Resource Owner
    public enum ResourceOwner: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .account,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// List Blueprint Request
public struct ListBlueprintsInput: Swift.Sendable {
    /// ARN of a Blueprint
    public var blueprintArn: Swift.String?
    /// Blueprint Stage filter
    public var blueprintStageFilter: BedrockDataAutomationClientTypes.BlueprintStageFilter?
    /// Max Results
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Data Automation Project Filter
    public var projectFilter: BedrockDataAutomationClientTypes.DataAutomationProjectFilter?
    /// Resource Owner
    public var resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStageFilter: BedrockDataAutomationClientTypes.BlueprintStageFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectFilter: BedrockDataAutomationClientTypes.DataAutomationProjectFilter? = nil,
        resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStageFilter = blueprintStageFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectFilter = projectFilter
        self.resourceOwner = resourceOwner
    }
}

extension BedrockDataAutomationClientTypes {

    /// Summary of a Blueprint
    public struct BlueprintSummary: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Name of the Blueprint
        public var blueprintName: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Time Stamp
        public var lastModifiedTime: Foundation.Date?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintName: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

extension BedrockDataAutomationClientTypes.BlueprintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BlueprintSummary(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), blueprintVersion: \(Swift.String(describing: blueprintVersion)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), blueprintName: \"CONTENT_REDACTED\")"}
}

/// List Blueprint Response
public struct ListBlueprintsOutput: Swift.Sendable {
    /// List of Blueprints
    /// This member is required.
    public var blueprints: [BedrockDataAutomationClientTypes.BlueprintSummary]?
    /// Pagination token
    public var nextToken: Swift.String?

    public init(
        blueprints: [BedrockDataAutomationClientTypes.BlueprintSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.blueprints = blueprints
        self.nextToken = nextToken
    }
}

/// Update Blueprint Request
public struct UpdateBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Stage of the Blueprint
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Schema of the blueprint
    /// This member is required.
    public var schema: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        schema: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStage = blueprintStage
        self.encryptionConfiguration = encryptionConfiguration
        self.schema = schema
    }
}

extension UpdateBlueprintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBlueprintInput(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), schema: \"CONTENT_REDACTED\")"}
}

/// Update Blueprint Response
public struct UpdateBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

/// CopyBlueprintStage Request
public struct CopyBlueprintStageInput: Swift.Sendable {
    /// Blueprint to be copied
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Client token for idempotency
    public var clientToken: Swift.String?
    /// Source stage to copy from
    /// This member is required.
    public var sourceStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// Target stage to copy to
    /// This member is required.
    public var targetStage: BedrockDataAutomationClientTypes.BlueprintStage?

    public init(
        blueprintArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        sourceStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        targetStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.clientToken = clientToken
        self.sourceStage = sourceStage
        self.targetStage = targetStage
    }
}

/// CopyBlueprintStage Response
public struct CopyBlueprintStageOutput: Swift.Sendable {

    public init() { }
}

/// Create Blueprint Version Request
public struct CreateBlueprintVersionInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.clientToken = clientToken
    }
}

/// Create Blueprint Version Response
public struct CreateBlueprintVersionOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Item
    public struct BlueprintItem: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Custom output configuration
    public struct CustomOutputConfiguration: Swift.Sendable {
        /// List of Blueprint Item
        public var blueprints: [BedrockDataAutomationClientTypes.BlueprintItem]?

        public init(
            blueprints: [BedrockDataAutomationClientTypes.BlueprintItem]? = nil
        ) {
            self.blueprints = blueprints
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for Audio output language
    public enum AudioGenerativeOutputLanguage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case en
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioGenerativeOutputLanguage] {
            return [
                .default,
                .en
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .en: return "EN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Supported input languages
    public enum Language: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cn
        case de
        case en
        case es
        case fr
        case hk
        case it
        case ja
        case ko
        case pt
        case tw
        case sdkUnknown(Swift.String)

        public static var allCases: [Language] {
            return [
                .cn,
                .de,
                .en,
                .es,
                .fr,
                .hk,
                .it,
                .ja,
                .ko,
                .pt,
                .tw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cn: return "CN"
            case .de: return "DE"
            case .en: return "EN"
            case .es: return "ES"
            case .fr: return "FR"
            case .hk: return "HK"
            case .it: return "IT"
            case .ja: return "JA"
            case .ko: return "KO"
            case .pt: return "PT"
            case .tw: return "TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Optional configuration for audio language settings
    public struct AudioLanguageConfiguration: Swift.Sendable {
        /// Configuration for Audio output language
        public var generativeOutputLanguage: BedrockDataAutomationClientTypes.AudioGenerativeOutputLanguage?
        /// Enable multiple language identification in audio
        public var identifyMultipleLanguages: Swift.Bool?
        /// List of supported audio languages
        public var inputLanguages: [BedrockDataAutomationClientTypes.Language]?

        public init(
            generativeOutputLanguage: BedrockDataAutomationClientTypes.AudioGenerativeOutputLanguage? = nil,
            identifyMultipleLanguages: Swift.Bool? = nil,
            inputLanguages: [BedrockDataAutomationClientTypes.Language]? = nil
        ) {
            self.generativeOutputLanguage = generativeOutputLanguage
            self.identifyMultipleLanguages = identifyMultipleLanguages
            self.inputLanguages = inputLanguages
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// State
    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration to enable/disable processing of modality
    public struct ModalityProcessingConfiguration: Swift.Sendable {
        /// State
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Mode for sensitive data detection
    public enum SensitiveDataDetectionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Only detect sensitive data without redaction
        case detection
        /// Detect and redact sensitive data
        case detectionAndRedaction
        case sdkUnknown(Swift.String)

        public static var allCases: [SensitiveDataDetectionMode] {
            return [
                .detection,
                .detectionAndRedaction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .detection: return "DETECTION"
            case .detectionAndRedaction: return "DETECTION_AND_REDACTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Types of sensitive data detection scope
    public enum SensitiveDataDetectionScopeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Custom PII detection
        case custom
        /// Standard PII detection
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [SensitiveDataDetectionScopeType] {
            return [
                .custom,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Types of PII entities that can be detected, we will support every types that Guardrails can support
    public enum PIIEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// A physical address, such as '100 Main Street, Anytown, USA' or 'Suite #12, Building 123'
        case address
        /// An individual's age, including the quantity and unit of time
        case age
        /// All supported PII entity types
        case all
        /// A unique identifier associated with AWS secret access key
        case awsAccessKey
        /// A unique identifier associated with AWS access key for signing programmatic requests
        case awsSecretKey
        /// A Canadian Health Service Number - 10-digit unique identifier for healthcare benefits
        case caHealthNumber
        /// A Canadian Social Insurance Number (SIN) - nine-digit unique identifier
        case caSocialInsuranceNumber
        /// A three-digit card verification code (CVV) for VISA, MasterCard, and Discover cards, or four-digit for American Express
        case creditDebitCardCvv
        /// The expiration date for a credit or debit card
        case creditDebitCardExpiry
        /// The number for a credit or debit card
        case creditDebitCardNumber
        /// The number assigned to a driver's license
        case driverId
        /// An email address, such as marymajor@email.com
        case email
        /// An International Bank Account Number with specific formats for each country
        case internationalBankAccountNumber
        /// An IPv4 address, such as 198.51.100.0
        case ipAddress
        /// A license plate for a vehicle issued by the state or country where the vehicle is registered
        case licensePlate
        /// A media access control (MAC) address - unique identifier for network interface controller
        case macAddress
        /// An individual's name. Does not include titles such as Dr., Mr., Mrs., or Miss
        case name
        /// An alphanumeric string that is used as a password
        case password
        /// A phone number. Also includes fax and pager numbers
        case phone
        /// A four-digit personal identification number (PIN)
        case pin
        /// A SWIFT code - standard format of Bank Identifier Code (BIC)
        case swiftCode
        /// A UK National Health Service Number - 10-17 digit number
        case ukNationalHealthServiceNumber
        /// A UK National Insurance Number (NINO) for accessing National Insurance benefits
        case ukNationalInsuranceNumber
        /// A UK Unique Taxpayer Reference (UTR) - 10-digit number identifying taxpayer or business
        case ukUniqueTaxpayerReferenceNumber
        /// A web address, such as www.example.com
        case url
        /// A user name that identifies an account, such as a login name, screen name, nick name, or handle
        case username
        /// A US bank account number, typically 10 to 12 digits long
        case usBankAccountNumber
        /// A US bank account routing number, typically nine digits long
        case usBankRoutingNumber
        /// A US Individual Taxpayer Identification Number (ITIN)
        case usIndividualTaxIdentificationNumber
        /// A US passport number, ranging from six to nine alphanumeric characters
        case usPassportNumber
        /// A US Social Security Number (SSN) - nine-digit number for US citizens and residents
        case usSocialSecurityNumber
        /// A Vehicle Identification Number (VIN) that uniquely identifies a vehicle
        case vehicleIdentificationNumber
        case sdkUnknown(Swift.String)

        public static var allCases: [PIIEntityType] {
            return [
                .address,
                .age,
                .all,
                .awsAccessKey,
                .awsSecretKey,
                .caHealthNumber,
                .caSocialInsuranceNumber,
                .creditDebitCardCvv,
                .creditDebitCardExpiry,
                .creditDebitCardNumber,
                .driverId,
                .email,
                .internationalBankAccountNumber,
                .ipAddress,
                .licensePlate,
                .macAddress,
                .name,
                .password,
                .phone,
                .pin,
                .swiftCode,
                .ukNationalHealthServiceNumber,
                .ukNationalInsuranceNumber,
                .ukUniqueTaxpayerReferenceNumber,
                .url,
                .username,
                .usBankAccountNumber,
                .usBankRoutingNumber,
                .usIndividualTaxIdentificationNumber,
                .usPassportNumber,
                .usSocialSecurityNumber,
                .vehicleIdentificationNumber
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .address: return "ADDRESS"
            case .age: return "AGE"
            case .all: return "ALL"
            case .awsAccessKey: return "AWS_ACCESS_KEY"
            case .awsSecretKey: return "AWS_SECRET_KEY"
            case .caHealthNumber: return "CA_HEALTH_NUMBER"
            case .caSocialInsuranceNumber: return "CA_SOCIAL_INSURANCE_NUMBER"
            case .creditDebitCardCvv: return "CREDIT_DEBIT_CARD_CVV"
            case .creditDebitCardExpiry: return "CREDIT_DEBIT_CARD_EXPIRY"
            case .creditDebitCardNumber: return "CREDIT_DEBIT_CARD_NUMBER"
            case .driverId: return "DRIVER_ID"
            case .email: return "EMAIL"
            case .internationalBankAccountNumber: return "INTERNATIONAL_BANK_ACCOUNT_NUMBER"
            case .ipAddress: return "IP_ADDRESS"
            case .licensePlate: return "LICENSE_PLATE"
            case .macAddress: return "MAC_ADDRESS"
            case .name: return "NAME"
            case .password: return "PASSWORD"
            case .phone: return "PHONE"
            case .pin: return "PIN"
            case .swiftCode: return "SWIFT_CODE"
            case .ukNationalHealthServiceNumber: return "UK_NATIONAL_HEALTH_SERVICE_NUMBER"
            case .ukNationalInsuranceNumber: return "UK_NATIONAL_INSURANCE_NUMBER"
            case .ukUniqueTaxpayerReferenceNumber: return "UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER"
            case .url: return "URL"
            case .username: return "USERNAME"
            case .usBankAccountNumber: return "US_BANK_ACCOUNT_NUMBER"
            case .usBankRoutingNumber: return "US_BANK_ROUTING_NUMBER"
            case .usIndividualTaxIdentificationNumber: return "US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER"
            case .usPassportNumber: return "US_PASSPORT_NUMBER"
            case .usSocialSecurityNumber: return "US_SOCIAL_SECURITY_NUMBER"
            case .vehicleIdentificationNumber: return "VEHICLE_IDENTIFICATION_NUMBER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Mode for redacting detected PII
    public enum PIIRedactionMaskMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Replace with specific entity type marker, e.g. [NAME]/[SSN] etc.
        case entityType
        /// Replace with generic PII marker [PII]
        case pii
        case sdkUnknown(Swift.String)

        public static var allCases: [PIIRedactionMaskMode] {
            return [
                .entityType,
                .pii
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entityType: return "ENTITY_TYPE"
            case .pii: return "PII"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for PII entities detection and redaction
    public struct PIIEntitiesConfiguration: Swift.Sendable {
        /// Types of PII entities to detect
        public var piiEntityTypes: [BedrockDataAutomationClientTypes.PIIEntityType]?
        /// Mode for redacting detected PII
        public var redactionMaskMode: BedrockDataAutomationClientTypes.PIIRedactionMaskMode?

        public init(
            piiEntityTypes: [BedrockDataAutomationClientTypes.PIIEntityType]? = nil,
            redactionMaskMode: BedrockDataAutomationClientTypes.PIIRedactionMaskMode? = nil
        ) {
            self.piiEntityTypes = piiEntityTypes
            self.redactionMaskMode = redactionMaskMode
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for sensitive data detection and redaction
    public struct SensitiveDataConfiguration: Swift.Sendable {
        /// Mode for sensitive data detection
        /// This member is required.
        public var detectionMode: BedrockDataAutomationClientTypes.SensitiveDataDetectionMode?
        /// Scope of detection - what types of sensitive data to detect
        public var detectionScope: [BedrockDataAutomationClientTypes.SensitiveDataDetectionScopeType]?
        /// Configuration for PII entities detection and redaction
        public var piiEntitiesConfiguration: BedrockDataAutomationClientTypes.PIIEntitiesConfiguration?

        public init(
            detectionMode: BedrockDataAutomationClientTypes.SensitiveDataDetectionMode? = nil,
            detectionScope: [BedrockDataAutomationClientTypes.SensitiveDataDetectionScopeType]? = nil,
            piiEntitiesConfiguration: BedrockDataAutomationClientTypes.PIIEntitiesConfiguration? = nil
        ) {
            self.detectionMode = detectionMode
            self.detectionScope = detectionScope
            self.piiEntitiesConfiguration = piiEntitiesConfiguration
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Audio
    public struct AudioOverrideConfiguration: Swift.Sendable {
        /// Optional configuration for audio language settings
        public var languageConfiguration: BedrockDataAutomationClientTypes.AudioLanguageConfiguration?
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?
        /// Configuration for sensitive data detection and redaction
        public var sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration?

        public init(
            languageConfiguration: BedrockDataAutomationClientTypes.AudioLanguageConfiguration? = nil,
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil,
            sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration? = nil
        ) {
            self.languageConfiguration = languageConfiguration
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration of Splitter
    public struct SplitterConfiguration: Swift.Sendable {
        /// State
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Document
    public struct DocumentOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?
        /// Configuration for sensitive data detection and redaction
        public var sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration?
        /// Configuration of Splitter
        public var splitter: BedrockDataAutomationClientTypes.SplitterConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil,
            sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration? = nil,
            splitter: BedrockDataAutomationClientTypes.SplitterConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
            self.splitter = splitter
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Image
    public struct ImageOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?
        /// Configuration for sensitive data detection and redaction
        public var sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil,
            sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Desired Modality types
    public enum DesiredModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audio
        case document
        case image
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredModality] {
            return [
                .audio,
                .document,
                .image,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for routing file type to desired modality
    public struct ModalityRoutingConfiguration: Swift.Sendable {
        /// Desired Modality types
        public var jpeg: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var mov: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var mp4: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var png: BedrockDataAutomationClientTypes.DesiredModality?

        public init(
            jpeg: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            mov: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            mp4: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            png: BedrockDataAutomationClientTypes.DesiredModality? = nil
        ) {
            self.jpeg = jpeg
            self.mov = mov
            self.mp4 = mp4
            self.png = png
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Video
    public struct VideoOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?
        /// Configuration for sensitive data detection and redaction
        public var sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil,
            sensitiveDataConfiguration: BedrockDataAutomationClientTypes.SensitiveDataConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
            self.sensitiveDataConfiguration = sensitiveDataConfiguration
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override configuration
    public struct OverrideConfiguration: Swift.Sendable {
        /// Override Configuration of Audio
        public var audio: BedrockDataAutomationClientTypes.AudioOverrideConfiguration?
        /// Override Configuration of Document
        public var document: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration?
        /// Override Configuration of Image
        public var image: BedrockDataAutomationClientTypes.ImageOverrideConfiguration?
        /// Configuration for routing file type to desired modality
        public var modalityRouting: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration?
        /// Override Configuration of Video
        public var video: BedrockDataAutomationClientTypes.VideoOverrideConfiguration?

        public init(
            audio: BedrockDataAutomationClientTypes.AudioOverrideConfiguration? = nil,
            document: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration? = nil,
            image: BedrockDataAutomationClientTypes.ImageOverrideConfiguration? = nil,
            modalityRouting: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration? = nil,
            video: BedrockDataAutomationClientTypes.VideoOverrideConfiguration? = nil
        ) {
            self.audio = audio
            self.document = document
            self.image = image
            self.modalityRouting = modalityRouting
            self.video = video
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Type of the DataAutomationProject
    public enum DataAutomationProjectType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case async
        case sync
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectType] {
            return [
                .async,
                .sync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .async: return "ASYNC"
            case .sync: return "SYNC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Channel labeling configuration
    public struct ChannelLabelingConfiguration: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Speaker labeling configuration
    public struct SpeakerLabelingConfiguration: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for transcript related features
    public struct TranscriptConfiguration: Swift.Sendable {
        /// Channel labeling configuration
        public var channelLabeling: BedrockDataAutomationClientTypes.ChannelLabelingConfiguration?
        /// Speaker labeling configuration
        public var speakerLabeling: BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration?

        public init(
            channelLabeling: BedrockDataAutomationClientTypes.ChannelLabelingConfiguration? = nil,
            speakerLabeling: BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration? = nil
        ) {
            self.channelLabeling = channelLabeling
            self.speakerLabeling = speakerLabeling
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for different audio extraction category types
    public struct AudioExtractionCategoryTypeConfiguration: Swift.Sendable {
        /// Configuration for transcript related features
        public var transcript: BedrockDataAutomationClientTypes.TranscriptConfiguration?

        public init(
            transcript: BedrockDataAutomationClientTypes.TranscriptConfiguration? = nil
        ) {
            self.transcript = transcript
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum AudioExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioContentModeration
        case topicContentModeration
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioExtractionCategoryType] {
            return [
                .audioContentModeration,
                .topicContentModeration,
                .transcript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioContentModeration: return "AUDIO_CONTENT_MODERATION"
            case .topicContentModeration: return "TOPIC_CONTENT_MODERATION"
            case .transcript: return "TRANSCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Audio Extraction
    public struct AudioExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// Configuration for different audio extraction category types
        public var typeConfiguration: BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration?
        /// List of Audio Extraction Category Type
        public var types: [BedrockDataAutomationClientTypes.AudioExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            typeConfiguration: BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration? = nil,
            types: [BedrockDataAutomationClientTypes.AudioExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.typeConfiguration = typeConfiguration
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Audio
    public struct AudioStandardExtraction: Swift.Sendable {
        /// Category of Audio Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.AudioExtractionCategory?

        public init(
            category: BedrockDataAutomationClientTypes.AudioExtractionCategory? = nil
        ) {
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum AudioStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioSummary
        case iab
        case topicSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioStandardGenerativeFieldType] {
            return [
                .audioSummary,
                .iab,
                .topicSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioSummary: return "AUDIO_SUMMARY"
            case .iab: return "IAB"
            case .topicSummary: return "TOPIC_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Audio
    public struct AudioStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Audio Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Audio
    public struct AudioStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Audio
        public var extraction: BedrockDataAutomationClientTypes.AudioStandardExtraction?
        /// Standard Generative Field Configuration of Audio
        public var generativeField: BedrockDataAutomationClientTypes.AudioStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.AudioStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.AudioStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Document Extraction
    public struct DocumentBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum DocumentExtractionGranularityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case document
        case element
        case line
        case page
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentExtractionGranularityType] {
            return [
                .document,
                .element,
                .line,
                .page,
                .word
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .element: return "ELEMENT"
            case .line: return "LINE"
            case .page: return "PAGE"
            case .word: return "WORD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Granularity of Document Extraction
    public struct DocumentExtractionGranularity: Swift.Sendable {
        /// List of Document Extraction Granularity Type
        public var types: [BedrockDataAutomationClientTypes.DocumentExtractionGranularityType]?

        public init(
            types: [BedrockDataAutomationClientTypes.DocumentExtractionGranularityType]? = nil
        ) {
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Document
    public struct DocumentStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Document Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.DocumentBoundingBox?
        /// Granularity of Document Extraction
        /// This member is required.
        public var granularity: BedrockDataAutomationClientTypes.DocumentExtractionGranularity?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.DocumentBoundingBox? = nil,
            granularity: BedrockDataAutomationClientTypes.DocumentExtractionGranularity? = nil
        ) {
            self.boundingBox = boundingBox
            self.granularity = granularity
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Document
    public struct DocumentStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Additional File Format of Document Output
    public struct DocumentOutputAdditionalFileFormat: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum DocumentOutputTextFormatType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case html
        case markdown
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentOutputTextFormatType] {
            return [
                .csv,
                .html,
                .markdown,
                .plainText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .html: return "HTML"
            case .markdown: return "MARKDOWN"
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Text Format of Document Output
    public struct DocumentOutputTextFormat: Swift.Sendable {
        /// List of Document Output Text Format Type
        public var types: [BedrockDataAutomationClientTypes.DocumentOutputTextFormatType]?

        public init(
            types: [BedrockDataAutomationClientTypes.DocumentOutputTextFormatType]? = nil
        ) {
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Output Format of Document
    public struct DocumentOutputFormat: Swift.Sendable {
        /// Additional File Format of Document Output
        /// This member is required.
        public var additionalFileFormat: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat?
        /// Text Format of Document Output
        /// This member is required.
        public var textFormat: BedrockDataAutomationClientTypes.DocumentOutputTextFormat?

        public init(
            additionalFileFormat: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat? = nil,
            textFormat: BedrockDataAutomationClientTypes.DocumentOutputTextFormat? = nil
        ) {
            self.additionalFileFormat = additionalFileFormat
            self.textFormat = textFormat
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Document
    public struct DocumentStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Document
        public var extraction: BedrockDataAutomationClientTypes.DocumentStandardExtraction?
        /// Standard Generative Field Configuration of Document
        public var generativeField: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField?
        /// Output Format of Document
        public var outputFormat: BedrockDataAutomationClientTypes.DocumentOutputFormat?

        public init(
            extraction: BedrockDataAutomationClientTypes.DocumentStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField? = nil,
            outputFormat: BedrockDataAutomationClientTypes.DocumentOutputFormat? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
            self.outputFormat = outputFormat
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Image Extraction
    public struct ImageBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum ImageExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentModeration
        case logos
        case textDetection
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageExtractionCategoryType] {
            return [
                .contentModeration,
                .logos,
                .textDetection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentModeration: return "CONTENT_MODERATION"
            case .logos: return "LOGOS"
            case .textDetection: return "TEXT_DETECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Image Extraction
    public struct ImageExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Image Extraction Category
        public var types: [BedrockDataAutomationClientTypes.ImageExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.ImageExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Image
    public struct ImageStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Image Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.ImageBoundingBox?
        /// Category of Image Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.ImageExtractionCategory?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.ImageBoundingBox? = nil,
            category: BedrockDataAutomationClientTypes.ImageExtractionCategory? = nil
        ) {
            self.boundingBox = boundingBox
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum ImageStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iab
        case imageSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStandardGenerativeFieldType] {
            return [
                .iab,
                .imageSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iab: return "IAB"
            case .imageSummary: return "IMAGE_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Image
    public struct ImageStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Image Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Image
    public struct ImageStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Image
        public var extraction: BedrockDataAutomationClientTypes.ImageStandardExtraction?
        /// Standard Generative Field Configuration of Image
        public var generativeField: BedrockDataAutomationClientTypes.ImageStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.ImageStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.ImageStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Video Extraction
    public struct VideoBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum VideoExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentModeration
        case logos
        case textDetection
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoExtractionCategoryType] {
            return [
                .contentModeration,
                .logos,
                .textDetection,
                .transcript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentModeration: return "CONTENT_MODERATION"
            case .logos: return "LOGOS"
            case .textDetection: return "TEXT_DETECTION"
            case .transcript: return "TRANSCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Video Extraction
    public struct VideoExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Video Extraction Category Type
        public var types: [BedrockDataAutomationClientTypes.VideoExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.VideoExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Video
    public struct VideoStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Video Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.VideoBoundingBox?
        /// Category of Video Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.VideoExtractionCategory?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.VideoBoundingBox? = nil,
            category: BedrockDataAutomationClientTypes.VideoExtractionCategory? = nil
        ) {
            self.boundingBox = boundingBox
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum VideoStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chapterSummary
        case iab
        case videoSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoStandardGenerativeFieldType] {
            return [
                .chapterSummary,
                .iab,
                .videoSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chapterSummary: return "CHAPTER_SUMMARY"
            case .iab: return "IAB"
            case .videoSummary: return "VIDEO_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Video
    public struct VideoStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Video Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Video
    public struct VideoStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Video
        public var extraction: BedrockDataAutomationClientTypes.VideoStandardExtraction?
        /// Standard Generative Field Configuration of Video
        public var generativeField: BedrockDataAutomationClientTypes.VideoStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.VideoStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.VideoStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard output configuration
    public struct StandardOutputConfiguration: Swift.Sendable {
        /// Standard Output Configuration of Audio
        public var audio: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration?
        /// Standard Output Configuration of Document
        public var document: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration?
        /// Standard Output Configuration of Image
        public var image: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration?
        /// Standard Output Configuration of Video
        public var video: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration?

        public init(
            audio: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration? = nil,
            document: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration? = nil,
            image: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration? = nil,
            video: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration? = nil
        ) {
            self.audio = audio
            self.document = document
            self.image = image
            self.video = video
        }
    }
}

/// Create DataAutomationProject Request
public struct CreateDataAutomationProjectInput: Swift.Sendable {
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Custom output configuration
    public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Override configuration
    public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
    /// Description of the DataAutomationProject
    public var projectDescription: Swift.String?
    /// Name of the DataAutomationProject
    /// This member is required.
    public var projectName: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Type of the DataAutomationProject
    public var projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType?
    /// Standard output configuration
    /// This member is required.
    public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType? = nil,
        standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.customOutputConfiguration = customOutputConfiguration
        self.encryptionConfiguration = encryptionConfiguration
        self.overrideConfiguration = overrideConfiguration
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.projectStage = projectStage
        self.projectType = projectType
        self.standardOutputConfiguration = standardOutputConfiguration
        self.tags = tags
    }
}

extension CreateDataAutomationProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataAutomationProjectInput(clientToken: \(Swift.String(describing: clientToken)), customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectStage: \(Swift.String(describing: projectStage)), projectType: \(Swift.String(describing: projectType)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), tags: \(Swift.String(describing: tags)), projectDescription: \"CONTENT_REDACTED\", projectName: \"CONTENT_REDACTED\")"}
}

extension BedrockDataAutomationClientTypes {

    /// Status of Data Automation Project
    public enum DataAutomationProjectStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Create DataAutomationProject Response
public struct CreateDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
        self.status = status
    }
}

/// Delete DataAutomationProject Request
public struct DeleteDataAutomationProjectInput: Swift.Sendable {
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?

    public init(
        projectArn: Swift.String? = nil
    ) {
        self.projectArn = projectArn
    }
}

/// Delete DataAutomationProject Response
public struct DeleteDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.status = status
    }
}

/// Get DataAutomationProject Request
public struct GetDataAutomationProjectInput: Swift.Sendable {
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?
    /// Optional field to delete a specific DataAutomationProject stage
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
    }
}

extension BedrockDataAutomationClientTypes {

    /// Contains the information of a DataAutomationProject.
    public struct DataAutomationProject: Swift.Sendable {
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Custom output configuration
        public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        public var kmsKeyId: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// Override configuration
        public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Description of the DataAutomationProject
        public var projectDescription: Swift.String?
        /// Name of the DataAutomationProject
        /// This member is required.
        public var projectName: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
        /// Type of the DataAutomationProject
        public var projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType?
        /// Standard output configuration
        public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?
        /// Status of Data Automation Project
        /// This member is required.
        public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
            projectArn: Swift.String? = nil,
            projectDescription: Swift.String? = nil,
            projectName: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
            projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType? = nil,
            standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil,
            status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
        ) {
            self.creationTime = creationTime
            self.customOutputConfiguration = customOutputConfiguration
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.projectType = projectType
            self.standardOutputConfiguration = standardOutputConfiguration
            self.status = status
        }
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataAutomationProject(creationTime: \(Swift.String(describing: creationTime)), customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), kmsEncryptionContext: \(Swift.String(describing: kmsEncryptionContext)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), projectType: \(Swift.String(describing: projectType)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), status: \(Swift.String(describing: status)), projectDescription: \"CONTENT_REDACTED\", projectName: \"CONTENT_REDACTED\")"}
}

/// Get DataAutomationProject Response
public struct GetDataAutomationProjectOutput: Swift.Sendable {
    /// Contains the information of a DataAutomationProject.
    /// This member is required.
    public var project: BedrockDataAutomationClientTypes.DataAutomationProject?

    public init(
        project: BedrockDataAutomationClientTypes.DataAutomationProject? = nil
    ) {
        self.project = project
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Filter
    public struct BlueprintFilter: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Project Stage filter
    public enum DataAutomationProjectStageFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStageFilter] {
            return [
                .all,
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// List DataAutomationProject Request
public struct ListDataAutomationProjectsInput: Swift.Sendable {
    /// Blueprint Filter
    public var blueprintFilter: BedrockDataAutomationClientTypes.BlueprintFilter?
    /// Max Results
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Project Stage filter
    public var projectStageFilter: BedrockDataAutomationClientTypes.DataAutomationProjectStageFilter?
    /// Resource Owner
    public var resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner?

    public init(
        blueprintFilter: BedrockDataAutomationClientTypes.BlueprintFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectStageFilter: BedrockDataAutomationClientTypes.DataAutomationProjectStageFilter? = nil,
        resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner? = nil
    ) {
        self.blueprintFilter = blueprintFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectStageFilter = projectStageFilter
        self.resourceOwner = resourceOwner
    }
}

extension BedrockDataAutomationClientTypes {

    /// Summary of a DataAutomationProject
    public struct DataAutomationProjectSummary: Swift.Sendable {
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Name of the DataAutomationProject
        public var projectName: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
        /// Type of the DataAutomationProject
        public var projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType?

        public init(
            creationTime: Foundation.Date? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
            projectType: BedrockDataAutomationClientTypes.DataAutomationProjectType? = nil
        ) {
            self.creationTime = creationTime
            self.projectArn = projectArn
            self.projectName = projectName
            self.projectStage = projectStage
            self.projectType = projectType
        }
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataAutomationProjectSummary(creationTime: \(Swift.String(describing: creationTime)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), projectType: \(Swift.String(describing: projectType)), projectName: \"CONTENT_REDACTED\")"}
}

/// List DataAutomationProject Response
public struct ListDataAutomationProjectsOutput: Swift.Sendable {
    /// Pagination token
    public var nextToken: Swift.String?
    /// List of DataAutomationProjectSummary
    /// This member is required.
    public var projects: [BedrockDataAutomationClientTypes.DataAutomationProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [BedrockDataAutomationClientTypes.DataAutomationProjectSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.projects = projects
    }
}

/// Update DataAutomationProject Request
public struct UpdateDataAutomationProjectInput: Swift.Sendable {
    /// Custom output configuration
    public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Override configuration
    public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?
    /// Description of the DataAutomationProject
    public var projectDescription: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Standard output configuration
    /// This member is required.
    public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?

    public init(
        customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
        projectArn: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil
    ) {
        self.customOutputConfiguration = customOutputConfiguration
        self.encryptionConfiguration = encryptionConfiguration
        self.overrideConfiguration = overrideConfiguration
        self.projectArn = projectArn
        self.projectDescription = projectDescription
        self.projectStage = projectStage
        self.standardOutputConfiguration = standardOutputConfiguration
    }
}

extension UpdateDataAutomationProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataAutomationProjectInput(customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), projectDescription: \"CONTENT_REDACTED\")"}
}

/// Update DataAutomationProject Response
public struct UpdateDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
        self.status = status
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tags
    /// This member is required.
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tag keys
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CopyBlueprintStageInput {

    static func urlPathProvider(_ value: CopyBlueprintStageInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())/copy-stage"
    }
}

extension CreateBlueprintInput {

    static func urlPathProvider(_ value: CreateBlueprintInput) -> Swift.String? {
        return "/blueprints"
    }
}

extension CreateBlueprintVersionInput {

    static func urlPathProvider(_ value: CreateBlueprintVersionInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())/versions"
    }
}

extension CreateDataAutomationProjectInput {

    static func urlPathProvider(_ value: CreateDataAutomationProjectInput) -> Swift.String? {
        return "/data-automation-projects"
    }
}

extension DeleteBlueprintInput {

    static func urlPathProvider(_ value: DeleteBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension DeleteBlueprintInput {

    static func queryItemProvider(_ value: DeleteBlueprintInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let blueprintVersion = value.blueprintVersion {
            let blueprintVersionQueryItem = Smithy.URIQueryItem(name: "blueprintVersion".urlPercentEncoding(), value: Swift.String(blueprintVersion).urlPercentEncoding())
            items.append(blueprintVersionQueryItem)
        }
        return items
    }
}

extension DeleteDataAutomationProjectInput {

    static func urlPathProvider(_ value: DeleteDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension GetBlueprintInput {

    static func urlPathProvider(_ value: GetBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension GetBlueprintOptimizationStatusInput {

    static func urlPathProvider(_ value: GetBlueprintOptimizationStatusInput) -> Swift.String? {
        guard let invocationArn = value.invocationArn else {
            return nil
        }
        return "/getBlueprintOptimizationStatus/\(invocationArn.urlPercentEncoding())"
    }
}

extension GetDataAutomationProjectInput {

    static func urlPathProvider(_ value: GetDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension InvokeBlueprintOptimizationAsyncInput {

    static func urlPathProvider(_ value: InvokeBlueprintOptimizationAsyncInput) -> Swift.String? {
        return "/invokeBlueprintOptimizationAsync"
    }
}

extension ListBlueprintsInput {

    static func urlPathProvider(_ value: ListBlueprintsInput) -> Swift.String? {
        return "/blueprints"
    }
}

extension ListDataAutomationProjectsInput {

    static func urlPathProvider(_ value: ListDataAutomationProjectsInput) -> Swift.String? {
        return "/data-automation-projects"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UpdateBlueprintInput {

    static func urlPathProvider(_ value: UpdateBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension UpdateDataAutomationProjectInput {

    static func urlPathProvider(_ value: UpdateDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension CopyBlueprintStageInput {

    static func write(value: CopyBlueprintStageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["sourceStage"].write(value.sourceStage)
        try writer["targetStage"].write(value.targetStage)
    }
}

extension CreateBlueprintInput {

    static func write(value: CreateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintName"].write(value.blueprintName)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["clientToken"].write(value.clientToken)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["schema"].write(value.schema)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateBlueprintVersionInput {

    static func write(value: CreateBlueprintVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateDataAutomationProjectInput {

    static func write(value: CreateDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customOutputConfiguration"].write(value.customOutputConfiguration, with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.write(value:to:))
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["overrideConfiguration"].write(value.overrideConfiguration, with: BedrockDataAutomationClientTypes.OverrideConfiguration.write(value:to:))
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectName"].write(value.projectName)
        try writer["projectStage"].write(value.projectStage)
        try writer["projectType"].write(value.projectType)
        try writer["standardOutputConfiguration"].write(value.standardOutputConfiguration, with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetBlueprintInput {

    static func write(value: GetBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }
}

extension GetDataAutomationProjectInput {

    static func write(value: GetDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectStage"].write(value.projectStage)
    }
}

extension InvokeBlueprintOptimizationAsyncInput {

    static func write(value: InvokeBlueprintOptimizationAsyncInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprint"].write(value.blueprint, with: BedrockDataAutomationClientTypes.BlueprintOptimizationObject.write(value:to:))
        try writer["dataAutomationProfileArn"].write(value.dataAutomationProfileArn)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["outputConfiguration"].write(value.outputConfiguration, with: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration.write(value:to:))
        try writer["samples"].writeList(value.samples, memberWritingClosure: BedrockDataAutomationClientTypes.BlueprintOptimizationSample.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListBlueprintsInput {

    static func write(value: ListBlueprintsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStageFilter"].write(value.blueprintStageFilter)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectFilter"].write(value.projectFilter, with: BedrockDataAutomationClientTypes.DataAutomationProjectFilter.write(value:to:))
        try writer["resourceOwner"].write(value.resourceOwner)
    }
}

extension ListDataAutomationProjectsInput {

    static func write(value: ListDataAutomationProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintFilter"].write(value.blueprintFilter, with: BedrockDataAutomationClientTypes.BlueprintFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectStageFilter"].write(value.projectStageFilter)
        try writer["resourceOwner"].write(value.resourceOwner)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBlueprintInput {

    static func write(value: UpdateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["schema"].write(value.schema)
    }
}

extension UpdateDataAutomationProjectInput {

    static func write(value: UpdateDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customOutputConfiguration"].write(value.customOutputConfiguration, with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.write(value:to:))
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["overrideConfiguration"].write(value.overrideConfiguration, with: BedrockDataAutomationClientTypes.OverrideConfiguration.write(value:to:))
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectStage"].write(value.projectStage)
        try writer["standardOutputConfiguration"].write(value.standardOutputConfiguration, with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.write(value:to:))
    }
}

extension CopyBlueprintStageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CopyBlueprintStageOutput {
        return CopyBlueprintStageOutput()
    }
}

extension CreateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension CreateBlueprintVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBlueprintVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBlueprintVersionOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension CreateDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBlueprintOutput {
        return DeleteBlueprintOutput()
    }
}

extension DeleteDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension GetBlueprintOptimizationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintOptimizationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintOptimizationStatusOutput()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorType = try reader["errorType"].readIfPresent()
        value.outputConfiguration = try reader["outputConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataAutomationProjectOutput()
        value.project = try reader["project"].readIfPresent(with: BedrockDataAutomationClientTypes.DataAutomationProject.read(from:))
        return value
    }
}

extension InvokeBlueprintOptimizationAsyncOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeBlueprintOptimizationAsyncOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InvokeBlueprintOptimizationAsyncOutput()
        value.invocationArn = try reader["invocationArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBlueprintsOutput()
        value.blueprints = try reader["blueprints"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.BlueprintSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataAutomationProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataAutomationProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataAutomationProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.DataAutomationProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension UpdateDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

enum CopyBlueprintStageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBlueprintVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintOptimizationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeBlueprintOptimizationAsyncOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataAutomationProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockDataAutomationClientTypes.Blueprint {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.Blueprint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.Blueprint()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.blueprintName = try reader["blueprintName"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.kmsEncryptionContext = try reader["kmsEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.optimizationSamples = try reader["optimizationSamples"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.BlueprintOptimizationSample.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.optimizationTime = try reader["optimizationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintOptimizationSample {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintOptimizationSample?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetS3Object"].write(value.assetS3Object, with: BedrockDataAutomationClientTypes.S3Object.write(value:to:))
        try writer["groundTruthS3Object"].write(value.groundTruthS3Object, with: BedrockDataAutomationClientTypes.S3Object.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintOptimizationSample {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintOptimizationSample()
        value.assetS3Object = try reader["assetS3Object"].readIfPresent(with: BedrockDataAutomationClientTypes.S3Object.read(from:))
        value.groundTruthS3Object = try reader["groundTruthS3Object"].readIfPresent(with: BedrockDataAutomationClientTypes.S3Object.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.S3Object {

    static func write(value: BedrockDataAutomationClientTypes.S3Object?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Uri"].write(value.s3Uri)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.S3Object {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.S3Object()
        value.s3Uri = try reader["s3Uri"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Object"].write(value.s3Object, with: BedrockDataAutomationClientTypes.S3Object.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintOptimizationOutputConfiguration()
        value.s3Object = try reader["s3Object"].readIfPresent(with: BedrockDataAutomationClientTypes.S3Object.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProject {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DataAutomationProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DataAutomationProject()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.projectType = try reader["projectType"].readIfPresent()
        value.projectDescription = try reader["projectDescription"].readIfPresent()
        value.standardOutputConfiguration = try reader["standardOutputConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.read(from:))
        value.customOutputConfiguration = try reader["customOutputConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.read(from:))
        value.overrideConfiguration = try reader["overrideConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.OverrideConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.kmsEncryptionContext = try reader["kmsEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.OverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.OverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audio"].write(value.audio, with: BedrockDataAutomationClientTypes.AudioOverrideConfiguration.write(value:to:))
        try writer["document"].write(value.document, with: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration.write(value:to:))
        try writer["image"].write(value.image, with: BedrockDataAutomationClientTypes.ImageOverrideConfiguration.write(value:to:))
        try writer["modalityRouting"].write(value.modalityRouting, with: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration.write(value:to:))
        try writer["video"].write(value.video, with: BedrockDataAutomationClientTypes.VideoOverrideConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.OverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.OverrideConfiguration()
        value.document = try reader["document"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration.read(from:))
        value.image = try reader["image"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageOverrideConfiguration.read(from:))
        value.video = try reader["video"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoOverrideConfiguration.read(from:))
        value.audio = try reader["audio"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioOverrideConfiguration.read(from:))
        value.modalityRouting = try reader["modalityRouting"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ModalityRoutingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jpeg"].write(value.jpeg)
        try writer["mov"].write(value.mov)
        try writer["mp4"].write(value.mp4)
        try writer["png"].write(value.png)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ModalityRoutingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ModalityRoutingConfiguration()
        value.jpeg = try reader["jpeg"].readIfPresent()
        value.png = try reader["png"].readIfPresent()
        value.mp4 = try reader["mp4"].readIfPresent()
        value.mov = try reader["mov"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["languageConfiguration"].write(value.languageConfiguration, with: BedrockDataAutomationClientTypes.AudioLanguageConfiguration.write(value:to:))
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
        try writer["sensitiveDataConfiguration"].write(value.sensitiveDataConfiguration, with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        value.languageConfiguration = try reader["languageConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioLanguageConfiguration.read(from:))
        value.sensitiveDataConfiguration = try reader["sensitiveDataConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.SensitiveDataConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.SensitiveDataConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["detectionMode"].write(value.detectionMode)
        try writer["detectionScope"].writeList(value.detectionScope, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.SensitiveDataDetectionScopeType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["piiEntitiesConfiguration"].write(value.piiEntitiesConfiguration, with: BedrockDataAutomationClientTypes.PIIEntitiesConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.SensitiveDataConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.SensitiveDataConfiguration()
        value.detectionMode = try reader["detectionMode"].readIfPresent() ?? .sdkUnknown("")
        value.detectionScope = try reader["detectionScope"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.SensitiveDataDetectionScopeType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.piiEntitiesConfiguration = try reader["piiEntitiesConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.PIIEntitiesConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.PIIEntitiesConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.PIIEntitiesConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["piiEntityTypes"].writeList(value.piiEntityTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.PIIEntityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["redactionMaskMode"].write(value.redactionMaskMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.PIIEntitiesConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.PIIEntitiesConfiguration()
        value.piiEntityTypes = try reader["piiEntityTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.PIIEntityType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.redactionMaskMode = try reader["redactionMaskMode"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioLanguageConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioLanguageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["generativeOutputLanguage"].write(value.generativeOutputLanguage)
        try writer["identifyMultipleLanguages"].write(value.identifyMultipleLanguages)
        try writer["inputLanguages"].writeList(value.inputLanguages, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.Language>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioLanguageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioLanguageConfiguration()
        value.inputLanguages = try reader["inputLanguages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.Language>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.generativeOutputLanguage = try reader["generativeOutputLanguage"].readIfPresent()
        value.identifyMultipleLanguages = try reader["identifyMultipleLanguages"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.ModalityProcessingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ModalityProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ModalityProcessingConfiguration()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.VideoOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
        try writer["sensitiveDataConfiguration"].write(value.sensitiveDataConfiguration, with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        value.sensitiveDataConfiguration = try reader["sensitiveDataConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ImageOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
        try writer["sensitiveDataConfiguration"].write(value.sensitiveDataConfiguration, with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        value.sensitiveDataConfiguration = try reader["sensitiveDataConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
        try writer["sensitiveDataConfiguration"].write(value.sensitiveDataConfiguration, with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.write(value:to:))
        try writer["splitter"].write(value.splitter, with: BedrockDataAutomationClientTypes.SplitterConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOverrideConfiguration()
        value.splitter = try reader["splitter"].readIfPresent(with: BedrockDataAutomationClientTypes.SplitterConfiguration.read(from:))
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        value.sensitiveDataConfiguration = try reader["sensitiveDataConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.SensitiveDataConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.SplitterConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.SplitterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.SplitterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.SplitterConfiguration()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.CustomOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.CustomOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprints"].writeList(value.blueprints, memberWritingClosure: BedrockDataAutomationClientTypes.BlueprintItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.CustomOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.CustomOutputConfiguration()
        value.blueprints = try reader["blueprints"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.BlueprintItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintItem {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintItem()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.StandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.StandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audio"].write(value.audio, with: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration.write(value:to:))
        try writer["document"].write(value.document, with: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration.write(value:to:))
        try writer["image"].write(value.image, with: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration.write(value:to:))
        try writer["video"].write(value.video, with: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.StandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.StandardOutputConfiguration()
        value.document = try reader["document"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration.read(from:))
        value.image = try reader["image"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration.read(from:))
        value.video = try reader["video"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration.read(from:))
        value.audio = try reader["audio"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.AudioStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.AudioStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.AudioExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioExtractionCategory.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.AudioExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["typeConfiguration"].write(value.typeConfiguration, with: BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration.write(value:to:))
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.AudioExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.AudioExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.typeConfiguration = try reader["typeConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transcript"].write(value.transcript, with: BedrockDataAutomationClientTypes.TranscriptConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioExtractionCategoryTypeConfiguration()
        value.transcript = try reader["transcript"].readIfPresent(with: BedrockDataAutomationClientTypes.TranscriptConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.TranscriptConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.TranscriptConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["channelLabeling"].write(value.channelLabeling, with: BedrockDataAutomationClientTypes.ChannelLabelingConfiguration.write(value:to:))
        try writer["speakerLabeling"].write(value.speakerLabeling, with: BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.TranscriptConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.TranscriptConfiguration()
        value.speakerLabeling = try reader["speakerLabeling"].readIfPresent(with: BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration.read(from:))
        value.channelLabeling = try reader["channelLabeling"].readIfPresent(with: BedrockDataAutomationClientTypes.ChannelLabelingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ChannelLabelingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ChannelLabelingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ChannelLabelingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ChannelLabelingConfiguration()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.SpeakerLabelingConfiguration()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.VideoStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.VideoStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.VideoBoundingBox.write(value:to:))
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.VideoExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoExtractionCategory.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.VideoBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.VideoExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.VideoExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.VideoExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.ImageStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.ImageStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.ImageBoundingBox.write(value:to:))
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.ImageExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageExtractionCategory.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.ImageBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.ImageExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.ImageExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.ImageExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.DocumentStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField.write(value:to:))
        try writer["outputFormat"].write(value.outputFormat, with: BedrockDataAutomationClientTypes.DocumentOutputFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField.read(from:))
        value.outputFormat = try reader["outputFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputFormat.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalFileFormat"].write(value.additionalFileFormat, with: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat.write(value:to:))
        try writer["textFormat"].write(value.textFormat, with: BedrockDataAutomationClientTypes.DocumentOutputTextFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputFormat()
        value.textFormat = try reader["textFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputTextFormat.read(from:))
        value.additionalFileFormat = try reader["additionalFileFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputTextFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputTextFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.DocumentOutputTextFormatType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputTextFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputTextFormat()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.DocumentOutputTextFormatType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.DocumentBoundingBox.write(value:to:))
        try writer["granularity"].write(value.granularity, with: BedrockDataAutomationClientTypes.DocumentExtractionGranularity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardExtraction()
        value.granularity = try reader["granularity"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentExtractionGranularity.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.DocumentBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentExtractionGranularity {

    static func write(value: BedrockDataAutomationClientTypes.DocumentExtractionGranularity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.DocumentExtractionGranularityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentExtractionGranularity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentExtractionGranularity()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.DocumentExtractionGranularityType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintSummary()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        value.blueprintName = try reader["blueprintName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DataAutomationProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DataAutomationProjectSummary()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.projectType = try reader["projectType"].readIfPresent()
        value.projectName = try reader["projectName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockDataAutomationClientTypes.Tag {

    static func write(value: BedrockDataAutomationClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationClientTypes.EncryptionConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }
}

extension BedrockDataAutomationClientTypes.BlueprintOptimizationObject {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintOptimizationObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["stage"].write(value.stage)
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectFilter {

    static func write(value: BedrockDataAutomationClientTypes.DataAutomationProjectFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
        try writer["projectStage"].write(value.projectStage)
    }
}

extension BedrockDataAutomationClientTypes.BlueprintFilter {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }
}

public enum BedrockDataAutomationClientTypes {}
