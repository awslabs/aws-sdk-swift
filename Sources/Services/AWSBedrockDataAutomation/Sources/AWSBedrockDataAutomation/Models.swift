//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// This exception is thrown when a request is denied per access permissions
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when there is a conflict performing an operation
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown if there was an unexpected error during processing of request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when a request is made beyond the service quota
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This exception is thrown when the number of requests exceeds the limit
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception
    public struct ValidationExceptionField: Swift.Sendable {
        /// Non Blank String
        /// This member is required.
        public var message: Swift.String?
        /// Non Blank String
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

/// This exception is thrown when the request's input validation fails
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// list of ValidationExceptionField
        public internal(set) var fieldList: [BedrockDataAutomationClientTypes.ValidationExceptionField]? = nil
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BedrockDataAutomationClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stage of the Blueprint
    public enum BlueprintStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// KMS Encryption Configuration
    public struct EncryptionConfiguration: Swift.Sendable {
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        /// This member is required.
        public var kmsKeyId: Swift.String?

        public init(
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil
        ) {
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Key value pair of a tag
    public struct Tag: Swift.Sendable {
        /// Defines the context of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// Defines the value within the context. e.g. <key=reason, value=training>.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Type
    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case document
        case image
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .document,
                .image
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Create Blueprint Request
public struct CreateBlueprintInput: Swift.Sendable {
    /// Name of the Blueprint
    /// This member is required.
    public var blueprintName: Swift.String?
    /// Stage of the Blueprint
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Schema of the blueprint
    /// This member is required.
    public var schema: Swift.String?
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?
    /// Type
    /// This member is required.
    public var type: BedrockDataAutomationClientTypes.ModelType?

    public init(
        blueprintName: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        clientToken: Swift.String? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        schema: Swift.String? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil,
        type: BedrockDataAutomationClientTypes.ModelType? = nil
    ) {
        self.blueprintName = blueprintName
        self.blueprintStage = blueprintStage
        self.clientToken = clientToken
        self.encryptionConfiguration = encryptionConfiguration
        self.schema = schema
        self.tags = tags
        self.type = type
    }
}

extension CreateBlueprintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBlueprintInput(blueprintStage: \(Swift.String(describing: blueprintStage)), clientToken: \(Swift.String(describing: clientToken)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), blueprintName: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\")"}
}

extension BedrockDataAutomationClientTypes {

    /// Contains the information of a Blueprint.
    public struct Blueprint: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Name of the Blueprint
        /// This member is required.
        public var blueprintName: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        public var kmsKeyId: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// Schema of the blueprint
        /// This member is required.
        public var schema: Swift.String?
        /// Type
        /// This member is required.
        public var type: BedrockDataAutomationClientTypes.ModelType?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintName: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            schema: Swift.String? = nil,
            type: BedrockDataAutomationClientTypes.ModelType? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.schema = schema
            self.type = type
        }
    }
}

extension BedrockDataAutomationClientTypes.Blueprint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Blueprint(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), blueprintVersion: \(Swift.String(describing: blueprintVersion)), creationTime: \(Swift.String(describing: creationTime)), kmsEncryptionContext: \(Swift.String(describing: kmsEncryptionContext)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), type: \(Swift.String(describing: type)), blueprintName: \"CONTENT_REDACTED\", schema: \"CONTENT_REDACTED\")"}
}

/// Create Blueprint Response
public struct CreateBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

/// This exception is thrown when a resource referenced by the operation does not exist
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Non Blank String
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Delete Blueprint Request
public struct DeleteBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Optional field to delete a specific Blueprint version
    public var blueprintVersion: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintVersion: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintVersion = blueprintVersion
    }
}

/// Delete Blueprint Response
public struct DeleteBlueprintOutput: Swift.Sendable {

    public init() { }
}

/// Get Blueprint Request
public struct GetBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Optional field to get a specific Blueprint stage
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// Optional field to get a specific Blueprint version
    public var blueprintVersion: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        blueprintVersion: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStage = blueprintStage
        self.blueprintVersion = blueprintVersion
    }
}

/// Get Blueprint Response
public struct GetBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Stage filter
    public enum BlueprintStageFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [BlueprintStageFilter] {
            return [
                .all,
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Stage of the Project
    public enum DataAutomationProjectStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStage] {
            return [
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Data Automation Project Filter
    public struct DataAutomationProjectFilter: Swift.Sendable {
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?

        public init(
            projectArn: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil
        ) {
            self.projectArn = projectArn
            self.projectStage = projectStage
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Resource Owner
    public enum ResourceOwner: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case account
        case service
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceOwner] {
            return [
                .account,
                .service
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .service: return "SERVICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// List Blueprint Request
public struct ListBlueprintsInput: Swift.Sendable {
    /// ARN of a Blueprint
    public var blueprintArn: Swift.String?
    /// Blueprint Stage filter
    public var blueprintStageFilter: BedrockDataAutomationClientTypes.BlueprintStageFilter?
    /// Max Results
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Data Automation Project Filter
    public var projectFilter: BedrockDataAutomationClientTypes.DataAutomationProjectFilter?
    /// Resource Owner
    public var resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStageFilter: BedrockDataAutomationClientTypes.BlueprintStageFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectFilter: BedrockDataAutomationClientTypes.DataAutomationProjectFilter? = nil,
        resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStageFilter = blueprintStageFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectFilter = projectFilter
        self.resourceOwner = resourceOwner
    }
}

extension BedrockDataAutomationClientTypes {

    /// Summary of a Blueprint
    public struct BlueprintSummary: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Name of the Blueprint
        public var blueprintName: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Time Stamp
        public var lastModifiedTime: Foundation.Date?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintName: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            lastModifiedTime: Foundation.Date? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintName = blueprintName
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
            self.creationTime = creationTime
            self.lastModifiedTime = lastModifiedTime
        }
    }
}

extension BedrockDataAutomationClientTypes.BlueprintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BlueprintSummary(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), blueprintVersion: \(Swift.String(describing: blueprintVersion)), creationTime: \(Swift.String(describing: creationTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), blueprintName: \"CONTENT_REDACTED\")"}
}

/// List Blueprint Response
public struct ListBlueprintsOutput: Swift.Sendable {
    /// List of Blueprints
    /// This member is required.
    public var blueprints: [BedrockDataAutomationClientTypes.BlueprintSummary]?
    /// Pagination token
    public var nextToken: Swift.String?

    public init(
        blueprints: [BedrockDataAutomationClientTypes.BlueprintSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.blueprints = blueprints
        self.nextToken = nextToken
    }
}

/// Update Blueprint Request
public struct UpdateBlueprintInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Stage of the Blueprint
    public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Schema of the blueprint
    /// This member is required.
    public var schema: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        schema: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.blueprintStage = blueprintStage
        self.encryptionConfiguration = encryptionConfiguration
        self.schema = schema
    }
}

extension UpdateBlueprintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateBlueprintInput(blueprintArn: \(Swift.String(describing: blueprintArn)), blueprintStage: \(Swift.String(describing: blueprintStage)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), schema: \"CONTENT_REDACTED\")"}
}

/// Update Blueprint Response
public struct UpdateBlueprintOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

/// Create Blueprint Version Request
public struct CreateBlueprintVersionInput: Swift.Sendable {
    /// ARN generated at the server side when a Blueprint is created
    /// This member is required.
    public var blueprintArn: Swift.String?
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?

    public init(
        blueprintArn: Swift.String? = nil,
        clientToken: Swift.String? = nil
    ) {
        self.blueprintArn = blueprintArn
        self.clientToken = clientToken
    }
}

/// Create Blueprint Version Response
public struct CreateBlueprintVersionOutput: Swift.Sendable {
    /// Contains the information of a Blueprint.
    /// This member is required.
    public var blueprint: BedrockDataAutomationClientTypes.Blueprint?

    public init(
        blueprint: BedrockDataAutomationClientTypes.Blueprint? = nil
    ) {
        self.blueprint = blueprint
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Item
    public struct BlueprintItem: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Custom output configuration
    public struct CustomOutputConfiguration: Swift.Sendable {
        /// List of Blueprint Item
        public var blueprints: [BedrockDataAutomationClientTypes.BlueprintItem]?

        public init(
            blueprints: [BedrockDataAutomationClientTypes.BlueprintItem]? = nil
        ) {
            self.blueprints = blueprints
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// State
    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration to enable/disable processing of modality
    public struct ModalityProcessingConfiguration: Swift.Sendable {
        /// State
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Audio
    public struct AudioOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration of Splitter
    public struct SplitterConfiguration: Swift.Sendable {
        /// State
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Document
    public struct DocumentOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?
        /// Configuration of Splitter
        public var splitter: BedrockDataAutomationClientTypes.SplitterConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil,
            splitter: BedrockDataAutomationClientTypes.SplitterConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
            self.splitter = splitter
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Image
    public struct ImageOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Desired Modality types
    public enum DesiredModality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audio
        case document
        case image
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [DesiredModality] {
            return [
                .audio,
                .document,
                .image,
                .video
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audio: return "AUDIO"
            case .document: return "DOCUMENT"
            case .image: return "IMAGE"
            case .video: return "VIDEO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Configuration for routing file type to desired modality
    public struct ModalityRoutingConfiguration: Swift.Sendable {
        /// Desired Modality types
        public var jpeg: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var mov: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var mp4: BedrockDataAutomationClientTypes.DesiredModality?
        /// Desired Modality types
        public var png: BedrockDataAutomationClientTypes.DesiredModality?

        public init(
            jpeg: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            mov: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            mp4: BedrockDataAutomationClientTypes.DesiredModality? = nil,
            png: BedrockDataAutomationClientTypes.DesiredModality? = nil
        ) {
            self.jpeg = jpeg
            self.mov = mov
            self.mp4 = mp4
            self.png = png
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override Configuration of Video
    public struct VideoOverrideConfiguration: Swift.Sendable {
        /// Configuration to enable/disable processing of modality
        public var modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?

        public init(
            modalityProcessing: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration? = nil
        ) {
            self.modalityProcessing = modalityProcessing
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Override configuration
    public struct OverrideConfiguration: Swift.Sendable {
        /// Override Configuration of Audio
        public var audio: BedrockDataAutomationClientTypes.AudioOverrideConfiguration?
        /// Override Configuration of Document
        public var document: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration?
        /// Override Configuration of Image
        public var image: BedrockDataAutomationClientTypes.ImageOverrideConfiguration?
        /// Configuration for routing file type to desired modality
        public var modalityRouting: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration?
        /// Override Configuration of Video
        public var video: BedrockDataAutomationClientTypes.VideoOverrideConfiguration?

        public init(
            audio: BedrockDataAutomationClientTypes.AudioOverrideConfiguration? = nil,
            document: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration? = nil,
            image: BedrockDataAutomationClientTypes.ImageOverrideConfiguration? = nil,
            modalityRouting: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration? = nil,
            video: BedrockDataAutomationClientTypes.VideoOverrideConfiguration? = nil
        ) {
            self.audio = audio
            self.document = document
            self.image = image
            self.modalityRouting = modalityRouting
            self.video = video
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum AudioExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioContentModeration
        case topicContentModeration
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioExtractionCategoryType] {
            return [
                .audioContentModeration,
                .topicContentModeration,
                .transcript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioContentModeration: return "AUDIO_CONTENT_MODERATION"
            case .topicContentModeration: return "TOPIC_CONTENT_MODERATION"
            case .transcript: return "TRANSCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Audio Extraction
    public struct AudioExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Audio Extraction Category Type
        public var types: [BedrockDataAutomationClientTypes.AudioExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.AudioExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Audio
    public struct AudioStandardExtraction: Swift.Sendable {
        /// Category of Audio Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.AudioExtractionCategory?

        public init(
            category: BedrockDataAutomationClientTypes.AudioExtractionCategory? = nil
        ) {
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum AudioStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case audioSummary
        case iab
        case topicSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [AudioStandardGenerativeFieldType] {
            return [
                .audioSummary,
                .iab,
                .topicSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .audioSummary: return "AUDIO_SUMMARY"
            case .iab: return "IAB"
            case .topicSummary: return "TOPIC_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Audio
    public struct AudioStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Audio Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Audio
    public struct AudioStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Audio
        public var extraction: BedrockDataAutomationClientTypes.AudioStandardExtraction?
        /// Standard Generative Field Configuration of Audio
        public var generativeField: BedrockDataAutomationClientTypes.AudioStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.AudioStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.AudioStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Document Extraction
    public struct DocumentBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum DocumentExtractionGranularityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case document
        case element
        case line
        case page
        case word
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentExtractionGranularityType] {
            return [
                .document,
                .element,
                .line,
                .page,
                .word
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .document: return "DOCUMENT"
            case .element: return "ELEMENT"
            case .line: return "LINE"
            case .page: return "PAGE"
            case .word: return "WORD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Granularity of Document Extraction
    public struct DocumentExtractionGranularity: Swift.Sendable {
        /// List of Document Extraction Granularity Type
        public var types: [BedrockDataAutomationClientTypes.DocumentExtractionGranularityType]?

        public init(
            types: [BedrockDataAutomationClientTypes.DocumentExtractionGranularityType]? = nil
        ) {
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Document
    public struct DocumentStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Document Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.DocumentBoundingBox?
        /// Granularity of Document Extraction
        /// This member is required.
        public var granularity: BedrockDataAutomationClientTypes.DocumentExtractionGranularity?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.DocumentBoundingBox? = nil,
            granularity: BedrockDataAutomationClientTypes.DocumentExtractionGranularity? = nil
        ) {
            self.boundingBox = boundingBox
            self.granularity = granularity
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Document
    public struct DocumentStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Additional File Format of Document Output
    public struct DocumentOutputAdditionalFileFormat: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum DocumentOutputTextFormatType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case html
        case markdown
        case plainText
        case sdkUnknown(Swift.String)

        public static var allCases: [DocumentOutputTextFormatType] {
            return [
                .csv,
                .html,
                .markdown,
                .plainText
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .html: return "HTML"
            case .markdown: return "MARKDOWN"
            case .plainText: return "PLAIN_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Text Format of Document Output
    public struct DocumentOutputTextFormat: Swift.Sendable {
        /// List of Document Output Text Format Type
        public var types: [BedrockDataAutomationClientTypes.DocumentOutputTextFormatType]?

        public init(
            types: [BedrockDataAutomationClientTypes.DocumentOutputTextFormatType]? = nil
        ) {
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Output Format of Document
    public struct DocumentOutputFormat: Swift.Sendable {
        /// Additional File Format of Document Output
        /// This member is required.
        public var additionalFileFormat: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat?
        /// Text Format of Document Output
        /// This member is required.
        public var textFormat: BedrockDataAutomationClientTypes.DocumentOutputTextFormat?

        public init(
            additionalFileFormat: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat? = nil,
            textFormat: BedrockDataAutomationClientTypes.DocumentOutputTextFormat? = nil
        ) {
            self.additionalFileFormat = additionalFileFormat
            self.textFormat = textFormat
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Document
    public struct DocumentStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Document
        public var extraction: BedrockDataAutomationClientTypes.DocumentStandardExtraction?
        /// Standard Generative Field Configuration of Document
        public var generativeField: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField?
        /// Output Format of Document
        public var outputFormat: BedrockDataAutomationClientTypes.DocumentOutputFormat?

        public init(
            extraction: BedrockDataAutomationClientTypes.DocumentStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField? = nil,
            outputFormat: BedrockDataAutomationClientTypes.DocumentOutputFormat? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
            self.outputFormat = outputFormat
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Image Extraction
    public struct ImageBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum ImageExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentModeration
        case logos
        case textDetection
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageExtractionCategoryType] {
            return [
                .contentModeration,
                .logos,
                .textDetection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentModeration: return "CONTENT_MODERATION"
            case .logos: return "LOGOS"
            case .textDetection: return "TEXT_DETECTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Image Extraction
    public struct ImageExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Image Extraction Category
        public var types: [BedrockDataAutomationClientTypes.ImageExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.ImageExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Image
    public struct ImageStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Image Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.ImageBoundingBox?
        /// Category of Image Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.ImageExtractionCategory?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.ImageBoundingBox? = nil,
            category: BedrockDataAutomationClientTypes.ImageExtractionCategory? = nil
        ) {
            self.boundingBox = boundingBox
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum ImageStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iab
        case imageSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStandardGenerativeFieldType] {
            return [
                .iab,
                .imageSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iab: return "IAB"
            case .imageSummary: return "IMAGE_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Image
    public struct ImageStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Image Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Image
    public struct ImageStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Image
        public var extraction: BedrockDataAutomationClientTypes.ImageStandardExtraction?
        /// Standard Generative Field Configuration of Image
        public var generativeField: BedrockDataAutomationClientTypes.ImageStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.ImageStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.ImageStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Bounding Box Configuration of Video Extraction
    public struct VideoBoundingBox: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil
        ) {
            self.state = state
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum VideoExtractionCategoryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contentModeration
        case logos
        case textDetection
        case transcript
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoExtractionCategoryType] {
            return [
                .contentModeration,
                .logos,
                .textDetection,
                .transcript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contentModeration: return "CONTENT_MODERATION"
            case .logos: return "LOGOS"
            case .textDetection: return "TEXT_DETECTION"
            case .transcript: return "TRANSCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Category of Video Extraction
    public struct VideoExtractionCategory: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Video Extraction Category Type
        public var types: [BedrockDataAutomationClientTypes.VideoExtractionCategoryType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.VideoExtractionCategoryType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Extraction Configuration of Video
    public struct VideoStandardExtraction: Swift.Sendable {
        /// Bounding Box Configuration of Video Extraction
        /// This member is required.
        public var boundingBox: BedrockDataAutomationClientTypes.VideoBoundingBox?
        /// Category of Video Extraction
        /// This member is required.
        public var category: BedrockDataAutomationClientTypes.VideoExtractionCategory?

        public init(
            boundingBox: BedrockDataAutomationClientTypes.VideoBoundingBox? = nil,
            category: BedrockDataAutomationClientTypes.VideoExtractionCategory? = nil
        ) {
            self.boundingBox = boundingBox
            self.category = category
        }
    }
}

extension BedrockDataAutomationClientTypes {

    public enum VideoStandardGenerativeFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case chapterSummary
        case iab
        case videoSummary
        case sdkUnknown(Swift.String)

        public static var allCases: [VideoStandardGenerativeFieldType] {
            return [
                .chapterSummary,
                .iab,
                .videoSummary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .chapterSummary: return "CHAPTER_SUMMARY"
            case .iab: return "IAB"
            case .videoSummary: return "VIDEO_SUMMARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Generative Field Configuration of Video
    public struct VideoStandardGenerativeField: Swift.Sendable {
        /// State
        /// This member is required.
        public var state: BedrockDataAutomationClientTypes.State?
        /// List of Video Standard Generative Field Type
        public var types: [BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType]?

        public init(
            state: BedrockDataAutomationClientTypes.State? = nil,
            types: [BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType]? = nil
        ) {
            self.state = state
            self.types = types
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard Output Configuration of Video
    public struct VideoStandardOutputConfiguration: Swift.Sendable {
        /// Standard Extraction Configuration of Video
        public var extraction: BedrockDataAutomationClientTypes.VideoStandardExtraction?
        /// Standard Generative Field Configuration of Video
        public var generativeField: BedrockDataAutomationClientTypes.VideoStandardGenerativeField?

        public init(
            extraction: BedrockDataAutomationClientTypes.VideoStandardExtraction? = nil,
            generativeField: BedrockDataAutomationClientTypes.VideoStandardGenerativeField? = nil
        ) {
            self.extraction = extraction
            self.generativeField = generativeField
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Standard output configuration
    public struct StandardOutputConfiguration: Swift.Sendable {
        /// Standard Output Configuration of Audio
        public var audio: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration?
        /// Standard Output Configuration of Document
        public var document: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration?
        /// Standard Output Configuration of Image
        public var image: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration?
        /// Standard Output Configuration of Video
        public var video: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration?

        public init(
            audio: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration? = nil,
            document: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration? = nil,
            image: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration? = nil,
            video: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration? = nil
        ) {
            self.audio = audio
            self.document = document
            self.image = image
            self.video = video
        }
    }
}

/// Create DataAutomationProject Request
public struct CreateDataAutomationProjectInput: Swift.Sendable {
    /// Client specified token used for idempotency checks
    public var clientToken: Swift.String?
    /// Custom output configuration
    public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Override configuration
    public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
    /// Description of the DataAutomationProject
    public var projectDescription: Swift.String?
    /// Name of the DataAutomationProject
    /// This member is required.
    public var projectName: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Standard output configuration
    /// This member is required.
    public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.customOutputConfiguration = customOutputConfiguration
        self.encryptionConfiguration = encryptionConfiguration
        self.overrideConfiguration = overrideConfiguration
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.projectStage = projectStage
        self.standardOutputConfiguration = standardOutputConfiguration
        self.tags = tags
    }
}

extension CreateDataAutomationProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDataAutomationProjectInput(clientToken: \(Swift.String(describing: clientToken)), customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectStage: \(Swift.String(describing: projectStage)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), tags: \(Swift.String(describing: tags)), projectDescription: \"CONTENT_REDACTED\", projectName: \"CONTENT_REDACTED\")"}
}

extension BedrockDataAutomationClientTypes {

    /// Status of Data Automation Project
    public enum DataAutomationProjectStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStatus] {
            return [
                .completed,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Create DataAutomationProject Response
public struct CreateDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
        self.status = status
    }
}

/// Delete DataAutomationProject Request
public struct DeleteDataAutomationProjectInput: Swift.Sendable {
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?

    public init(
        projectArn: Swift.String? = nil
    ) {
        self.projectArn = projectArn
    }
}

/// Delete DataAutomationProject Response
public struct DeleteDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.status = status
    }
}

/// Get DataAutomationProject Request
public struct GetDataAutomationProjectInput: Swift.Sendable {
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?
    /// Optional field to delete a specific DataAutomationProject stage
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
    }
}

extension BedrockDataAutomationClientTypes {

    /// Contains the information of a DataAutomationProject.
    public struct DataAutomationProject: Swift.Sendable {
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// Custom output configuration
        public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
        /// KMS Encryption Context
        public var kmsEncryptionContext: [Swift.String: Swift.String]?
        /// KMS Key Identifier
        public var kmsKeyId: Swift.String?
        /// Time Stamp
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// Override configuration
        public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Description of the DataAutomationProject
        public var projectDescription: Swift.String?
        /// Name of the DataAutomationProject
        /// This member is required.
        public var projectName: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
        /// Standard output configuration
        public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?
        /// Status of Data Automation Project
        /// This member is required.
        public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
            kmsEncryptionContext: [Swift.String: Swift.String]? = nil,
            kmsKeyId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
            projectArn: Swift.String? = nil,
            projectDescription: Swift.String? = nil,
            projectName: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
            standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil,
            status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
        ) {
            self.creationTime = creationTime
            self.customOutputConfiguration = customOutputConfiguration
            self.kmsEncryptionContext = kmsEncryptionContext
            self.kmsKeyId = kmsKeyId
            self.lastModifiedTime = lastModifiedTime
            self.overrideConfiguration = overrideConfiguration
            self.projectArn = projectArn
            self.projectDescription = projectDescription
            self.projectName = projectName
            self.projectStage = projectStage
            self.standardOutputConfiguration = standardOutputConfiguration
            self.status = status
        }
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProject: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataAutomationProject(creationTime: \(Swift.String(describing: creationTime)), customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), kmsEncryptionContext: \(Swift.String(describing: kmsEncryptionContext)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), status: \(Swift.String(describing: status)), projectDescription: \"CONTENT_REDACTED\", projectName: \"CONTENT_REDACTED\")"}
}

/// Get DataAutomationProject Response
public struct GetDataAutomationProjectOutput: Swift.Sendable {
    /// Contains the information of a DataAutomationProject.
    /// This member is required.
    public var project: BedrockDataAutomationClientTypes.DataAutomationProject?

    public init(
        project: BedrockDataAutomationClientTypes.DataAutomationProject? = nil
    ) {
        self.project = project
    }
}

extension BedrockDataAutomationClientTypes {

    /// Blueprint Filter
    public struct BlueprintFilter: Swift.Sendable {
        /// ARN of a Blueprint
        /// This member is required.
        public var blueprintArn: Swift.String?
        /// Stage of the Blueprint
        public var blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage?
        /// Blueprint Version
        public var blueprintVersion: Swift.String?

        public init(
            blueprintArn: Swift.String? = nil,
            blueprintStage: BedrockDataAutomationClientTypes.BlueprintStage? = nil,
            blueprintVersion: Swift.String? = nil
        ) {
            self.blueprintArn = blueprintArn
            self.blueprintStage = blueprintStage
            self.blueprintVersion = blueprintVersion
        }
    }
}

extension BedrockDataAutomationClientTypes {

    /// Project Stage filter
    public enum DataAutomationProjectStageFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case development
        case live
        case sdkUnknown(Swift.String)

        public static var allCases: [DataAutomationProjectStageFilter] {
            return [
                .all,
                .development,
                .live
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .development: return "DEVELOPMENT"
            case .live: return "LIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// List DataAutomationProject Request
public struct ListDataAutomationProjectsInput: Swift.Sendable {
    /// Blueprint Filter
    public var blueprintFilter: BedrockDataAutomationClientTypes.BlueprintFilter?
    /// Max Results
    public var maxResults: Swift.Int?
    /// Pagination token
    public var nextToken: Swift.String?
    /// Project Stage filter
    public var projectStageFilter: BedrockDataAutomationClientTypes.DataAutomationProjectStageFilter?
    /// Resource Owner
    public var resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner?

    public init(
        blueprintFilter: BedrockDataAutomationClientTypes.BlueprintFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectStageFilter: BedrockDataAutomationClientTypes.DataAutomationProjectStageFilter? = nil,
        resourceOwner: BedrockDataAutomationClientTypes.ResourceOwner? = nil
    ) {
        self.blueprintFilter = blueprintFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectStageFilter = projectStageFilter
        self.resourceOwner = resourceOwner
    }
}

extension BedrockDataAutomationClientTypes {

    /// Summary of a DataAutomationProject
    public struct DataAutomationProjectSummary: Swift.Sendable {
        /// Time Stamp
        /// This member is required.
        public var creationTime: Foundation.Date?
        /// ARN of a DataAutomationProject
        /// This member is required.
        public var projectArn: Swift.String?
        /// Name of the DataAutomationProject
        public var projectName: Swift.String?
        /// Stage of the Project
        public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?

        public init(
            creationTime: Foundation.Date? = nil,
            projectArn: Swift.String? = nil,
            projectName: Swift.String? = nil,
            projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil
        ) {
            self.creationTime = creationTime
            self.projectArn = projectArn
            self.projectName = projectName
            self.projectStage = projectStage
        }
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataAutomationProjectSummary(creationTime: \(Swift.String(describing: creationTime)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), projectName: \"CONTENT_REDACTED\")"}
}

/// List DataAutomationProject Response
public struct ListDataAutomationProjectsOutput: Swift.Sendable {
    /// Pagination token
    public var nextToken: Swift.String?
    /// List of DataAutomationProjectSummary
    /// This member is required.
    public var projects: [BedrockDataAutomationClientTypes.DataAutomationProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projects: [BedrockDataAutomationClientTypes.DataAutomationProjectSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.projects = projects
    }
}

/// Update DataAutomationProject Request
public struct UpdateDataAutomationProjectInput: Swift.Sendable {
    /// Custom output configuration
    public var customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration?
    /// KMS Encryption Configuration
    public var encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration?
    /// Override configuration
    public var overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration?
    /// ARN generated at the server side when a DataAutomationProject is created
    /// This member is required.
    public var projectArn: Swift.String?
    /// Description of the DataAutomationProject
    public var projectDescription: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Standard output configuration
    /// This member is required.
    public var standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration?

    public init(
        customOutputConfiguration: BedrockDataAutomationClientTypes.CustomOutputConfiguration? = nil,
        encryptionConfiguration: BedrockDataAutomationClientTypes.EncryptionConfiguration? = nil,
        overrideConfiguration: BedrockDataAutomationClientTypes.OverrideConfiguration? = nil,
        projectArn: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        standardOutputConfiguration: BedrockDataAutomationClientTypes.StandardOutputConfiguration? = nil
    ) {
        self.customOutputConfiguration = customOutputConfiguration
        self.encryptionConfiguration = encryptionConfiguration
        self.overrideConfiguration = overrideConfiguration
        self.projectArn = projectArn
        self.projectDescription = projectDescription
        self.projectStage = projectStage
        self.standardOutputConfiguration = standardOutputConfiguration
    }
}

extension UpdateDataAutomationProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDataAutomationProjectInput(customOutputConfiguration: \(Swift.String(describing: customOutputConfiguration)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), overrideConfiguration: \(Swift.String(describing: overrideConfiguration)), projectArn: \(Swift.String(describing: projectArn)), projectStage: \(Swift.String(describing: projectStage)), standardOutputConfiguration: \(Swift.String(describing: standardOutputConfiguration)), projectDescription: \"CONTENT_REDACTED\")"}
}

/// Update DataAutomationProject Response
public struct UpdateDataAutomationProjectOutput: Swift.Sendable {
    /// ARN of a DataAutomationProject
    /// This member is required.
    public var projectArn: Swift.String?
    /// Stage of the Project
    public var projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage?
    /// Status of Data Automation Project
    public var status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus?

    public init(
        projectArn: Swift.String? = nil,
        projectStage: BedrockDataAutomationClientTypes.DataAutomationProjectStage? = nil,
        status: BedrockDataAutomationClientTypes.DataAutomationProjectStatus? = nil
    ) {
        self.projectArn = projectArn
        self.projectStage = projectStage
        self.status = status
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    ) {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// List of tags
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tags
    /// This member is required.
    public var tags: [BedrockDataAutomationClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [BedrockDataAutomationClientTypes.Tag]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// ARN of a taggable resource
    /// This member is required.
    public var resourceARN: Swift.String?
    /// List of tag keys
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateBlueprintInput {

    static func urlPathProvider(_ value: CreateBlueprintInput) -> Swift.String? {
        return "/blueprints"
    }
}

extension CreateBlueprintVersionInput {

    static func urlPathProvider(_ value: CreateBlueprintVersionInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())/versions"
    }
}

extension CreateDataAutomationProjectInput {

    static func urlPathProvider(_ value: CreateDataAutomationProjectInput) -> Swift.String? {
        return "/data-automation-projects"
    }
}

extension DeleteBlueprintInput {

    static func urlPathProvider(_ value: DeleteBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension DeleteBlueprintInput {

    static func queryItemProvider(_ value: DeleteBlueprintInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let blueprintVersion = value.blueprintVersion {
            let blueprintVersionQueryItem = Smithy.URIQueryItem(name: "blueprintVersion".urlPercentEncoding(), value: Swift.String(blueprintVersion).urlPercentEncoding())
            items.append(blueprintVersionQueryItem)
        }
        return items
    }
}

extension DeleteDataAutomationProjectInput {

    static func urlPathProvider(_ value: DeleteDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension GetBlueprintInput {

    static func urlPathProvider(_ value: GetBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension GetDataAutomationProjectInput {

    static func urlPathProvider(_ value: GetDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension ListBlueprintsInput {

    static func urlPathProvider(_ value: ListBlueprintsInput) -> Swift.String? {
        return "/blueprints"
    }
}

extension ListDataAutomationProjectsInput {

    static func urlPathProvider(_ value: ListDataAutomationProjectsInput) -> Swift.String? {
        return "/data-automation-projects"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/listTagsForResource"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untagResource"
    }
}

extension UpdateBlueprintInput {

    static func urlPathProvider(_ value: UpdateBlueprintInput) -> Swift.String? {
        guard let blueprintArn = value.blueprintArn else {
            return nil
        }
        return "/blueprints/\(blueprintArn.urlPercentEncoding())"
    }
}

extension UpdateDataAutomationProjectInput {

    static func urlPathProvider(_ value: UpdateDataAutomationProjectInput) -> Swift.String? {
        guard let projectArn = value.projectArn else {
            return nil
        }
        return "/data-automation-projects/\(projectArn.urlPercentEncoding())"
    }
}

extension CreateBlueprintInput {

    static func write(value: CreateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintName"].write(value.blueprintName)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["clientToken"].write(value.clientToken)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["schema"].write(value.schema)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreateBlueprintVersionInput {

    static func write(value: CreateBlueprintVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension CreateDataAutomationProjectInput {

    static func write(value: CreateDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["customOutputConfiguration"].write(value.customOutputConfiguration, with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.write(value:to:))
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["overrideConfiguration"].write(value.overrideConfiguration, with: BedrockDataAutomationClientTypes.OverrideConfiguration.write(value:to:))
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectName"].write(value.projectName)
        try writer["projectStage"].write(value.projectStage)
        try writer["standardOutputConfiguration"].write(value.standardOutputConfiguration, with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetBlueprintInput {

    static func write(value: GetBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }
}

extension GetDataAutomationProjectInput {

    static func write(value: GetDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectStage"].write(value.projectStage)
    }
}

extension ListBlueprintsInput {

    static func write(value: ListBlueprintsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStageFilter"].write(value.blueprintStageFilter)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectFilter"].write(value.projectFilter, with: BedrockDataAutomationClientTypes.DataAutomationProjectFilter.write(value:to:))
        try writer["resourceOwner"].write(value.resourceOwner)
    }
}

extension ListDataAutomationProjectsInput {

    static func write(value: ListDataAutomationProjectsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintFilter"].write(value.blueprintFilter, with: BedrockDataAutomationClientTypes.BlueprintFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["projectStageFilter"].write(value.projectStageFilter)
        try writer["resourceOwner"].write(value.resourceOwner)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeList(value.tags, memberWritingClosure: BedrockDataAutomationClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBlueprintInput {

    static func write(value: UpdateBlueprintInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["schema"].write(value.schema)
    }
}

extension UpdateDataAutomationProjectInput {

    static func write(value: UpdateDataAutomationProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customOutputConfiguration"].write(value.customOutputConfiguration, with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.write(value:to:))
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: BedrockDataAutomationClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["overrideConfiguration"].write(value.overrideConfiguration, with: BedrockDataAutomationClientTypes.OverrideConfiguration.write(value:to:))
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectStage"].write(value.projectStage)
        try writer["standardOutputConfiguration"].write(value.standardOutputConfiguration, with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.write(value:to:))
    }
}

extension CreateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension CreateBlueprintVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBlueprintVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBlueprintVersionOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension CreateDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension DeleteBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBlueprintOutput {
        return DeleteBlueprintOutput()
    }
}

extension DeleteDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension GetDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataAutomationProjectOutput()
        value.project = try reader["project"].readIfPresent(with: BedrockDataAutomationClientTypes.DataAutomationProject.read(from:))
        return value
    }
}

extension ListBlueprintsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBlueprintsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBlueprintsOutput()
        value.blueprints = try reader["blueprints"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.BlueprintSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataAutomationProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataAutomationProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataAutomationProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projects = try reader["projects"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.DataAutomationProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBlueprintOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBlueprintOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBlueprintOutput()
        value.blueprint = try reader["blueprint"].readIfPresent(with: BedrockDataAutomationClientTypes.Blueprint.read(from:))
        return value
    }
}

extension UpdateDataAutomationProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataAutomationProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataAutomationProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

enum CreateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBlueprintVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBlueprintsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataAutomationProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBlueprintOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataAutomationProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BedrockDataAutomationClientTypes.Blueprint {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.Blueprint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.Blueprint()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.blueprintName = try reader["blueprintName"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.kmsEncryptionContext = try reader["kmsEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProject {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DataAutomationProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DataAutomationProject()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.projectDescription = try reader["projectDescription"].readIfPresent()
        value.standardOutputConfiguration = try reader["standardOutputConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.StandardOutputConfiguration.read(from:))
        value.customOutputConfiguration = try reader["customOutputConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.CustomOutputConfiguration.read(from:))
        value.overrideConfiguration = try reader["overrideConfiguration"].readIfPresent(with: BedrockDataAutomationClientTypes.OverrideConfiguration.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.kmsEncryptionContext = try reader["kmsEncryptionContext"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.OverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.OverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audio"].write(value.audio, with: BedrockDataAutomationClientTypes.AudioOverrideConfiguration.write(value:to:))
        try writer["document"].write(value.document, with: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration.write(value:to:))
        try writer["image"].write(value.image, with: BedrockDataAutomationClientTypes.ImageOverrideConfiguration.write(value:to:))
        try writer["modalityRouting"].write(value.modalityRouting, with: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration.write(value:to:))
        try writer["video"].write(value.video, with: BedrockDataAutomationClientTypes.VideoOverrideConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.OverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.OverrideConfiguration()
        value.document = try reader["document"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration.read(from:))
        value.image = try reader["image"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageOverrideConfiguration.read(from:))
        value.video = try reader["video"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoOverrideConfiguration.read(from:))
        value.audio = try reader["audio"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioOverrideConfiguration.read(from:))
        value.modalityRouting = try reader["modalityRouting"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ModalityRoutingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ModalityRoutingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["jpeg"].write(value.jpeg)
        try writer["mov"].write(value.mov)
        try writer["mp4"].write(value.mp4)
        try writer["png"].write(value.png)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ModalityRoutingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ModalityRoutingConfiguration()
        value.jpeg = try reader["jpeg"].readIfPresent()
        value.png = try reader["png"].readIfPresent()
        value.mp4 = try reader["mp4"].readIfPresent()
        value.mov = try reader["mov"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ModalityProcessingConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ModalityProcessingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ModalityProcessingConfiguration()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.VideoOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ImageOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageOverrideConfiguration()
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOverrideConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOverrideConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["modalityProcessing"].write(value.modalityProcessing, with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.write(value:to:))
        try writer["splitter"].write(value.splitter, with: BedrockDataAutomationClientTypes.SplitterConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOverrideConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOverrideConfiguration()
        value.splitter = try reader["splitter"].readIfPresent(with: BedrockDataAutomationClientTypes.SplitterConfiguration.read(from:))
        value.modalityProcessing = try reader["modalityProcessing"].readIfPresent(with: BedrockDataAutomationClientTypes.ModalityProcessingConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.SplitterConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.SplitterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.SplitterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.SplitterConfiguration()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.CustomOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.CustomOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprints"].writeList(value.blueprints, memberWritingClosure: BedrockDataAutomationClientTypes.BlueprintItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.CustomOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.CustomOutputConfiguration()
        value.blueprints = try reader["blueprints"].readListIfPresent(memberReadingClosure: BedrockDataAutomationClientTypes.BlueprintItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintItem {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintItem()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        return value
    }
}

extension BedrockDataAutomationClientTypes.StandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.StandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["audio"].write(value.audio, with: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration.write(value:to:))
        try writer["document"].write(value.document, with: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration.write(value:to:))
        try writer["image"].write(value.image, with: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration.write(value:to:))
        try writer["video"].write(value.video, with: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.StandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.StandardOutputConfiguration()
        value.document = try reader["document"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration.read(from:))
        value.image = try reader["image"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration.read(from:))
        value.video = try reader["video"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration.read(from:))
        value.audio = try reader["audio"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.AudioStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.AudioStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.AudioStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.AudioStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.AudioExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.AudioExtractionCategory.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.AudioExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.AudioExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.AudioExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.AudioExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.AudioExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.AudioExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.VideoStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.VideoStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.VideoStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.VideoStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.VideoBoundingBox.write(value:to:))
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.VideoExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoExtractionCategory.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.VideoBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.VideoBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.VideoExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.VideoExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.VideoExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.VideoExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.VideoExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.VideoExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.ImageStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.ImageStandardGenerativeField.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageStandardGenerativeField.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.ImageStandardGenerativeFieldType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.ImageStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.ImageBoundingBox.write(value:to:))
        try writer["category"].write(value.category, with: BedrockDataAutomationClientTypes.ImageExtractionCategory.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageStandardExtraction()
        value.category = try reader["category"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageExtractionCategory.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.ImageBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.ImageBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.ImageExtractionCategory {

    static func write(value: BedrockDataAutomationClientTypes.ImageExtractionCategory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.ImageExtractionCategoryType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ImageExtractionCategory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ImageExtractionCategory()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.ImageExtractionCategoryType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["extraction"].write(value.extraction, with: BedrockDataAutomationClientTypes.DocumentStandardExtraction.write(value:to:))
        try writer["generativeField"].write(value.generativeField, with: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField.write(value:to:))
        try writer["outputFormat"].write(value.outputFormat, with: BedrockDataAutomationClientTypes.DocumentOutputFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardOutputConfiguration()
        value.extraction = try reader["extraction"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardExtraction.read(from:))
        value.generativeField = try reader["generativeField"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField.read(from:))
        value.outputFormat = try reader["outputFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputFormat.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalFileFormat"].write(value.additionalFileFormat, with: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat.write(value:to:))
        try writer["textFormat"].write(value.textFormat, with: BedrockDataAutomationClientTypes.DocumentOutputTextFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputFormat()
        value.textFormat = try reader["textFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputTextFormat.read(from:))
        value.additionalFileFormat = try reader["additionalFileFormat"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputAdditionalFileFormat()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentOutputTextFormat {

    static func write(value: BedrockDataAutomationClientTypes.DocumentOutputTextFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.DocumentOutputTextFormatType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentOutputTextFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentOutputTextFormat()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.DocumentOutputTextFormatType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardGenerativeField {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardGenerativeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardGenerativeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardGenerativeField()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentStandardExtraction {

    static func write(value: BedrockDataAutomationClientTypes.DocumentStandardExtraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["boundingBox"].write(value.boundingBox, with: BedrockDataAutomationClientTypes.DocumentBoundingBox.write(value:to:))
        try writer["granularity"].write(value.granularity, with: BedrockDataAutomationClientTypes.DocumentExtractionGranularity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentStandardExtraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentStandardExtraction()
        value.granularity = try reader["granularity"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentExtractionGranularity.read(from:))
        value.boundingBox = try reader["boundingBox"].readIfPresent(with: BedrockDataAutomationClientTypes.DocumentBoundingBox.read(from:))
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentBoundingBox {

    static func write(value: BedrockDataAutomationClientTypes.DocumentBoundingBox?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentBoundingBox {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentBoundingBox()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BedrockDataAutomationClientTypes.DocumentExtractionGranularity {

    static func write(value: BedrockDataAutomationClientTypes.DocumentExtractionGranularity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["types"].writeList(value.types, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BedrockDataAutomationClientTypes.DocumentExtractionGranularityType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DocumentExtractionGranularity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DocumentExtractionGranularity()
        value.types = try reader["types"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BedrockDataAutomationClientTypes.DocumentExtractionGranularityType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BedrockDataAutomationClientTypes.BlueprintSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.BlueprintSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.BlueprintSummary()
        value.blueprintArn = try reader["blueprintArn"].readIfPresent() ?? ""
        value.blueprintVersion = try reader["blueprintVersion"].readIfPresent()
        value.blueprintStage = try reader["blueprintStage"].readIfPresent()
        value.blueprintName = try reader["blueprintName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.DataAutomationProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.DataAutomationProjectSummary()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectStage = try reader["projectStage"].readIfPresent()
        value.projectName = try reader["projectName"].readIfPresent()
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BedrockDataAutomationClientTypes.Tag {

    static func write(value: BedrockDataAutomationClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.Tag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BedrockDataAutomationClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BedrockDataAutomationClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BedrockDataAutomationClientTypes.EncryptionConfiguration {

    static func write(value: BedrockDataAutomationClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsEncryptionContext"].writeMap(value.kmsEncryptionContext, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }
}

extension BedrockDataAutomationClientTypes.DataAutomationProjectFilter {

    static func write(value: BedrockDataAutomationClientTypes.DataAutomationProjectFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["projectArn"].write(value.projectArn)
        try writer["projectStage"].write(value.projectStage)
    }
}

extension BedrockDataAutomationClientTypes.BlueprintFilter {

    static func write(value: BedrockDataAutomationClientTypes.BlueprintFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["blueprintArn"].write(value.blueprintArn)
        try writer["blueprintStage"].write(value.blueprintStage)
        try writer["blueprintVersion"].write(value.blueprintVersion)
    }
}

public enum BedrockDataAutomationClientTypes {}
