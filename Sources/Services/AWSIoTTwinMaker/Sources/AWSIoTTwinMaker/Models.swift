//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An unexpected error has occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource wasn't found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The rate exceeds the limit.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Failed
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that uniquely identifies an entity property.
    public struct EntityPropertyReference: Swift.Sendable {
        /// The name of the component.
        public var componentName: Swift.String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public var componentPath: Swift.String?
        /// The ID of the entity.
        public var entityId: Swift.String?
        /// A mapping of external IDs to property names. External IDs uniquely identify properties from external data stores.
        public var externalIdProperty: [Swift.String: Swift.String]?
        /// The name of the property.
        /// This member is required.
        public var propertyName: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            componentPath: Swift.String? = nil,
            entityId: Swift.String? = nil,
            externalIdProperty: [Swift.String: Swift.String]? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentPath = componentPath
            self.entityId = entityId
            self.externalIdProperty = externalIdProperty
            self.propertyName = propertyName
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// A value that associates a component and an entity.
    public struct RelationshipValue: Swift.Sendable {
        /// The name of the target component associated with the relationship value.
        public var targetComponentName: Swift.String?
        /// The ID of the target entity associated with this relationship value.
        public var targetEntityId: Swift.String?

        public init(
            targetComponentName: Swift.String? = nil,
            targetEntityId: Swift.String? = nil
        )
        {
            self.targetComponentName = targetComponentName
            self.targetEntityId = targetEntityId
        }
    }
}

/// A conflict occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CancelMetadataTransferJobInput: Swift.Sendable {
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?

    public init(
        metadataTransferJobId: Swift.String? = nil
    )
    {
        self.metadataTransferJobId = metadataTransferJobId
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job's progress.
    public struct MetadataTransferJobProgress: Swift.Sendable {
        /// The failed count.
        public var failedCount: Swift.Int?
        /// The skipped count.
        public var skippedCount: Swift.Int?
        /// The succeeded count.
        public var succeededCount: Swift.Int?
        /// The total count. [of what]
        public var totalCount: Swift.Int?

        public init(
            failedCount: Swift.Int? = nil,
            skippedCount: Swift.Int? = nil,
            succeededCount: Swift.Int? = nil,
            totalCount: Swift.Int? = nil
        )
        {
            self.failedCount = failedCount
            self.skippedCount = skippedCount
            self.succeededCount = succeededCount
            self.totalCount = totalCount
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compositeComponentFailure
        case internalFailure
        case processingError
        case syncCreatingError
        case syncDeletingError
        case syncInitializingError
        case syncProcessingError
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .compositeComponentFailure,
                .internalFailure,
                .processingError,
                .syncCreatingError,
                .syncDeletingError,
                .syncInitializingError,
                .syncProcessingError,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compositeComponentFailure: return "COMPOSITE_COMPONENT_FAILURE"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .processingError: return "PROCESSING_ERROR"
            case .syncCreatingError: return "SYNC_CREATING_ERROR"
            case .syncDeletingError: return "SYNC_DELETING_ERROR"
            case .syncInitializingError: return "SYNC_INITIALIZING_ERROR"
            case .syncProcessingError: return "SYNC_PROCESSING_ERROR"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The error details.
    public struct ErrorDetails: Swift.Sendable {
        /// The error code.
        public var code: IoTTwinMakerClientTypes.ErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: IoTTwinMakerClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum MetadataTransferJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case error
        case pending
        case running
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [MetadataTransferJobState] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .error,
                .pending,
                .running,
                .validating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .error: return "ERROR"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job status.
    public struct MetadataTransferJobStatus: Swift.Sendable {
        /// The metadata transfer job error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The queued position.
        public var queuedPosition: Swift.Int?
        /// The metadata transfer job state.
        public var state: IoTTwinMakerClientTypes.MetadataTransferJobState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            queuedPosition: Swift.Int? = nil,
            state: IoTTwinMakerClientTypes.MetadataTransferJobState? = nil
        )
        {
            self.error = error
            self.queuedPosition = queuedPosition
            self.state = state
        }
    }
}

public struct CancelMetadataTransferJobOutput: Swift.Sendable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job's progress.
    public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
    /// The metadata transfer job's status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    /// Used to update the DateTime property.
    /// This member is required.
    public var updateDateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        metadataTransferJobId: Swift.String? = nil,
        progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
        updateDateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.metadataTransferJobId = metadataTransferJobId
        self.progress = progress
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

/// The service quota was exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about the composite component types of a component type.
    public struct CompositeComponentTypeRequest: Swift.Sendable {
        /// This is the componentTypeId that the compositeComponentType refers to.
        public var componentTypeId: Swift.String?

        public init(
            componentTypeId: Swift.String? = nil
        )
        {
            self.componentTypeId = componentTypeId
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The Lambda function.
    public struct LambdaFunction: Swift.Sendable {
        /// The ARN of the Lambda function.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The data connector.
    public struct DataConnector: Swift.Sendable {
        /// A Boolean value that specifies whether the data connector is native to IoT TwinMaker.
        public var isNative: Swift.Bool?
        /// The Lambda function associated with this data connector.
        public var lambda: IoTTwinMakerClientTypes.LambdaFunction?

        public init(
            isNative: Swift.Bool? = nil,
            lambda: IoTTwinMakerClientTypes.LambdaFunction? = nil
        )
        {
            self.isNative = isNative
            self.lambda = lambda
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum Scope: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case entity
        case workspace
        case sdkUnknown(Swift.String)

        public static var allCases: [Scope] {
            return [
                .entity,
                .workspace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .entity: return "ENTITY"
            case .workspace: return "WORKSPACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The function request body.
    public struct FunctionRequest: Swift.Sendable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init(
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that specifies a relationship with another component type.
    public struct Relationship: Swift.Sendable {
        /// The type of the relationship.
        public var relationshipType: Swift.String?
        /// The ID of the target component type associated with this relationship.
        public var targetComponentTypeId: Swift.String?

        public init(
            relationshipType: Swift.String? = nil,
            targetComponentTypeId: Swift.String? = nil
        )
        {
            self.relationshipType = relationshipType
            self.targetComponentTypeId = targetComponentTypeId
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum ModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case double
        case integer
        case list
        case long
        case map
        case relationship
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelType] {
            return [
                .boolean,
                .double,
                .integer,
                .list,
                .long,
                .map,
                .relationship,
                .string
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .list: return "LIST"
            case .long: return "LONG"
            case .map: return "MAP"
            case .relationship: return "RELATIONSHIP"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum GroupType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupType] {
            return [
                .tabular
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    ///
    public struct PropertyGroupRequest: Swift.Sendable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The names of properties.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum State: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateComponentTypeOutput: Swift.Sendable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

extension IoTTwinMakerClientTypes {

    public enum PropertyUpdateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case resetValue
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyUpdateType] {
            return [
                .create,
                .delete,
                .resetValue,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .resetValue: return "RESET_VALUE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum PropertyGroupUpdateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyGroupUpdateType] {
            return [
                .create,
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The component property group request.
    public struct ComponentPropertyGroupRequest: Swift.Sendable {
        /// The group type.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// The property names.
        public var propertyNames: [Swift.String]?
        /// The update type.
        public var updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            propertyNames: [Swift.String]? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyGroupUpdateType? = nil
        )
        {
            self.groupType = groupType
            self.propertyNames = propertyNames
            self.updateType = updateType
        }
    }
}

public struct CreateEntityOutput: Swift.Sendable {
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The current state of the entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        entityId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.entityId = entityId
        self.state = state
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job AWS IoT TwinMaker destination configuration.
    public struct IotTwinMakerDestinationConfiguration: Swift.Sendable {
        /// The IoT TwinMaker workspace.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            workspace: Swift.String? = nil
        )
        {
            self.workspace = workspace
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The S3 destination configuration.
    public struct S3DestinationConfiguration: Swift.Sendable {
        /// The S3 destination configuration location.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum DestinationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iotsitewise
        case iottwinmaker
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .iotsitewise,
                .iottwinmaker,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iotsitewise: return "iotsitewise"
            case .iottwinmaker: return "iottwinmaker"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The [link to action] metadata transfer job destination configuration.
    public struct DestinationConfiguration: Swift.Sendable {
        /// The metadata transfer job Amazon Web Services IoT TwinMaker configuration.
        public var iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration?
        /// The metadata transfer job S3 configuration. [need to add S3 entity]
        public var s3Configuration: IoTTwinMakerClientTypes.S3DestinationConfiguration?
        /// The destination type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.DestinationType?

        public init(
            iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration? = nil,
            s3Configuration: IoTTwinMakerClientTypes.S3DestinationConfiguration? = nil,
            type: IoTTwinMakerClientTypes.DestinationType? = nil
        )
        {
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Filter by asset. [TwinMaker asset]
    public struct FilterByAsset: Swift.Sendable {
        /// The external-Id property of an asset.
        public var assetExternalId: Swift.String?
        /// Filter by asset Id.
        public var assetId: Swift.String?
        /// Boolean to include the asset model.
        public var includeAssetModel: Swift.Bool?
        /// Includes sub-assets.[need description hekp for this]
        public var includeOffspring: Swift.Bool?

        public init(
            assetExternalId: Swift.String? = nil,
            assetId: Swift.String? = nil,
            includeAssetModel: Swift.Bool? = nil,
            includeOffspring: Swift.Bool? = nil
        )
        {
            self.assetExternalId = assetExternalId
            self.assetId = assetId
            self.includeAssetModel = includeAssetModel
            self.includeOffspring = includeOffspring
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Filter by asset model.
    public struct FilterByAssetModel: Swift.Sendable {
        /// The external-Id property of an asset model.
        public var assetModelExternalId: Swift.String?
        /// The asset model Id.
        public var assetModelId: Swift.String?
        /// Bolean to include assets.
        public var includeAssets: Swift.Bool?
        /// Include asset offspring. [need desc.]
        public var includeOffspring: Swift.Bool?

        public init(
            assetModelExternalId: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            includeAssets: Swift.Bool? = nil,
            includeOffspring: Swift.Bool? = nil
        )
        {
            self.assetModelExternalId = assetModelExternalId
            self.assetModelId = assetModelId
            self.includeAssets = includeAssets
            self.includeOffspring = includeOffspring
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The AWS IoT SiteWise soucre configuration filter.[need held with desc here]
    public enum IotSiteWiseSourceConfigurationFilter: Swift.Sendable {
        /// Filter by asset model.
        case filterbyassetmodel(IoTTwinMakerClientTypes.FilterByAssetModel)
        /// Filter by asset.
        case filterbyasset(IoTTwinMakerClientTypes.FilterByAsset)
        case sdkUnknown(Swift.String)
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job AWS IoT SiteWise source configuration.
    public struct IotSiteWiseSourceConfiguration: Swift.Sendable {
        /// The AWS IoT SiteWise soucre configuration filters.
        public var filters: [IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]?

        public init(
            filters: [IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter]? = nil
        )
        {
            self.filters = filters
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Filter by component type.
    public struct FilterByComponentType: Swift.Sendable {
        /// The component type Id.
        /// This member is required.
        public var componentTypeId: Swift.String?

        public init(
            componentTypeId: Swift.String? = nil
        )
        {
            self.componentTypeId = componentTypeId
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Vilter by entity.
    public struct FilterByEntity: Swift.Sendable {
        /// The entity Id.
        /// This member is required.
        public var entityId: Swift.String?

        public init(
            entityId: Swift.String? = nil
        )
        {
            self.entityId = entityId
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job AWS IoT TwinMaker source configuration filter.
    public enum IotTwinMakerSourceConfigurationFilter: Swift.Sendable {
        /// Filter by component type.
        case filterbycomponenttype(IoTTwinMakerClientTypes.FilterByComponentType)
        /// Filter by entity.
        case filterbyentity(IoTTwinMakerClientTypes.FilterByEntity)
        case sdkUnknown(Swift.String)
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job AWS IoT TwinMaker source configuration.
    public struct IotTwinMakerSourceConfiguration: Swift.Sendable {
        /// The metadata transfer job AWS IoT TwinMaker source configuration filters.
        public var filters: [IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]?
        /// The IoT TwinMaker workspace.
        /// This member is required.
        public var workspace: Swift.String?

        public init(
            filters: [IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter]? = nil,
            workspace: Swift.String? = nil
        )
        {
            self.filters = filters
            self.workspace = workspace
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The S3 destination source configuration.
    public struct S3SourceConfiguration: Swift.Sendable {
        /// The S3 destination source configuration location.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum SourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iotsitewise
        case iottwinmaker
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .iotsitewise,
                .iottwinmaker,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iotsitewise: return "iotsitewise"
            case .iottwinmaker: return "iottwinmaker"
            case .s3: return "s3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The source configuration.
    public struct SourceConfiguration: Swift.Sendable {
        /// The source configuration IoT SiteWise configuration.
        public var iotSiteWiseConfiguration: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration?
        /// The source configuration IoT TwinMaker configuration.
        public var iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration?
        /// The source configuration S3 configuration.
        public var s3Configuration: IoTTwinMakerClientTypes.S3SourceConfiguration?
        /// The source configuration type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.SourceType?

        public init(
            iotSiteWiseConfiguration: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration? = nil,
            iotTwinMakerConfiguration: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration? = nil,
            s3Configuration: IoTTwinMakerClientTypes.S3SourceConfiguration? = nil,
            type: IoTTwinMakerClientTypes.SourceType? = nil
        )
        {
            self.iotSiteWiseConfiguration = iotSiteWiseConfiguration
            self.iotTwinMakerConfiguration = iotTwinMakerConfiguration
            self.s3Configuration = s3Configuration
            self.type = type
        }
    }
}

public struct CreateMetadataTransferJobInput: Swift.Sendable {
    /// The metadata transfer job description.
    public var description: Swift.String?
    /// The metadata transfer job destination.
    /// This member is required.
    public var destination: IoTTwinMakerClientTypes.DestinationConfiguration?
    /// The metadata transfer job Id.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job sources.
    /// This member is required.
    public var sources: [IoTTwinMakerClientTypes.SourceConfiguration]?

    public init(
        description: Swift.String? = nil,
        destination: IoTTwinMakerClientTypes.DestinationConfiguration? = nil,
        metadataTransferJobId: Swift.String? = nil,
        sources: [IoTTwinMakerClientTypes.SourceConfiguration]? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.metadataTransferJobId = metadataTransferJobId
        self.sources = sources
    }
}

public struct CreateMetadataTransferJobOutput: Swift.Sendable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The The metadata transfer job creation DateTime property.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job response status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        metadataTransferJobId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.metadataTransferJobId = metadataTransferJobId
        self.status = status
    }
}

public struct CreateSceneInput: Swift.Sendable {
    /// A list of capabilities that the scene uses to render itself.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The description for this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The request metadata.
    public var sceneMetadata: [Swift.String: Swift.String]?
    /// Metadata that you can use to manage the scene.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String: Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

public struct CreateSceneOutput: Swift.Sendable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

public struct CreateSyncJobInput: Swift.Sendable {
    /// The SyncJob IAM role. This IAM role is used by the SyncJob to read from the syncSource, and create, update, or delete the corresponding resources.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync source. Currently the only supported syncSoource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The SyncJob tags.
    public var tags: [Swift.String: Swift.String]?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    public enum SyncJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case error
        case initializing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncJobState] {
            return [
                .active,
                .creating,
                .deleting,
                .error,
                .initializing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSyncJobOutput: Swift.Sendable {
    /// The SyncJob ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time for the SyncJob creation.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.state = state
    }
}

public struct CreateWorkspaceInput: Swift.Sendable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// Metadata that you can use to manage the workspace
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

public struct CreateWorkspaceOutput: Swift.Sendable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
    }
}

public struct DeleteComponentTypeInput: Swift.Sendable {
    /// The ID of the component type to delete.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

public struct DeleteComponentTypeOutput: Swift.Sendable {
    /// The current state of the component type to be deleted.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

public struct DeleteEntityInput: Swift.Sendable {
    /// The ID of the entity to delete.
    /// This member is required.
    public var entityId: Swift.String?
    /// A Boolean value that specifies whether the operation deletes child entities.
    public var isRecursive: Swift.Bool?
    /// The ID of the workspace that contains the entity to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        isRecursive: Swift.Bool? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.isRecursive = isRecursive
        self.workspaceId = workspaceId
    }
}

public struct DeleteEntityOutput: Swift.Sendable {
    /// The current state of the deleted entity.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil
    )
    {
        self.state = state
    }
}

public struct DeleteSceneInput: Swift.Sendable {
    /// The ID of the scene to delete.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

public struct DeleteSceneOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteSyncJobInput: Swift.Sendable {
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

public struct DeleteSyncJobOutput: Swift.Sendable {
    /// The SyncJob response state.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.SyncJobState?

    public init(
        state: IoTTwinMakerClientTypes.SyncJobState? = nil
    )
    {
        self.state = state
    }
}

public struct DeleteWorkspaceInput: Swift.Sendable {
    /// The ID of the workspace to delete.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct DeleteWorkspaceOutput: Swift.Sendable {
    /// The string that specifies the delete result for the workspace.
    public var message: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

/// The query timeout exception.
public struct QueryTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ExecuteQueryInput: Swift.Sendable {
    /// The maximum number of results to return at one time. The default is 50.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The query statement.
    /// This member is required.
    public var queryStatement: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatement: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatement = queryStatement
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    public enum ColumnType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edge
        case node
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnType] {
            return [
                .edge,
                .node,
                .value
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edge: return "EDGE"
            case .node: return "NODE"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// A description of the column in the query results.
    public struct ColumnDescription: Swift.Sendable {
        /// The name of the column description.
        public var name: Swift.String?
        /// The type of the column description.
        public var type: IoTTwinMakerClientTypes.ColumnType?

        public init(
            name: Swift.String? = nil,
            type: IoTTwinMakerClientTypes.ColumnType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Represents a single row in the query results.
    public struct Row: Swift.Sendable {
        /// The data in a row of query results.
        public var rowData: [Smithy.Document]?

        public init(
            rowData: [Smithy.Document]? = nil
        )
        {
            self.rowData = rowData
        }
    }
}

public struct ExecuteQueryOutput: Swift.Sendable {
    /// A list of ColumnDescription objects.
    public var columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Represents a single row in the query results.
    public var rows: [IoTTwinMakerClientTypes.Row]?

    public init(
        columnDescriptions: [IoTTwinMakerClientTypes.ColumnDescription]? = nil,
        nextToken: Swift.String? = nil,
        rows: [IoTTwinMakerClientTypes.Row]? = nil
    )
    {
        self.columnDescriptions = columnDescriptions
        self.nextToken = nextToken
        self.rows = rows
    }
}

public struct GetComponentTypeInput: Swift.Sendable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that returns information about the composite component types of a component type.
    public struct CompositeComponentTypeResponse: Swift.Sendable {
        /// This is the componentTypeId that this compositeComponentType refers to.
        public var componentTypeId: Swift.String?
        /// This boolean indicates whether this compositeComponentType is inherited from its parent.
        public var isInherited: Swift.Bool?

        public init(
            componentTypeId: Swift.String? = nil,
            isInherited: Swift.Bool? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.isInherited = isInherited
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The function response.
    public struct FunctionResponse: Swift.Sendable {
        /// The data connector.
        public var implementedBy: IoTTwinMakerClientTypes.DataConnector?
        /// Indicates whether this function is inherited.
        public var isInherited: Swift.Bool?
        /// The required properties of the function.
        public var requiredProperties: [Swift.String]?
        /// The scope of the function.
        public var scope: IoTTwinMakerClientTypes.Scope?

        public init(
            implementedBy: IoTTwinMakerClientTypes.DataConnector? = nil,
            isInherited: Swift.Bool? = nil,
            requiredProperties: [Swift.String]? = nil,
            scope: IoTTwinMakerClientTypes.Scope? = nil
        )
        {
            self.implementedBy = implementedBy
            self.isInherited = isInherited
            self.requiredProperties = requiredProperties
            self.scope = scope
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The property group response
    public struct PropertyGroupResponse: Swift.Sendable {
        /// The group types.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties.
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that represents the status of an entity, component, component type, or workspace.
    public struct Status: Swift.Sendable {
        /// The error message.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The current state of the entity, component, component type, or workspace.
        public var state: IoTTwinMakerClientTypes.State?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.State? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

public struct GetEntityInput: Swift.Sendable {
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entityId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// The component property group response.
    public struct ComponentPropertyGroupResponse: Swift.Sendable {
        /// The group type.
        /// This member is required.
        public var groupType: IoTTwinMakerClientTypes.GroupType?
        /// A Boolean value that specifies whether the property group is inherited from a parent entity
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// The names of properties
        /// This member is required.
        public var propertyNames: [Swift.String]?

        public init(
            groupType: IoTTwinMakerClientTypes.GroupType? = nil,
            isInherited: Swift.Bool? = nil,
            propertyNames: [Swift.String]? = nil
        )
        {
            self.groupType = groupType
            self.isInherited = isInherited
            self.propertyNames = propertyNames
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that returns information about a component summary.
    public struct ComponentSummary: Swift.Sendable {
        /// The name of the component.
        /// This member is required.
        public var componentName: Swift.String?
        /// This string specifies the path to the composite component, starting from the top-level component.
        public var componentPath: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// The property groups.
        public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]?
        /// The status of the component type.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public var syncSource: Swift.String?

        public init(
            componentName: Swift.String? = nil,
            componentPath: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            syncSource: Swift.String? = nil
        )
        {
            self.componentName = componentName
            self.componentPath = componentPath
            self.componentTypeId = componentTypeId
            self.definedIn = definedIn
            self.description = description
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }
    }
}

public struct GetMetadataTransferJobInput: Swift.Sendable {
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?

    public init(
        metadataTransferJobId: Swift.String? = nil
    )
    {
        self.metadataTransferJobId = metadataTransferJobId
    }
}

public struct GetMetadataTransferJobOutput: Swift.Sendable {
    /// The metadata transfer job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The metadata transfer job's creation DateTime property.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The metadata transfer job description.
    public var description: Swift.String?
    /// The metadata transfer job's destination.
    /// This member is required.
    public var destination: IoTTwinMakerClientTypes.DestinationConfiguration?
    /// The metadata transfer job Id.
    /// This member is required.
    public var metadataTransferJobId: Swift.String?
    /// The metadata transfer job's role.
    /// This member is required.
    public var metadataTransferJobRole: Swift.String?
    /// The metadata transfer job's progress.
    public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
    /// The metadata transfer job's report URL.
    public var reportUrl: Swift.String?
    /// The metadata transfer job's sources.
    /// This member is required.
    public var sources: [IoTTwinMakerClientTypes.SourceConfiguration]?
    /// The metadata transfer job's status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
    /// The metadata transfer job's update DateTime property.
    /// This member is required.
    public var updateDateTime: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        destination: IoTTwinMakerClientTypes.DestinationConfiguration? = nil,
        metadataTransferJobId: Swift.String? = nil,
        metadataTransferJobRole: Swift.String? = nil,
        progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
        reportUrl: Swift.String? = nil,
        sources: [IoTTwinMakerClientTypes.SourceConfiguration]? = nil,
        status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
        updateDateTime: Foundation.Date? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.destination = destination
        self.metadataTransferJobId = metadataTransferJobId
        self.metadataTransferJobRole = metadataTransferJobRole
        self.progress = progress
        self.reportUrl = reportUrl
        self.sources = sources
        self.status = status
        self.updateDateTime = updateDateTime
    }
}

public struct GetPricingPlanInput: Swift.Sendable {

    public init() { }
}

extension IoTTwinMakerClientTypes {

    public enum PricingTier: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case tier1
        case tier2
        case tier3
        case tier4
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingTier] {
            return [
                .tier1,
                .tier2,
                .tier3,
                .tier4
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .tier1: return "TIER_1"
            case .tier2: return "TIER_2"
            case .tier3: return "TIER_3"
            case .tier4: return "TIER_4"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Information about the pricing bundle.
    public struct BundleInformation: Swift.Sendable {
        /// The bundle names.
        /// This member is required.
        public var bundleNames: [Swift.String]?
        /// The pricing tier.
        public var pricingTier: IoTTwinMakerClientTypes.PricingTier?

        public init(
            bundleNames: [Swift.String]? = nil,
            pricingTier: IoTTwinMakerClientTypes.PricingTier? = nil
        )
        {
            self.bundleNames = bundleNames
            self.pricingTier = pricingTier
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum PricingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case basic
        case standard
        case tieredBundle
        case sdkUnknown(Swift.String)

        public static var allCases: [PricingMode] {
            return [
                .basic,
                .standard,
                .tieredBundle
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .standard: return "STANDARD"
            case .tieredBundle: return "TIERED_BUNDLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum UpdateReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case entityCountUpdate
        case overwritten
        case pricingModeUpdate
        case pricingTierUpdate
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateReason] {
            return [
                .default,
                .entityCountUpdate,
                .overwritten,
                .pricingModeUpdate,
                .pricingTierUpdate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .entityCountUpdate: return "ENTITY_COUNT_UPDATE"
            case .overwritten: return "OVERWRITTEN"
            case .pricingModeUpdate: return "PRICING_MODE_UPDATE"
            case .pricingTierUpdate: return "PRICING_TIER_UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The pricing plan.
    public struct PricingPlan: Swift.Sendable {
        /// The billable entity count.
        public var billableEntityCount: Swift.Int?
        /// The pricing plan's bundle information.
        public var bundleInformation: IoTTwinMakerClientTypes.BundleInformation?
        /// The effective date and time of the pricing plan.
        /// This member is required.
        public var effectiveDateTime: Foundation.Date?
        /// The pricing mode.
        /// This member is required.
        public var pricingMode: IoTTwinMakerClientTypes.PricingMode?
        /// The set date and time for updating a pricing plan.
        /// This member is required.
        public var updateDateTime: Foundation.Date?
        /// The update reason for changing a pricing plan.
        /// This member is required.
        public var updateReason: IoTTwinMakerClientTypes.UpdateReason?

        public init(
            billableEntityCount: Swift.Int? = nil,
            bundleInformation: IoTTwinMakerClientTypes.BundleInformation? = nil,
            effectiveDateTime: Foundation.Date? = nil,
            pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil,
            updateDateTime: Foundation.Date? = nil,
            updateReason: IoTTwinMakerClientTypes.UpdateReason? = nil
        )
        {
            self.billableEntityCount = billableEntityCount
            self.bundleInformation = bundleInformation
            self.effectiveDateTime = effectiveDateTime
            self.pricingMode = pricingMode
            self.updateDateTime = updateDateTime
            self.updateReason = updateReason
        }
    }
}

public struct GetPricingPlanOutput: Swift.Sendable {
    /// The chosen pricing plan for the current billing cycle.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// The pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init(
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

/// The connector failed.
public struct ConnectorFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The connector timed out.
public struct ConnectorTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConnectorTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTTwinMakerClientTypes {

    public enum Order: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// Filter criteria that orders the return output. It can be sorted in ascending or descending order.
    public struct OrderBy: Swift.Sendable {
        /// The set order that filters results.
        public var order: IoTTwinMakerClientTypes.Order?
        /// The property name.
        /// This member is required.
        public var propertyName: Swift.String?

        public init(
            order: IoTTwinMakerClientTypes.Order? = nil,
            propertyName: Swift.String? = nil
        )
        {
            self.order = order
            self.propertyName = propertyName
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum InterpolationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [InterpolationType] {
            return [
                .linear
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that specifies how to interpolate data in a list.
    public struct InterpolationParameters: Swift.Sendable {
        /// The interpolation type.
        public var interpolationType: IoTTwinMakerClientTypes.InterpolationType?
        /// The interpolation time interval in seconds.
        public var intervalInSeconds: Swift.Int?

        public init(
            interpolationType: IoTTwinMakerClientTypes.InterpolationType? = nil,
            intervalInSeconds: Swift.Int? = nil
        )
        {
            self.interpolationType = interpolationType
            self.intervalInSeconds = intervalInSeconds
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum OrderByTime: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderByTime] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetSceneInput: Swift.Sendable {
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        sceneId: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.sceneId = sceneId
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    public enum SceneErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case matterportError
        case sdkUnknown(Swift.String)

        public static var allCases: [SceneErrorCode] {
            return [
                .matterportError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .matterportError: return "MATTERPORT_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The scene error.
    public struct SceneError: Swift.Sendable {
        /// The SceneError code.
        public var code: IoTTwinMakerClientTypes.SceneErrorCode?
        /// The SceneError message.
        public var message: Swift.String?

        public init(
            code: IoTTwinMakerClientTypes.SceneErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

public struct GetSceneOutput: Swift.Sendable {
    /// The ARN of the scene.
    /// This member is required.
    public var arn: Swift.String?
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    /// This member is required.
    public var contentLocation: Swift.String?
    /// The date and time when the scene was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The description of the scene.
    public var description: Swift.String?
    /// The SceneResponse error.
    public var error: IoTTwinMakerClientTypes.SceneError?
    /// The generated scene metadata.
    public var generatedSceneMetadata: [Swift.String: Swift.String]?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The response metadata.
    public var sceneMetadata: [Swift.String: Swift.String]?
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        error: IoTTwinMakerClientTypes.SceneError? = nil,
        generatedSceneMetadata: [Swift.String: Swift.String]? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String: Swift.String]? = nil,
        updateDateTime: Foundation.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.creationDateTime = creationDateTime
        self.description = description
        self.error = error
        self.generatedSceneMetadata = generatedSceneMetadata
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

public struct GetSyncJobInput: Swift.Sendable {
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The workspace ID.
    public var workspaceId: Swift.String?

    public init(
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// The SyncJob status.
    public struct SyncJobStatus: Swift.Sendable {
        /// The SyncJob error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The SyncJob status state.
        public var state: IoTTwinMakerClientTypes.SyncJobState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncJobState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

public struct GetSyncJobOutput: Swift.Sendable {
    /// The sync job ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// The creation date and time.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The SyncJob response status.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.SyncJobStatus?
    /// The sync IAM role.
    /// This member is required.
    public var syncRole: Swift.String?
    /// The sync soucre. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The update date and time.
    /// This member is required.
    public var updateDateTime: Foundation.Date?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
        syncRole: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: Foundation.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.status = status
        self.syncRole = syncRole
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

public struct GetWorkspaceInput: Swift.Sendable {
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        workspaceId: Swift.String? = nil
    )
    {
        self.workspaceId = workspaceId
    }
}

public struct GetWorkspaceOutput: Swift.Sendable {
    /// The ARN of the workspace.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time when the workspace was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The description of the workspace.
    public var description: Swift.String?
    /// A list of services that are linked to the workspace.
    public var linkedServices: [Swift.String]?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// The date and time when the workspace was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        linkedServices: [Swift.String]? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        updateDateTime: Foundation.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.linkedServices = linkedServices
        self.role = role
        self.s3Location = s3Location
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

public struct ListComponentsInput: Swift.Sendable {
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID for the entity whose metadata (component/properties) is returned by the operation.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results returned at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentPath: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentPath = componentPath
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

public struct ListComponentsOutput: Swift.Sendable {
    /// A list of objects that contain information about the components.
    /// This member is required.
    public var componentSummaries: [IoTTwinMakerClientTypes.ComponentSummary]?
    /// The string that specifies the next page of component results.
    public var nextToken: Swift.String?

    public init(
        componentSummaries: [IoTTwinMakerClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentSummaries = componentSummaries
        self.nextToken = nextToken
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that filters items in a list of component types. Only one object is accepted as a valid input.
    public enum ListComponentTypesFilter: Swift.Sendable {
        /// The component type that the component types in the list extend.
        case extendsfrom(Swift.String)
        /// The namespace to which the component types in the list belong.
        case namespace(Swift.String)
        /// A Boolean value that specifies whether the component types in the list are abstract.
        case isabstract(Swift.Bool)
        case sdkUnknown(Swift.String)
    }
}

public struct ListComponentTypesInput: Swift.Sendable {
    /// A list of objects that filter the request.
    public var filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.ListComponentTypesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about a component type.
    public struct ComponentTypeSummary: Swift.Sendable {
        /// The ARN of the component type.
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the component type.
        /// This member is required.
        public var componentTypeId: Swift.String?
        /// The component type name.
        public var componentTypeName: Swift.String?
        /// The date and time when the component type was created.
        /// This member is required.
        public var creationDateTime: Foundation.Date?
        /// The description of the component type.
        public var description: Swift.String?
        /// The current status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The date and time when the component type was last updated.
        /// This member is required.
        public var updateDateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            componentTypeName: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.componentTypeId = componentTypeId
            self.componentTypeName = componentTypeName
            self.creationDateTime = creationDateTime
            self.description = description
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }
}

public struct ListComponentTypesOutput: Swift.Sendable {
    /// A list of objects that contain information about the component types.
    /// This member is required.
    public var componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]?
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeSummaries: [IoTTwinMakerClientTypes.ComponentTypeSummary]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeSummaries = componentTypeSummaries
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that filters items in a list of entities.
    public enum ListEntitiesFilter: Swift.Sendable {
        /// The parent of the entities in the list.
        case parententityid(Swift.String)
        /// The ID of the component type in the entities in the list.
        case componenttypeid(Swift.String)
        /// The external-Id property of a component. The external-Id property is the primary key of an external storage system.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct ListEntitiesInput: Swift.Sendable {
    /// A list of objects that filter the request. Only one object is accepted as a valid input.
    public var filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.ListEntitiesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about an entity.
    public struct EntitySummary: Swift.Sendable {
        /// The ARN of the entity.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the entity was created.
        /// This member is required.
        public var creationDateTime: Foundation.Date?
        /// The description of the entity.
        public var description: Swift.String?
        /// The ID of the entity.
        /// This member is required.
        public var entityId: Swift.String?
        /// The name of the entity.
        /// This member is required.
        public var entityName: Swift.String?
        /// An eventual Boolean value that specifies whether the entity has child entities or not.
        public var hasChildEntities: Swift.Bool?
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The current status of the entity.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The last date and time when the entity was updated.
        /// This member is required.
        public var updateDateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            entityId: Swift.String? = nil,
            entityName: Swift.String? = nil,
            hasChildEntities: Swift.Bool? = nil,
            parentEntityId: Swift.String? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            updateDateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.entityId = entityId
            self.entityName = entityName
            self.hasChildEntities = hasChildEntities
            self.parentEntityId = parentEntityId
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }
}

public struct ListEntitiesOutput: Swift.Sendable {
    /// A list of objects that contain information about the entities.
    public var entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        entitySummaries: [IoTTwinMakerClientTypes.EntitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitySummaries = entitySummaries
        self.nextToken = nextToken
    }
}

extension IoTTwinMakerClientTypes {

    /// The ListMetadataTransferJobs filter.
    public enum ListMetadataTransferJobsFilter: Swift.Sendable {
        /// The workspace Id.
        case workspaceid(Swift.String)
        /// The filter state.
        case state(IoTTwinMakerClientTypes.MetadataTransferJobState)
        case sdkUnknown(Swift.String)
    }
}

public struct ListMetadataTransferJobsInput: Swift.Sendable {
    /// The metadata transfer job's destination type.
    /// This member is required.
    public var destinationType: IoTTwinMakerClientTypes.DestinationType?
    /// An object that filters metadata transfer jobs.
    public var filters: [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]?
    /// The maximum number of results to return at one time.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The metadata transfer job's source type.
    /// This member is required.
    public var sourceType: IoTTwinMakerClientTypes.SourceType?

    public init(
        destinationType: IoTTwinMakerClientTypes.DestinationType? = nil,
        filters: [IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sourceType: IoTTwinMakerClientTypes.SourceType? = nil
    )
    {
        self.destinationType = destinationType
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceType = sourceType
    }
}

extension IoTTwinMakerClientTypes {

    /// The metadata transfer job summary.
    public struct MetadataTransferJobSummary: Swift.Sendable {
        /// The metadata transfer job summary ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// The metadata transfer job summary creation DateTime object.
        /// This member is required.
        public var creationDateTime: Foundation.Date?
        /// The metadata transfer job summary Id.
        /// This member is required.
        public var metadataTransferJobId: Swift.String?
        /// The metadata transfer job summary progess.
        public var progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress?
        /// The metadata transfer job summary status.
        /// This member is required.
        public var status: IoTTwinMakerClientTypes.MetadataTransferJobStatus?
        /// The metadata transfer job summary update DateTime object
        /// This member is required.
        public var updateDateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            metadataTransferJobId: Swift.String? = nil,
            progress: IoTTwinMakerClientTypes.MetadataTransferJobProgress? = nil,
            status: IoTTwinMakerClientTypes.MetadataTransferJobStatus? = nil,
            updateDateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.metadataTransferJobId = metadataTransferJobId
            self.progress = progress
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }
}

public struct ListMetadataTransferJobsOutput: Swift.Sendable {
    /// The metadata transfer job summaries.
    /// This member is required.
    public var metadataTransferJobSummaries: [IoTTwinMakerClientTypes.MetadataTransferJobSummary]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        metadataTransferJobSummaries: [IoTTwinMakerClientTypes.MetadataTransferJobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.metadataTransferJobSummaries = metadataTransferJobSummaries
        self.nextToken = nextToken
    }
}

public struct ListPropertiesInput: Swift.Sendable {
    /// The name of the component whose properties are returned by the operation.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID for the entity whose metadata (component/properties) is returned by the operation.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results returned at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The workspace ID.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

public struct ListScenesInput: Swift.Sendable {
    /// Specifies the maximum number of results to display.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the scenes.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about a scene.
    public struct SceneSummary: Swift.Sendable {
        /// The ARN of the scene.
        /// This member is required.
        public var arn: Swift.String?
        /// The relative path that specifies the location of the content definition file.
        /// This member is required.
        public var contentLocation: Swift.String?
        /// The date and time when the scene was created.
        /// This member is required.
        public var creationDateTime: Foundation.Date?
        /// The scene description.
        public var description: Swift.String?
        /// The ID of the scene.
        /// This member is required.
        public var sceneId: Swift.String?
        /// The date and time when the scene was last updated.
        /// This member is required.
        public var updateDateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            contentLocation: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            sceneId: Swift.String? = nil,
            updateDateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.contentLocation = contentLocation
            self.creationDateTime = creationDateTime
            self.description = description
            self.sceneId = sceneId
            self.updateDateTime = updateDateTime
        }
    }
}

public struct ListScenesOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the scenes.
    public var sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]?

    public init(
        nextToken: Swift.String? = nil,
        sceneSummaries: [IoTTwinMakerClientTypes.SceneSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.sceneSummaries = sceneSummaries
    }
}

public struct ListSyncJobsInput: Swift.Sendable {
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// The SyncJob summary.
    public struct SyncJobSummary: Swift.Sendable {
        /// The SyncJob summary ARN.
        public var arn: Swift.String?
        /// The creation date and time.
        public var creationDateTime: Foundation.Date?
        /// The SyncJob summaries status.
        public var status: IoTTwinMakerClientTypes.SyncJobStatus?
        /// The sync source.
        public var syncSource: Swift.String?
        /// The update date and time.
        public var updateDateTime: Foundation.Date?
        /// The ID of the workspace that contains the sync job.
        public var workspaceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            status: IoTTwinMakerClientTypes.SyncJobStatus? = nil,
            syncSource: Swift.String? = nil,
            updateDateTime: Foundation.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.status = status
            self.syncSource = syncSource
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }
}

public struct ListSyncJobsOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The listed SyncJob summaries.
    public var syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        syncJobSummaries: [IoTTwinMakerClientTypes.SyncJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncJobSummaries = syncJobSummaries
    }
}

extension IoTTwinMakerClientTypes {

    public enum SyncResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case componentType
        case entity
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceType] {
            return [
                .componentType,
                .entity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .componentType: return "COMPONENT_TYPE"
            case .entity: return "ENTITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum SyncResourceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleted
        case error
        case initializing
        case inSync
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncResourceState] {
            return [
                .deleted,
                .error,
                .initializing,
                .inSync,
                .processing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .error: return "ERROR"
            case .initializing: return "INITIALIZING"
            case .inSync: return "IN_SYNC"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The sync resource filter.
    public enum SyncResourceFilter: Swift.Sendable {
        /// The sync resource filter's state.
        case state(IoTTwinMakerClientTypes.SyncResourceState)
        /// The sync resource filter resource type
        case resourcetype(IoTTwinMakerClientTypes.SyncResourceType)
        /// The sync resource filter resource ID.
        case resourceid(Swift.String)
        /// The external ID.
        case externalid(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

public struct ListSyncResourcesInput: Swift.Sendable {
    /// A list of objects that filter the request. The following filter combinations are supported:
    ///
    /// * Filter with state
    ///
    /// * Filter with ResourceType and ResourceId
    ///
    /// * Filter with ResourceType and ExternalId
    public var filters: [IoTTwinMakerClientTypes.SyncResourceFilter]?
    /// The maximum number of results to return at one time. The default is 50. Valid Range: Minimum value of 0. Maximum value of 200.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync source. Currently the only supported syncSource is SITEWISE .
    /// This member is required.
    public var syncSource: Swift.String?
    /// The ID of the workspace that contains the sync job.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        filters: [IoTTwinMakerClientTypes.SyncResourceFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        syncSource: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.syncSource = syncSource
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// The sync resource status.
    public struct SyncResourceStatus: Swift.Sendable {
        /// The status error.
        public var error: IoTTwinMakerClientTypes.ErrorDetails?
        /// The sync resource status state.
        public var state: IoTTwinMakerClientTypes.SyncResourceState?

        public init(
            error: IoTTwinMakerClientTypes.ErrorDetails? = nil,
            state: IoTTwinMakerClientTypes.SyncResourceState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The sync resource summary.
    public struct SyncResourceSummary: Swift.Sendable {
        /// The external ID.
        public var externalId: Swift.String?
        /// The resource ID.
        public var resourceId: Swift.String?
        /// The resource type.
        public var resourceType: IoTTwinMakerClientTypes.SyncResourceType?
        /// The sync resource summary status.
        public var status: IoTTwinMakerClientTypes.SyncResourceStatus?
        /// The update date and time.
        public var updateDateTime: Foundation.Date?

        public init(
            externalId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: IoTTwinMakerClientTypes.SyncResourceType? = nil,
            status: IoTTwinMakerClientTypes.SyncResourceStatus? = nil,
            updateDateTime: Foundation.Date? = nil
        )
        {
            self.externalId = externalId
            self.resourceId = resourceId
            self.resourceType = resourceType
            self.status = status
            self.updateDateTime = updateDateTime
        }
    }
}

public struct ListSyncResourcesOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The sync resources.
    public var syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        syncResources: [IoTTwinMakerClientTypes.SyncResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.syncResources = syncResources
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Metadata that you can use to manage a resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListWorkspacesInput: Swift.Sendable {
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about a workspace.
    public struct WorkspaceSummary: Swift.Sendable {
        /// The ARN of the workspace.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the workspace was created.
        /// This member is required.
        public var creationDateTime: Foundation.Date?
        /// The description of the workspace.
        public var description: Swift.String?
        /// A list of services that are linked to the workspace.
        public var linkedServices: [Swift.String]?
        /// The date and time when the workspace was last updated.
        /// This member is required.
        public var updateDateTime: Foundation.Date?
        /// The ID of the workspace.
        /// This member is required.
        public var workspaceId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            linkedServices: [Swift.String]? = nil,
            updateDateTime: Foundation.Date? = nil,
            workspaceId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.linkedServices = linkedServices
            self.updateDateTime = updateDateTime
            self.workspaceId = workspaceId
        }
    }
}

public struct ListWorkspacesOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the workspaces.
    public var workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceSummaries: [IoTTwinMakerClientTypes.WorkspaceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.workspaceSummaries = workspaceSummaries
    }
}

/// The number of tags exceeds the limit.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Metadata to add to this resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tag key names to remove from the resource. You don't specify the value. Both the key and its associated value are removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateComponentTypeOutput: Swift.Sendable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The current state of the component type.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        state: IoTTwinMakerClientTypes.State? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.state = state
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    public enum ComponentUpdateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentUpdateType] {
            return [
                .create,
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    public enum ParentEntityUpdateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [ParentEntityUpdateType] {
            return [
                .delete,
                .update
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The parent entity update request.
    public struct ParentEntityUpdateRequest: Swift.Sendable {
        /// The ID of the parent entity.
        public var parentEntityId: Swift.String?
        /// The type of the update.
        /// This member is required.
        public var updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType?

        public init(
            parentEntityId: Swift.String? = nil,
            updateType: IoTTwinMakerClientTypes.ParentEntityUpdateType? = nil
        )
        {
            self.parentEntityId = parentEntityId
            self.updateType = updateType
        }
    }
}

public struct UpdateEntityOutput: Swift.Sendable {
    /// The current state of the entity update.
    /// This member is required.
    public var state: IoTTwinMakerClientTypes.State?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?

    public init(
        state: IoTTwinMakerClientTypes.State? = nil,
        updateDateTime: Foundation.Date? = nil
    )
    {
        self.state = state
        self.updateDateTime = updateDateTime
    }
}

public struct UpdatePricingPlanInput: Swift.Sendable {
    /// The bundle names.
    public var bundleNames: [Swift.String]?
    /// The pricing mode.
    /// This member is required.
    public var pricingMode: IoTTwinMakerClientTypes.PricingMode?

    public init(
        bundleNames: [Swift.String]? = nil,
        pricingMode: IoTTwinMakerClientTypes.PricingMode? = nil
    )
    {
        self.bundleNames = bundleNames
        self.pricingMode = pricingMode
    }
}

public struct UpdatePricingPlanOutput: Swift.Sendable {
    /// Update the current pricing plan.
    /// This member is required.
    public var currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan?
    /// Update the pending pricing plan.
    public var pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan?

    public init(
        currentPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil,
        pendingPricingPlan: IoTTwinMakerClientTypes.PricingPlan? = nil
    )
    {
        self.currentPricingPlan = currentPricingPlan
        self.pendingPricingPlan = pendingPricingPlan
    }
}

public struct UpdateSceneInput: Swift.Sendable {
    /// A list of capabilities that the scene uses to render.
    public var capabilities: [Swift.String]?
    /// The relative path that specifies the location of the content definition file.
    public var contentLocation: Swift.String?
    /// The description of this scene.
    public var description: Swift.String?
    /// The ID of the scene.
    /// This member is required.
    public var sceneId: Swift.String?
    /// The scene metadata.
    public var sceneMetadata: [Swift.String: Swift.String]?
    /// The ID of the workspace that contains the scene.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        contentLocation: Swift.String? = nil,
        description: Swift.String? = nil,
        sceneId: Swift.String? = nil,
        sceneMetadata: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.contentLocation = contentLocation
        self.description = description
        self.sceneId = sceneId
        self.sceneMetadata = sceneMetadata
        self.workspaceId = workspaceId
    }
}

public struct UpdateSceneOutput: Swift.Sendable {
    /// The date and time when the scene was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?

    public init(
        updateDateTime: Foundation.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

public struct UpdateWorkspaceInput: Swift.Sendable {
    /// The description of the workspace.
    public var description: Swift.String?
    /// The ARN of the execution role associated with the workspace.
    public var role: Swift.String?
    /// The ARN of the S3 bucket where resources associated with the workspace are stored.
    public var s3Location: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        description: Swift.String? = nil,
        role: Swift.String? = nil,
        s3Location: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.description = description
        self.role = role
        self.s3Location = s3Location
        self.workspaceId = workspaceId
    }
}

public struct UpdateWorkspaceOutput: Swift.Sendable {
    /// The date and time of the current update.
    /// This member is required.
    public var updateDateTime: Foundation.Date?

    public init(
        updateDateTime: Foundation.Date? = nil
    )
    {
        self.updateDateTime = updateDateTime
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that specifies a value for a property.
    public struct DataValue: Swift.Sendable {
        /// A Boolean value.
        public var booleanValue: Swift.Bool?
        /// A double value.
        public var doubleValue: Swift.Double?
        /// An expression that produces the value.
        public var expression: Swift.String?
        /// An integer value.
        public var integerValue: Swift.Int?
        /// A list of multiple values.
        public var listValue: [IoTTwinMakerClientTypes.DataValue]?
        /// A long value.
        public var longValue: Swift.Int?
        /// An object that maps strings to multiple DataValue objects.
        public var mapValue: [Swift.String: IoTTwinMakerClientTypes.DataValue]?
        /// A value that relates a component to another component.
        public var relationshipValue: IoTTwinMakerClientTypes.RelationshipValue?
        /// A string value.
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            expression: Swift.String? = nil,
            integerValue: Swift.Int? = nil,
            listValue: [IoTTwinMakerClientTypes.DataValue]? = nil,
            longValue: Swift.Int? = nil,
            mapValue: [Swift.String: IoTTwinMakerClientTypes.DataValue]? = nil,
            relationshipValue: IoTTwinMakerClientTypes.RelationshipValue? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.expression = expression
            self.integerValue = integerValue
            self.listValue = listValue
            self.longValue = longValue
            self.mapValue = mapValue
            self.relationshipValue = relationshipValue
            self.stringValue = stringValue
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that filters items returned by a property request.
    public struct PropertyFilter: Swift.Sendable {
        /// The operator associated with this property filter.
        public var `operator`: Swift.String?
        /// The property name associated with this property filter.
        public var propertyName: Swift.String?
        /// The value associated with this property filter.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            `operator`: Swift.String? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.`operator` = `operator`
            self.propertyName = propertyName
            self.value = value
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The latest value of the property.
    public struct PropertyLatestValue: Swift.Sendable {
        /// An object that specifies information about a property.
        /// This member is required.
        public var propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// The value of the property.
        public var propertyValue: IoTTwinMakerClientTypes.DataValue?

        public init(
            propertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValue: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.propertyReference = propertyReference
            self.propertyValue = propertyValue
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about a value for a time series property.
    public struct PropertyValue: Swift.Sendable {
        /// ISO8601 DateTime of a value for a time series property. The time for when the property value was recorded in ISO 8601 format: YYYY-MM-DDThh:mm:ss[.SSSSSSSSS][Z/±HH:mm].
        ///
        /// * [YYYY]: year
        ///
        /// * [MM]: month
        ///
        /// * [DD]: day
        ///
        /// * [hh]: hour
        ///
        /// * [mm]: minute
        ///
        /// * [ss]: seconds
        ///
        /// * [.SSSSSSSSS]: additional precision, where precedence is maintained. For example: [.573123] is equal to 573123000 nanoseconds.
        ///
        /// * Z: default timezone UTC
        ///
        /// * ± HH:mm: time zone offset in Hours and Minutes.
        ///
        ///
        /// Required sub-fields: YYYY-MM-DDThh:mm:ss and [Z/±HH:mm]
        public var time: Swift.String?
        /// The timestamp of a value for a time series property.
        @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use time instead.")
        public var timestamp: Foundation.Date?
        /// An object that specifies a value for a time series property.
        /// This member is required.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            time: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.time = time
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that specifies the data type of a property.
    public struct DataType: Swift.Sendable {
        /// The allowed values for this data type.
        public var allowedValues: [IoTTwinMakerClientTypes.DataValue]?
        /// The nested type in the data type.
        @Indirect public var nestedType: IoTTwinMakerClientTypes.DataType?
        /// A relationship that associates a component with another component.
        public var relationship: IoTTwinMakerClientTypes.Relationship?
        /// The underlying type of the data type.
        /// This member is required.
        public var type: IoTTwinMakerClientTypes.ModelType?
        /// The unit of measure used in this data type.
        public var unitOfMeasure: Swift.String?

        public init(
            allowedValues: [IoTTwinMakerClientTypes.DataValue]? = nil,
            nestedType: IoTTwinMakerClientTypes.DataType? = nil,
            relationship: IoTTwinMakerClientTypes.Relationship? = nil,
            type: IoTTwinMakerClientTypes.ModelType? = nil,
            unitOfMeasure: Swift.String? = nil
        )
        {
            self.allowedValues = allowedValues
            self.nestedType = nestedType
            self.relationship = relationship
            self.type = type
            self.unitOfMeasure = unitOfMeasure
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that specifies information about time series property values. This object is used and consumed by the [BatchPutPropertyValues](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_BatchPutPropertyValues.html) action.
    public struct PropertyValueEntry: Swift.Sendable {
        /// An object that contains information about the entity that has the property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that specify time series property values.
        public var propertyValues: [IoTTwinMakerClientTypes.PropertyValue]?

        public init(
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            propertyValues: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.propertyValues = propertyValues
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The history of values for a time series property.
    public struct PropertyValueHistory: Swift.Sendable {
        /// An object that uniquely identifies an entity property.
        /// This member is required.
        public var entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference?
        /// A list of objects that contain information about the values in the history of a time series property.
        public var values: [IoTTwinMakerClientTypes.PropertyValue]?

        public init(
            entityPropertyReference: IoTTwinMakerClientTypes.EntityPropertyReference? = nil,
            values: [IoTTwinMakerClientTypes.PropertyValue]? = nil
        )
        {
            self.entityPropertyReference = entityPropertyReference
            self.values = values
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The tabular conditions.
    public struct TabularConditions: Swift.Sendable {
        /// Filter criteria that orders the output. It can be sorted in ascending or descending order.
        public var orderBy: [IoTTwinMakerClientTypes.OrderBy]?
        /// You can filter the request using various logical operators and a key-value format. For example: {"key": "serverType", "value": "webServer"}
        public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?

        public init(
            orderBy: [IoTTwinMakerClientTypes.OrderBy]? = nil,
            propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil
        )
        {
            self.orderBy = orderBy
            self.propertyFilters = propertyFilters
        }
    }
}

public struct GetPropertyValueHistoryInput: Swift.Sendable {
    /// The name of the component.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID of the component type.
    public var componentTypeId: Swift.String?
    /// The date and time of the latest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use endTime instead.")
    public var endDateTime: Foundation.Date?
    /// The ISO8601 DateTime of the latest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var endTime: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// An object that specifies the interpolation type and the interval over which to interpolate data.
    public var interpolation: IoTTwinMakerClientTypes.InterpolationParameters?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The time direction to use in the result order.
    public var orderByTime: IoTTwinMakerClientTypes.OrderByTime?
    /// A list of objects that filter the property value history request.
    public var propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]?
    /// A list of properties whose value histories the request retrieves.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The date and time of the earliest property value to return.
    @available(*, deprecated, message: "This field is deprecated and will throw an error in the future. Use startTime instead.")
    public var startDateTime: Foundation.Date?
    /// The ISO8601 DateTime of the earliest property value to return. For more information about the ISO8601 DateTime format, see the data type [PropertyValue](https://docs.aws.amazon.com/iot-twinmaker/latest/apireference/API_PropertyValue.html).
    public var startTime: Swift.String?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        endDateTime: Foundation.Date? = nil,
        endTime: Swift.String? = nil,
        entityId: Swift.String? = nil,
        interpolation: IoTTwinMakerClientTypes.InterpolationParameters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderByTime: IoTTwinMakerClientTypes.OrderByTime? = nil,
        propertyFilters: [IoTTwinMakerClientTypes.PropertyFilter]? = nil,
        selectedProperties: [Swift.String]? = nil,
        startDateTime: Foundation.Date? = nil,
        startTime: Swift.String? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.componentTypeId = componentTypeId
        self.endDateTime = endDateTime
        self.endTime = endTime
        self.entityId = entityId
        self.interpolation = interpolation
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderByTime = orderByTime
        self.propertyFilters = propertyFilters
        self.selectedProperties = selectedProperties
        self.startDateTime = startDateTime
        self.startTime = startTime
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An error returned by the BatchPutProperty action.
    public struct BatchPutPropertyError: Swift.Sendable {
        /// An object that contains information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var entry: IoTTwinMakerClientTypes.PropertyValueEntry?
        /// The error code.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entry: IoTTwinMakerClientTypes.PropertyValueEntry? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entry = entry
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

public struct GetPropertyValueInput: Swift.Sendable {
    /// The name of the component whose property values the operation returns.
    public var componentName: Swift.String?
    /// This string specifies the path to the composite component, starting from the top-level component.
    public var componentPath: Swift.String?
    /// The ID of the component type whose property values the operation returns.
    public var componentTypeId: Swift.String?
    /// The ID of the entity whose property values the operation returns.
    public var entityId: Swift.String?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The property group name.
    public var propertyGroupName: Swift.String?
    /// The properties whose values the operation returns.
    /// This member is required.
    public var selectedProperties: [Swift.String]?
    /// The tabular conditions.
    public var tabularConditions: IoTTwinMakerClientTypes.TabularConditions?
    /// The ID of the workspace whose values the operation returns.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentName: Swift.String? = nil,
        componentPath: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyGroupName: Swift.String? = nil,
        selectedProperties: [Swift.String]? = nil,
        tabularConditions: IoTTwinMakerClientTypes.TabularConditions? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentName = componentName
        self.componentPath = componentPath
        self.componentTypeId = componentTypeId
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyGroupName = propertyGroupName
        self.selectedProperties = selectedProperties
        self.tabularConditions = tabularConditions
        self.workspaceId = workspaceId
    }
}

public struct BatchPutPropertyValuesInput: Swift.Sendable {
    /// An object that maps strings to the property value entries to set. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var entries: [IoTTwinMakerClientTypes.PropertyValueEntry]?
    /// The ID of the workspace that contains the properties to set.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        entries: [IoTTwinMakerClientTypes.PropertyValueEntry]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.entries = entries
        self.workspaceId = workspaceId
    }
}

public struct GetPropertyValueHistoryOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    /// This member is required.
    public var propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]?

    public init(
        nextToken: Swift.String? = nil,
        propertyValues: [IoTTwinMakerClientTypes.PropertyValueHistory]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about errors returned by the BatchPutProperty action.
    public struct BatchPutPropertyErrorEntry: Swift.Sendable {
        /// A list of objects that contain information about errors returned by the BatchPutProperty action.
        /// This member is required.
        public var errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]?

        public init(
            errors: [IoTTwinMakerClientTypes.BatchPutPropertyError]? = nil
        )
        {
            self.errors = errors
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about a property.
    public struct PropertyDefinitionRequest: Swift.Sendable {
        /// A mapping that specifies configuration information about the property. Use this field to specify information that you read from and write to an external source.
        public var configuration: [Swift.String: Swift.String]?
        /// An object that contains information about the data type.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        public var isTimeSeries: Swift.Bool?

        public init(
            configuration: [Swift.String: Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains response data from a property definition request.
    public struct PropertyDefinitionResponse: Swift.Sendable {
        /// A mapping that specifies configuration information about the property.
        public var configuration: [Swift.String: Swift.String]?
        /// An object that contains information about the data type.
        /// This member is required.
        public var dataType: IoTTwinMakerClientTypes.DataType?
        /// An object that contains the default value.
        public var defaultValue: IoTTwinMakerClientTypes.DataValue?
        /// A friendly name for the property.
        public var displayName: Swift.String?
        /// A Boolean value that specifies whether the property ID comes from an external data store.
        /// This member is required.
        public var isExternalId: Swift.Bool?
        /// A Boolean value that specifies whether the property definition can be updated.
        /// This member is required.
        public var isFinal: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is imported from an external data store.
        /// This member is required.
        public var isImported: Swift.Bool?
        /// A Boolean value that specifies whether the property definition is inherited from a parent entity.
        /// This member is required.
        public var isInherited: Swift.Bool?
        /// A Boolean value that specifies whether the property is required in an entity.
        /// This member is required.
        public var isRequiredInEntity: Swift.Bool?
        /// A Boolean value that specifies whether the property is stored externally.
        /// This member is required.
        public var isStoredExternally: Swift.Bool?
        /// A Boolean value that specifies whether the property consists of time series data.
        /// This member is required.
        public var isTimeSeries: Swift.Bool?

        public init(
            configuration: [Swift.String: Swift.String]? = nil,
            dataType: IoTTwinMakerClientTypes.DataType? = nil,
            defaultValue: IoTTwinMakerClientTypes.DataValue? = nil,
            displayName: Swift.String? = nil,
            isExternalId: Swift.Bool? = nil,
            isFinal: Swift.Bool? = nil,
            isImported: Swift.Bool? = nil,
            isInherited: Swift.Bool? = nil,
            isRequiredInEntity: Swift.Bool? = nil,
            isStoredExternally: Swift.Bool? = nil,
            isTimeSeries: Swift.Bool? = nil
        )
        {
            self.configuration = configuration
            self.dataType = dataType
            self.defaultValue = defaultValue
            self.displayName = displayName
            self.isExternalId = isExternalId
            self.isFinal = isFinal
            self.isImported = isImported
            self.isInherited = isInherited
            self.isRequiredInEntity = isRequiredInEntity
            self.isStoredExternally = isStoredExternally
            self.isTimeSeries = isTimeSeries
        }
    }
}

public struct BatchPutPropertyValuesOutput: Swift.Sendable {
    /// Entries that caused errors in the batch put operation.
    /// This member is required.
    public var errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]?

    public init(
        errorEntries: [IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

public struct GetPropertyValueOutput: Swift.Sendable {
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// An object that maps strings to the properties and latest property values in the response. Each string in the mapping must be unique to this object.
    public var propertyValues: [Swift.String: IoTTwinMakerClientTypes.PropertyLatestValue]?
    /// A table of property values.
    public var tabularPropertyValues: [[[Swift.String: IoTTwinMakerClientTypes.DataValue]]]?

    public init(
        nextToken: Swift.String? = nil,
        propertyValues: [Swift.String: IoTTwinMakerClientTypes.PropertyLatestValue]? = nil,
        tabularPropertyValues: [[[Swift.String: IoTTwinMakerClientTypes.DataValue]]]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertyValues = propertyValues
        self.tabularPropertyValues = tabularPropertyValues
    }
}

public struct CreateComponentTypeInput: Swift.Sendable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// A friendly name for the component type.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the parent component type to extend.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String: IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    ///
    public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// Metadata that you can use to manage the component type.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String: IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

public struct GetComponentTypeOutput: Swift.Sendable {
    /// The ARN of the component type.
    /// This member is required.
    public var arn: Swift.String?
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeResponse]?
    /// The date and time when the component type was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The description of the component type.
    public var description: Swift.String?
    /// The name of the parent component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String: IoTTwinMakerClientTypes.FunctionResponse]?
    /// A Boolean value that specifies whether the component type is abstract.
    public var isAbstract: Swift.Bool?
    /// A Boolean value that specifies whether the component type has a schema initializer and that the schema initializer has run.
    public var isSchemaInitialized: Swift.Bool?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionResponse]?
    /// The maximum number of results to return at one time. The default is 25. Valid Range: Minimum value of 1. Maximum value of 250.
    public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupResponse]?
    /// The current status of the component type.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the SyncJob, if this entity was created by a SyncJob.
    public var syncSource: Swift.String?
    /// The date and time when the component was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?
    /// The ID of the workspace that contains the component type.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeResponse]? = nil,
        creationDateTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String: IoTTwinMakerClientTypes.FunctionResponse]? = nil,
        isAbstract: Swift.Bool? = nil,
        isSchemaInitialized: Swift.Bool? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionResponse]? = nil,
        propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupResponse]? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: Foundation.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.creationDateTime = creationDateTime
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isAbstract = isAbstract
        self.isSchemaInitialized = isSchemaInitialized
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

public struct UpdateComponentTypeInput: Swift.Sendable {
    /// The ID of the component type.
    /// This member is required.
    public var componentTypeId: Swift.String?
    /// The component type name.
    public var componentTypeName: Swift.String?
    /// This is an object that maps strings to compositeComponentTypes of the componentType. CompositeComponentType is referenced by componentTypeId.
    public var compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest]?
    /// The description of the component type.
    public var description: Swift.String?
    /// Specifies the component type that this component type extends.
    public var extendsFrom: [Swift.String]?
    /// An object that maps strings to the functions in the component type. Each string in the mapping must be unique to this object.
    public var functions: [Swift.String: IoTTwinMakerClientTypes.FunctionRequest]?
    /// A Boolean value that specifies whether an entity can have more than one component of this type.
    public var isSingleton: Swift.Bool?
    /// An object that maps strings to the property definitions in the component type. Each string in the mapping must be unique to this object.
    public var propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest]?
    /// The property groups.
    public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest]?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentTypeId: Swift.String? = nil,
        componentTypeName: Swift.String? = nil,
        compositeComponentTypes: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentTypeRequest]? = nil,
        description: Swift.String? = nil,
        extendsFrom: [Swift.String]? = nil,
        functions: [Swift.String: IoTTwinMakerClientTypes.FunctionRequest]? = nil,
        isSingleton: Swift.Bool? = nil,
        propertyDefinitions: [Swift.String: IoTTwinMakerClientTypes.PropertyDefinitionRequest]? = nil,
        propertyGroups: [Swift.String: IoTTwinMakerClientTypes.PropertyGroupRequest]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentTypeId = componentTypeId
        self.componentTypeName = componentTypeName
        self.compositeComponentTypes = compositeComponentTypes
        self.description = description
        self.extendsFrom = extendsFrom
        self.functions = functions
        self.isSingleton = isSingleton
        self.propertyDefinitions = propertyDefinitions
        self.propertyGroups = propertyGroups
        self.workspaceId = workspaceId
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about a property.
    public struct PropertyRequest: Swift.Sendable {
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest?
        /// The update type of the update property request.
        public var updateType: IoTTwinMakerClientTypes.PropertyUpdateType?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            definition: IoTTwinMakerClientTypes.PropertyDefinitionRequest? = nil,
            updateType: IoTTwinMakerClientTypes.PropertyUpdateType? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.definition = definition
            self.updateType = updateType
            self.value = value
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that contains information about a property response.
    public struct PropertyResponse: Swift.Sendable {
        /// This flag notes whether all values of a list or map type property are returned in the API response. The maximum number of values per property returned is 50.
        public var areAllPropertyValuesReturned: Swift.Bool?
        /// An object that specifies information about a property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// The value of the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            areAllPropertyValuesReturned: Swift.Bool? = nil,
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.value = value
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// This is an object that contains the information of a property.
    public struct PropertySummary: Swift.Sendable {
        /// This flag notes whether all values of a list or map type property are returned in the API response. The maximum number of values per property returned is 50.
        public var areAllPropertyValuesReturned: Swift.Bool?
        /// This is the schema for the property.
        public var definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse?
        /// This is the name of the property.
        /// This member is required.
        public var propertyName: Swift.String?
        /// This is the value for the property.
        public var value: IoTTwinMakerClientTypes.DataValue?

        public init(
            areAllPropertyValuesReturned: Swift.Bool? = nil,
            definition: IoTTwinMakerClientTypes.PropertyDefinitionResponse? = nil,
            propertyName: Swift.String? = nil,
            value: IoTTwinMakerClientTypes.DataValue? = nil
        )
        {
            self.areAllPropertyValuesReturned = areAllPropertyValuesReturned
            self.definition = definition
            self.propertyName = propertyName
            self.value = value
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about a component type create or update request.
    public struct ComponentRequest: Swift.Sendable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component request.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]?
        /// The property groups.
        public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?

        public init(
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that returns information about a component type create or update request.
    public struct ComponentResponse: Swift.Sendable {
        /// This flag notes whether all compositeComponents are returned in the API response.
        public var areAllCompositeComponentsReturned: Swift.Bool?
        /// This flag notes whether all properties of the component are returned in the API response. The maximum number of properties returned is 800.
        public var areAllPropertiesReturned: Swift.Bool?
        /// The name of the component.
        public var componentName: Swift.String?
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// This lists objects that contain information about the compositeComponents.
        public var compositeComponents: [Swift.String: IoTTwinMakerClientTypes.ComponentSummary]?
        /// The name of the property definition set in the request.
        public var definedIn: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// An object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String: IoTTwinMakerClientTypes.PropertyResponse]?
        /// The property groups.
        public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]?
        /// The status of the component type.
        public var status: IoTTwinMakerClientTypes.Status?
        /// The syncSource of the sync job, if this entity was created by a sync job.
        public var syncSource: Swift.String?

        public init(
            areAllCompositeComponentsReturned: Swift.Bool? = nil,
            areAllPropertiesReturned: Swift.Bool? = nil,
            componentName: Swift.String? = nil,
            componentTypeId: Swift.String? = nil,
            compositeComponents: [Swift.String: IoTTwinMakerClientTypes.ComponentSummary]? = nil,
            definedIn: Swift.String? = nil,
            description: Swift.String? = nil,
            properties: [Swift.String: IoTTwinMakerClientTypes.PropertyResponse]? = nil,
            propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse]? = nil,
            status: IoTTwinMakerClientTypes.Status? = nil,
            syncSource: Swift.String? = nil
        )
        {
            self.areAllCompositeComponentsReturned = areAllCompositeComponentsReturned
            self.areAllPropertiesReturned = areAllPropertiesReturned
            self.componentName = componentName
            self.componentTypeId = componentTypeId
            self.compositeComponents = compositeComponents
            self.definedIn = definedIn
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
            self.status = status
            self.syncSource = syncSource
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// The component update request.
    public struct ComponentUpdateRequest: Swift.Sendable {
        /// The ID of the component type.
        public var componentTypeId: Swift.String?
        /// The description of the component type.
        public var description: Swift.String?
        /// The property group updates.
        public var propertyGroupUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init(
            componentTypeId: Swift.String? = nil,
            description: Swift.String? = nil,
            propertyGroupUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil,
            propertyUpdates: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.componentTypeId = componentTypeId
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about the composite component update request.
    public struct CompositeComponentRequest: Swift.Sendable {
        /// The description of the component type.
        public var description: Swift.String?
        /// This is an object that maps strings to the properties to set in the component type. Each string in the mapping must be unique to this object.
        public var properties: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]?
        /// The property groups.
        public var propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?

        public init(
            description: Swift.String? = nil,
            properties: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            propertyGroups: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil
        )
        {
            self.description = description
            self.properties = properties
            self.propertyGroups = propertyGroups
        }
    }
}

extension IoTTwinMakerClientTypes {

    /// An object that sets information about the composite component update request.
    public struct CompositeComponentUpdateRequest: Swift.Sendable {
        /// The description of the component type.
        public var description: Swift.String?
        /// The property group updates.
        public var propertyGroupUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]?
        /// An object that maps strings to the properties to set in the component type update. Each string in the mapping must be unique to this object.
        public var propertyUpdates: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]?
        /// The update type of the component update request.
        public var updateType: IoTTwinMakerClientTypes.ComponentUpdateType?

        public init(
            description: Swift.String? = nil,
            propertyGroupUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest]? = nil,
            propertyUpdates: [Swift.String: IoTTwinMakerClientTypes.PropertyRequest]? = nil,
            updateType: IoTTwinMakerClientTypes.ComponentUpdateType? = nil
        )
        {
            self.description = description
            self.propertyGroupUpdates = propertyGroupUpdates
            self.propertyUpdates = propertyUpdates
            self.updateType = updateType
        }
    }
}

public struct ListPropertiesOutput: Swift.Sendable {
    /// The string that specifies the next page of property results.
    public var nextToken: Swift.String?
    /// A list of objects that contain information about the properties.
    /// This member is required.
    public var propertySummaries: [IoTTwinMakerClientTypes.PropertySummary]?

    public init(
        nextToken: Swift.String? = nil,
        propertySummaries: [IoTTwinMakerClientTypes.PropertySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.propertySummaries = propertySummaries
    }
}

public struct GetEntityOutput: Swift.Sendable {
    /// This flag notes whether all components are returned in the API response. The maximum number of components returned is 30.
    public var areAllComponentsReturned: Swift.Bool?
    /// The ARN of the entity.
    /// This member is required.
    public var arn: Swift.String?
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String: IoTTwinMakerClientTypes.ComponentResponse]?
    /// The date and time when the entity was created.
    /// This member is required.
    public var creationDateTime: Foundation.Date?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// A Boolean value that specifies whether the entity has associated child entities.
    /// This member is required.
    public var hasChildEntities: Swift.Bool?
    /// The ID of the parent entity for this entity.
    /// This member is required.
    public var parentEntityId: Swift.String?
    /// The current status of the entity.
    /// This member is required.
    public var status: IoTTwinMakerClientTypes.Status?
    /// The syncSource of the sync job, if this entity was created by a sync job.
    public var syncSource: Swift.String?
    /// The date and time when the entity was last updated.
    /// This member is required.
    public var updateDateTime: Foundation.Date?
    /// The ID of the workspace.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        areAllComponentsReturned: Swift.Bool? = nil,
        arn: Swift.String? = nil,
        components: [Swift.String: IoTTwinMakerClientTypes.ComponentResponse]? = nil,
        creationDateTime: Foundation.Date? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        hasChildEntities: Swift.Bool? = nil,
        parentEntityId: Swift.String? = nil,
        status: IoTTwinMakerClientTypes.Status? = nil,
        syncSource: Swift.String? = nil,
        updateDateTime: Foundation.Date? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.areAllComponentsReturned = areAllComponentsReturned
        self.arn = arn
        self.components = components
        self.creationDateTime = creationDateTime
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.hasChildEntities = hasChildEntities
        self.parentEntityId = parentEntityId
        self.status = status
        self.syncSource = syncSource
        self.updateDateTime = updateDateTime
        self.workspaceId = workspaceId
    }
}

public struct CreateEntityInput: Swift.Sendable {
    /// An object that maps strings to the components in the entity. Each string in the mapping must be unique to this object.
    public var components: [Swift.String: IoTTwinMakerClientTypes.ComponentRequest]?
    /// This is an object that maps strings to compositeComponent updates in the request. Each key of the map represents the componentPath of the compositeComponent.
    public var compositeComponents: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    public var entityId: Swift.String?
    /// The name of the entity.
    /// This member is required.
    public var entityName: Swift.String?
    /// The ID of the entity's parent entity.
    public var parentEntityId: Swift.String?
    /// Metadata that you can use to manage the entity.
    public var tags: [Swift.String: Swift.String]?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        components: [Swift.String: IoTTwinMakerClientTypes.ComponentRequest]? = nil,
        compositeComponents: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.components = components
        self.compositeComponents = compositeComponents
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityId = parentEntityId
        self.tags = tags
        self.workspaceId = workspaceId
    }
}

public struct UpdateEntityInput: Swift.Sendable {
    /// An object that maps strings to the component updates in the request. Each string in the mapping must be unique to this object.
    public var componentUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentUpdateRequest]?
    /// This is an object that maps strings to compositeComponent updates in the request. Each key of the map represents the componentPath of the compositeComponent.
    public var compositeComponentUpdates: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]?
    /// The description of the entity.
    public var description: Swift.String?
    /// The ID of the entity.
    /// This member is required.
    public var entityId: Swift.String?
    /// The name of the entity.
    public var entityName: Swift.String?
    /// An object that describes the update request for a parent entity.
    public var parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?
    /// The ID of the workspace that contains the entity.
    /// This member is required.
    public var workspaceId: Swift.String?

    public init(
        componentUpdates: [Swift.String: IoTTwinMakerClientTypes.ComponentUpdateRequest]? = nil,
        compositeComponentUpdates: [Swift.String: IoTTwinMakerClientTypes.CompositeComponentUpdateRequest]? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        entityName: Swift.String? = nil,
        parentEntityUpdate: IoTTwinMakerClientTypes.ParentEntityUpdateRequest? = nil,
        workspaceId: Swift.String? = nil
    )
    {
        self.componentUpdates = componentUpdates
        self.compositeComponentUpdates = compositeComponentUpdates
        self.description = description
        self.entityId = entityId
        self.entityName = entityName
        self.parentEntityUpdate = parentEntityUpdate
        self.workspaceId = workspaceId
    }
}

extension BatchPutPropertyValuesInput {

    static func urlPathProvider(_ value: BatchPutPropertyValuesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties"
    }
}

extension CancelMetadataTransferJobInput {

    static func urlPathProvider(_ value: CancelMetadataTransferJobInput) -> Swift.String? {
        guard let metadataTransferJobId = value.metadataTransferJobId else {
            return nil
        }
        return "/metadata-transfer-jobs/\(metadataTransferJobId.urlPercentEncoding())/cancel"
    }
}

extension CreateComponentTypeInput {

    static func urlPathProvider(_ value: CreateComponentTypeInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let componentTypeId = value.componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

extension CreateEntityInput {

    static func urlPathProvider(_ value: CreateEntityInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities"
    }
}

extension CreateMetadataTransferJobInput {

    static func urlPathProvider(_ value: CreateMetadataTransferJobInput) -> Swift.String? {
        return "/metadata-transfer-jobs"
    }
}

extension CreateSceneInput {

    static func urlPathProvider(_ value: CreateSceneInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes"
    }
}

extension CreateSyncJobInput {

    static func urlPathProvider(_ value: CreateSyncJobInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let syncSource = value.syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

extension CreateWorkspaceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension DeleteComponentTypeInput {

    static func urlPathProvider(_ value: DeleteComponentTypeInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let componentTypeId = value.componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

extension DeleteEntityInput {

    static func urlPathProvider(_ value: DeleteEntityInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let entityId = value.entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

extension DeleteEntityInput {

    static func queryItemProvider(_ value: DeleteEntityInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let isRecursive = value.isRecursive {
            let isRecursiveQueryItem = Smithy.URIQueryItem(name: "isRecursive".urlPercentEncoding(), value: Swift.String(isRecursive).urlPercentEncoding())
            items.append(isRecursiveQueryItem)
        }
        return items
    }
}

extension DeleteSceneInput {

    static func urlPathProvider(_ value: DeleteSceneInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let sceneId = value.sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

extension DeleteSyncJobInput {

    static func urlPathProvider(_ value: DeleteSyncJobInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let syncSource = value.syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

extension DeleteWorkspaceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension ExecuteQueryInput {

    static func urlPathProvider(_ value: ExecuteQueryInput) -> Swift.String? {
        return "/queries/execution"
    }
}

extension GetComponentTypeInput {

    static func urlPathProvider(_ value: GetComponentTypeInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let componentTypeId = value.componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

extension GetEntityInput {

    static func urlPathProvider(_ value: GetEntityInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let entityId = value.entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

extension GetMetadataTransferJobInput {

    static func urlPathProvider(_ value: GetMetadataTransferJobInput) -> Swift.String? {
        guard let metadataTransferJobId = value.metadataTransferJobId else {
            return nil
        }
        return "/metadata-transfer-jobs/\(metadataTransferJobId.urlPercentEncoding())"
    }
}

extension GetPricingPlanInput {

    static func urlPathProvider(_ value: GetPricingPlanInput) -> Swift.String? {
        return "/pricingplan"
    }
}

extension GetPropertyValueInput {

    static func urlPathProvider(_ value: GetPropertyValueInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/value"
    }
}

extension GetPropertyValueHistoryInput {

    static func urlPathProvider(_ value: GetPropertyValueHistoryInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entity-properties/history"
    }
}

extension GetSceneInput {

    static func urlPathProvider(_ value: GetSceneInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let sceneId = value.sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

extension GetSyncJobInput {

    static func urlPathProvider(_ value: GetSyncJobInput) -> Swift.String? {
        guard let syncSource = value.syncSource else {
            return nil
        }
        return "/sync-jobs/\(syncSource.urlPercentEncoding())"
    }
}

extension GetSyncJobInput {

    static func queryItemProvider(_ value: GetSyncJobInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let workspaceId = value.workspaceId {
            let workspaceIdQueryItem = Smithy.URIQueryItem(name: "workspace".urlPercentEncoding(), value: Swift.String(workspaceId).urlPercentEncoding())
            items.append(workspaceIdQueryItem)
        }
        return items
    }
}

extension GetWorkspaceInput {

    static func urlPathProvider(_ value: GetWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension ListComponentsInput {

    static func urlPathProvider(_ value: ListComponentsInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let entityId = value.entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())/components-list"
    }
}

extension ListComponentTypesInput {

    static func urlPathProvider(_ value: ListComponentTypesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types-list"
    }
}

extension ListEntitiesInput {

    static func urlPathProvider(_ value: ListEntitiesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities-list"
    }
}

extension ListMetadataTransferJobsInput {

    static func urlPathProvider(_ value: ListMetadataTransferJobsInput) -> Swift.String? {
        return "/metadata-transfer-jobs-list"
    }
}

extension ListPropertiesInput {

    static func urlPathProvider(_ value: ListPropertiesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/properties-list"
    }
}

extension ListScenesInput {

    static func urlPathProvider(_ value: ListScenesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes-list"
    }
}

extension ListSyncJobsInput {

    static func urlPathProvider(_ value: ListSyncJobsInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs-list"
    }
}

extension ListSyncResourcesInput {

    static func urlPathProvider(_ value: ListSyncResourcesInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let syncSource = value.syncSource else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/sync-jobs/\(syncSource.urlPercentEncoding())/resources-list"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags-list"
    }
}

extension ListWorkspacesInput {

    static func urlPathProvider(_ value: ListWorkspacesInput) -> Swift.String? {
        return "/workspaces-list"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let resourceARN = value.resourceARN else {
            let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceARNQueryItem = Smithy.URIQueryItem(name: "resourceARN".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
        items.append(resourceARNQueryItem)
        return items
    }
}

extension UpdateComponentTypeInput {

    static func urlPathProvider(_ value: UpdateComponentTypeInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let componentTypeId = value.componentTypeId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/component-types/\(componentTypeId.urlPercentEncoding())"
    }
}

extension UpdateEntityInput {

    static func urlPathProvider(_ value: UpdateEntityInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let entityId = value.entityId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/entities/\(entityId.urlPercentEncoding())"
    }
}

extension UpdatePricingPlanInput {

    static func urlPathProvider(_ value: UpdatePricingPlanInput) -> Swift.String? {
        return "/pricingplan"
    }
}

extension UpdateSceneInput {

    static func urlPathProvider(_ value: UpdateSceneInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        guard let sceneId = value.sceneId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())/scenes/\(sceneId.urlPercentEncoding())"
    }
}

extension UpdateWorkspaceInput {

    static func urlPathProvider(_ value: UpdateWorkspaceInput) -> Swift.String? {
        guard let workspaceId = value.workspaceId else {
            return nil
        }
        return "/workspaces/\(workspaceId.urlPercentEncoding())"
    }
}

extension BatchPutPropertyValuesInput {

    static func write(value: BatchPutPropertyValuesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: IoTTwinMakerClientTypes.PropertyValueEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateComponentTypeInput {

    static func write(value: CreateComponentTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeName"].write(value.componentTypeName)
        try writer["compositeComponentTypes"].writeMap(value.compositeComponentTypes, valueWritingClosure: IoTTwinMakerClientTypes.CompositeComponentTypeRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["extendsFrom"].writeList(value.extendsFrom, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["functions"].writeMap(value.functions, valueWritingClosure: IoTTwinMakerClientTypes.FunctionRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["isSingleton"].write(value.isSingleton)
        try writer["propertyDefinitions"].writeMap(value.propertyDefinitions, valueWritingClosure: IoTTwinMakerClientTypes.PropertyDefinitionRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyGroups"].writeMap(value.propertyGroups, valueWritingClosure: IoTTwinMakerClientTypes.PropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateEntityInput {

    static func write(value: CreateEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["components"].writeMap(value.components, valueWritingClosure: IoTTwinMakerClientTypes.ComponentRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["compositeComponents"].writeMap(value.compositeComponents, valueWritingClosure: IoTTwinMakerClientTypes.CompositeComponentRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["entityId"].write(value.entityId)
        try writer["entityName"].write(value.entityName)
        try writer["parentEntityId"].write(value.parentEntityId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateMetadataTransferJobInput {

    static func write(value: CreateMetadataTransferJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["destination"].write(value.destination, with: IoTTwinMakerClientTypes.DestinationConfiguration.write(value:to:))
        try writer["metadataTransferJobId"].write(value.metadataTransferJobId)
        try writer["sources"].writeList(value.sources, memberWritingClosure: IoTTwinMakerClientTypes.SourceConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSceneInput {

    static func write(value: CreateSceneInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["contentLocation"].write(value.contentLocation)
        try writer["description"].write(value.description)
        try writer["sceneId"].write(value.sceneId)
        try writer["sceneMetadata"].writeMap(value.sceneMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSyncJobInput {

    static func write(value: CreateSyncJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["syncRole"].write(value.syncRole)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorkspaceInput {

    static func write(value: CreateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["role"].write(value.role)
        try writer["s3Location"].write(value.s3Location)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ExecuteQueryInput {

    static func write(value: ExecuteQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["queryStatement"].write(value.queryStatement)
        try writer["workspaceId"].write(value.workspaceId)
    }
}

extension GetPropertyValueInput {

    static func write(value: GetPropertyValueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentName"].write(value.componentName)
        try writer["componentPath"].write(value.componentPath)
        try writer["componentTypeId"].write(value.componentTypeId)
        try writer["entityId"].write(value.entityId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["propertyGroupName"].write(value.propertyGroupName)
        try writer["selectedProperties"].writeList(value.selectedProperties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tabularConditions"].write(value.tabularConditions, with: IoTTwinMakerClientTypes.TabularConditions.write(value:to:))
    }
}

extension GetPropertyValueHistoryInput {

    static func write(value: GetPropertyValueHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentName"].write(value.componentName)
        try writer["componentPath"].write(value.componentPath)
        try writer["componentTypeId"].write(value.componentTypeId)
        try writer["endDateTime"].writeTimestamp(value.endDateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["endTime"].write(value.endTime)
        try writer["entityId"].write(value.entityId)
        try writer["interpolation"].write(value.interpolation, with: IoTTwinMakerClientTypes.InterpolationParameters.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["orderByTime"].write(value.orderByTime)
        try writer["propertyFilters"].writeList(value.propertyFilters, memberWritingClosure: IoTTwinMakerClientTypes.PropertyFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["selectedProperties"].writeList(value.selectedProperties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startDateTime"].writeTimestamp(value.startDateTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["startTime"].write(value.startTime)
    }
}

extension ListComponentsInput {

    static func write(value: ListComponentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentPath"].write(value.componentPath)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListComponentTypesInput {

    static func write(value: ListComponentTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.ListComponentTypesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEntitiesInput {

    static func write(value: ListEntitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.ListEntitiesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListMetadataTransferJobsInput {

    static func write(value: ListMetadataTransferJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["destinationType"].write(value.destinationType)
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sourceType"].write(value.sourceType)
    }
}

extension ListPropertiesInput {

    static func write(value: ListPropertiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentName"].write(value.componentName)
        try writer["componentPath"].write(value.componentPath)
        try writer["entityId"].write(value.entityId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListScenesInput {

    static func write(value: ListScenesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSyncJobsInput {

    static func write(value: ListSyncJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListSyncResourcesInput {

    static func write(value: ListSyncResourcesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.SyncResourceFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["resourceARN"].write(value.resourceARN)
    }
}

extension ListWorkspacesInput {

    static func write(value: ListWorkspacesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceARN"].write(value.resourceARN)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateComponentTypeInput {

    static func write(value: UpdateComponentTypeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeName"].write(value.componentTypeName)
        try writer["compositeComponentTypes"].writeMap(value.compositeComponentTypes, valueWritingClosure: IoTTwinMakerClientTypes.CompositeComponentTypeRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["extendsFrom"].writeList(value.extendsFrom, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["functions"].writeMap(value.functions, valueWritingClosure: IoTTwinMakerClientTypes.FunctionRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["isSingleton"].write(value.isSingleton)
        try writer["propertyDefinitions"].writeMap(value.propertyDefinitions, valueWritingClosure: IoTTwinMakerClientTypes.PropertyDefinitionRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyGroups"].writeMap(value.propertyGroups, valueWritingClosure: IoTTwinMakerClientTypes.PropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateEntityInput {

    static func write(value: UpdateEntityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentUpdates"].writeMap(value.componentUpdates, valueWritingClosure: IoTTwinMakerClientTypes.ComponentUpdateRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["compositeComponentUpdates"].writeMap(value.compositeComponentUpdates, valueWritingClosure: IoTTwinMakerClientTypes.CompositeComponentUpdateRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["entityName"].write(value.entityName)
        try writer["parentEntityUpdate"].write(value.parentEntityUpdate, with: IoTTwinMakerClientTypes.ParentEntityUpdateRequest.write(value:to:))
    }
}

extension UpdatePricingPlanInput {

    static func write(value: UpdatePricingPlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bundleNames"].writeList(value.bundleNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["pricingMode"].write(value.pricingMode)
    }
}

extension UpdateSceneInput {

    static func write(value: UpdateSceneInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["contentLocation"].write(value.contentLocation)
        try writer["description"].write(value.description)
        try writer["sceneMetadata"].writeMap(value.sceneMetadata, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateWorkspaceInput {

    static func write(value: UpdateWorkspaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["role"].write(value.role)
        try writer["s3Location"].write(value.s3Location)
    }
}

extension BatchPutPropertyValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutPropertyValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutPropertyValuesOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CancelMetadataTransferJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelMetadataTransferJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelMetadataTransferJobOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.metadataTransferJobId = try reader["metadataTransferJobId"].readIfPresent() ?? ""
        value.progress = try reader["progress"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobProgress.read(from:))
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobStatus.read(from:))
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateComponentTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateComponentTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateComponentTypeOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEntityOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateMetadataTransferJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMetadataTransferJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMetadataTransferJobOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.metadataTransferJobId = try reader["metadataTransferJobId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobStatus.read(from:))
        return value
    }
}

extension CreateSceneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSceneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSceneOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateSyncJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSyncJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSyncJobOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeleteComponentTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteComponentTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteComponentTypeOutput()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEntityOutput()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteSceneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSceneOutput {
        return DeleteSceneOutput()
    }
}

extension DeleteSyncJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSyncJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSyncJobOutput()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteWorkspaceOutput()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension ExecuteQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteQueryOutput()
        value.columnDescriptions = try reader["columnDescriptions"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.ColumnDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.rows = try reader["rows"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.Row.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetComponentTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetComponentTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetComponentTypeOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.componentTypeId = try reader["componentTypeId"].readIfPresent() ?? ""
        value.componentTypeName = try reader["componentTypeName"].readIfPresent()
        value.compositeComponentTypes = try reader["compositeComponentTypes"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.CompositeComponentTypeResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.extendsFrom = try reader["extendsFrom"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.functions = try reader["functions"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.FunctionResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.isAbstract = try reader["isAbstract"].readIfPresent()
        value.isSchemaInitialized = try reader["isSchemaInitialized"].readIfPresent()
        value.isSingleton = try reader["isSingleton"].readIfPresent()
        value.propertyDefinitions = try reader["propertyDefinitions"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.PropertyDefinitionResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.propertyGroups = try reader["propertyGroups"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.PropertyGroupResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.syncSource = try reader["syncSource"].readIfPresent()
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension GetEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEntityOutput()
        value.areAllComponentsReturned = try reader["areAllComponentsReturned"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.components = try reader["components"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.ComponentResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        value.entityName = try reader["entityName"].readIfPresent() ?? ""
        value.hasChildEntities = try reader["hasChildEntities"].readIfPresent() ?? false
        value.parentEntityId = try reader["parentEntityId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.syncSource = try reader["syncSource"].readIfPresent()
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension GetMetadataTransferJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMetadataTransferJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMetadataTransferJobOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.destination = try reader["destination"].readIfPresent(with: IoTTwinMakerClientTypes.DestinationConfiguration.read(from:))
        value.metadataTransferJobId = try reader["metadataTransferJobId"].readIfPresent() ?? ""
        value.metadataTransferJobRole = try reader["metadataTransferJobRole"].readIfPresent() ?? ""
        value.progress = try reader["progress"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobProgress.read(from:))
        value.reportUrl = try reader["reportUrl"].readIfPresent()
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.SourceConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobStatus.read(from:))
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetPricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPricingPlanOutput()
        value.currentPricingPlan = try reader["currentPricingPlan"].readIfPresent(with: IoTTwinMakerClientTypes.PricingPlan.read(from:))
        value.pendingPricingPlan = try reader["pendingPricingPlan"].readIfPresent(with: IoTTwinMakerClientTypes.PricingPlan.read(from:))
        return value
    }
}

extension GetPropertyValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPropertyValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPropertyValueOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.propertyValues = try reader["propertyValues"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.PropertyLatestValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.tabularPropertyValues = try reader["tabularPropertyValues"].readListIfPresent(memberReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: IoTTwinMakerClientTypes.DataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPropertyValueHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPropertyValueHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPropertyValueHistoryOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.propertyValues = try reader["propertyValues"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.PropertyValueHistory.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetSceneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSceneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSceneOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.contentLocation = try reader["contentLocation"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: IoTTwinMakerClientTypes.SceneError.read(from:))
        value.generatedSceneMetadata = try reader["generatedSceneMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sceneId = try reader["sceneId"].readIfPresent() ?? ""
        value.sceneMetadata = try reader["sceneMetadata"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension GetSyncJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSyncJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSyncJobOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.SyncJobStatus.read(from:))
        value.syncRole = try reader["syncRole"].readIfPresent() ?? ""
        value.syncSource = try reader["syncSource"].readIfPresent() ?? ""
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension GetWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkspaceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.linkedServices = try reader["linkedServices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.role = try reader["role"].readIfPresent()
        value.s3Location = try reader["s3Location"].readIfPresent()
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension ListComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentsOutput()
        value.componentSummaries = try reader["componentSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.ComponentSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListComponentTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListComponentTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListComponentTypesOutput()
        value.componentTypeSummaries = try reader["componentTypeSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.ComponentTypeSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.maxResults = try reader["maxResults"].readIfPresent()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension ListEntitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEntitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEntitiesOutput()
        value.entitySummaries = try reader["entitySummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.EntitySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMetadataTransferJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMetadataTransferJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMetadataTransferJobsOutput()
        value.metadataTransferJobSummaries = try reader["metadataTransferJobSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.MetadataTransferJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPropertiesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.propertySummaries = try reader["propertySummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.PropertySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListScenesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListScenesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListScenesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.sceneSummaries = try reader["sceneSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.SceneSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSyncJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSyncJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSyncJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.syncJobSummaries = try reader["syncJobSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.SyncJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSyncResourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSyncResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSyncResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.syncResources = try reader["syncResources"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.SyncResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkspacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspacesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.workspaceSummaries = try reader["workspaceSummaries"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.WorkspaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateComponentTypeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateComponentTypeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateComponentTypeOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.componentTypeId = try reader["componentTypeId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateEntityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEntityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEntityOutput()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdatePricingPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePricingPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePricingPlanOutput()
        value.currentPricingPlan = try reader["currentPricingPlan"].readIfPresent(with: IoTTwinMakerClientTypes.PricingPlan.read(from:))
        value.pendingPricingPlan = try reader["pendingPricingPlan"].readIfPresent(with: IoTTwinMakerClientTypes.PricingPlan.read(from:))
        return value
    }
}

extension UpdateSceneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSceneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSceneOutput()
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateWorkspaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkspaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkspaceOutput()
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum BatchPutPropertyValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelMetadataTransferJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateComponentTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMetadataTransferJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSceneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSyncJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteComponentTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSceneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSyncJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetComponentTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMetadataTransferJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPropertyValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConnectorFailureException": return try ConnectorFailureException.makeError(baseError: baseError)
            case "ConnectorTimeoutException": return try ConnectorTimeoutException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPropertyValueHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConnectorFailureException": return try ConnectorFailureException.makeError(baseError: baseError)
            case "ConnectorTimeoutException": return try ConnectorTimeoutException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSceneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSyncJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListComponentTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEntitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMetadataTransferJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListScenesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSyncJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSyncResourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateComponentTypeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEntityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePricingPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSceneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkspaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QueryTimeoutException {
        let reader = baseError.errorBodyReader
        var value = QueryTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectorFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConnectorFailureException {
        let reader = baseError.errorBodyReader
        var value = ConnectorFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConnectorTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConnectorTimeoutException {
        let reader = baseError.errorBodyReader
        var value = ConnectorTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.BatchPutPropertyErrorEntry()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.BatchPutPropertyError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTTwinMakerClientTypes.BatchPutPropertyError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.BatchPutPropertyError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.BatchPutPropertyError()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.entry = try reader["entry"].readIfPresent(with: IoTTwinMakerClientTypes.PropertyValueEntry.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyValueEntry {

    static func write(value: IoTTwinMakerClientTypes.PropertyValueEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityPropertyReference"].write(value.entityPropertyReference, with: IoTTwinMakerClientTypes.EntityPropertyReference.write(value:to:))
        try writer["propertyValues"].writeList(value.propertyValues, memberWritingClosure: IoTTwinMakerClientTypes.PropertyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyValueEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyValueEntry()
        value.entityPropertyReference = try reader["entityPropertyReference"].readIfPresent(with: IoTTwinMakerClientTypes.EntityPropertyReference.read(from:))
        value.propertyValues = try reader["propertyValues"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.PropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyValue {

    static func write(value: IoTTwinMakerClientTypes.PropertyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["time"].write(value.time)
        try writer["timestamp"].writeTimestamp(value.timestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["value"].write(value.value, with: IoTTwinMakerClientTypes.DataValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyValue()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.value = try reader["value"].readIfPresent(with: IoTTwinMakerClientTypes.DataValue.read(from:))
        value.time = try reader["time"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.DataValue {

    static func write(value: IoTTwinMakerClientTypes.DataValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["booleanValue"].write(value.booleanValue)
        try writer["doubleValue"].write(value.doubleValue)
        try writer["expression"].write(value.expression)
        try writer["integerValue"].write(value.integerValue)
        try writer["listValue"].writeList(value.listValue, memberWritingClosure: IoTTwinMakerClientTypes.DataValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["longValue"].write(value.longValue)
        try writer["mapValue"].writeMap(value.mapValue, valueWritingClosure: IoTTwinMakerClientTypes.DataValue.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["relationshipValue"].write(value.relationshipValue, with: IoTTwinMakerClientTypes.RelationshipValue.write(value:to:))
        try writer["stringValue"].write(value.stringValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.DataValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.DataValue()
        value.booleanValue = try reader["booleanValue"].readIfPresent()
        value.doubleValue = try reader["doubleValue"].readIfPresent()
        value.integerValue = try reader["integerValue"].readIfPresent()
        value.longValue = try reader["longValue"].readIfPresent()
        value.stringValue = try reader["stringValue"].readIfPresent()
        value.listValue = try reader["listValue"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.DataValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.mapValue = try reader["mapValue"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.DataValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.relationshipValue = try reader["relationshipValue"].readIfPresent(with: IoTTwinMakerClientTypes.RelationshipValue.read(from:))
        value.expression = try reader["expression"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.RelationshipValue {

    static func write(value: IoTTwinMakerClientTypes.RelationshipValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetComponentName"].write(value.targetComponentName)
        try writer["targetEntityId"].write(value.targetEntityId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.RelationshipValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.RelationshipValue()
        value.targetEntityId = try reader["targetEntityId"].readIfPresent()
        value.targetComponentName = try reader["targetComponentName"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.EntityPropertyReference {

    static func write(value: IoTTwinMakerClientTypes.EntityPropertyReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentName"].write(value.componentName)
        try writer["componentPath"].write(value.componentPath)
        try writer["entityId"].write(value.entityId)
        try writer["externalIdProperty"].writeMap(value.externalIdProperty, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyName"].write(value.propertyName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.EntityPropertyReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.EntityPropertyReference()
        value.componentName = try reader["componentName"].readIfPresent()
        value.componentPath = try reader["componentPath"].readIfPresent()
        value.externalIdProperty = try reader["externalIdProperty"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.entityId = try reader["entityId"].readIfPresent()
        value.propertyName = try reader["propertyName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.MetadataTransferJobStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.MetadataTransferJobStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.MetadataTransferJobStatus()
        value.state = try reader["state"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: IoTTwinMakerClientTypes.ErrorDetails.read(from:))
        value.queuedPosition = try reader["queuedPosition"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ErrorDetails()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.MetadataTransferJobProgress {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.MetadataTransferJobProgress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.MetadataTransferJobProgress()
        value.totalCount = try reader["totalCount"].readIfPresent()
        value.succeededCount = try reader["succeededCount"].readIfPresent()
        value.skippedCount = try reader["skippedCount"].readIfPresent()
        value.failedCount = try reader["failedCount"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.ColumnDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ColumnDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ColumnDescription()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.Row {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.Row {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.Row()
        value.rowData = try reader["rowData"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyDefinitionResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyDefinitionResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyDefinitionResponse()
        value.dataType = try reader["dataType"].readIfPresent(with: IoTTwinMakerClientTypes.DataType.read(from:))
        value.isTimeSeries = try reader["isTimeSeries"].readIfPresent() ?? false
        value.isRequiredInEntity = try reader["isRequiredInEntity"].readIfPresent() ?? false
        value.isExternalId = try reader["isExternalId"].readIfPresent() ?? false
        value.isStoredExternally = try reader["isStoredExternally"].readIfPresent() ?? false
        value.isImported = try reader["isImported"].readIfPresent() ?? false
        value.isFinal = try reader["isFinal"].readIfPresent() ?? false
        value.isInherited = try reader["isInherited"].readIfPresent() ?? false
        value.defaultValue = try reader["defaultValue"].readIfPresent(with: IoTTwinMakerClientTypes.DataValue.read(from:))
        value.configuration = try reader["configuration"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.displayName = try reader["displayName"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.DataType {

    static func write(value: IoTTwinMakerClientTypes.DataType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedValues"].writeList(value.allowedValues, memberWritingClosure: IoTTwinMakerClientTypes.DataValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nestedType"].write(value.nestedType, with: IoTTwinMakerClientTypes.DataType.write(value:to:))
        try writer["relationship"].write(value.relationship, with: IoTTwinMakerClientTypes.Relationship.write(value:to:))
        try writer["type"].write(value.type)
        try writer["unitOfMeasure"].write(value.unitOfMeasure)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.DataType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.DataType()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.nestedType = try reader["nestedType"].readIfPresent(with: IoTTwinMakerClientTypes.DataType.read(from:))
        value.allowedValues = try reader["allowedValues"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.DataValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.unitOfMeasure = try reader["unitOfMeasure"].readIfPresent()
        value.relationship = try reader["relationship"].readIfPresent(with: IoTTwinMakerClientTypes.Relationship.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.Relationship {

    static func write(value: IoTTwinMakerClientTypes.Relationship?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["relationshipType"].write(value.relationshipType)
        try writer["targetComponentTypeId"].write(value.targetComponentTypeId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.Relationship {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.Relationship()
        value.targetComponentTypeId = try reader["targetComponentTypeId"].readIfPresent()
        value.relationshipType = try reader["relationshipType"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.FunctionResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.FunctionResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.FunctionResponse()
        value.requiredProperties = try reader["requiredProperties"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scope = try reader["scope"].readIfPresent()
        value.implementedBy = try reader["implementedBy"].readIfPresent(with: IoTTwinMakerClientTypes.DataConnector.read(from:))
        value.isInherited = try reader["isInherited"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.DataConnector {

    static func write(value: IoTTwinMakerClientTypes.DataConnector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isNative"].write(value.isNative)
        try writer["lambda"].write(value.lambda, with: IoTTwinMakerClientTypes.LambdaFunction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.DataConnector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.DataConnector()
        value.lambda = try reader["lambda"].readIfPresent(with: IoTTwinMakerClientTypes.LambdaFunction.read(from:))
        value.isNative = try reader["isNative"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.LambdaFunction {

    static func write(value: IoTTwinMakerClientTypes.LambdaFunction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.LambdaFunction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.LambdaFunction()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.Status {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.Status {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.Status()
        value.state = try reader["state"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: IoTTwinMakerClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyGroupResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyGroupResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyGroupResponse()
        value.groupType = try reader["groupType"].readIfPresent() ?? .sdkUnknown("")
        value.propertyNames = try reader["propertyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isInherited = try reader["isInherited"].readIfPresent() ?? false
        return value
    }
}

extension IoTTwinMakerClientTypes.CompositeComponentTypeResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.CompositeComponentTypeResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.CompositeComponentTypeResponse()
        value.componentTypeId = try reader["componentTypeId"].readIfPresent()
        value.isInherited = try reader["isInherited"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.ComponentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ComponentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ComponentResponse()
        value.componentName = try reader["componentName"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.componentTypeId = try reader["componentTypeId"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.definedIn = try reader["definedIn"].readIfPresent()
        value.properties = try reader["properties"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.PropertyResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.propertyGroups = try reader["propertyGroups"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.syncSource = try reader["syncSource"].readIfPresent()
        value.areAllPropertiesReturned = try reader["areAllPropertiesReturned"].readIfPresent()
        value.compositeComponents = try reader["compositeComponents"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.ComponentSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.areAllCompositeComponentsReturned = try reader["areAllCompositeComponentsReturned"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.ComponentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ComponentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ComponentSummary()
        value.componentName = try reader["componentName"].readIfPresent() ?? ""
        value.componentTypeId = try reader["componentTypeId"].readIfPresent() ?? ""
        value.definedIn = try reader["definedIn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.propertyGroups = try reader["propertyGroups"].readMapIfPresent(valueReadingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupResponse.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.syncSource = try reader["syncSource"].readIfPresent()
        value.componentPath = try reader["componentPath"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ComponentPropertyGroupResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ComponentPropertyGroupResponse()
        value.groupType = try reader["groupType"].readIfPresent() ?? .sdkUnknown("")
        value.propertyNames = try reader["propertyNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.isInherited = try reader["isInherited"].readIfPresent() ?? false
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyResponse()
        value.definition = try reader["definition"].readIfPresent(with: IoTTwinMakerClientTypes.PropertyDefinitionResponse.read(from:))
        value.value = try reader["value"].readIfPresent(with: IoTTwinMakerClientTypes.DataValue.read(from:))
        value.areAllPropertyValuesReturned = try reader["areAllPropertyValuesReturned"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.SourceConfiguration {

    static func write(value: IoTTwinMakerClientTypes.SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iotSiteWiseConfiguration"].write(value.iotSiteWiseConfiguration, with: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration.write(value:to:))
        try writer["iotTwinMakerConfiguration"].write(value.iotTwinMakerConfiguration, with: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration.write(value:to:))
        try writer["s3Configuration"].write(value.s3Configuration, with: IoTTwinMakerClientTypes.S3SourceConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SourceConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: IoTTwinMakerClientTypes.S3SourceConfiguration.read(from:))
        value.iotSiteWiseConfiguration = try reader["iotSiteWiseConfiguration"].readIfPresent(with: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration.read(from:))
        value.iotTwinMakerConfiguration = try reader["iotTwinMakerConfiguration"].readIfPresent(with: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration {

    static func write(value: IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workspace"].write(value.workspace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.IotTwinMakerSourceConfiguration()
        value.workspace = try reader["workspace"].readIfPresent() ?? ""
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter {

    static func write(value: IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filterbycomponenttype(filterbycomponenttype):
                try writer["filterByComponentType"].write(filterbycomponenttype, with: IoTTwinMakerClientTypes.FilterByComponentType.write(value:to:))
            case let .filterbyentity(filterbyentity):
                try writer["filterByEntity"].write(filterbyentity, with: IoTTwinMakerClientTypes.FilterByEntity.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.IotTwinMakerSourceConfigurationFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "filterByComponentType":
                return .filterbycomponenttype(try reader["filterByComponentType"].read(with: IoTTwinMakerClientTypes.FilterByComponentType.read(from:)))
            case "filterByEntity":
                return .filterbyentity(try reader["filterByEntity"].read(with: IoTTwinMakerClientTypes.FilterByEntity.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTTwinMakerClientTypes.FilterByEntity {

    static func write(value: IoTTwinMakerClientTypes.FilterByEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entityId"].write(value.entityId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.FilterByEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.FilterByEntity()
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.FilterByComponentType {

    static func write(value: IoTTwinMakerClientTypes.FilterByComponentType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeId"].write(value.componentTypeId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.FilterByComponentType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.FilterByComponentType()
        value.componentTypeId = try reader["componentTypeId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration {

    static func write(value: IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.IotSiteWiseSourceConfiguration()
        value.filters = try reader["filters"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter {

    static func write(value: IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filterbyasset(filterbyasset):
                try writer["filterByAsset"].write(filterbyasset, with: IoTTwinMakerClientTypes.FilterByAsset.write(value:to:))
            case let .filterbyassetmodel(filterbyassetmodel):
                try writer["filterByAssetModel"].write(filterbyassetmodel, with: IoTTwinMakerClientTypes.FilterByAssetModel.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.IotSiteWiseSourceConfigurationFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "filterByAssetModel":
                return .filterbyassetmodel(try reader["filterByAssetModel"].read(with: IoTTwinMakerClientTypes.FilterByAssetModel.read(from:)))
            case "filterByAsset":
                return .filterbyasset(try reader["filterByAsset"].read(with: IoTTwinMakerClientTypes.FilterByAsset.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension IoTTwinMakerClientTypes.FilterByAsset {

    static func write(value: IoTTwinMakerClientTypes.FilterByAsset?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetExternalId"].write(value.assetExternalId)
        try writer["assetId"].write(value.assetId)
        try writer["includeAssetModel"].write(value.includeAssetModel)
        try writer["includeOffspring"].write(value.includeOffspring)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.FilterByAsset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.FilterByAsset()
        value.assetId = try reader["assetId"].readIfPresent()
        value.assetExternalId = try reader["assetExternalId"].readIfPresent()
        value.includeOffspring = try reader["includeOffspring"].readIfPresent()
        value.includeAssetModel = try reader["includeAssetModel"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.FilterByAssetModel {

    static func write(value: IoTTwinMakerClientTypes.FilterByAssetModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelExternalId"].write(value.assetModelExternalId)
        try writer["assetModelId"].write(value.assetModelId)
        try writer["includeAssets"].write(value.includeAssets)
        try writer["includeOffspring"].write(value.includeOffspring)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.FilterByAssetModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.FilterByAssetModel()
        value.assetModelId = try reader["assetModelId"].readIfPresent()
        value.assetModelExternalId = try reader["assetModelExternalId"].readIfPresent()
        value.includeOffspring = try reader["includeOffspring"].readIfPresent()
        value.includeAssets = try reader["includeAssets"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.S3SourceConfiguration {

    static func write(value: IoTTwinMakerClientTypes.S3SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.S3SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.S3SourceConfiguration()
        value.location = try reader["location"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.DestinationConfiguration {

    static func write(value: IoTTwinMakerClientTypes.DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iotTwinMakerConfiguration"].write(value.iotTwinMakerConfiguration, with: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration.write(value:to:))
        try writer["s3Configuration"].write(value.s3Configuration, with: IoTTwinMakerClientTypes.S3DestinationConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.DestinationConfiguration()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.s3Configuration = try reader["s3Configuration"].readIfPresent(with: IoTTwinMakerClientTypes.S3DestinationConfiguration.read(from:))
        value.iotTwinMakerConfiguration = try reader["iotTwinMakerConfiguration"].readIfPresent(with: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration {

    static func write(value: IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["workspace"].write(value.workspace)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.IotTwinMakerDestinationConfiguration()
        value.workspace = try reader["workspace"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.S3DestinationConfiguration {

    static func write(value: IoTTwinMakerClientTypes.S3DestinationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.S3DestinationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.S3DestinationConfiguration()
        value.location = try reader["location"].readIfPresent() ?? ""
        return value
    }
}

extension IoTTwinMakerClientTypes.PricingPlan {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PricingPlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PricingPlan()
        value.billableEntityCount = try reader["billableEntityCount"].readIfPresent()
        value.bundleInformation = try reader["bundleInformation"].readIfPresent(with: IoTTwinMakerClientTypes.BundleInformation.read(from:))
        value.effectiveDateTime = try reader["effectiveDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.pricingMode = try reader["pricingMode"].readIfPresent() ?? .sdkUnknown("")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateReason = try reader["updateReason"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTTwinMakerClientTypes.BundleInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.BundleInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.BundleInformation()
        value.bundleNames = try reader["bundleNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.pricingTier = try reader["pricingTier"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyLatestValue {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyLatestValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyLatestValue()
        value.propertyReference = try reader["propertyReference"].readIfPresent(with: IoTTwinMakerClientTypes.EntityPropertyReference.read(from:))
        value.propertyValue = try reader["propertyValue"].readIfPresent(with: IoTTwinMakerClientTypes.DataValue.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyValueHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertyValueHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertyValueHistory()
        value.entityPropertyReference = try reader["entityPropertyReference"].readIfPresent(with: IoTTwinMakerClientTypes.EntityPropertyReference.read(from:))
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: IoTTwinMakerClientTypes.PropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTTwinMakerClientTypes.SceneError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SceneError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SceneError()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.SyncJobStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SyncJobStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SyncJobStatus()
        value.state = try reader["state"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: IoTTwinMakerClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.ComponentTypeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.ComponentTypeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.ComponentTypeSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.componentTypeId = try reader["componentTypeId"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.componentTypeName = try reader["componentTypeName"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.EntitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.EntitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.EntitySummary()
        value.entityId = try reader["entityId"].readIfPresent() ?? ""
        value.entityName = try reader["entityName"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.parentEntityId = try reader["parentEntityId"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.Status.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.hasChildEntities = try reader["hasChildEntities"].readIfPresent()
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTTwinMakerClientTypes.MetadataTransferJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.MetadataTransferJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.MetadataTransferJobSummary()
        value.metadataTransferJobId = try reader["metadataTransferJobId"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobStatus.read(from:))
        value.progress = try reader["progress"].readIfPresent(with: IoTTwinMakerClientTypes.MetadataTransferJobProgress.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.PropertySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.PropertySummary()
        value.definition = try reader["definition"].readIfPresent(with: IoTTwinMakerClientTypes.PropertyDefinitionResponse.read(from:))
        value.propertyName = try reader["propertyName"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: IoTTwinMakerClientTypes.DataValue.read(from:))
        value.areAllPropertyValuesReturned = try reader["areAllPropertyValuesReturned"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.SceneSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SceneSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SceneSummary()
        value.sceneId = try reader["sceneId"].readIfPresent() ?? ""
        value.contentLocation = try reader["contentLocation"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension IoTTwinMakerClientTypes.SyncJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SyncJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SyncJobSummary()
        value.arn = try reader["arn"].readIfPresent()
        value.workspaceId = try reader["workspaceId"].readIfPresent()
        value.syncSource = try reader["syncSource"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.SyncJobStatus.read(from:))
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTTwinMakerClientTypes.SyncResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SyncResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SyncResourceSummary()
        value.resourceType = try reader["resourceType"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.resourceId = try reader["resourceId"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTTwinMakerClientTypes.SyncResourceStatus.read(from:))
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTTwinMakerClientTypes.SyncResourceStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.SyncResourceStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.SyncResourceStatus()
        value.state = try reader["state"].readIfPresent()
        value.error = try reader["error"].readIfPresent(with: IoTTwinMakerClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension IoTTwinMakerClientTypes.WorkspaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTTwinMakerClientTypes.WorkspaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTTwinMakerClientTypes.WorkspaceSummary()
        value.workspaceId = try reader["workspaceId"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.linkedServices = try reader["linkedServices"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDateTime = try reader["creationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateDateTime = try reader["updateDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTTwinMakerClientTypes.PropertyDefinitionRequest {

    static func write(value: IoTTwinMakerClientTypes.PropertyDefinitionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].writeMap(value.configuration, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["dataType"].write(value.dataType, with: IoTTwinMakerClientTypes.DataType.write(value:to:))
        try writer["defaultValue"].write(value.defaultValue, with: IoTTwinMakerClientTypes.DataValue.write(value:to:))
        try writer["displayName"].write(value.displayName)
        try writer["isExternalId"].write(value.isExternalId)
        try writer["isRequiredInEntity"].write(value.isRequiredInEntity)
        try writer["isStoredExternally"].write(value.isStoredExternally)
        try writer["isTimeSeries"].write(value.isTimeSeries)
    }
}

extension IoTTwinMakerClientTypes.FunctionRequest {

    static func write(value: IoTTwinMakerClientTypes.FunctionRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["implementedBy"].write(value.implementedBy, with: IoTTwinMakerClientTypes.DataConnector.write(value:to:))
        try writer["requiredProperties"].writeList(value.requiredProperties, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scope"].write(value.scope)
    }
}

extension IoTTwinMakerClientTypes.PropertyGroupRequest {

    static func write(value: IoTTwinMakerClientTypes.PropertyGroupRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupType"].write(value.groupType)
        try writer["propertyNames"].writeList(value.propertyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTTwinMakerClientTypes.CompositeComponentTypeRequest {

    static func write(value: IoTTwinMakerClientTypes.CompositeComponentTypeRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeId"].write(value.componentTypeId)
    }
}

extension IoTTwinMakerClientTypes.ComponentRequest {

    static func write(value: IoTTwinMakerClientTypes.ComponentRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeId"].write(value.componentTypeId)
        try writer["description"].write(value.description)
        try writer["properties"].writeMap(value.properties, valueWritingClosure: IoTTwinMakerClientTypes.PropertyRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyGroups"].writeMap(value.propertyGroups, valueWritingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension IoTTwinMakerClientTypes.ComponentPropertyGroupRequest {

    static func write(value: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupType"].write(value.groupType)
        try writer["propertyNames"].writeList(value.propertyNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["updateType"].write(value.updateType)
    }
}

extension IoTTwinMakerClientTypes.PropertyRequest {

    static func write(value: IoTTwinMakerClientTypes.PropertyRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["definition"].write(value.definition, with: IoTTwinMakerClientTypes.PropertyDefinitionRequest.write(value:to:))
        try writer["updateType"].write(value.updateType)
        try writer["value"].write(value.value, with: IoTTwinMakerClientTypes.DataValue.write(value:to:))
    }
}

extension IoTTwinMakerClientTypes.CompositeComponentRequest {

    static func write(value: IoTTwinMakerClientTypes.CompositeComponentRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["properties"].writeMap(value.properties, valueWritingClosure: IoTTwinMakerClientTypes.PropertyRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyGroups"].writeMap(value.propertyGroups, valueWritingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension IoTTwinMakerClientTypes.TabularConditions {

    static func write(value: IoTTwinMakerClientTypes.TabularConditions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["orderBy"].writeList(value.orderBy, memberWritingClosure: IoTTwinMakerClientTypes.OrderBy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["propertyFilters"].writeList(value.propertyFilters, memberWritingClosure: IoTTwinMakerClientTypes.PropertyFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTTwinMakerClientTypes.PropertyFilter {

    static func write(value: IoTTwinMakerClientTypes.PropertyFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["operator"].write(value.`operator`)
        try writer["propertyName"].write(value.propertyName)
        try writer["value"].write(value.value, with: IoTTwinMakerClientTypes.DataValue.write(value:to:))
    }
}

extension IoTTwinMakerClientTypes.OrderBy {

    static func write(value: IoTTwinMakerClientTypes.OrderBy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["order"].write(value.order)
        try writer["propertyName"].write(value.propertyName)
    }
}

extension IoTTwinMakerClientTypes.InterpolationParameters {

    static func write(value: IoTTwinMakerClientTypes.InterpolationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interpolationType"].write(value.interpolationType)
        try writer["intervalInSeconds"].write(value.intervalInSeconds)
    }
}

extension IoTTwinMakerClientTypes.ListComponentTypesFilter {

    static func write(value: IoTTwinMakerClientTypes.ListComponentTypesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .extendsfrom(extendsfrom):
                try writer["extendsFrom"].write(extendsfrom)
            case let .isabstract(isabstract):
                try writer["isAbstract"].write(isabstract)
            case let .namespace(namespace):
                try writer["namespace"].write(namespace)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension IoTTwinMakerClientTypes.ListEntitiesFilter {

    static func write(value: IoTTwinMakerClientTypes.ListEntitiesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .componenttypeid(componenttypeid):
                try writer["componentTypeId"].write(componenttypeid)
            case let .externalid(externalid):
                try writer["externalId"].write(externalid)
            case let .parententityid(parententityid):
                try writer["parentEntityId"].write(parententityid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter {

    static func write(value: IoTTwinMakerClientTypes.ListMetadataTransferJobsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .state(state):
                try writer["state"].write(state)
            case let .workspaceid(workspaceid):
                try writer["workspaceId"].write(workspaceid)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension IoTTwinMakerClientTypes.SyncResourceFilter {

    static func write(value: IoTTwinMakerClientTypes.SyncResourceFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .externalid(externalid):
                try writer["externalId"].write(externalid)
            case let .resourceid(resourceid):
                try writer["resourceId"].write(resourceid)
            case let .resourcetype(resourcetype):
                try writer["resourceType"].write(resourcetype)
            case let .state(state):
                try writer["state"].write(state)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension IoTTwinMakerClientTypes.ComponentUpdateRequest {

    static func write(value: IoTTwinMakerClientTypes.ComponentUpdateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentTypeId"].write(value.componentTypeId)
        try writer["description"].write(value.description)
        try writer["propertyGroupUpdates"].writeMap(value.propertyGroupUpdates, valueWritingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyUpdates"].writeMap(value.propertyUpdates, valueWritingClosure: IoTTwinMakerClientTypes.PropertyRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["updateType"].write(value.updateType)
    }
}

extension IoTTwinMakerClientTypes.CompositeComponentUpdateRequest {

    static func write(value: IoTTwinMakerClientTypes.CompositeComponentUpdateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["propertyGroupUpdates"].writeMap(value.propertyGroupUpdates, valueWritingClosure: IoTTwinMakerClientTypes.ComponentPropertyGroupRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["propertyUpdates"].writeMap(value.propertyUpdates, valueWritingClosure: IoTTwinMakerClientTypes.PropertyRequest.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["updateType"].write(value.updateType)
    }
}

extension IoTTwinMakerClientTypes.ParentEntityUpdateRequest {

    static func write(value: IoTTwinMakerClientTypes.ParentEntityUpdateRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parentEntityId"].write(value.parentEntityId)
        try writer["updateType"].write(value.updateType)
    }
}

public enum IoTTwinMakerClientTypes {}
