// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension IoTTwinMakerClient {
    /// Paginate over `[ExecuteQueryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ExecuteQueryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ExecuteQueryOutput`
    public func executeQueryPaginated(input: ExecuteQueryInput) -> ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput> {
        return ClientRuntime.PaginatorSequence<ExecuteQueryInput, ExecuteQueryOutput>(input: input, inputKey: \ExecuteQueryInput.nextToken, outputKey: \ExecuteQueryOutput.nextToken, paginationFunction: self.executeQuery(input:))
    }
}

extension ExecuteQueryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ExecuteQueryInput {
        return ExecuteQueryInput(
            maxResults: self.maxResults,
            nextToken: token,
            queryStatement: self.queryStatement,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[GetPropertyValueOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPropertyValueInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPropertyValueOutput`
    public func getPropertyValuePaginated(input: GetPropertyValueInput) -> ClientRuntime.PaginatorSequence<GetPropertyValueInput, GetPropertyValueOutput> {
        return ClientRuntime.PaginatorSequence<GetPropertyValueInput, GetPropertyValueOutput>(input: input, inputKey: \GetPropertyValueInput.nextToken, outputKey: \GetPropertyValueOutput.nextToken, paginationFunction: self.getPropertyValue(input:))
    }
}

extension GetPropertyValueInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPropertyValueInput {
        return GetPropertyValueInput(
            componentName: self.componentName,
            componentTypeId: self.componentTypeId,
            entityId: self.entityId,
            maxResults: self.maxResults,
            nextToken: token,
            propertyGroupName: self.propertyGroupName,
            selectedProperties: self.selectedProperties,
            tabularConditions: self.tabularConditions,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[GetPropertyValueHistoryOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPropertyValueHistoryInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPropertyValueHistoryOutput`
    public func getPropertyValueHistoryPaginated(input: GetPropertyValueHistoryInput) -> ClientRuntime.PaginatorSequence<GetPropertyValueHistoryInput, GetPropertyValueHistoryOutput> {
        return ClientRuntime.PaginatorSequence<GetPropertyValueHistoryInput, GetPropertyValueHistoryOutput>(input: input, inputKey: \GetPropertyValueHistoryInput.nextToken, outputKey: \GetPropertyValueHistoryOutput.nextToken, paginationFunction: self.getPropertyValueHistory(input:))
    }
}

extension GetPropertyValueHistoryInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPropertyValueHistoryInput {
        return GetPropertyValueHistoryInput(
            componentName: self.componentName,
            componentTypeId: self.componentTypeId,
            endDateTime: self.endDateTime,
            endTime: self.endTime,
            entityId: self.entityId,
            interpolation: self.interpolation,
            maxResults: self.maxResults,
            nextToken: token,
            orderByTime: self.orderByTime,
            propertyFilters: self.propertyFilters,
            selectedProperties: self.selectedProperties,
            startDateTime: self.startDateTime,
            startTime: self.startTime,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListComponentTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListComponentTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListComponentTypesOutput`
    public func listComponentTypesPaginated(input: ListComponentTypesInput) -> ClientRuntime.PaginatorSequence<ListComponentTypesInput, ListComponentTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListComponentTypesInput, ListComponentTypesOutput>(input: input, inputKey: \ListComponentTypesInput.nextToken, outputKey: \ListComponentTypesOutput.nextToken, paginationFunction: self.listComponentTypes(input:))
    }
}

extension ListComponentTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListComponentTypesInput {
        return ListComponentTypesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListEntitiesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEntitiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEntitiesOutput`
    public func listEntitiesPaginated(input: ListEntitiesInput) -> ClientRuntime.PaginatorSequence<ListEntitiesInput, ListEntitiesOutput> {
        return ClientRuntime.PaginatorSequence<ListEntitiesInput, ListEntitiesOutput>(input: input, inputKey: \ListEntitiesInput.nextToken, outputKey: \ListEntitiesOutput.nextToken, paginationFunction: self.listEntities(input:))
    }
}

extension ListEntitiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEntitiesInput {
        return ListEntitiesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListScenesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListScenesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListScenesOutput`
    public func listScenesPaginated(input: ListScenesInput) -> ClientRuntime.PaginatorSequence<ListScenesInput, ListScenesOutput> {
        return ClientRuntime.PaginatorSequence<ListScenesInput, ListScenesOutput>(input: input, inputKey: \ListScenesInput.nextToken, outputKey: \ListScenesOutput.nextToken, paginationFunction: self.listScenes(input:))
    }
}

extension ListScenesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListScenesInput {
        return ListScenesInput(
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListSyncJobsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSyncJobsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSyncJobsOutput`
    public func listSyncJobsPaginated(input: ListSyncJobsInput) -> ClientRuntime.PaginatorSequence<ListSyncJobsInput, ListSyncJobsOutput> {
        return ClientRuntime.PaginatorSequence<ListSyncJobsInput, ListSyncJobsOutput>(input: input, inputKey: \ListSyncJobsInput.nextToken, outputKey: \ListSyncJobsOutput.nextToken, paginationFunction: self.listSyncJobs(input:))
    }
}

extension ListSyncJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSyncJobsInput {
        return ListSyncJobsInput(
            maxResults: self.maxResults,
            nextToken: token,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListSyncResourcesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListSyncResourcesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListSyncResourcesOutput`
    public func listSyncResourcesPaginated(input: ListSyncResourcesInput) -> ClientRuntime.PaginatorSequence<ListSyncResourcesInput, ListSyncResourcesOutput> {
        return ClientRuntime.PaginatorSequence<ListSyncResourcesInput, ListSyncResourcesOutput>(input: input, inputKey: \ListSyncResourcesInput.nextToken, outputKey: \ListSyncResourcesOutput.nextToken, paginationFunction: self.listSyncResources(input:))
    }
}

extension ListSyncResourcesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListSyncResourcesInput {
        return ListSyncResourcesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            syncSource: self.syncSource,
            workspaceId: self.workspaceId
        )}
}
extension IoTTwinMakerClient {
    /// Paginate over `[ListWorkspacesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkspacesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkspacesOutput`
    public func listWorkspacesPaginated(input: ListWorkspacesInput) -> ClientRuntime.PaginatorSequence<ListWorkspacesInput, ListWorkspacesOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkspacesInput, ListWorkspacesOutput>(input: input, inputKey: \ListWorkspacesInput.nextToken, outputKey: \ListWorkspacesOutput.nextToken, paginationFunction: self.listWorkspaces(input:))
    }
}

extension ListWorkspacesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkspacesInput {
        return ListWorkspacesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}
